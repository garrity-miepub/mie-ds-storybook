import {
  require_jquery
} from "./chunk-2OZ2EN5G.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-BFCEFRYA.js";

// node_modules/block-ui/jquery.blockUI.js
var require_jquery_blockUI = __commonJS({
  "node_modules/block-ui/jquery.blockUI.js"(exports) {
    (function() {
      "use strict";
      function setup($) {
        $.fn._fadeIn = $.fn.fadeIn;
        var noOp = $.noop || function() {
        };
        var msie = /MSIE/.test(navigator.userAgent);
        var ie6 = /MSIE 6.0/.test(navigator.userAgent) && !/MSIE 8.0/.test(navigator.userAgent);
        var mode = document.documentMode || 0;
        var setExpr = $.isFunction(document.createElement("div").style.setExpression);
        $.blockUI = function(opts) {
          install(window, opts);
        };
        $.unblockUI = function(opts) {
          remove(window, opts);
        };
        $.growlUI = function(title, message, timeout, onClose) {
          var $m = $('<div class="growlUI"></div>');
          if (title) $m.append("<h1>" + title + "</h1>");
          if (message) $m.append("<h2>" + message + "</h2>");
          if (timeout === void 0) timeout = 3e3;
          var callBlock = function(opts) {
            opts = opts || {};
            $.blockUI({
              message: $m,
              fadeIn: typeof opts.fadeIn !== "undefined" ? opts.fadeIn : 700,
              fadeOut: typeof opts.fadeOut !== "undefined" ? opts.fadeOut : 1e3,
              timeout: typeof opts.timeout !== "undefined" ? opts.timeout : timeout,
              centerY: false,
              showOverlay: false,
              onUnblock: onClose,
              css: $.blockUI.defaults.growlCSS
            });
          };
          callBlock();
          var nonmousedOpacity = $m.css("opacity");
          $m.mouseover(function() {
            callBlock({
              fadeIn: 0,
              timeout: 3e4
            });
            var displayBlock = $(".blockMsg");
            displayBlock.stop();
            displayBlock.fadeTo(300, 1);
          }).mouseout(function() {
            $(".blockMsg").fadeOut(1e3);
          });
        };
        $.fn.block = function(opts) {
          if (this[0] === window) {
            $.blockUI(opts);
            return this;
          }
          var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
          this.each(function() {
            var $el = $(this);
            if (fullOpts.ignoreIfBlocked && $el.data("blockUI.isBlocked"))
              return;
            $el.unblock({ fadeOut: 0 });
          });
          return this.each(function() {
            if ($.css(this, "position") == "static") {
              this.style.position = "relative";
              $(this).data("blockUI.static", true);
            }
            this.style.zoom = 1;
            install(this, opts);
          });
        };
        $.fn.unblock = function(opts) {
          if (this[0] === window) {
            $.unblockUI(opts);
            return this;
          }
          return this.each(function() {
            remove(this, opts);
          });
        };
        $.blockUI.version = 2.7;
        $.blockUI.defaults = {
          // message displayed when blocking (use null for no message)
          message: "<h1>Please wait...</h1>",
          title: null,
          // title string; only used when theme == true
          draggable: true,
          // only used when theme == true (requires jquery-ui.js to be loaded)
          theme: false,
          // set to true to use with jQuery UI themes
          // styles for the message when blocking; if you wish to disable
          // these and use an external stylesheet then do this in your code:
          // $.blockUI.defaults.css = {};
          css: {
            padding: 0,
            margin: 0,
            width: "30%",
            top: "40%",
            left: "35%",
            textAlign: "center",
            color: "#000",
            border: "3px solid #aaa",
            backgroundColor: "#fff",
            cursor: "wait"
          },
          // minimal style set used when themes are used
          themedCSS: {
            width: "30%",
            top: "40%",
            left: "35%"
          },
          // styles for the overlay
          overlayCSS: {
            backgroundColor: "#000",
            opacity: 0.6,
            cursor: "wait"
          },
          // style to replace wait cursor before unblocking to correct issue
          // of lingering wait cursor
          cursorReset: "default",
          // styles applied when using $.growlUI
          growlCSS: {
            width: "350px",
            top: "10px",
            left: "",
            right: "10px",
            border: "none",
            padding: "5px",
            opacity: 0.6,
            cursor: "default",
            color: "#fff",
            backgroundColor: "#000",
            "-webkit-border-radius": "10px",
            "-moz-border-radius": "10px",
            "border-radius": "10px"
          },
          // IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w
          // (hat tip to Jorge H. N. de Vasconcelos)
          /*jshint scripturl:true */
          iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank",
          // force usage of iframe in non-IE browsers (handy for blocking applets)
          forceIframe: false,
          // z-index for the blocking overlay
          baseZ: 1e3,
          // set these to true to have the message automatically centered
          centerX: true,
          // <-- only effects element blocking (page block controlled via css above)
          centerY: true,
          // allow body element to be stetched in ie6; this makes blocking look better
          // on "short" pages.  disable if you wish to prevent changes to the body height
          allowBodyStretch: true,
          // enable if you want key and mouse events to be disabled for content that is blocked
          bindEvents: true,
          // be default blockUI will supress tab navigation from leaving blocking content
          // (if bindEvents is true)
          constrainTabKey: true,
          // fadeIn time in millis; set to 0 to disable fadeIn on block
          fadeIn: 200,
          // fadeOut time in millis; set to 0 to disable fadeOut on unblock
          fadeOut: 400,
          // time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
          timeout: 0,
          // disable if you don't want to show the overlay
          showOverlay: true,
          // if true, focus will be placed in the first available input field when
          // page blocking
          focusInput: true,
          // elements that can receive focus
          focusableElements: ":input:enabled:visible",
          // suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
          // no longer needed in 2012
          // applyPlatformOpacityRules: true,
          // callback method invoked when fadeIn has completed and blocking message is visible
          onBlock: null,
          // callback method invoked when unblocking has completed; the callback is
          // passed the element that has been unblocked (which is the window object for page
          // blocks) and the options that were passed to the unblock call:
          //	onUnblock(element, options)
          onUnblock: null,
          // callback method invoked when the overlay area is clicked.
          // setting this will turn the cursor to a pointer, otherwise cursor defined in overlayCss will be used.
          onOverlayClick: null,
          // don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493
          quirksmodeOffsetHack: 4,
          // class name of the message block
          blockMsgClass: "blockMsg",
          // if it is already blocked, then ignore it (don't unblock and reblock)
          ignoreIfBlocked: false
        };
        var pageBlock = null;
        var pageBlockEls = [];
        function install(el, opts) {
          var css, themedCSS;
          var full = el == window;
          var msg = opts && opts.message !== void 0 ? opts.message : void 0;
          opts = $.extend({}, $.blockUI.defaults, opts || {});
          if (opts.ignoreIfBlocked && $(el).data("blockUI.isBlocked"))
            return;
          opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
          css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
          if (opts.onOverlayClick)
            opts.overlayCSS.cursor = "pointer";
          themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
          msg = msg === void 0 ? opts.message : msg;
          if (full && pageBlock)
            remove(window, { fadeOut: 0 });
          if (msg && typeof msg != "string" && (msg.parentNode || msg.jquery)) {
            var node = msg.jquery ? msg[0] : msg;
            var data = {};
            $(el).data("blockUI.history", data);
            data.el = node;
            data.parent = node.parentNode;
            data.display = node.style.display;
            data.position = node.style.position;
            if (data.parent)
              data.parent.removeChild(node);
          }
          $(el).data("blockUI.onUnblock", opts.onUnblock);
          var z = opts.baseZ;
          var lyr1, lyr2, lyr3, s2;
          if (msie || opts.forceIframe)
            lyr1 = $('<iframe class="blockUI" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="' + opts.iframeSrc + '"></iframe>');
          else
            lyr1 = $('<div class="blockUI" style="display:none"></div>');
          if (opts.theme)
            lyr2 = $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:' + z++ + ';display:none"></div>');
          else
            lyr2 = $('<div class="blockUI blockOverlay" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
          if (opts.theme && full) {
            s2 = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:fixed">';
            if (opts.title) {
              s2 += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>";
            }
            s2 += '<div class="ui-widget-content ui-dialog-content"></div>';
            s2 += "</div>";
          } else if (opts.theme) {
            s2 = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:absolute">';
            if (opts.title) {
              s2 += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>";
            }
            s2 += '<div class="ui-widget-content ui-dialog-content"></div>';
            s2 += "</div>";
          } else if (full) {
            s2 = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:' + (z + 10) + ';display:none;position:fixed"></div>';
          } else {
            s2 = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:' + (z + 10) + ';display:none;position:absolute"></div>';
          }
          lyr3 = $(s2);
          if (msg) {
            if (opts.theme) {
              lyr3.css(themedCSS);
              lyr3.addClass("ui-widget-content");
            } else
              lyr3.css(css);
          }
          if (!opts.theme)
            lyr2.css(opts.overlayCSS);
          lyr2.css("position", full ? "fixed" : "absolute");
          if (msie || opts.forceIframe)
            lyr1.css("opacity", 0);
          var layers = [lyr1, lyr2, lyr3], $par = full ? $("body") : $(el);
          $.each(layers, function() {
            this.appendTo($par);
          });
          if (opts.theme && opts.draggable && $.fn.draggable) {
            lyr3.draggable({
              handle: ".ui-dialog-titlebar",
              cancel: "li"
            });
          }
          var expr = setExpr && (!$.support.boxModel || $("object,embed", full ? null : el).length > 0);
          if (ie6 || expr) {
            if (full && opts.allowBodyStretch && $.support.boxModel)
              $("html,body").css("height", "100%");
            if ((ie6 || !$.support.boxModel) && !full) {
              var t2 = sz(el, "borderTopWidth"), l2 = sz(el, "borderLeftWidth");
              var fixT = t2 ? "(0 - " + t2 + ")" : 0;
              var fixL = l2 ? "(0 - " + l2 + ")" : 0;
            }
            $.each(layers, function(i2, o2) {
              var s3 = o2[0].style;
              s3.position = "absolute";
              if (i2 < 2) {
                if (full)
                  s3.setExpression("height", "Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:" + opts.quirksmodeOffsetHack + ') + "px"');
                else
                  s3.setExpression("height", 'this.parentNode.offsetHeight + "px"');
                if (full)
                  s3.setExpression("width", 'jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"');
                else
                  s3.setExpression("width", 'this.parentNode.offsetWidth + "px"');
                if (fixL) s3.setExpression("left", fixL);
                if (fixT) s3.setExpression("top", fixT);
              } else if (opts.centerY) {
                if (full) s3.setExpression("top", '(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
                s3.marginTop = 0;
              } else if (!opts.centerY && full) {
                var top = opts.css && opts.css.top ? parseInt(opts.css.top, 10) : 0;
                var expression = "((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + " + top + ') + "px"';
                s3.setExpression("top", expression);
              }
            });
          }
          if (msg) {
            if (opts.theme)
              lyr3.find(".ui-widget-content").append(msg);
            else
              lyr3.append(msg);
            if (msg.jquery || msg.nodeType)
              $(msg).show();
          }
          if ((msie || opts.forceIframe) && opts.showOverlay)
            lyr1.show();
          if (opts.fadeIn) {
            var cb2 = opts.onBlock ? opts.onBlock : noOp;
            var cb1 = opts.showOverlay && !msg ? cb2 : noOp;
            var cb22 = msg ? cb2 : noOp;
            if (opts.showOverlay)
              lyr2._fadeIn(opts.fadeIn, cb1);
            if (msg)
              lyr3._fadeIn(opts.fadeIn, cb22);
          } else {
            if (opts.showOverlay)
              lyr2.show();
            if (msg)
              lyr3.show();
            if (opts.onBlock)
              opts.onBlock.bind(lyr3)();
          }
          bind(1, el, opts);
          if (full) {
            pageBlock = lyr3[0];
            pageBlockEls = $(opts.focusableElements, pageBlock);
            if (opts.focusInput)
              setTimeout(focus, 20);
          } else
            center(lyr3[0], opts.centerX, opts.centerY);
          if (opts.timeout) {
            var to3 = setTimeout(function() {
              if (full)
                $.unblockUI(opts);
              else
                $(el).unblock(opts);
            }, opts.timeout);
            $(el).data("blockUI.timeout", to3);
          }
        }
        function remove(el, opts) {
          var count;
          var full = el == window;
          var $el = $(el);
          var data = $el.data("blockUI.history");
          var to3 = $el.data("blockUI.timeout");
          if (to3) {
            clearTimeout(to3);
            $el.removeData("blockUI.timeout");
          }
          opts = $.extend({}, $.blockUI.defaults, opts || {});
          bind(0, el, opts);
          if (opts.onUnblock === null) {
            opts.onUnblock = $el.data("blockUI.onUnblock");
            $el.removeData("blockUI.onUnblock");
          }
          var els;
          if (full)
            els = $("body").children().filter(".blockUI").add("body > .blockUI");
          else
            els = $el.find(">.blockUI");
          if (opts.cursorReset) {
            if (els.length > 1)
              els[1].style.cursor = opts.cursorReset;
            if (els.length > 2)
              els[2].style.cursor = opts.cursorReset;
          }
          if (full)
            pageBlock = pageBlockEls = null;
          if (opts.fadeOut) {
            count = els.length;
            els.stop().fadeOut(opts.fadeOut, function() {
              if (--count === 0)
                reset(els, data, opts, el);
            });
          } else
            reset(els, data, opts, el);
        }
        function reset(els, data, opts, el) {
          var $el = $(el);
          if ($el.data("blockUI.isBlocked"))
            return;
          els.each(function(i2, o2) {
            if (this.parentNode)
              this.parentNode.removeChild(this);
          });
          if (data && data.el) {
            data.el.style.display = data.display;
            data.el.style.position = data.position;
            data.el.style.cursor = "default";
            if (data.parent)
              data.parent.appendChild(data.el);
            $el.removeData("blockUI.history");
          }
          if ($el.data("blockUI.static")) {
            $el.css("position", "static");
          }
          if (typeof opts.onUnblock == "function")
            opts.onUnblock(el, opts);
          var body = $(document.body), w = body.width(), cssW = body[0].style.width;
          body.width(w - 1).width(w);
          body[0].style.width = cssW;
        }
        function bind(b, el, opts) {
          var full = el == window, $el = $(el);
          if (!b && (full && !pageBlock || !full && !$el.data("blockUI.isBlocked")))
            return;
          $el.data("blockUI.isBlocked", b);
          if (!full || !opts.bindEvents || b && !opts.showOverlay)
            return;
          var events = "mousedown mouseup keydown keypress keyup touchstart touchend touchmove";
          if (b)
            $(document).bind(events, opts, handler);
          else
            $(document).unbind(events, handler);
        }
        function handler(e2) {
          if (e2.type === "keydown" && e2.keyCode && e2.keyCode == 9) {
            if (pageBlock && e2.data.constrainTabKey) {
              var els = pageBlockEls;
              var fwd = !e2.shiftKey && e2.target === els[els.length - 1];
              var back = e2.shiftKey && e2.target === els[0];
              if (fwd || back) {
                setTimeout(function() {
                  focus(back);
                }, 10);
                return false;
              }
            }
          }
          var opts = e2.data;
          var target = $(e2.target);
          if (target.hasClass("blockOverlay") && opts.onOverlayClick)
            opts.onOverlayClick(e2);
          if (target.parents("div." + opts.blockMsgClass).length > 0)
            return true;
          return target.parents().children().filter("div.blockUI").length === 0;
        }
        function focus(back) {
          if (!pageBlockEls)
            return;
          var e2 = pageBlockEls[back === true ? pageBlockEls.length - 1 : 0];
          if (e2)
            e2.focus();
        }
        function center(el, x, y) {
          var p = el.parentNode, s2 = el.style;
          var l2 = (p.offsetWidth - el.offsetWidth) / 2 - sz(p, "borderLeftWidth");
          var t2 = (p.offsetHeight - el.offsetHeight) / 2 - sz(p, "borderTopWidth");
          if (x) s2.left = l2 > 0 ? l2 + "px" : "0";
          if (y) s2.top = t2 > 0 ? t2 + "px" : "0";
        }
        function sz(el, p) {
          return parseInt($.css(el, p), 10) || 0;
        }
      }
      if (typeof define === "function" && define.amd) {
        define(["jquery"], setup);
      } else if (typeof exports === "object") {
        setup(require_jquery());
      } else {
        setup(jQuery);
      }
    })();
  }
});

// node_modules/jquery-contextmenu/dist/jquery.contextMenu.js
var require_jquery_contextMenu = __commonJS({
  "node_modules/jquery-contextmenu/dist/jquery.contextMenu.js"(exports) {
    (function(factory) {
      if (typeof define === "function" && define.amd) {
        define(["jquery"], factory);
      } else if (typeof exports === "object") {
        factory(require_jquery());
      } else {
        factory(jQuery);
      }
    })(function($) {
      "use strict";
      $.support.htmlMenuitem = "HTMLMenuItemElement" in window;
      $.support.htmlCommand = "HTMLCommandElement" in window;
      $.support.eventSelectstart = "onselectstart" in document.documentElement;
      if (!$.ui || !$.widget) {
        $.cleanData = /* @__PURE__ */ function(orig) {
          return function(elems) {
            var events, elem, i2;
            for (i2 = 0; elems[i2] != null; i2++) {
              elem = elems[i2];
              try {
                events = $._data(elem, "events");
                if (events && events.remove) {
                  $(elem).triggerHandler("remove");
                }
              } catch (e2) {
              }
            }
            orig(elems);
          };
        }($.cleanData);
      }
      var $currentTrigger = null, initialized = false, $win = $(window), counter = 0, namespaces = {}, menus = {}, types2 = {}, defaults4 = {
        // selector of contextMenu trigger
        selector: null,
        // where to append the menu to
        appendTo: null,
        // method to trigger context menu ["right", "left", "hover"]
        trigger: "right",
        // hide menu when mouse leaves trigger / menu elements
        autoHide: false,
        // ms to wait before showing a hover-triggered context menu
        delay: 200,
        // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
        // as long as the trigger happened on one of the trigger-element's child nodes
        reposition: true,
        // Flag denoting if a second trigger should close the menu, as long as
        // the trigger happened on one of the trigger-element's child nodes.
        // This overrides the reposition option.
        hideOnSecondTrigger: false,
        //ability to select submenu
        selectableSubMenu: false,
        // Default classname configuration to be able avoid conflicts in frameworks
        classNames: {
          hover: "context-menu-hover",
          // Item hover
          disabled: "context-menu-disabled",
          // Item disabled
          visible: "context-menu-visible",
          // Item visible
          notSelectable: "context-menu-not-selectable",
          // Item not selectable
          icon: "context-menu-icon",
          iconEdit: "context-menu-icon-edit",
          iconCut: "context-menu-icon-cut",
          iconCopy: "context-menu-icon-copy",
          iconPaste: "context-menu-icon-paste",
          iconDelete: "context-menu-icon-delete",
          iconAdd: "context-menu-icon-add",
          iconQuit: "context-menu-icon-quit",
          iconLoadingClass: "context-menu-icon-loading"
        },
        // determine position to show menu at
        determinePosition: function($menu) {
          if ($.ui && $.ui.position) {
            $menu.css("display", "block").position({
              my: "center top",
              at: "center bottom",
              of: this,
              offset: "0 5",
              collision: "fit"
            }).css("display", "none");
          } else {
            var offset2 = this.offset();
            offset2.top += this.outerHeight();
            offset2.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
            $menu.css(offset2);
          }
        },
        // position menu
        position: function(opt, x, y) {
          var offset2;
          if (!x && !y) {
            opt.determinePosition.call(this, opt.$menu);
            return;
          } else if (x === "maintain" && y === "maintain") {
            offset2 = opt.$menu.position();
          } else {
            var offsetParentOffset = opt.$menu.offsetParent().offset();
            offset2 = { top: y - offsetParentOffset.top, left: x - offsetParentOffset.left };
          }
          var bottom = $win.scrollTop() + $win.height(), right = $win.scrollLeft() + $win.width(), height = opt.$menu.outerHeight(), width = opt.$menu.outerWidth();
          if (offset2.top + height > bottom) {
            offset2.top -= height;
          }
          if (offset2.top < 0) {
            offset2.top = 0;
          }
          if (offset2.left + width > right) {
            offset2.left -= width;
          }
          if (offset2.left < 0) {
            offset2.left = 0;
          }
          opt.$menu.css(offset2);
        },
        // position the sub-menu
        positionSubmenu: function($menu) {
          if (typeof $menu === "undefined") {
            return;
          }
          if ($.ui && $.ui.position) {
            $menu.css("display", "block").position({
              my: "left top-5",
              at: "right top",
              of: this,
              collision: "flipfit fit"
            }).css("display", "");
          } else {
            var offset2 = {
              top: -9,
              left: this.outerWidth() - 5
            };
            $menu.css(offset2);
          }
        },
        // offset to add to zIndex
        zIndex: 1,
        // show hide animation settings
        animation: {
          duration: 50,
          show: "slideDown",
          hide: "slideUp"
        },
        // events
        events: {
          preShow: $.noop,
          show: $.noop,
          hide: $.noop,
          activated: $.noop
        },
        // default callback
        callback: null,
        // list of contextMenu items
        items: {}
      }, hoveract = {
        timer: null,
        pageX: null,
        pageY: null
      }, zindex = function($t) {
        var zin = 0, $tt = $t;
        while (true) {
          zin = Math.max(zin, parseInt($tt.css("z-index"), 10) || 0);
          $tt = $tt.parent();
          if (!$tt || !$tt.length || "html body".indexOf($tt.prop("nodeName").toLowerCase()) > -1) {
            break;
          }
        }
        return zin;
      }, handle = {
        // abort anything
        abortevent: function(e2) {
          e2.preventDefault();
          e2.stopImmediatePropagation();
        },
        // contextmenu show dispatcher
        contextmenu: function(e2) {
          var $this = $(this);
          if (e2.data.events.preShow($this, e2) === false) {
            return;
          }
          if (e2.data.trigger === "right") {
            e2.preventDefault();
            e2.stopImmediatePropagation();
          }
          if (e2.data.trigger !== "right" && e2.data.trigger !== "demand" && e2.originalEvent) {
            return;
          }
          if (typeof e2.mouseButton !== "undefined" && e2.data) {
            if (!(e2.data.trigger === "left" && e2.mouseButton === 0) && !(e2.data.trigger === "right" && e2.mouseButton === 2)) {
              return;
            }
          }
          if ($this.hasClass("context-menu-active")) {
            return;
          }
          if (!$this.hasClass("context-menu-disabled")) {
            $currentTrigger = $this;
            if (e2.data.build) {
              var built = e2.data.build($currentTrigger, e2);
              if (built === false) {
                return;
              }
              e2.data = $.extend(true, {}, defaults4, e2.data, built || {});
              if (!e2.data.items || $.isEmptyObject(e2.data.items)) {
                if (window.console) {
                  (console.error || console.log).call(console, "No items specified to show in contextMenu");
                }
                throw new Error("No Items specified");
              }
              e2.data.$trigger = $currentTrigger;
              op.create(e2.data);
            }
            op.show.call($this, e2.data, e2.pageX, e2.pageY);
          }
        },
        // contextMenu left-click trigger
        click: function(e2) {
          e2.preventDefault();
          e2.stopImmediatePropagation();
          $(this).trigger($.Event("contextmenu", { data: e2.data, pageX: e2.pageX, pageY: e2.pageY }));
        },
        // contextMenu right-click trigger
        mousedown: function(e2) {
          var $this = $(this);
          if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
            $currentTrigger.data("contextMenu").$menu.trigger("contextmenu:hide");
          }
          if (e2.button === 2) {
            $currentTrigger = $this.data("contextMenuActive", true);
          }
        },
        // contextMenu right-click trigger
        mouseup: function(e2) {
          var $this = $(this);
          if ($this.data("contextMenuActive") && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass("context-menu-disabled")) {
            e2.preventDefault();
            e2.stopImmediatePropagation();
            $currentTrigger = $this;
            $this.trigger($.Event("contextmenu", { data: e2.data, pageX: e2.pageX, pageY: e2.pageY }));
          }
          $this.removeData("contextMenuActive");
        },
        // contextMenu hover trigger
        mouseenter: function(e2) {
          var $this = $(this), $related = $(e2.relatedTarget), $document = $(document);
          if ($related.is(".context-menu-list") || $related.closest(".context-menu-list").length) {
            return;
          }
          if ($currentTrigger && $currentTrigger.length) {
            return;
          }
          hoveract.pageX = e2.pageX;
          hoveract.pageY = e2.pageY;
          hoveract.data = e2.data;
          $document.on("mousemove.contextMenuShow", handle.mousemove);
          hoveract.timer = setTimeout(function() {
            hoveract.timer = null;
            $document.off("mousemove.contextMenuShow");
            $currentTrigger = $this;
            $this.trigger($.Event("contextmenu", {
              data: hoveract.data,
              pageX: hoveract.pageX,
              pageY: hoveract.pageY
            }));
          }, e2.data.delay);
        },
        // contextMenu hover trigger
        mousemove: function(e2) {
          hoveract.pageX = e2.pageX;
          hoveract.pageY = e2.pageY;
        },
        // contextMenu hover trigger
        mouseleave: function(e2) {
          var $related = $(e2.relatedTarget);
          if ($related.is(".context-menu-list") || $related.closest(".context-menu-list").length) {
            return;
          }
          try {
            clearTimeout(hoveract.timer);
          } catch (e3) {
          }
          hoveract.timer = null;
        },
        // click on layer to hide contextMenu
        layerClick: function(e2) {
          var $this = $(this), root2 = $this.data("contextMenuRoot"), button = e2.button, x = e2.pageX, y = e2.pageY, fakeClick = x === void 0, target, offset2;
          e2.preventDefault();
          setTimeout(function() {
            if (fakeClick) {
              if (root2 !== null && typeof root2 !== "undefined" && root2.$menu !== null && typeof root2.$menu !== "undefined") {
                root2.$menu.trigger("contextmenu:hide");
              }
              return;
            }
            var $window;
            var triggerAction = root2.trigger === "left" && button === 0 || root2.trigger === "right" && button === 2;
            if (document.elementFromPoint && root2.$layer) {
              root2.$layer.hide();
              target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());
              if (target !== null && target.isContentEditable) {
                var range2 = document.createRange(), sel = window.getSelection();
                range2.selectNode(target);
                range2.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range2);
              }
              $(target).trigger(e2);
              root2.$layer.show();
            }
            if (root2.hideOnSecondTrigger && triggerAction && root2.$menu !== null && typeof root2.$menu !== "undefined") {
              root2.$menu.trigger("contextmenu:hide");
              return;
            }
            if (root2.reposition && triggerAction) {
              if (document.elementFromPoint) {
                if (root2.$trigger.is(target)) {
                  root2.position.call(root2.$trigger, root2, x, y);
                  return;
                }
              } else {
                offset2 = root2.$trigger.offset();
                $window = $(window);
                offset2.top += $window.scrollTop();
                if (offset2.top <= e2.pageY) {
                  offset2.left += $window.scrollLeft();
                  if (offset2.left <= e2.pageX) {
                    offset2.bottom = offset2.top + root2.$trigger.outerHeight();
                    if (offset2.bottom >= e2.pageY) {
                      offset2.right = offset2.left + root2.$trigger.outerWidth();
                      if (offset2.right >= e2.pageX) {
                        root2.position.call(root2.$trigger, root2, x, y);
                        return;
                      }
                    }
                  }
                }
              }
            }
            if (target && triggerAction) {
              root2.$trigger.one("contextmenu:hidden", function() {
                $(target).contextMenu({ x, y, button });
              });
            }
            if (root2 !== null && typeof root2 !== "undefined" && root2.$menu !== null && typeof root2.$menu !== "undefined") {
              root2.$menu.trigger("contextmenu:hide");
            }
          }, 50);
        },
        // key handled :hover
        keyStop: function(e2, opt) {
          if (!opt.isInput) {
            e2.preventDefault();
          }
          e2.stopPropagation();
        },
        key: function(e2) {
          var opt = {};
          if ($currentTrigger) {
            opt = $currentTrigger.data("contextMenu") || {};
          }
          if (typeof opt.zIndex === "undefined") {
            opt.zIndex = 0;
          }
          var targetZIndex = 0;
          var getZIndexOfTriggerTarget = function(target) {
            if (target.style.zIndex !== "") {
              targetZIndex = target.style.zIndex;
            } else {
              if (target.offsetParent !== null && typeof target.offsetParent !== "undefined") {
                getZIndexOfTriggerTarget(target.offsetParent);
              } else if (target.parentElement !== null && typeof target.parentElement !== "undefined") {
                getZIndexOfTriggerTarget(target.parentElement);
              }
            }
          };
          getZIndexOfTriggerTarget(e2.target);
          if (opt.$menu && parseInt(targetZIndex, 10) > parseInt(opt.$menu.css("zIndex"), 10)) {
            return;
          }
          switch (e2.keyCode) {
            case 9:
            case 38:
              handle.keyStop(e2, opt);
              if (opt.isInput) {
                if (e2.keyCode === 9 && e2.shiftKey) {
                  e2.preventDefault();
                  if (opt.$selected) {
                    opt.$selected.find("input, textarea, select").blur();
                  }
                  if (opt.$menu !== null && typeof opt.$menu !== "undefined") {
                    opt.$menu.trigger("prevcommand");
                  }
                  return;
                } else if (e2.keyCode === 38 && opt.$selected.find("input, textarea, select").prop("type") === "checkbox") {
                  e2.preventDefault();
                  return;
                }
              } else if (e2.keyCode !== 9 || e2.shiftKey) {
                if (opt.$menu !== null && typeof opt.$menu !== "undefined") {
                  opt.$menu.trigger("prevcommand");
                }
                return;
              }
              break;
            // omitting break;
            // case 9: // tab - reached through omitted break;
            case 40:
              handle.keyStop(e2, opt);
              if (opt.isInput) {
                if (e2.keyCode === 9) {
                  e2.preventDefault();
                  if (opt.$selected) {
                    opt.$selected.find("input, textarea, select").blur();
                  }
                  if (opt.$menu !== null && typeof opt.$menu !== "undefined") {
                    opt.$menu.trigger("nextcommand");
                  }
                  return;
                } else if (e2.keyCode === 40 && opt.$selected.find("input, textarea, select").prop("type") === "checkbox") {
                  e2.preventDefault();
                  return;
                }
              } else {
                if (opt.$menu !== null && typeof opt.$menu !== "undefined") {
                  opt.$menu.trigger("nextcommand");
                }
                return;
              }
              break;
            case 37:
              handle.keyStop(e2, opt);
              if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                break;
              }
              if (!opt.$selected.parent().hasClass("context-menu-root")) {
                var $parent = opt.$selected.parent().parent();
                opt.$selected.trigger("contextmenu:blur");
                opt.$selected = $parent;
                return;
              }
              break;
            case 39:
              handle.keyStop(e2, opt);
              if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                break;
              }
              var itemdata = opt.$selected.data("contextMenu") || {};
              if (itemdata.$menu && opt.$selected.hasClass("context-menu-submenu")) {
                opt.$selected = null;
                itemdata.$selected = null;
                itemdata.$menu.trigger("nextcommand");
                return;
              }
              break;
            case 35:
            // end
            case 36:
              if (opt.$selected && opt.$selected.find("input, textarea, select").length) {
                return;
              } else {
                (opt.$selected && opt.$selected.parent() || opt.$menu).children(":not(." + opt.classNames.disabled + ", ." + opt.classNames.notSelectable + ")")[e2.keyCode === 36 ? "first" : "last"]().trigger("contextmenu:focus");
                e2.preventDefault();
                return;
              }
              break;
            case 13:
              handle.keyStop(e2, opt);
              if (opt.isInput) {
                if (opt.$selected && !opt.$selected.is("textarea, select")) {
                  e2.preventDefault();
                  return;
                }
                break;
              }
              if (typeof opt.$selected !== "undefined" && opt.$selected !== null) {
                opt.$selected.trigger("mouseup");
              }
              return;
            case 32:
            // space
            case 33:
            // page up
            case 34:
              handle.keyStop(e2, opt);
              return;
            case 27:
              handle.keyStop(e2, opt);
              if (opt.$menu !== null && typeof opt.$menu !== "undefined") {
                opt.$menu.trigger("contextmenu:hide");
              }
              return;
            default:
              var k = String.fromCharCode(e2.keyCode).toUpperCase();
              if (opt.accesskeys && opt.accesskeys[k]) {
                opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? "contextmenu:focus" : "mouseup");
                return;
              }
              break;
          }
          e2.stopPropagation();
          if (typeof opt.$selected !== "undefined" && opt.$selected !== null) {
            opt.$selected.trigger(e2);
          }
        },
        // select previous possible command in menu
        prevItem: function(e2) {
          e2.stopPropagation();
          var opt = $(this).data("contextMenu") || {};
          var root2 = $(this).data("contextMenuRoot") || {};
          if (opt.$selected) {
            var $s = opt.$selected;
            opt = opt.$selected.parent().data("contextMenu") || {};
            opt.$selected = $s;
          }
          var $children = opt.$menu.children(), $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(), $round = $prev;
          while ($prev.hasClass(root2.classNames.disabled) || $prev.hasClass(root2.classNames.notSelectable) || $prev.is(":hidden")) {
            if ($prev.prev().length) {
              $prev = $prev.prev();
            } else {
              $prev = $children.last();
            }
            if ($prev.is($round)) {
              return;
            }
          }
          if (opt.$selected) {
            handle.itemMouseleave.call(opt.$selected.get(0), e2);
          }
          handle.itemMouseenter.call($prev.get(0), e2);
          var $input = $prev.find("input, textarea, select");
          if ($input.length) {
            $input.focus();
          }
        },
        // select next possible command in menu
        nextItem: function(e2) {
          e2.stopPropagation();
          var opt = $(this).data("contextMenu") || {};
          var root2 = $(this).data("contextMenuRoot") || {};
          if (opt.$selected) {
            var $s = opt.$selected;
            opt = opt.$selected.parent().data("contextMenu") || {};
            opt.$selected = $s;
          }
          var $children = opt.$menu.children(), $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(), $round = $next;
          while ($next.hasClass(root2.classNames.disabled) || $next.hasClass(root2.classNames.notSelectable) || $next.is(":hidden")) {
            if ($next.next().length) {
              $next = $next.next();
            } else {
              $next = $children.first();
            }
            if ($next.is($round)) {
              return;
            }
          }
          if (opt.$selected) {
            handle.itemMouseleave.call(opt.$selected.get(0), e2);
          }
          handle.itemMouseenter.call($next.get(0), e2);
          var $input = $next.find("input, textarea, select");
          if ($input.length) {
            $input.focus();
          }
        },
        // flag that we're inside an input so the key handler can act accordingly
        focusInput: function() {
          var $this = $(this).closest(".context-menu-item"), data = $this.data(), opt = data.contextMenu, root2 = data.contextMenuRoot;
          root2.$selected = opt.$selected = $this;
          root2.isInput = opt.isInput = true;
        },
        // flag that we're inside an input so the key handler can act accordingly
        blurInput: function() {
          var $this = $(this).closest(".context-menu-item"), data = $this.data(), opt = data.contextMenu, root2 = data.contextMenuRoot;
          root2.isInput = opt.isInput = false;
        },
        // :hover on menu
        menuMouseenter: function() {
          var root2 = $(this).data().contextMenuRoot;
          root2.hovering = true;
        },
        // :hover on menu
        menuMouseleave: function(e2) {
          var root2 = $(this).data().contextMenuRoot;
          if (root2.$layer && root2.$layer.is(e2.relatedTarget)) {
            root2.hovering = false;
          }
        },
        // :hover done manually so key handling is possible
        itemMouseenter: function(e2) {
          var $this = $(this), data = $this.data(), opt = data.contextMenu, root2 = data.contextMenuRoot;
          root2.hovering = true;
          if (e2 && root2.$layer && root2.$layer.is(e2.relatedTarget)) {
            e2.preventDefault();
            e2.stopImmediatePropagation();
          }
          (opt.$menu ? opt : root2).$menu.children("." + root2.classNames.hover).trigger("contextmenu:blur").children(".hover").trigger("contextmenu:blur");
          if ($this.hasClass(root2.classNames.disabled) || $this.hasClass(root2.classNames.notSelectable)) {
            opt.$selected = null;
            return;
          }
          $this.trigger("contextmenu:focus");
        },
        // :hover done manually so key handling is possible
        itemMouseleave: function(e2) {
          var $this = $(this), data = $this.data(), opt = data.contextMenu, root2 = data.contextMenuRoot;
          if (root2 !== opt && root2.$layer && root2.$layer.is(e2.relatedTarget)) {
            if (typeof root2.$selected !== "undefined" && root2.$selected !== null) {
              root2.$selected.trigger("contextmenu:blur");
            }
            e2.preventDefault();
            e2.stopImmediatePropagation();
            root2.$selected = opt.$selected = opt.$node;
            return;
          }
          if (opt && opt.$menu && opt.$menu.hasClass("context-menu-visible")) {
            return;
          }
          $this.trigger("contextmenu:blur");
        },
        // contextMenu item click
        itemClick: function(e2) {
          var $this = $(this), data = $this.data(), opt = data.contextMenu, root2 = data.contextMenuRoot, key = data.contextMenuKey, callback2;
          if (!opt.items[key] || $this.is("." + root2.classNames.disabled + ", .context-menu-separator, ." + root2.classNames.notSelectable) || $this.is(".context-menu-submenu") && root2.selectableSubMenu === false) {
            return;
          }
          e2.preventDefault();
          e2.stopImmediatePropagation();
          if ($.isFunction(opt.callbacks[key]) && Object.prototype.hasOwnProperty.call(opt.callbacks, key)) {
            callback2 = opt.callbacks[key];
          } else if ($.isFunction(root2.callback)) {
            callback2 = root2.callback;
          } else {
            return;
          }
          if (callback2.call(root2.$trigger, key, root2, e2) !== false) {
            root2.$menu.trigger("contextmenu:hide");
          } else if (root2.$menu.parent().length) {
            op.update.call(root2.$trigger, root2);
          }
        },
        // ignore click events on input elements
        inputClick: function(e2) {
          e2.stopImmediatePropagation();
        },
        // hide <menu>
        hideMenu: function(e2, data) {
          var root2 = $(this).data("contextMenuRoot");
          op.hide.call(root2.$trigger, root2, data && data.force);
        },
        // focus <command>
        focusItem: function(e2) {
          e2.stopPropagation();
          var $this = $(this), data = $this.data(), opt = data.contextMenu, root2 = data.contextMenuRoot;
          if ($this.hasClass(root2.classNames.disabled) || $this.hasClass(root2.classNames.notSelectable)) {
            return;
          }
          $this.addClass([root2.classNames.hover, root2.classNames.visible].join(" ")).parent().find(".context-menu-item").not($this).removeClass(root2.classNames.visible).filter("." + root2.classNames.hover).trigger("contextmenu:blur");
          opt.$selected = root2.$selected = $this;
          if (opt && opt.$node && opt.$node.hasClass("context-menu-submenu")) {
            opt.$node.addClass(root2.classNames.hover);
          }
          if (opt.$node) {
            root2.positionSubmenu.call(opt.$node, opt.$menu);
          }
        },
        // blur <command>
        blurItem: function(e2) {
          e2.stopPropagation();
          var $this = $(this), data = $this.data(), opt = data.contextMenu, root2 = data.contextMenuRoot;
          if (opt.autoHide) {
            $this.removeClass(root2.classNames.visible);
          }
          $this.removeClass(root2.classNames.hover);
          opt.$selected = null;
        }
      }, op = {
        show: function(opt, x, y) {
          var $trigger = $(this), css = {};
          $("#context-menu-layer").trigger("mousedown");
          opt.$trigger = $trigger;
          if (opt.events.show.call($trigger, opt) === false) {
            $currentTrigger = null;
            return;
          }
          var hasVisibleItems = op.update.call($trigger, opt);
          if (hasVisibleItems === false) {
            $currentTrigger = null;
            return;
          }
          opt.position.call($trigger, opt, x, y);
          if (opt.zIndex) {
            var additionalZValue = opt.zIndex;
            if (typeof opt.zIndex === "function") {
              additionalZValue = opt.zIndex.call($trigger, opt);
            }
            css.zIndex = zindex($trigger) + additionalZValue;
          }
          op.layer.call(opt.$menu, opt, css.zIndex);
          opt.$menu.find("ul").css("zIndex", css.zIndex + 1);
          opt.$menu.css(css)[opt.animation.show](opt.animation.duration, function() {
            $trigger.trigger("contextmenu:visible");
            op.activated(opt);
            opt.events.activated(opt);
          });
          $trigger.data("contextMenu", opt).addClass("context-menu-active");
          $(document).off("keydown.contextMenu").on("keydown.contextMenu", handle.key);
          if (opt.autoHide) {
            $(document).on("mousemove.contextMenuAutoHide", function(e2) {
              var pos = $trigger.offset();
              pos.right = pos.left + $trigger.outerWidth();
              pos.bottom = pos.top + $trigger.outerHeight();
              if (opt.$layer && !opt.hovering && (!(e2.pageX >= pos.left && e2.pageX <= pos.right) || !(e2.pageY >= pos.top && e2.pageY <= pos.bottom))) {
                setTimeout(function() {
                  if (!opt.hovering && opt.$menu !== null && typeof opt.$menu !== "undefined") {
                    opt.$menu.trigger("contextmenu:hide");
                  }
                }, 50);
              }
            });
          }
        },
        hide: function(opt, force) {
          var $trigger = $(this);
          if (!opt) {
            opt = $trigger.data("contextMenu") || {};
          }
          if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
            return;
          }
          $trigger.removeData("contextMenu").removeClass("context-menu-active");
          if (opt.$layer) {
            setTimeout(/* @__PURE__ */ function($layer) {
              return function() {
                $layer.remove();
              };
            }(opt.$layer), 10);
            try {
              delete opt.$layer;
            } catch (e2) {
              opt.$layer = null;
            }
          }
          $currentTrigger = null;
          opt.$menu.find("." + opt.classNames.hover).trigger("contextmenu:blur");
          opt.$selected = null;
          opt.$menu.find("." + opt.classNames.visible).removeClass(opt.classNames.visible);
          $(document).off(".contextMenuAutoHide").off("keydown.contextMenu");
          if (opt.$menu) {
            opt.$menu[opt.animation.hide](opt.animation.duration, function() {
              if (opt.build) {
                opt.$menu.remove();
                $.each(opt, function(key) {
                  switch (key) {
                    case "ns":
                    case "selector":
                    case "build":
                    case "trigger":
                      return true;
                    default:
                      opt[key] = void 0;
                      try {
                        delete opt[key];
                      } catch (e2) {
                      }
                      return true;
                  }
                });
              }
              setTimeout(function() {
                $trigger.trigger("contextmenu:hidden");
              }, 10);
            });
          }
        },
        create: function(opt, root2) {
          if (typeof root2 === "undefined") {
            root2 = opt;
          }
          opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || "").data({
            "contextMenu": opt,
            "contextMenuRoot": root2
          });
          if (opt.dataAttr) {
            $.each(opt.dataAttr, function(key, item) {
              opt.$menu.attr("data-" + opt.key, item);
            });
          }
          $.each(["callbacks", "commands", "inputs"], function(i2, k) {
            opt[k] = {};
            if (!root2[k]) {
              root2[k] = {};
            }
          });
          if (!root2.accesskeys) {
            root2.accesskeys = {};
          }
          function createNameNode(item) {
            var $name = $("<span></span>");
            if (item._accesskey) {
              if (item._beforeAccesskey) {
                $name.append(document.createTextNode(item._beforeAccesskey));
              }
              $("<span></span>").addClass("context-menu-accesskey").text(item._accesskey).appendTo($name);
              if (item._afterAccesskey) {
                $name.append(document.createTextNode(item._afterAccesskey));
              }
            } else {
              if (item.isHtmlName) {
                if (typeof item.accesskey !== "undefined") {
                  throw new Error("accesskeys are not compatible with HTML names and cannot be used together in the same item");
                }
                $name.html(item.name);
              } else {
                $name.text(item.name);
              }
            }
            return $name;
          }
          $.each(opt.items, function(key, item) {
            var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ""), $label = null, $input = null;
            $t.on("click", $.noop);
            if (typeof item === "string" || item.type === "cm_separator") {
              item = { type: "cm_seperator" };
            }
            item.$node = $t.data({
              "contextMenu": opt,
              "contextMenuRoot": root2,
              "contextMenuKey": key
            });
            if (typeof item.accesskey !== "undefined") {
              var aks = splitAccesskey(item.accesskey);
              for (var i2 = 0, ak; ak = aks[i2]; i2++) {
                if (!root2.accesskeys[ak]) {
                  root2.accesskeys[ak] = item;
                  var matched = item.name.match(new RegExp("^(.*?)(" + ak + ")(.*)$", "i"));
                  if (matched) {
                    item._beforeAccesskey = matched[1];
                    item._accesskey = matched[2];
                    item._afterAccesskey = matched[3];
                  }
                  break;
                }
              }
            }
            if (item.type && types2[item.type]) {
              types2[item.type].call($t, item, opt, root2);
              $.each([opt, root2], function(i3, k) {
                k.commands[key] = item;
                if ($.isFunction(item.callback) && (typeof k.callbacks[key] === "undefined" || typeof opt.type === "undefined")) {
                  k.callbacks[key] = item.callback;
                }
              });
            } else {
              if (item.type === "cm_seperator") {
                $t.addClass("context-menu-separator " + root2.classNames.notSelectable);
              } else if (item.type === "html") {
                $t.addClass("context-menu-html " + root2.classNames.notSelectable);
              } else if (item.type !== "sub" && item.type) {
                $label = $("<label></label>").appendTo($t);
                createNameNode(item).appendTo($label);
                $t.addClass("context-menu-input");
                opt.hasTypes = true;
                $.each([opt, root2], function(i3, k) {
                  k.commands[key] = item;
                  k.inputs[key] = item;
                });
              } else if (item.items) {
                item.type = "sub";
              }
              switch (item.type) {
                case "cm_seperator":
                  break;
                case "text":
                  $input = $('<input type="text" value="1" name="" />').attr("name", "context-menu-input-" + key).val(item.value || "").appendTo($label);
                  break;
                case "textarea":
                  $input = $('<textarea name=""></textarea>').attr("name", "context-menu-input-" + key).val(item.value || "").appendTo($label);
                  if (item.height) {
                    $input.height(item.height);
                  }
                  break;
                case "checkbox":
                  $input = $('<input type="checkbox" value="1" name="" />').attr("name", "context-menu-input-" + key).val(item.value || "").prop("checked", !!item.selected).prependTo($label);
                  break;
                case "radio":
                  $input = $('<input type="radio" value="1" name="" />').attr("name", "context-menu-input-" + item.radio).val(item.value || "").prop("checked", !!item.selected).prependTo($label);
                  break;
                case "select":
                  $input = $('<select name=""></select>').attr("name", "context-menu-input-" + key).appendTo($label);
                  if (item.options) {
                    $.each(item.options, function(value, text) {
                      $("<option></option>").val(value).text(text).appendTo($input);
                    });
                    $input.val(item.selected);
                  }
                  break;
                case "sub":
                  createNameNode(item).appendTo($t);
                  item.appendTo = item.$node;
                  $t.data("contextMenu", item).addClass("context-menu-submenu");
                  item.callback = null;
                  if ("function" === typeof item.items.then) {
                    op.processPromises(item, root2, item.items);
                  } else {
                    op.create(item, root2);
                  }
                  break;
                case "html":
                  $(item.html).appendTo($t);
                  break;
                default:
                  $.each([opt, root2], function(i3, k) {
                    k.commands[key] = item;
                    if ($.isFunction(item.callback) && (typeof k.callbacks[key] === "undefined" || typeof opt.type === "undefined")) {
                      k.callbacks[key] = item.callback;
                    }
                  });
                  createNameNode(item).appendTo($t);
                  break;
              }
              if (item.type && item.type !== "sub" && item.type !== "html" && item.type !== "cm_seperator") {
                $input.on("focus", handle.focusInput).on("blur", handle.blurInput);
                if (item.events) {
                  $input.on(item.events, opt);
                }
              }
              if (item.icon) {
                if ($.isFunction(item.icon)) {
                  item._icon = item.icon.call(this, this, $t, key, item);
                } else {
                  if (typeof item.icon === "string" && (item.icon.substring(0, 4) === "fab " || item.icon.substring(0, 4) === "fas " || item.icon.substring(0, 4) === "fad " || item.icon.substring(0, 4) === "far " || item.icon.substring(0, 4) === "fal ")) {
                    $t.addClass(root2.classNames.icon + " " + root2.classNames.icon + "--fa5");
                    item._icon = $('<i class="' + item.icon + '"></i>');
                  } else if (typeof item.icon === "string" && item.icon.substring(0, 3) === "fa-") {
                    item._icon = root2.classNames.icon + " " + root2.classNames.icon + "--fa fa " + item.icon;
                  } else {
                    item._icon = root2.classNames.icon + " " + root2.classNames.icon + "-" + item.icon;
                  }
                }
                if (typeof item._icon === "string") {
                  $t.addClass(item._icon);
                } else {
                  $t.prepend(item._icon);
                }
              }
            }
            item.$input = $input;
            item.$label = $label;
            $t.appendTo(opt.$menu);
            if (!opt.hasTypes && $.support.eventSelectstart) {
              $t.on("selectstart.disableTextSelect", handle.abortevent);
            }
          });
          if (!opt.$node) {
            opt.$menu.css("display", "none").addClass("context-menu-root");
          }
          opt.$menu.appendTo(opt.appendTo || document.body);
        },
        resize: function($menu, nested) {
          var domMenu;
          $menu.css({ position: "absolute", display: "block" });
          $menu.data(
            "width",
            (domMenu = $menu.get(0)).getBoundingClientRect ? Math.ceil(domMenu.getBoundingClientRect().width) : $menu.outerWidth() + 1
          );
          $menu.css({
            position: "static",
            minWidth: "0px",
            maxWidth: "100000px"
          });
          $menu.find("> li > ul").each(function() {
            op.resize($(this), true);
          });
          if (!nested) {
            $menu.find("ul").addBack().css({
              position: "",
              display: "",
              minWidth: "",
              maxWidth: ""
            }).outerWidth(function() {
              return $(this).data("width");
            });
          }
        },
        update: function(opt, root2) {
          var $trigger = this;
          if (typeof root2 === "undefined") {
            root2 = opt;
            op.resize(opt.$menu);
          }
          var hasVisibleItems = false;
          opt.$menu.children().each(function() {
            var $item = $(this), key = $item.data("contextMenuKey"), item = opt.items[key], disabled = $.isFunction(item.disabled) && item.disabled.call($trigger, key, root2) || item.disabled === true, visible;
            if ($.isFunction(item.visible)) {
              visible = item.visible.call($trigger, key, root2);
            } else if (typeof item.visible !== "undefined") {
              visible = item.visible === true;
            } else {
              visible = true;
            }
            if (visible) {
              hasVisibleItems = true;
            }
            $item[visible ? "show" : "hide"]();
            $item[disabled ? "addClass" : "removeClass"](root2.classNames.disabled);
            if ($.isFunction(item.icon)) {
              $item.removeClass(item._icon);
              var iconResult = item.icon.call(this, $trigger, $item, key, item);
              if (typeof iconResult === "string") {
                $item.addClass(iconResult);
              } else {
                $item.prepend(iconResult);
              }
            }
            if (item.type) {
              $item.find("input, select, textarea").prop("disabled", disabled);
              switch (item.type) {
                case "text":
                case "textarea":
                  item.$input.val(item.value || "");
                  break;
                case "checkbox":
                case "radio":
                  item.$input.val(item.value || "").prop("checked", !!item.selected);
                  break;
                case "select":
                  item.$input.val((item.selected === 0 ? "0" : item.selected) || "");
                  break;
              }
            }
            if (item.$menu) {
              var subMenuHasVisibleItems = op.update.call($trigger, item, root2);
              if (subMenuHasVisibleItems) {
                hasVisibleItems = true;
              }
            }
          });
          return hasVisibleItems;
        },
        layer: function(opt, zIndex) {
          var $layer = opt.$layer = $('<div id="context-menu-layer"></div>').css({
            height: $win.height(),
            width: $win.width(),
            display: "block",
            position: "fixed",
            "z-index": zIndex - 1,
            top: 0,
            left: 0,
            opacity: 0,
            filter: "alpha(opacity=0)",
            "background-color": "#000"
          }).data("contextMenuRoot", opt).appendTo(document.body).on("contextmenu", handle.abortevent).on("mousedown", handle.layerClick);
          if (typeof document.body.style.maxWidth === "undefined") {
            $layer.css({
              "position": "absolute",
              "height": $(document).height()
            });
          }
          return $layer;
        },
        processPromises: function(opt, root2, promise) {
          opt.$node.addClass(root2.classNames.iconLoadingClass);
          function completedPromise(opt2, root3, items) {
            if (typeof items === "undefined") {
              errorPromise(void 0);
            }
            finishPromiseProcess(opt2, root3, items);
          }
          function errorPromise(opt2, root3, errorItem) {
            if (typeof errorItem === "undefined") {
              errorItem = {
                "error": {
                  name: "No items and no error item",
                  icon: "context-menu-icon context-menu-icon-quit"
                }
              };
              if (window.console) {
                (console.error || console.log).call(console, 'When you reject a promise, provide an "items" object, equal to normal sub-menu items');
              }
            } else if (typeof errorItem === "string") {
              errorItem = { "error": { name: errorItem } };
            }
            finishPromiseProcess(opt2, root3, errorItem);
          }
          function finishPromiseProcess(opt2, root3, items) {
            if (typeof root3.$menu === "undefined" || !root3.$menu.is(":visible")) {
              return;
            }
            opt2.$node.removeClass(root3.classNames.iconLoadingClass);
            opt2.items = items;
            op.create(opt2, root3, true);
            op.update(opt2, root3);
            root3.positionSubmenu.call(opt2.$node, opt2.$menu);
          }
          promise.then(completedPromise.bind(this, opt, root2), errorPromise.bind(this, opt, root2));
        },
        // operation that will run after contextMenu showed on screen
        activated: function(opt) {
          var $menu = opt.$menu;
          var $menuOffset = $menu.offset();
          var winHeight = $(window).height();
          var winScrollTop = $(window).scrollTop();
          var menuHeight = $menu.height();
          if (menuHeight > winHeight) {
            $menu.css({
              "height": winHeight + "px",
              "overflow-x": "hidden",
              "overflow-y": "auto",
              "top": winScrollTop + "px"
            });
          } else if ($menuOffset.top < winScrollTop || $menuOffset.top + menuHeight > winScrollTop + winHeight) {
            $menu.css({
              "top": winScrollTop + "px"
            });
          }
        }
      };
      function splitAccesskey(val) {
        var t2 = val.split(/\s+/);
        var keys3 = [];
        for (var i2 = 0, k; k = t2[i2]; i2++) {
          k = k.charAt(0).toUpperCase();
          keys3.push(k);
        }
        return keys3;
      }
      $.fn.contextMenu = function(operation) {
        var $t = this, $o = operation;
        if (this.length > 0) {
          if (typeof operation === "undefined") {
            this.first().trigger("contextmenu");
          } else if (typeof operation.x !== "undefined" && typeof operation.y !== "undefined") {
            this.first().trigger($.Event("contextmenu", {
              pageX: operation.x,
              pageY: operation.y,
              mouseButton: operation.button
            }));
          } else if (operation === "hide") {
            var $menu = this.first().data("contextMenu") ? this.first().data("contextMenu").$menu : null;
            if ($menu) {
              $menu.trigger("contextmenu:hide");
            }
          } else if (operation === "destroy") {
            $.contextMenu("destroy", { context: this });
          } else if ($.isPlainObject(operation)) {
            operation.context = this;
            $.contextMenu("create", operation);
          } else if (operation) {
            this.removeClass("context-menu-disabled");
          } else if (!operation) {
            this.addClass("context-menu-disabled");
          }
        } else {
          $.each(menus, function() {
            if (this.selector === $t.selector) {
              $o.data = this;
              $.extend($o.data, { trigger: "demand" });
            }
          });
          handle.contextmenu.call($o.target, $o);
        }
        return this;
      };
      $.contextMenu = function(operation, options) {
        if (typeof operation !== "string") {
          options = operation;
          operation = "create";
        }
        if (typeof options === "string") {
          options = { selector: options };
        } else if (typeof options === "undefined") {
          options = {};
        }
        var o2 = $.extend(true, {}, defaults4, options || {});
        var $document = $(document);
        var $context = $document;
        var _hasContext = false;
        if (!o2.context || !o2.context.length) {
          o2.context = document;
        } else {
          $context = $(o2.context).first();
          o2.context = $context.get(0);
          _hasContext = !$(o2.context).is(document);
        }
        switch (operation) {
          case "update":
            if (_hasContext) {
              op.update($context);
            } else {
              for (var menu in menus) {
                if (menus.hasOwnProperty(menu)) {
                  op.update(menus[menu]);
                }
              }
            }
            break;
          case "create":
            if (!o2.selector) {
              throw new Error("No selector specified");
            }
            if (o2.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
              throw new Error('Cannot bind to selector "' + o2.selector + '" as it contains a reserved className');
            }
            if (!o2.build && (!o2.items || $.isEmptyObject(o2.items))) {
              throw new Error("No Items specified");
            }
            counter++;
            o2.ns = ".contextMenu" + counter;
            if (!_hasContext) {
              namespaces[o2.selector] = o2.ns;
            }
            menus[o2.ns] = o2;
            if (!o2.trigger) {
              o2.trigger = "right";
            }
            if (!initialized) {
              var itemClick = o2.itemClickEvent === "click" ? "click.contextMenu" : "mouseup.contextMenu";
              var contextMenuItemObj = {
                // 'mouseup.contextMenu': handle.itemClick,
                // 'click.contextMenu': handle.itemClick,
                "contextmenu:focus.contextMenu": handle.focusItem,
                "contextmenu:blur.contextMenu": handle.blurItem,
                "contextmenu.contextMenu": handle.abortevent,
                "mouseenter.contextMenu": handle.itemMouseenter,
                "mouseleave.contextMenu": handle.itemMouseleave
              };
              contextMenuItemObj[itemClick] = handle.itemClick;
              $document.on({
                "contextmenu:hide.contextMenu": handle.hideMenu,
                "prevcommand.contextMenu": handle.prevItem,
                "nextcommand.contextMenu": handle.nextItem,
                "contextmenu.contextMenu": handle.abortevent,
                "mouseenter.contextMenu": handle.menuMouseenter,
                "mouseleave.contextMenu": handle.menuMouseleave
              }, ".context-menu-list").on("mouseup.contextMenu", ".context-menu-input", handle.inputClick).on(contextMenuItemObj, ".context-menu-item");
              initialized = true;
            }
            $context.on("contextmenu" + o2.ns, o2.selector, o2, handle.contextmenu);
            if (_hasContext) {
              $context.on("remove" + o2.ns, function() {
                $(this).contextMenu("destroy");
              });
            }
            switch (o2.trigger) {
              case "hover":
                $context.on("mouseenter" + o2.ns, o2.selector, o2, handle.mouseenter).on("mouseleave" + o2.ns, o2.selector, o2, handle.mouseleave);
                break;
              case "left":
                $context.on("click" + o2.ns, o2.selector, o2, handle.click);
                break;
              case "touchstart":
                $context.on("touchstart" + o2.ns, o2.selector, o2, handle.click);
                break;
            }
            if (!o2.build) {
              op.create(o2);
            }
            break;
          case "destroy":
            var $visibleMenu;
            if (_hasContext) {
              var context = o2.context;
              $.each(menus, function(ns, o3) {
                if (!o3) {
                  return true;
                }
                if (!$(context).is(o3.selector)) {
                  return true;
                }
                $visibleMenu = $(".context-menu-list").filter(":visible");
                if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o3.context).find(o3.selector))) {
                  $visibleMenu.trigger("contextmenu:hide", { force: true });
                }
                try {
                  if (menus[o3.ns].$menu) {
                    menus[o3.ns].$menu.remove();
                  }
                  delete menus[o3.ns];
                } catch (e2) {
                  menus[o3.ns] = null;
                }
                $(o3.context).off(o3.ns);
                return true;
              });
            } else if (!o2.selector) {
              $document.off(".contextMenu .contextMenuAutoHide");
              $.each(menus, function(ns, o3) {
                $(o3.context).off(o3.ns);
              });
              namespaces = {};
              menus = {};
              counter = 0;
              initialized = false;
              $("#context-menu-layer, .context-menu-list").remove();
            } else if (namespaces[o2.selector]) {
              $visibleMenu = $(".context-menu-list").filter(":visible");
              if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o2.selector)) {
                $visibleMenu.trigger("contextmenu:hide", { force: true });
              }
              try {
                if (menus[namespaces[o2.selector]].$menu) {
                  menus[namespaces[o2.selector]].$menu.remove();
                }
                delete menus[namespaces[o2.selector]];
              } catch (e2) {
                menus[namespaces[o2.selector]] = null;
              }
              $document.off(namespaces[o2.selector]);
            }
            break;
          case "html5":
            if (!$.support.htmlCommand && !$.support.htmlMenuitem || typeof options === "boolean" && options) {
              $('menu[type="context"]').each(function() {
                if (this.id) {
                  $.contextMenu({
                    selector: "[contextmenu=" + this.id + "]",
                    items: $.contextMenu.fromMenu(this)
                  });
                }
              }).css("display", "none");
            }
            break;
          default:
            throw new Error('Unknown operation "' + operation + '"');
        }
        return this;
      };
      $.contextMenu.setInputValues = function(opt, data) {
        if (typeof data === "undefined") {
          data = {};
        }
        $.each(opt.inputs, function(key, item) {
          switch (item.type) {
            case "text":
            case "textarea":
              item.value = data[key] || "";
              break;
            case "checkbox":
              item.selected = data[key] ? true : false;
              break;
            case "radio":
              item.selected = (data[item.radio] || "") === item.value;
              break;
            case "select":
              item.selected = data[key] || "";
              break;
          }
        });
      };
      $.contextMenu.getInputValues = function(opt, data) {
        if (typeof data === "undefined") {
          data = {};
        }
        $.each(opt.inputs, function(key, item) {
          switch (item.type) {
            case "text":
            case "textarea":
            case "select":
              data[key] = item.$input.val();
              break;
            case "checkbox":
              data[key] = item.$input.prop("checked");
              break;
            case "radio":
              if (item.$input.prop("checked")) {
                data[item.radio] = item.value;
              }
              break;
          }
        });
        return data;
      };
      function inputLabel(node) {
        return node.id && $('label[for="' + node.id + '"]').val() || node.name;
      }
      function menuChildren(items, $children, counter2) {
        if (!counter2) {
          counter2 = 0;
        }
        $children.each(function() {
          var $node = $(this), node = this, nodeName = this.nodeName.toLowerCase(), label, item;
          if (nodeName === "label" && $node.find("input, textarea, select").length) {
            label = $node.text();
            $node = $node.children().first();
            node = $node.get(0);
            nodeName = node.nodeName.toLowerCase();
          }
          switch (nodeName) {
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
            case "menu":
              item = { name: $node.attr("label"), items: {} };
              counter2 = menuChildren(item.items, $node.children(), counter2);
              break;
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
            case "a":
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
            case "button":
              item = {
                name: $node.text(),
                disabled: !!$node.attr("disabled"),
                callback: /* @__PURE__ */ function() {
                  return function() {
                    $node.get(0).click();
                  };
                }()
              };
              break;
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command
            case "menuitem":
            case "command":
              switch ($node.attr("type")) {
                case void 0:
                case "command":
                case "menuitem":
                  item = {
                    name: $node.attr("label"),
                    disabled: !!$node.attr("disabled"),
                    icon: $node.attr("icon"),
                    callback: /* @__PURE__ */ function() {
                      return function() {
                        $node.get(0).click();
                      };
                    }()
                  };
                  break;
                case "checkbox":
                  item = {
                    type: "checkbox",
                    disabled: !!$node.attr("disabled"),
                    name: $node.attr("label"),
                    selected: !!$node.attr("checked")
                  };
                  break;
                case "radio":
                  item = {
                    type: "radio",
                    disabled: !!$node.attr("disabled"),
                    name: $node.attr("label"),
                    radio: $node.attr("radiogroup"),
                    value: $node.attr("id"),
                    selected: !!$node.attr("checked")
                  };
                  break;
                default:
                  item = void 0;
              }
              break;
            case "hr":
              item = "-------";
              break;
            case "input":
              switch ($node.attr("type")) {
                case "text":
                  item = {
                    type: "text",
                    name: label || inputLabel(node),
                    disabled: !!$node.attr("disabled"),
                    value: $node.val()
                  };
                  break;
                case "checkbox":
                  item = {
                    type: "checkbox",
                    name: label || inputLabel(node),
                    disabled: !!$node.attr("disabled"),
                    selected: !!$node.attr("checked")
                  };
                  break;
                case "radio":
                  item = {
                    type: "radio",
                    name: label || inputLabel(node),
                    disabled: !!$node.attr("disabled"),
                    radio: !!$node.attr("name"),
                    value: $node.val(),
                    selected: !!$node.attr("checked")
                  };
                  break;
                default:
                  item = void 0;
                  break;
              }
              break;
            case "select":
              item = {
                type: "select",
                name: label || inputLabel(node),
                disabled: !!$node.attr("disabled"),
                selected: $node.val(),
                options: {}
              };
              $node.children().each(function() {
                item.options[this.value] = $(this).text();
              });
              break;
            case "textarea":
              item = {
                type: "textarea",
                name: label || inputLabel(node),
                disabled: !!$node.attr("disabled"),
                value: $node.val()
              };
              break;
            case "label":
              break;
            default:
              item = { type: "html", html: $node.clone(true) };
              break;
          }
          if (item) {
            counter2++;
            items["key" + counter2] = item;
          }
        });
        return counter2;
      }
      $.contextMenu.fromMenu = function(element) {
        var $this = $(element), items = {};
        menuChildren(items, $this.children());
        return items;
      };
      $.contextMenu.defaults = defaults4;
      $.contextMenu.types = types2;
      $.contextMenu.handle = handle;
      $.contextMenu.op = op;
      $.contextMenu.menus = menus;
    });
  }
});

// node_modules/sumoselect/jquery.sumoselect.js
var require_jquery_sumoselect = __commonJS({
  "node_modules/sumoselect/jquery.sumoselect.js"(exports, module2) {
    (function(factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(["jquery"], factory);
      } else if (typeof exports !== "undefined") {
        module2.exports = factory(require_jquery());
      } else {
        factory(jQuery);
      }
    })(($) => {
      "namespace sumo";
      $.fn.SumoSelect = function(options) {
        const dispatchEvent = (target, eventName) => {
          let event = null;
          if (typeof Event === "function") {
            event = new Event(eventName, {
              bubbles: true
            });
          } else {
            event = document.createEvent("Event");
            event.initEvent(eventName, true, true);
          }
          target.dispatchEvent(event);
        };
        if (window.NodeList && !NodeList.prototype.forEach) {
          NodeList.prototype.forEach = Array.prototype.forEach;
        }
        const defaultOptions = {
          placeholder: "Select Here",
          // Dont change it here.
          csvDispCount: 3,
          // display no. of items in multiselect. 0 to display all.
          captionFormat: "{0} Selected",
          // format of caption text. you can set your locale.
          captionFormatAllSelected: "{0} all selected!",
          // format of caption text when all elements are selected. set null to use captionFormat. It will not work if there are disabled elements in select.
          floatWidth: 400,
          // Screen width of device at which the list is rendered in floating popup fashion.
          forceCustomRendering: false,
          // force the custom modal on all devices below floatWidth resolution.
          nativeOnDevice: ["Android", "BlackBerry", "iPhone", "iPad", "iPod", "Opera Mini", "IEMobile", "Silk"],
          //
          outputAsCSV: false,
          // true to POST data as csv ( false for Html control array ie. default select )
          csvSepChar: ",",
          // separation char in csv mode
          okCancelInMulti: false,
          // display ok cancel buttons in desktop mode multiselect also.
          isClickAwayOk: false,
          // for okCancelInMulti=true. sets whether click outside will trigger Ok or Cancel (default is cancel).
          triggerChangeCombined: true,
          // im multi select mode whether to trigger change event on individual selection or combined selection.
          selectAll: false,
          // to display select all button in multiselect mode.|| also select all will not be available on mobile devices.
          selectAllPartialCheck: true,
          // Display a disabled checkbox in multiselect mode when all the items are not selected.
          search: false,
          // to display input for filtering content. selectAlltext will be input text placeholder
          searchText: "Search...",
          // placeholder for search input
          searchFn(haystack, needle) {
            return haystack.toLowerCase().indexOf(needle.toLowerCase()) < 0;
          },
          noMatch: 'No matches for "{0}"',
          prefix: "",
          // some prefix usually the field name. eg. '<b>Hello</b>'
          locale: ["OK", "Cancel", "Select All", "Clear all"],
          // all text that is used. don't change the index.
          up: false,
          // set true to open upside.
          showTitle: true,
          // set to false to prevent title (tooltip) from appearing
          clearAll: false,
          // im multi select - clear all checked options
          closeAfterClearAll: false,
          // im multi select - close select after clear
          max: null,
          // Maximum number of options selected (when multiple)
          // eslint-disable-next-line no-unused-vars
          renderLi: (li, _originalOption) => li
          // Custom <li> item renderer
        };
        const ret = this.each(function() {
          const selObj = this;
          if (this.sumo || !$(this).is("select")) return;
          const settings = $.extend({}, defaultOptions, options, $(this).data());
          this.sumo = {
            E: $(selObj),
            //the jquery object of original select element.
            is_multi: $(selObj).attr("multiple"),
            //if its a multiple select
            select: "",
            caption: "",
            placeholder: "",
            optDiv: "",
            CaptionCont: "",
            ul: "",
            is_floating: false,
            is_opened: false,
            //backdrop: '',
            mob: false,
            // if to open device default select
            Pstate: [],
            lastUnselected: null,
            selectedCount: 0,
            createElems() {
              const O = this;
              const selectedOptions = O.E.find("option:checked");
              O.E.wrap('<div class="SumoSelect" tabindex="0" role="button" aria-expanded="false">');
              selectedOptions.each((_3, selectedOption) => {
                selectedOption.selected = true;
              });
              O.select = O.E.parent();
              O.caption = $("<span>");
              O.CaptionCont = $(`<p class="CaptionCont SelectBox ${O.E.attr("class")}" ><label><i></i></label></p>`).attr("style", O.E.attr("style")).prepend(O.caption);
              O.select.append(O.CaptionCont);
              if (!O.is_multi) settings.okCancelInMulti = false;
              if (O.E.attr("disabled"))
                O.select.addClass("disabled").removeAttr("tabindex");
              if (settings.outputAsCSV && O.is_multi && O.E.attr("name")) {
                O.select.append($('<input class="HEMANT123" type="hidden" />').attr("name", O.E.attr("name")).val(O.getSelStr()));
                O.E.removeAttr("name");
              }
              if (O.isMobile() && !settings.forceCustomRendering) {
                O.setNativeMobile();
                return;
              }
              if (O.E.attr("name")) O.select.addClass(`sumo_${O.E.attr("name").replace(/\[\]/, "")}`);
              O.E.addClass("SumoUnder").attr("tabindex", "-1");
              O.optDiv = $(`<div class="optWrapper ${settings.up ? "up" : ""}">`);
              O.floatingList();
              O.ul = $('<ul class="options">');
              O.optDiv.append(O.ul);
              if (settings.clearAll && O.is_multi) O.ClearAll();
              if (settings.selectAll && O.is_multi && !settings.max) O.SelAll();
              if (settings.search) O.Search();
              O.ul.append(O.prepItems(O.E.children()));
              if (O.is_multi) O.multiSelelect();
              O.select.append(O.optDiv);
              O._handleMax();
              O.basicEvents();
              O.selAllState();
            },
            prepItems(opts, d2) {
              const lis = [], O = this;
              $(opts).each((i2, opt) => {
                const $opt = $(opt);
                lis.push(
                  $opt.is("optgroup") ? $(`<li class="group ${opt.disabled ? "disabled" : ""}"><label></label><ul></ul></li>`).find("label").text($opt.attr("label")).end().find("ul").append(O.prepItems($opt.children(), opt.disabled)).end() : O.createLi($opt, d2)
                );
              });
              return lis;
            },
            //## Creates a LI element from a given option and binds events to it
            //## returns the jquery instance of li (not inserted in dom)
            createLi(opt, d2) {
              const O = this;
              if (!opt.attr("value")) opt.attr("value", opt.val());
              const li = $(`<li class="opt"><label>${opt.html()}</label></li>`);
              li.data("opt", opt);
              opt.data("li", li);
              if (O.is_multi) li.prepend("<span><i></i></span>");
              if (opt[0].disabled || d2)
                li.addClass("disabled");
              O.onOptClick(li);
              if (opt[0].selected) {
                li.addClass("selected");
                O.selectedCount++;
              }
              if (opt.attr("class"))
                li.addClass(opt.attr("class"));
              if (opt.attr("title"))
                li.attr("title", opt.attr("title"));
              return settings.renderLi(li, opt);
            },
            //## Returns the selected items as string in a Multiselect.
            getSelStr() {
              const sopt = [];
              this.E.find("option:checked").each(function() {
                sopt.push($(this).val());
              });
              return sopt.join(settings.csvSepChar);
            },
            //## THOSE OK/CANCEL BUTTONS ON MULTIPLE SELECT.
            multiSelelect() {
              const O = this;
              O.optDiv.addClass("multiple");
              O.okbtn = $('<p tabindex="0" class="btnOk"></p>').on("click", () => {
                O._okbtn();
                O.hideOpts();
              });
              [O.okbtn[0].innerText] = settings.locale;
              O.cancelBtn = $('<p tabindex="0" class="btnCancel"></p>').on("click", () => {
                O._cnbtn();
                O.hideOpts();
              });
              [, O.cancelBtn[0].innerText] = settings.locale;
              const btns = O.okbtn.add(O.cancelBtn);
              O.optDiv.append($('<div class="MultiControls">').append(btns));
              btns.on("keydown.sumo", function(e2) {
                const el = $(this);
                switch (e2.which) {
                  case 32:
                  // space
                  case 13:
                    el.trigger("click");
                    break;
                  case 9:
                    if (el.hasClass("btnOk")) return;
                    break;
                  case 27:
                    O._cnbtn();
                    O.hideOpts();
                    return;
                  default:
                    break;
                }
                e2.stopPropagation();
                e2.preventDefault();
              });
            },
            _okbtn() {
              const O = this;
              let cg = 0;
              if (settings.triggerChangeCombined) {
                if (O.E.find("option:checked").length !== O.Pstate.length) {
                  cg = 1;
                } else {
                  O.E.find("option").each((i2, e2) => {
                    if (e2.selected && O.Pstate.indexOf(i2) < 0) cg = 1;
                  });
                }
                if (cg) {
                  O.callChange();
                  O.setText();
                }
              }
            },
            _cnbtn() {
              const O = this;
              O.E.find("option:checked").each(function() {
                this.selected = false;
              });
              O.optDiv.find("li.selected").removeClass("selected");
              for (let i2 = 0; i2 < O.Pstate.length; i2++) {
                O.E.find("option")[O.Pstate[i2]].selected = true;
                O.ul.find("li.opt").eq(O.Pstate[i2]).addClass("selected");
              }
              O.setText();
              O.selAllState();
            },
            _handleMax() {
              if (settings.max) {
                if (this.selectedCount >= +settings.max) {
                  this.optDiv.find("li.opt").not(".hidden").each((ix, e2) => {
                    if (!$(e2).hasClass("selected")) {
                      $(e2).addClass("temporary-disabled disabled");
                    }
                  });
                } else {
                  this.optDiv.find("li.opt").not(".hidden").each((ix, e2) => {
                    if ($(e2).hasClass("temporary-disabled")) {
                      $(e2).removeClass("temporary-disabled disabled");
                    }
                  });
                }
              }
            },
            ClearAll() {
              const O = this;
              if (!O.is_multi) return;
              O.selAll = $('<p class="reset-all"><span><i></i></span><label></label></p>');
              [, , , O.selAll.find("label")[0].innerText] = settings.locale;
              O.optDiv.addClass("resetAll");
              O.selAll.on("click", () => {
                O.selAll.removeClass("selected");
                O.toggSelAll(false, 1);
                if (settings.closeAfterClearAll) {
                  O.hideOpts();
                }
              });
              O.optDiv.prepend(O.selAll);
            },
            SelAll() {
              const O = this;
              if (!O.is_multi) return;
              O.selAll = $('<p class="select-all"><span><i></i></span><label></label></p>');
              [, , O.selAll.find("label")[0].innerText] = settings.locale;
              O.optDiv.addClass("selall");
              O.selAll.on("click", () => {
                O.selAll.toggleClass("selected");
                O.toggSelAll(O.selAll.hasClass("selected"), 1);
                O.selAllState();
              });
              O.optDiv.prepend(O.selAll);
            },
            // search module (can be removed if not required.)
            Search() {
              const O = this, cc = O.CaptionCont.addClass("search"), P = $('<p class="no-match">'), fn = options.searchFn && typeof options.searchFn === "function" ? options.searchFn : settings.searchFn;
              O.ftxt = $('<input type="search" class="search-txt" value="" autocomplete="off">').on("click", (e2) => {
                e2.stopPropagation();
              });
              O.ftxt[0].placeholder = settings.searchText;
              cc.append(O.ftxt);
              O.optDiv.children("ul").after(P);
              O.ftxt.on("input.sumo", () => {
                const hid = O.optDiv.find("ul.options li.opt").each((ix, e2) => {
                  const el = $(e2), { 0: opt } = el.data("opt");
                  opt.hidden = fn(el.text(), O.ftxt.val(), el);
                  el.toggleClass("hidden", opt.hidden);
                }).not(".hidden");
                O.optDiv[0].querySelectorAll("li.group").forEach((optGroup) => {
                  if (optGroup.querySelector("li:not(.hidden)")) {
                    optGroup.classList.remove("hidden");
                  } else {
                    optGroup.classList.add("hidden");
                  }
                });
                P.html(settings.noMatch.replace(/\{0\}/g, "<em></em>")).toggle(!hid.length);
                P.find("em").text(O.ftxt.val());
                O.selAllState();
              });
            },
            selAllState() {
              const O = this;
              if (settings.selectAll && O.is_multi) {
                let sc = 0, vc = 0;
                O.optDiv.find("li.opt:not(.disabled):not(.hidden)").each((ix, e2) => {
                  if ($(e2).hasClass("selected")) sc++;
                  vc++;
                });
                if (sc === vc) O.selAll.removeClass("partial").addClass("selected");
                else if (sc === 0) O.selAll.removeClass("selected partial");
                else {
                  if (settings.selectAllPartialCheck) {
                    O.selAll.addClass("partial");
                  }
                  O.selAll.removeClass("selected");
                }
              }
            },
            showOpts() {
              const O = this;
              if (O.E.attr("disabled")) return;
              O.E.trigger("sumo:opening", O);
              O.is_opened = true;
              O.select.addClass("open").attr("aria-expanded", "true");
              const firstSelected = O.optDiv.find("li.opt.selected").first();
              if (firstSelected.length) {
                O.optDiv.find(".options").scrollTop(firstSelected.position().top);
              } else {
                O.optDiv.find(".options").scrollTop(0);
              }
              O.E.trigger("sumo:opened", O);
              if (O.ftxt) O.ftxt.focus();
              else O.select.focus();
              $(document).on("click.sumo", (e2) => {
                if (!O.select.is(e2.target) && O.select.has(e2.target).length === 0) {
                  if (!O.is_opened) return;
                  O.hideOpts();
                  if (settings.okCancelInMulti) {
                    if (settings.isClickAwayOk)
                      O._okbtn();
                    else
                      O._cnbtn();
                  }
                }
              });
              if (O.is_floating) {
                let H = O.optDiv.children("ul").outerHeight() + 2;
                if (O.is_multi) H = H + +O.optDiv.css("padding-bottom");
                O.optDiv.css("height", H);
                $("body").addClass("sumoStopScroll");
              }
              O.setPstate();
            },
            //maintain state when ok/cancel buttons are available storing the indexes.
            setPstate() {
              const O = this;
              if (O.is_multi && (O.is_floating || settings.okCancelInMulti)) {
                O.Pstate = [];
                O.E.find("option").each((i2, e2) => {
                  if (e2.selected) O.Pstate.push(i2);
                });
              }
            },
            callChange() {
              this.E.get().forEach((e2) => {
                dispatchEvent(e2, "change");
                dispatchEvent(e2, "click");
              });
            },
            hideOpts() {
              const O = this;
              if (O.is_opened) {
                O.E.trigger("sumo:closing", O);
                O.is_opened = false;
                O.select.removeClass("open").attr("aria-expanded", "false").find("ul li.sel").removeClass("sel");
                O.E.trigger("sumo:closed", O);
                $(document).off("click.sumo");
                $("body").removeClass("sumoStopScroll");
                if (settings.search) {
                  O.ftxt.val("");
                  O.ftxt.trigger("input.sumo");
                }
              }
            },
            setOnOpen() {
              const O = this;
              let li = O.optDiv.find("li.opt:not(.hidden)").eq(settings.search ? 0 : O.E[0].selectedIndex);
              if (li.hasClass("disabled")) {
                li = li.next(":not(disabled)");
                if (!li.length) return;
              }
              O.optDiv.find("li.sel").removeClass("sel");
              li.addClass("sel");
              O.showOpts();
            },
            nav(up) {
              const O = this;
              let c2 = null, sel = O.ul.find("li.opt.sel:not(.hidden)");
              const s2 = O.ul.find("li.opt:not(.disabled):not(.hidden)"), idx = s2.index(sel);
              if (O.is_opened && sel.length) {
                if (up && idx > 0)
                  c2 = s2.eq(idx - 1);
                else if (!up && idx < s2.length - 1 && idx > -1)
                  c2 = s2.eq(idx + 1);
                else return;
                sel.removeClass("sel");
                sel = c2.addClass("sel");
                const { ul } = O, st = ul.scrollTop(), t2 = sel.position().top + st;
                if (t2 >= st + ul.height() - sel.outerHeight())
                  ul.scrollTop(t2 - ul.height() + sel.outerHeight());
                if (t2 < st)
                  ul.scrollTop(t2);
              } else
                O.setOnOpen();
            },
            basicEvents() {
              const O = this;
              O.CaptionCont.on("click", (evt) => {
                O.E.trigger("click");
                if (O.is_opened) O.hideOpts();
                else O.showOpts();
                evt.stopPropagation();
              });
              O.select.on("keydown.sumo", (e2) => {
                switch (e2.which) {
                  case 38:
                    O.nav(true);
                    break;
                  case 40:
                    O.nav(false);
                    break;
                  case 65:
                    if (O.is_multi && !settings.max && e2.ctrlKey) {
                      O.toggSelAll(!e2.shiftKey, 1);
                      break;
                    } else
                      return;
                  case 32:
                    if (settings.search && O.ftxt.is(e2.target)) return;
                    break;
                  case 13:
                    if (O.is_opened)
                      O.optDiv.find("ul li.sel").trigger("click");
                    if (settings.search) O.select.focus();
                    else
                      O.setOnOpen();
                    break;
                  case 9:
                    if (!settings.okCancelInMulti)
                      O.hideOpts();
                    return;
                  case 27:
                    if (settings.okCancelInMulti) O._cnbtn();
                    O.hideOpts();
                    if (settings.search) O.select.focus();
                    return;
                  default:
                    return;
                }
                e2.preventDefault();
              });
              $(window).on("resize.sumo", () => {
                O.floatingList();
              });
            },
            onOptClick(li) {
              const O = this;
              li.on("click", function() {
                const $li = $(this);
                if ($li.hasClass("disabled")) return;
                if (O.is_multi) {
                  $li.toggleClass("selected");
                  $li.data("opt")[0].selected = $li.hasClass("selected");
                  if ($li.data("opt")[0].selected === false) {
                    O.lastUnselected = $li.data("opt")[0].textContent;
                    O.selectedCount--;
                  } else {
                    O.selectedCount++;
                  }
                  if (settings.max) {
                    O._handleMax();
                  }
                  O.selAllState();
                } else {
                  $li.parent().find("li.selected").removeClass("selected");
                  $li.toggleClass("selected");
                  $li.data("opt")[0].selected = true;
                  O.selectedCount = 1;
                }
                if (!(O.is_multi && settings.triggerChangeCombined && (O.is_floating || settings.okCancelInMulti))) {
                  O.setText();
                  O.callChange();
                }
                if (!O.is_multi) O.hideOpts();
              });
            },
            // fixed some variables that were not explicitly typed (michc)
            setText() {
              const O = this;
              let lengthSelected = 0;
              O.placeholder = "";
              if (O.is_multi) {
                const sels = O.E.find(":checked").not(":disabled");
                lengthSelected = sels.length;
                if (settings.csvDispCount && sels.length > settings.csvDispCount) {
                  if (sels.length === O.E.find("option").length && settings.captionFormatAllSelected) {
                    O.placeholder = settings.captionFormatAllSelected.replace(/\{0\}/g, sels.length);
                  } else {
                    O.placeholder = settings.captionFormat.replace(/\{0\}/g, sels.length);
                  }
                } else {
                  O.placeholder = sels.toArray().map((selected) => selected.innerText).join(", ");
                }
              } else {
                const option = O.E.find(":checked").not(":disabled");
                O.placeholder = option.text();
                lengthSelected = option.length;
              }
              let is_placeholder = false;
              if (!O.placeholder) {
                is_placeholder = true;
                O.placeholder = O.E.attr("placeholder");
                if (!O.placeholder)
                  O.placeholder = O.E.find("option:disabled:checked").text();
              }
              O.select.attr("selected-count", lengthSelected);
              O.select.attr("is-selected", lengthSelected ? "true" : "false");
              O.placeholder = O.placeholder ? `${settings.prefix} ${O.placeholder}` : settings.placeholder;
              O.caption.text(O.placeholder);
              if (settings.showTitle) O.CaptionCont.attr("title", O.placeholder);
              const csvField = O.select.find("input.HEMANT123");
              if (csvField.length) csvField.val(O.getSelStr());
              if (is_placeholder) O.caption.addClass("placeholder");
              else O.caption.removeClass("placeholder");
              return O.placeholder;
            },
            isMobile() {
              const ua = navigator.userAgent || navigator.vendor || window.opera;
              for (let i2 = 0; i2 < settings.nativeOnDevice.length; i2++) if (ua.toString().toLowerCase().indexOf(settings.nativeOnDevice[i2].toLowerCase()) > 0) return settings.nativeOnDevice[i2];
              return false;
            },
            setNativeMobile() {
              const O = this;
              O.E.addClass("SelectClass");
              O.mob = true;
              O.E.change(() => {
                O.setText();
              });
            },
            floatingList() {
              const O = this;
              O.is_floating = $(window).width() <= settings.floatWidth;
              O.optDiv.toggleClass("isFloating", O.is_floating);
              if (!O.is_floating) O.optDiv.css("height", "");
              O.optDiv.toggleClass("okCancelInMulti", settings.okCancelInMulti && !O.is_floating);
            },
            //HELPERS FOR OUTSIDERS
            // validates range of given item operations
            vRange(i2) {
              const O = this;
              const opts = O.E.find("option");
              if (opts.length <= i2 || i2 < 0) throw new Error("index out of bounds");
              return O;
            },
            //toggles selection on c as boolean.
            toggSel(c2, i2) {
              const O = this;
              let opt = null;
              if (typeof i2 === "number") {
                O.vRange(i2);
                opt = O.E.find("option")[i2];
              } else {
                opt = O.E.find(`option[value="${i2.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"]`)[0] || 0;
              }
              if (!opt || opt.disabled)
                return;
              if (opt.selected !== c2) {
                if (settings.max && !opt.selected && O.selectedCount < settings.max || opt.selected || !settings.max && !opt.selected) {
                  opt.selected = c2;
                  if (!O.mob) $(opt).data("li").toggleClass("selected", c2);
                  O.callChange();
                  O.setPstate();
                  O.setText();
                  if (!O.isMobile() || settings.forceCustomRendering) {
                    O.selAllState();
                  }
                }
              }
            },
            //toggles disabled on c as boolean.
            toggDis(c2, i2) {
              const O = this.vRange(i2);
              O.E.find("option")[i2].disabled = c2;
              if (c2) O.E.find("option")[i2].selected = false;
              if (!O.mob) O.optDiv.find("ul.options li.opt").eq(i2).toggleClass("disabled", c2).removeClass("selected");
              O.setText();
            },
            // toggle disable/enable on complete select control
            toggSumo(val) {
              const O = this;
              O.enabled = val;
              O.select.toggleClass("disabled", val);
              if (val) {
                O.E.attr("disabled", "disabled");
                O.select.removeAttr("tabindex");
              } else {
                O.E.removeAttr("disabled");
                O.select.attr("tabindex", "0");
              }
              return O;
            },
            // toggles all option on c as boolean.
            // set direct=false/0 bypasses okCancelInMulti behaviour.
            toggSelAll(c2, direct) {
              const O = this;
              const cloneOriginalEvents = $.extend(true, {}, $._data(O.E.get(0), "events"));
              O.E.off();
              if (O.is_multi) {
                if (c2) {
                  O.E.find("option").toArray().filter((option) => !option.selected && !option.disabled && option.style.display !== "none").forEach((option) => {
                    if (!$(option).data("li").hasClass("hidden")) {
                      option.selected = true;
                      $(option).data("li").toggleClass("selected", true);
                    }
                  });
                } else {
                  O.E.find("option").toArray().filter((option) => option.selected && !option.disabled && option.style.display !== "none").forEach((option) => {
                    if (!$(option).data("li").hasClass("hidden")) {
                      option.selected = false;
                      $(option).data("li").toggleClass("selected", false);
                    }
                  });
                }
              } else {
                if (!c2) O.E[0].selectedIndex = -1;
                else console.warn("You called `SelectAll` on a non-multiple select");
              }
              $.each(cloneOriginalEvents, (_3, e2) => {
                $.each(e2, (__, ev) => {
                  O.E.on(ev.type, ev.handler);
                });
              });
              if (O.is_multi && !settings.okCancelInMulti || !O.is_multi) {
                O.callChange();
                O.setText();
              }
              if (!direct) {
                if (!O.mob && O.selAll) O.selAll.removeClass("partial").toggleClass("selected", !!c2);
                O.setText();
                O.setPstate();
              }
            },
            /* outside accessibility options
              which can be accessed from the element instance.
             */
            reload() {
              const elm = this.unload();
              return $(elm).SumoSelect(settings);
            },
            unload() {
              const O = this;
              O.select.before(O.E);
              O.E.show();
              O.E[0].classList.remove("SumoUnder", "SelectClass");
              if (settings.outputAsCSV && O.is_multi && O.select.find("input.HEMANT123").length) {
                O.E.attr("name", O.select.find("input.HEMANT123").attr("name"));
              }
              O.select.remove();
              delete selObj.sumo;
              O.E.trigger("sumo:unloaded", O);
              return selObj;
            },
            //## add a new option to select at a given index.
            add(val, txt, i2, attr) {
              if (typeof val === "undefined") throw new Error("No value to add");
              const O = this;
              const opts = O.E.find("option");
              const value = val;
              let text = txt, index2 = i2;
              if (typeof txt === "number") {
                index2 = txt;
                text = val;
              } else if (typeof txt === "undefined") {
                text = val;
              }
              const opt = $("<option></option>").val(value).html(text);
              if (attr && typeof attr === "object") {
                $.each(attr, (j, v) => {
                  opt.attr(j, v);
                });
              }
              if (opts.length < index2) throw new Error("index out of bounds");
              if (typeof index2 === "undefined" || opts.length === index2) {
                O.E.append(opt);
                if (!O.mob) O.ul.append(O.createLi(opt));
              } else {
                opts.eq(index2).before(opt);
                if (!O.mob) O.ul.find("li.opt").eq(index2).before(O.createLi(opt));
              }
              return selObj;
            },
            //## removes an item at a given index.
            remove(i2) {
              const O = this.vRange(i2);
              O.E.find("option").eq(i2).remove();
              if (!O.mob) O.optDiv.find("ul.options li.opt").eq(i2).remove();
              O.setText();
            },
            // removes all but the selected one
            removeAll() {
              const O = this;
              const optionList = O.E.find("option");
              for (let x = optionList.length - 1; x >= 0; x--) {
                if (optionList[x].selected !== true) {
                  O.remove(x);
                }
              }
            },
            find(val) {
              const O = this;
              const optionList = O.E.find("option");
              for (const x in optionList) {
                if (optionList[x].value === val) {
                  return +x;
                }
              }
              return -1;
            },
            //## Select an item at a given index.
            selectItem(i2) {
              this.toggSel(true, i2);
            },
            //## UnSelect an iten at a given index.
            unSelectItem(i2) {
              this.toggSel(false, i2);
            },
            //## Select all items  of the select.
            selectAll() {
              this.toggSelAll(true);
            },
            //## UnSelect all items of the select.
            unSelectAll() {
              this.toggSelAll(false);
            },
            //## Disable an iten at a given index.
            disableItem(i2) {
              this.toggDis(true, i2);
            },
            //## Removes disabled an iten at a given index.
            enableItem(i2) {
              this.toggDis(false, i2);
            },
            //## New simple methods as getter and setter are not working fine in ie8-
            //## variable to check state of control if enabled or disabled.
            enabled: true,
            //## Enables the control
            enable() {
              return this.toggSumo(false);
            },
            //## Disables the control
            disable() {
              return this.toggSumo(true);
            },
            init() {
              const O = this;
              O.createElems();
              O.setText();
              O.E.trigger("sumo:initialized", O);
              return O;
            }
          };
          selObj.sumo.init();
        });
        return ret.length === 1 ? ret[0] : ret;
      };
    });
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber9, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone5(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber10.prototype = { constructor: BigNumber10, toString: null, valueOf: null }, ONE = new BigNumber10(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber10(v, b) {
          var alphabet, c2, caseChanged, e2, i2, isNum, len, str, x = this;
          if (!(x instanceof BigNumber10)) return new BigNumber10(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e2 = 0, i2 = v; i2 >= 10; i2 /= 10, e2++) ;
                if (e2 > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e2;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0) e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber10(v);
              return round3(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber10.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet.indexOf(c2 = str.charAt(i2)) < 0) {
                if (c2 == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber10.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e2 < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e2;
              x.c = [];
              i2 = (e2 + 1) % LOG_BASE;
              if (e2 < 0) i2 += LOG_BASE;
              if (i2 < len) {
                if (i2) x.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber10.clone = clone5;
        BigNumber10.ROUND_UP = 0;
        BigNumber10.ROUND_DOWN = 1;
        BigNumber10.ROUND_CEIL = 2;
        BigNumber10.ROUND_FLOOR = 3;
        BigNumber10.ROUND_HALF_UP = 4;
        BigNumber10.ROUND_HALF_DOWN = 5;
        BigNumber10.ROUND_HALF_EVEN = 6;
        BigNumber10.ROUND_HALF_CEIL = 7;
        BigNumber10.ROUND_HALF_FLOOR = 8;
        BigNumber10.EUCLID = 9;
        BigNumber10.config = BigNumber10.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber10.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber10.DEBUG) return true;
          var i2, n2, c2 = v.c, e2 = v.e, s2 = v.s;
          out: if ({}.toString.call(c2) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c2[0] === 0) {
                if (e2 === 0 && c2.length === 1) return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1) i2 += LOG_BASE;
              if (String(c2[0]).length == i2) {
                for (i2 = 0; i2 < c2.length; i2++) {
                  n2 = c2[i2];
                  if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2)) break out;
                }
                if (n2 !== 0) return true;
              }
            }
          } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber10.maximum = BigNumber10.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber10.minimum = BigNumber10.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber10.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a2, b, e2, k, v, i2 = 0, c2 = [], rand = new BigNumber10(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a2 = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i2 < k; ) {
                  v = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a2[i2] = b[0];
                    a2[i2 + 1] = b[1];
                  } else {
                    c2.push(v % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k / 2;
              } else if (crypto.randomBytes) {
                a2 = crypto.randomBytes(k *= 7);
                for (; i2 < k; ) {
                  v = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a2, i2);
                  } else {
                    c2.push(v % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k; ) {
                v = random53bitInt();
                if (v < 9e15) c2[i2++] = v % 1e14;
              }
            }
            k = c2[--i2];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c2[i2] = mathfloor(k / v) * v;
            }
            for (; c2[i2] === 0; c2.pop(), i2--) ;
            if (i2 < 0) {
              c2 = [e2 = 0];
            } else {
              for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
              for (i2 = 1, v = c2[0]; v >= 10; v /= 10, i2++) ;
              if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
            }
            rand.e = e2;
            rand.c = c2;
            return rand;
          };
        }();
        BigNumber10.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber10(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i2++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign3, callerIsToString) {
            var alphabet, d2, e2, k, r2, x, xc, y, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber10(baseIn);
              x = y.pow(str.length - i2);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e2 = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x.c = xc;
              x.e = e2;
              x.s = sign3;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r2 = x.r;
              e2 = x.e;
            }
            d2 = e2 + dp + 1;
            i2 = xc[d2];
            k = baseOut / 2;
            r2 = r2 || d2 < 0 || xc[d2 + 1] != null;
            r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i2 > k || i2 == k && (rm == 4 || r2 || rm == 6 && xc[d2 - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d2 < 1 || !xc[0]) {
              str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d2;
              if (r2) {
                for (--baseOut; ++xc[--d2] > baseOut; ) {
                  xc[d2] = 0;
                  if (!d2) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i2 = 0, str = ""; i2 <= k; str += alphabet.charAt(xc[i2++])) ;
              str = toFixedPoint(str, e2, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i2--; ) {
              xlo = x[i2] % SQRT_BASE;
              xhi = x[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x[i2] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a2, b, aL, bL) {
            var i2, cmp2;
            if (aL != bL) {
              cmp2 = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp2 = 0; i2 < aL; i2++) {
                if (a2[i2] != b[i2]) {
                  cmp2 = a2[i2] > b[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp2;
          }
          function subtract2(a2, b, aL, base) {
            var i2 = 0;
            for (; aL--; ) {
              a2[aL] -= i2;
              i2 = a2[aL] < b[aL] ? 1 : 0;
              a2[aL] = i2 * base + a2[aL] - b[aL];
            }
            for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp2, e2, i2, more, n2, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber10(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q = new BigNumber10(s2);
            qc = q.c = [];
            e2 = x.e - y.e;
            s2 = dp + e2 + 1;
            if (!base) {
              base = BASE;
              e2 = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s2 = s2 / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n2 = mathfloor(base / (yc[0] + 1));
              if (n2 > 1) {
                yc = multiply(yc, n2, base);
                xc = multiply(xc, n2, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n2 = 0;
                cmp2 = compare2(yc, rem, yL, remL);
                if (cmp2 < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n2 = mathfloor(rem0 / yc0);
                  if (n2 > 1) {
                    if (n2 >= base) n2 = base - 1;
                    prod = multiply(yc, n2, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n2--;
                      subtract2(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp2 = 1;
                    }
                  } else {
                    if (n2 == 0) {
                      cmp2 = n2 = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract2(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp2 == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n2++;
                      subtract2(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp2 === 0) {
                  n2++;
                  rem = [0];
                }
                qc[i2++] = n2;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
              round3(q, dp + (q.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e2;
              q.r = +more;
            }
            return q;
          };
        }();
        function format3(n2, i2, rm, id) {
          var c0, e2, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n2.c) return n2.toString();
          c0 = n2.c[0];
          ne = n2.e;
          if (i2 == null) {
            str = coeffToString(n2.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n2 = round3(new BigNumber10(n2), i2, rm);
            e2 = n2.e;
            str = coeffToString(n2.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e2);
            } else {
              i2 -= ne;
              str = toFixedPoint(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n2.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n2) {
          var k, y, i2 = 1, x = new BigNumber10(args[0]);
          for (; i2 < args.length; i2++) {
            y = new BigNumber10(args[i2]);
            if (!y.s || (k = compare(x, y)) === n2 || k === 0 && x.s === n2) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n2, c2, e2) {
          var i2 = 1, j = c2.length;
          for (; !c2[--j]; c2.pop()) ;
          for (j = c2[0]; j >= 10; j /= 10, i2++) ;
          if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
            n2.c = n2.e = null;
          } else if (e2 < MIN_EXP) {
            n2.c = [n2.e = 0];
          } else {
            n2.e = e2;
            n2.c = c2;
          }
          return n2;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m2;
                });
                if (b) {
                  base = b;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber10(s2, base);
              }
              if (BigNumber10.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round3(x, sd, rm, r2) {
          var d2, i2, j, k, n2, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d2 = 1, k = xc[0]; k >= 10; k /= 10, d2++) ;
              i2 = sd - d2;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j = sd;
                n2 = xc[ni = 0];
                rd = mathfloor(n2 / pows10[d2 - j - 1] % 10);
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r2) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n2 = rd = 0;
                    d2 = 1;
                    i2 %= LOG_BASE;
                    j = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n2 = k = xc[ni];
                  for (d2 = 1; k >= 10; k /= 10, d2++) ;
                  i2 %= LOG_BASE;
                  j = i2 - LOG_BASE + d2;
                  rd = j < 0 ? 0 : mathfloor(n2 / pows10[d2 - j - 1] % 10);
                }
              }
              r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n2 : n2 % pows10[d2 - j - 1]);
              r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j > 0 ? n2 / pows10[d2 - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r2) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i2 == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i2];
                xc[ni] = j > 0 ? mathfloor(n2 / pows10[d2 - j] % pows10[j]) * k : 0;
              }
              if (r2) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j = xc[0]; j >= 10; j /= 10, i2++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i2 != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf2(n2) {
          var str, e2 = n2.e;
          if (e2 === null) return n2.toString();
          str = coeffToString(n2.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
          return n2.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber10(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber10(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c2, n2, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round3(new BigNumber10(x), dp + x.e + 1, rm);
          }
          if (!(c2 = x.c)) return null;
          n2 = ((v = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c2[v]) for (; v % 10 == 0; v /= 10, n2--) ;
          if (n2 < 0) n2 = 0;
          return n2;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber10(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber10(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n2, m2) {
          var half, isModExp, i2, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n2 = new BigNumber10(n2);
          if (n2.c && !n2.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf2(n2));
          }
          if (m2 != null) m2 = new BigNumber10(m2);
          nIsBig = n2.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n2.c || !n2.c[0]) {
            y = new BigNumber10(Math.pow(+valueOf2(x), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf2(n2)));
            return m2 ? y.mod(m2) : y;
          }
          nIsNeg = n2.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber10(NaN);
            isModExp = !nIsNeg && x.isInteger() && m2.isInteger();
            if (isModExp) x = x.mod(m2);
          } else if (n2.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n2) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber10(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber10(0.5);
            if (nIsNeg) n2.s = 1;
            nIsOdd = isOdd(n2);
          } else {
            i2 = Math.abs(+valueOf2(n2));
            nIsOdd = i2 % 2;
          }
          y = new BigNumber10(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n2 = n2.times(half);
              round3(n2, n2.e + 1, 1);
              if (n2.e > 14) {
                nIsOdd = isOdd(n2);
              } else {
                i2 = +valueOf2(n2);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m2);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m2 ? y.mod(m2) : k ? round3(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n2 = new BigNumber10(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round3(n2, n2.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber10(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber10(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber10(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber10(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber10(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i2, j, t2, xLTy, x = this, a2 = x.s;
          y = new BigNumber10(y, b);
          b = y.s;
          if (!a2 || !b) return new BigNumber10(NaN);
          if (a2 != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber10(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber10(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe - ye) {
            if (xLTy = a2 < 0) {
              a2 = -a2;
              t2 = xc;
            } else {
              ye = xe;
              t2 = yc;
            }
            t2.reverse();
            for (b = a2; b--; t2.push(0)) ;
            t2.reverse();
          } else {
            j = (xLTy = (a2 = xc.length) < (b = yc.length)) ? a2 : b;
            for (a2 = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t2 = xc;
            xc = yc;
            yc = t2;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i2 = xc.length);
          if (b > 0) for (; b--; xc[i2++] = 0) ;
          b = BASE - 1;
          for (; j > a2; ) {
            if (xc[--j] < yc[j]) {
              for (i2 = j; i2 && !xc[--i2]; xc[i2] = b) ;
              --xc[i2];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s2, x = this;
          y = new BigNumber10(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber10(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber10(x);
          }
          if (MODULO_MODE == 9) {
            s2 = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s2;
            q.s *= s2;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c2, e2, i2, j, k, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber10(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e2 = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c2 = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k = xcL, j = i2 + k; j > i2; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j] + c2;
              c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c2;
          }
          if (c2) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e2);
        };
        P.negated = function() {
          var x = new BigNumber10(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t2, x = this, a2 = x.s;
          y = new BigNumber10(y, b);
          b = y.s;
          if (!a2 || !b) return new BigNumber10(NaN);
          if (a2 != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber10(a2 / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber10(xc[0] ? x : a2 * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe - ye) {
            if (a2 > 0) {
              ye = xe;
              t2 = yc;
            } else {
              a2 = -a2;
              t2 = xc;
            }
            t2.reverse();
            for (; a2--; t2.push(0)) ;
            t2.reverse();
          }
          a2 = xc.length;
          b = yc.length;
          if (a2 - b < 0) {
            t2 = yc;
            yc = xc;
            xc = t2;
            b = a2;
          }
          for (a2 = 0; b; ) {
            a2 = (xc[--b] = xc[b] + yc[b] + a2) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a2) {
            xc = [a2].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c2, n2, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round3(new BigNumber10(x), sd, rm);
          }
          if (!(c2 = x.c)) return null;
          v = c2.length - 1;
          n2 = v * LOG_BASE + 1;
          if (v = c2[v]) {
            for (; v % 10 == 0; v /= 10, n2--) ;
            for (v = c2[0]; v >= 10; v /= 10, n2++) ;
          }
          if (sd && x.e + 1 > n2) n2 = x.e + 1;
          return n2;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m2, n2, r2, rep, t2, x = this, c2 = x.c, s2 = x.s, e2 = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber10("0.5");
          if (s2 !== 1 || !c2 || !c2[0]) {
            return new BigNumber10(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf2(x));
          if (s2 == 0 || s2 == 1 / 0) {
            n2 = coeffToString(c2);
            if ((n2.length + e2) % 2 == 0) n2 += "0";
            s2 = Math.sqrt(+n2);
            e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n2 = "5e" + e2;
            } else {
              n2 = s2.toExponential();
              n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
            }
            r2 = new BigNumber10(n2);
          } else {
            r2 = new BigNumber10(s2 + "");
          }
          if (r2.c[0]) {
            e2 = r2.e;
            s2 = e2 + dp;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t2 = r2;
              r2 = half.times(t2.plus(div(x, t2, dp, 1)));
              if (coeffToString(t2.c).slice(0, s2) === (n2 = coeffToString(r2.c)).slice(0, s2)) {
                if (r2.e < e2) --s2;
                n2 = n2.slice(s2 - 3, s2 + 1);
                if (n2 == "9999" || !rep && n2 == "4999") {
                  if (!rep) {
                    round3(t2, t2.e + DECIMAL_PLACES + 2, 0);
                    if (t2.times(t2).eq(x)) {
                      r2 = t2;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
                    round3(r2, r2.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r2.times(r2).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round3(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format3(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format3(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format4) {
          var str, x = this;
          if (format4 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format4 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format4 = dp;
              dp = rm = null;
            } else {
              format4 = FORMAT;
            }
          } else if (typeof format4 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format4);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i2, arr = str.split("."), g1 = +format4.groupSize, g2 = +format4.secondaryGroupSize, groupSeparator = format4.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format4.decimalSeparator || "") + ((g2 = +format4.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format4.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format4.prefix || "") + str + (format4.suffix || "");
        };
        P.toFraction = function(md) {
          var d2, d0, d1, d22, e2, exp, n2, n0, n1, q, r2, s2, x = this, xc = x.c;
          if (md != null) {
            n2 = new BigNumber10(md);
            if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf2(n2));
            }
          }
          if (!xc) return new BigNumber10(x);
          d2 = new BigNumber10(ONE);
          n1 = d0 = new BigNumber10(ONE);
          d1 = n0 = new BigNumber10(ONE);
          s2 = coeffToString(xc);
          e2 = d2.e = s2.length - x.e - 1;
          d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n2.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n2;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n2 = new BigNumber10(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n2, d2, 0, 1);
            d22 = d0.plus(q.times(d1));
            if (d22.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d22;
            n1 = n0.plus(q.times(d22 = n1));
            n0 = d22;
            d2 = n2.minus(q.times(d22 = d2));
            n2 = d22;
          }
          d22 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x.s;
          e2 = e2 * 2;
          r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e2, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r2;
        };
        P.toNumber = function() {
          return +valueOf2(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format3(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n2 = this, s2 = n2.s, e2 = n2.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n2 = round3(new BigNumber10(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b, s2, true);
            }
            if (s2 < 0 && n2.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf2(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber10.set(configObject);
        return BigNumber10;
      }
      function bitFloor(n2) {
        var i2 = n2 | 0;
        return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a2) {
        var s2, z, i2 = 1, j = a2.length, r2 = a2[0] + "";
        for (; i2 < j; ) {
          s2 = a2[i2++] + "";
          z = LOG_BASE - s2.length;
          for (; z--; s2 = "0" + s2) ;
          r2 += s2;
        }
        for (j = r2.length; r2.charCodeAt(--j) === 48; ) ;
        return r2.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a2, b, xc = x.c, yc = y.c, i2 = x.s, j = y.s, k = x.e, l2 = y.e;
        if (!i2 || !j) return null;
        a2 = xc && !xc[0];
        b = yc && !yc[0];
        if (a2 || b) return a2 ? b ? 0 : -j : i2;
        if (i2 != j) return i2;
        a2 = i2 < 0;
        b = k == l2;
        if (!xc || !yc) return b ? 0 : !xc ^ a2 ? 1 : -1;
        if (!b) return k > l2 ^ a2 ? 1 : -1;
        j = (k = xc.length) < (l2 = yc.length) ? k : l2;
        for (i2 = 0; i2 < j; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
        return k == l2 ? 0 : k > l2 ^ a2 ? 1 : -1;
      }
      function intCheck(n2, min3, max3, name) {
        if (n2 < min3 || n2 > max3 || n2 !== mathfloor(n2)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min3 || n2 > max3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
        }
      }
      function isOdd(n2) {
        var k = n2.c.length - 1;
        return bitFloor(n2.e / LOG_BASE) == k && n2.c[k] % 2 != 0;
      }
      function toExponential(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint(str, e2, z) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z + "."; ++e2; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z, e2 -= len; --e2; zs += z) ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber9 = clone5();
      BigNumber9["default"] = BigNumber9.BigNumber = BigNumber9;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber9;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber9;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber9;
      }
    })(exports);
  }
});

// node_modules/numeral/numeral.js
var require_numeral = __commonJS({
  "node_modules/numeral/numeral.js"(exports, module2) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        global2.numeral = factory();
      }
    })(exports, function() {
      var numeral17, _3, VERSION2 = "2.0.6", formats2 = {}, locales2 = {}, defaults4 = {
        currentLocale: "en",
        zeroFormat: null,
        nullFormat: null,
        defaultFormat: "0,0",
        scalePercentBy100: true
      }, options = {
        currentLocale: defaults4.currentLocale,
        zeroFormat: defaults4.zeroFormat,
        nullFormat: defaults4.nullFormat,
        defaultFormat: defaults4.defaultFormat,
        scalePercentBy100: defaults4.scalePercentBy100
      };
      function Numeral(input, number) {
        this._input = input;
        this._value = number;
      }
      numeral17 = function(input) {
        var value, kind, unformatFunction, regexp;
        if (numeral17.isNumeral(input)) {
          value = input.value();
        } else if (input === 0 || typeof input === "undefined") {
          value = 0;
        } else if (input === null || _3.isNaN(input)) {
          value = null;
        } else if (typeof input === "string") {
          if (options.zeroFormat && input === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, "").length) {
            value = null;
          } else {
            for (kind in formats2) {
              regexp = typeof formats2[kind].regexps.unformat === "function" ? formats2[kind].regexps.unformat() : formats2[kind].regexps.unformat;
              if (regexp && input.match(regexp)) {
                unformatFunction = formats2[kind].unformat;
                break;
              }
            }
            unformatFunction = unformatFunction || numeral17._.stringToNumber;
            value = unformatFunction(input);
          }
        } else {
          value = Number(input) || null;
        }
        return new Numeral(input, value);
      };
      numeral17.version = VERSION2;
      numeral17.isNumeral = function(obj) {
        return obj instanceof Numeral;
      };
      numeral17._ = _3 = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function(value, format3, roundingFunction) {
          var locale2 = locales2[numeral17.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = "", trillion = 1e12, billion = 1e9, million = 1e6, thousand = 1e3, decimal = "", neg = false, abbrForce, abs2, min3, max3, power, int2, precision, signed, thousands, output;
          value = value || 0;
          abs2 = Math.abs(value);
          if (numeral17._.includes(format3, "(")) {
            negP = true;
            format3 = format3.replace(/[\(|\)]/g, "");
          } else if (numeral17._.includes(format3, "+") || numeral17._.includes(format3, "-")) {
            signed = numeral17._.includes(format3, "+") ? format3.indexOf("+") : value < 0 ? format3.indexOf("-") : -1;
            format3 = format3.replace(/[\+|\-]/g, "");
          }
          if (numeral17._.includes(format3, "a")) {
            abbrForce = format3.match(/a(k|m|b|t)?/);
            abbrForce = abbrForce ? abbrForce[1] : false;
            if (numeral17._.includes(format3, " a")) {
              abbr = " ";
            }
            format3 = format3.replace(new RegExp(abbr + "a[kmbt]?"), "");
            if (abs2 >= trillion && !abbrForce || abbrForce === "t") {
              abbr += locale2.abbreviations.trillion;
              value = value / trillion;
            } else if (abs2 < trillion && abs2 >= billion && !abbrForce || abbrForce === "b") {
              abbr += locale2.abbreviations.billion;
              value = value / billion;
            } else if (abs2 < billion && abs2 >= million && !abbrForce || abbrForce === "m") {
              abbr += locale2.abbreviations.million;
              value = value / million;
            } else if (abs2 < million && abs2 >= thousand && !abbrForce || abbrForce === "k") {
              abbr += locale2.abbreviations.thousand;
              value = value / thousand;
            }
          }
          if (numeral17._.includes(format3, "[.]")) {
            optDec = true;
            format3 = format3.replace("[.]", ".");
          }
          int2 = value.toString().split(".")[0];
          precision = format3.split(".")[1];
          thousands = format3.indexOf(",");
          leadingCount = (format3.split(".")[0].split(",")[0].match(/0/g) || []).length;
          if (precision) {
            if (numeral17._.includes(precision, "[")) {
              precision = precision.replace("]", "");
              precision = precision.split("[");
              decimal = numeral17._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
            } else {
              decimal = numeral17._.toFixed(value, precision.length, roundingFunction);
            }
            int2 = decimal.split(".")[0];
            if (numeral17._.includes(decimal, ".")) {
              decimal = locale2.delimiters.decimal + decimal.split(".")[1];
            } else {
              decimal = "";
            }
            if (optDec && Number(decimal.slice(1)) === 0) {
              decimal = "";
            }
          } else {
            int2 = numeral17._.toFixed(value, 0, roundingFunction);
          }
          if (abbr && !abbrForce && Number(int2) >= 1e3 && abbr !== locale2.abbreviations.trillion) {
            int2 = String(Number(int2) / 1e3);
            switch (abbr) {
              case locale2.abbreviations.thousand:
                abbr = locale2.abbreviations.million;
                break;
              case locale2.abbreviations.million:
                abbr = locale2.abbreviations.billion;
                break;
              case locale2.abbreviations.billion:
                abbr = locale2.abbreviations.trillion;
                break;
            }
          }
          if (numeral17._.includes(int2, "-")) {
            int2 = int2.slice(1);
            neg = true;
          }
          if (int2.length < leadingCount) {
            for (var i2 = leadingCount - int2.length; i2 > 0; i2--) {
              int2 = "0" + int2;
            }
          }
          if (thousands > -1) {
            int2 = int2.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + locale2.delimiters.thousands);
          }
          if (format3.indexOf(".") === 0) {
            int2 = "";
          }
          output = int2 + decimal + (abbr ? abbr : "");
          if (negP) {
            output = (negP && neg ? "(" : "") + output + (negP && neg ? ")" : "");
          } else {
            if (signed >= 0) {
              output = signed === 0 ? (neg ? "-" : "+") + output : output + (neg ? "-" : "+");
            } else if (neg) {
              output = "-" + output;
            }
          }
          return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function(string) {
          var locale2 = locales2[options.currentLocale], stringOriginal = string, abbreviations = {
            thousand: 3,
            million: 6,
            billion: 9,
            trillion: 12
          }, abbreviation, value, i2, regexp;
          if (options.zeroFormat && string === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, "").length) {
            value = null;
          } else {
            value = 1;
            if (locale2.delimiters.decimal !== ".") {
              string = string.replace(/\./g, "").replace(locale2.delimiters.decimal, ".");
            }
            for (abbreviation in abbreviations) {
              regexp = new RegExp("[^a-zA-Z]" + locale2.abbreviations[abbreviation] + "(?:\\)|(\\" + locale2.currency.symbol + ")?(?:\\))?)?$");
              if (stringOriginal.match(regexp)) {
                value *= Math.pow(10, abbreviations[abbreviation]);
                break;
              }
            }
            value *= (string.split("-").length + Math.min(string.split("(").length - 1, string.split(")").length - 1)) % 2 ? 1 : -1;
            string = string.replace(/[^0-9\.]+/g, "");
            value *= Number(string);
          }
          return value;
        },
        isNaN: function(value) {
          return typeof value === "number" && isNaN(value);
        },
        includes: function(string, search) {
          return string.indexOf(search) !== -1;
        },
        insert: function(string, subString, start) {
          return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function(array, callback2) {
          if (this === null) {
            throw new TypeError("Array.prototype.reduce called on null or undefined");
          }
          if (typeof callback2 !== "function") {
            throw new TypeError(callback2 + " is not a function");
          }
          var t2 = Object(array), len = t2.length >>> 0, k = 0, value;
          if (arguments.length === 3) {
            value = arguments[2];
          } else {
            while (k < len && !(k in t2)) {
              k++;
            }
            if (k >= len) {
              throw new TypeError("Reduce of empty array with no initial value");
            }
            value = t2[k++];
          }
          for (; k < len; k++) {
            if (k in t2) {
              value = callback2(value, t2[k], k, t2);
            }
          }
          return value;
        },
        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function(x) {
          var parts = x.toString().split(".");
          return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function() {
          var args = Array.prototype.slice.call(arguments);
          return args.reduce(function(accum, next) {
            var mn = _3.multiplier(next);
            return accum > mn ? accum : mn;
          }, 1);
        },
        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
          var splitValue = value.toString().split("."), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;
          if (splitValue.length === 2) {
            boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
          } else {
            boundedPrecision = minDecimals;
          }
          power = Math.pow(10, boundedPrecision);
          output = (roundingFunction(value + "e+" + boundedPrecision) / power).toFixed(boundedPrecision);
          if (optionals > maxDecimals - boundedPrecision) {
            optionalsRegExp = new RegExp("\\.?0{1," + (optionals - (maxDecimals - boundedPrecision)) + "}$");
            output = output.replace(optionalsRegExp, "");
          }
          return output;
        }
      };
      numeral17.options = options;
      numeral17.formats = formats2;
      numeral17.locales = locales2;
      numeral17.locale = function(key) {
        if (key) {
          options.currentLocale = key.toLowerCase();
        }
        return options.currentLocale;
      };
      numeral17.localeData = function(key) {
        if (!key) {
          return locales2[options.currentLocale];
        }
        key = key.toLowerCase();
        if (!locales2[key]) {
          throw new Error("Unknown locale : " + key);
        }
        return locales2[key];
      };
      numeral17.reset = function() {
        for (var property2 in defaults4) {
          options[property2] = defaults4[property2];
        }
      };
      numeral17.zeroFormat = function(format3) {
        options.zeroFormat = typeof format3 === "string" ? format3 : null;
      };
      numeral17.nullFormat = function(format3) {
        options.nullFormat = typeof format3 === "string" ? format3 : null;
      };
      numeral17.defaultFormat = function(format3) {
        options.defaultFormat = typeof format3 === "string" ? format3 : "0.0";
      };
      numeral17.register = function(type, name, format3) {
        name = name.toLowerCase();
        if (this[type + "s"][name]) {
          throw new TypeError(name + " " + type + " already registered.");
        }
        this[type + "s"][name] = format3;
        return format3;
      };
      numeral17.validate = function(val, culture) {
        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData2, temp;
        if (typeof val !== "string") {
          val += "";
          if (console.warn) {
            console.warn("Numeral.js: Value is not string. It has been co-erced to: ", val);
          }
        }
        val = val.trim();
        if (!!val.match(/^\d+$/)) {
          return true;
        }
        if (val === "") {
          return false;
        }
        try {
          localeData2 = numeral17.localeData(culture);
        } catch (e2) {
          localeData2 = numeral17.localeData(numeral17.locale());
        }
        _currSymbol = localeData2.currency.symbol;
        _abbrObj = localeData2.abbreviations;
        _decimalSep = localeData2.delimiters.decimal;
        if (localeData2.delimiters.thousands === ".") {
          _thousandSep = "\\.";
        } else {
          _thousandSep = localeData2.delimiters.thousands;
        }
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
          val = val.substr(1);
          if (temp[0] !== _currSymbol) {
            return false;
          }
        }
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
          val = val.slice(0, -1);
          if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
            return false;
          }
        }
        _thousandRegEx = new RegExp(_thousandSep + "{2}");
        if (!val.match(/[^\d.,]/g)) {
          _valArray = val.split(_decimalSep);
          if (_valArray.length > 2) {
            return false;
          } else {
            if (_valArray.length < 2) {
              return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
            } else {
              if (_valArray[0].length === 1) {
                return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              } else {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              }
            }
          }
        }
        return false;
      };
      numeral17.fn = Numeral.prototype = {
        clone: function() {
          return numeral17(this);
        },
        format: function(inputString, roundingFunction) {
          var value = this._value, format3 = inputString || options.defaultFormat, kind, output, formatFunction;
          roundingFunction = roundingFunction || Math.round;
          if (value === 0 && options.zeroFormat !== null) {
            output = options.zeroFormat;
          } else if (value === null && options.nullFormat !== null) {
            output = options.nullFormat;
          } else {
            for (kind in formats2) {
              if (format3.match(formats2[kind].regexps.format)) {
                formatFunction = formats2[kind].format;
                break;
              }
            }
            formatFunction = formatFunction || numeral17._.numberToFormat;
            output = formatFunction(value, format3, roundingFunction);
          }
          return output;
        },
        value: function() {
          return this._value;
        },
        input: function() {
          return this._input;
        },
        set: function(value) {
          this._value = Number(value);
          return this;
        },
        add: function(value) {
          var corrFactor = _3.correctionFactor.call(null, this._value, value);
          function cback(accum, curr, currI, O) {
            return accum + Math.round(corrFactor * curr);
          }
          this._value = _3.reduce([this._value, value], cback, 0) / corrFactor;
          return this;
        },
        subtract: function(value) {
          var corrFactor = _3.correctionFactor.call(null, this._value, value);
          function cback(accum, curr, currI, O) {
            return accum - Math.round(corrFactor * curr);
          }
          this._value = _3.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
          return this;
        },
        multiply: function(value) {
          function cback(accum, curr, currI, O) {
            var corrFactor = _3.correctionFactor(accum, curr);
            return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
          }
          this._value = _3.reduce([this._value, value], cback, 1);
          return this;
        },
        divide: function(value) {
          function cback(accum, curr, currI, O) {
            var corrFactor = _3.correctionFactor(accum, curr);
            return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
          }
          this._value = _3.reduce([this._value, value], cback);
          return this;
        },
        difference: function(value) {
          return Math.abs(numeral17(this._value).subtract(value).value());
        }
      };
      numeral17.register("locale", "en", {
        delimiters: {
          thousands: ",",
          decimal: "."
        },
        abbreviations: {
          thousand: "k",
          million: "m",
          billion: "b",
          trillion: "t"
        },
        ordinal: function(number) {
          var b = number % 10;
          return ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        },
        currency: {
          symbol: "$"
        }
      });
      (function() {
        numeral17.register("format", "bps", {
          regexps: {
            format: /(BPS)/,
            unformat: /(BPS)/
          },
          format: function(value, format3, roundingFunction) {
            var space = numeral17._.includes(format3, " BPS") ? " " : "", output;
            value = value * 1e4;
            format3 = format3.replace(/\s?BPS/, "");
            output = numeral17._.numberToFormat(value, format3, roundingFunction);
            if (numeral17._.includes(output, ")")) {
              output = output.split("");
              output.splice(-1, 0, space + "BPS");
              output = output.join("");
            } else {
              output = output + space + "BPS";
            }
            return output;
          },
          unformat: function(string) {
            return +(numeral17._.stringToNumber(string) * 1e-4).toFixed(15);
          }
        });
      })();
      (function() {
        var decimal = {
          base: 1e3,
          suffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
        }, binary = {
          base: 1024,
          suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
        };
        var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function(item) {
          return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join("|");
        unformatRegex = "(" + unformatRegex.replace("B", "B(?!PS)") + ")";
        numeral17.register("format", "bytes", {
          regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
          },
          format: function(value, format3, roundingFunction) {
            var output, bytes = numeral17._.includes(format3, "ib") ? binary : decimal, suffix = numeral17._.includes(format3, " b") || numeral17._.includes(format3, " ib") ? " " : "", power, min3, max3;
            format3 = format3.replace(/\s?i?b/, "");
            for (power = 0; power <= bytes.suffixes.length; power++) {
              min3 = Math.pow(bytes.base, power);
              max3 = Math.pow(bytes.base, power + 1);
              if (value === null || value === 0 || value >= min3 && value < max3) {
                suffix += bytes.suffixes[power];
                if (min3 > 0) {
                  value = value / min3;
                }
                break;
              }
            }
            output = numeral17._.numberToFormat(value, format3, roundingFunction);
            return output + suffix;
          },
          unformat: function(string) {
            var value = numeral17._.stringToNumber(string), power, bytesMultiplier;
            if (value) {
              for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                if (numeral17._.includes(string, decimal.suffixes[power])) {
                  bytesMultiplier = Math.pow(decimal.base, power);
                  break;
                }
                if (numeral17._.includes(string, binary.suffixes[power])) {
                  bytesMultiplier = Math.pow(binary.base, power);
                  break;
                }
              }
              value *= bytesMultiplier || 1;
            }
            return value;
          }
        });
      })();
      (function() {
        numeral17.register("format", "currency", {
          regexps: {
            format: /(\$)/
          },
          format: function(value, format3, roundingFunction) {
            var locale2 = numeral17.locales[numeral17.options.currentLocale], symbols = {
              before: format3.match(/^([\+|\-|\(|\s|\$]*)/)[0],
              after: format3.match(/([\+|\-|\)|\s|\$]*)$/)[0]
            }, output, symbol, i2;
            format3 = format3.replace(/\s?\$\s?/, "");
            output = numeral17._.numberToFormat(value, format3, roundingFunction);
            if (value >= 0) {
              symbols.before = symbols.before.replace(/[\-\(]/, "");
              symbols.after = symbols.after.replace(/[\-\)]/, "");
            } else if (value < 0 && (!numeral17._.includes(symbols.before, "-") && !numeral17._.includes(symbols.before, "("))) {
              symbols.before = "-" + symbols.before;
            }
            for (i2 = 0; i2 < symbols.before.length; i2++) {
              symbol = symbols.before[i2];
              switch (symbol) {
                case "$":
                  output = numeral17._.insert(output, locale2.currency.symbol, i2);
                  break;
                case " ":
                  output = numeral17._.insert(output, " ", i2 + locale2.currency.symbol.length - 1);
                  break;
              }
            }
            for (i2 = symbols.after.length - 1; i2 >= 0; i2--) {
              symbol = symbols.after[i2];
              switch (symbol) {
                case "$":
                  output = i2 === symbols.after.length - 1 ? output + locale2.currency.symbol : numeral17._.insert(output, locale2.currency.symbol, -(symbols.after.length - (1 + i2)));
                  break;
                case " ":
                  output = i2 === symbols.after.length - 1 ? output + " " : numeral17._.insert(output, " ", -(symbols.after.length - (1 + i2) + locale2.currency.symbol.length - 1));
                  break;
              }
            }
            return output;
          }
        });
      })();
      (function() {
        numeral17.register("format", "exponential", {
          regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
          },
          format: function(value, format3, roundingFunction) {
            var output, exponential = typeof value === "number" && !numeral17._.isNaN(value) ? value.toExponential() : "0e+0", parts = exponential.split("e");
            format3 = format3.replace(/e[\+|\-]{1}0/, "");
            output = numeral17._.numberToFormat(Number(parts[0]), format3, roundingFunction);
            return output + "e" + parts[1];
          },
          unformat: function(string) {
            var parts = numeral17._.includes(string, "e+") ? string.split("e+") : string.split("e-"), value = Number(parts[0]), power = Number(parts[1]);
            power = numeral17._.includes(string, "e-") ? power *= -1 : power;
            function cback(accum, curr, currI, O) {
              var corrFactor = numeral17._.correctionFactor(accum, curr), num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
              return num;
            }
            return numeral17._.reduce([value, Math.pow(10, power)], cback, 1);
          }
        });
      })();
      (function() {
        numeral17.register("format", "ordinal", {
          regexps: {
            format: /(o)/
          },
          format: function(value, format3, roundingFunction) {
            var locale2 = numeral17.locales[numeral17.options.currentLocale], output, ordinal2 = numeral17._.includes(format3, " o") ? " " : "";
            format3 = format3.replace(/\s?o/, "");
            ordinal2 += locale2.ordinal(value);
            output = numeral17._.numberToFormat(value, format3, roundingFunction);
            return output + ordinal2;
          }
        });
      })();
      (function() {
        numeral17.register("format", "percentage", {
          regexps: {
            format: /(%)/,
            unformat: /(%)/
          },
          format: function(value, format3, roundingFunction) {
            var space = numeral17._.includes(format3, " %") ? " " : "", output;
            if (numeral17.options.scalePercentBy100) {
              value = value * 100;
            }
            format3 = format3.replace(/\s?\%/, "");
            output = numeral17._.numberToFormat(value, format3, roundingFunction);
            if (numeral17._.includes(output, ")")) {
              output = output.split("");
              output.splice(-1, 0, space + "%");
              output = output.join("");
            } else {
              output = output + space + "%";
            }
            return output;
          },
          unformat: function(string) {
            var number = numeral17._.stringToNumber(string);
            if (numeral17.options.scalePercentBy100) {
              return number * 0.01;
            }
            return number;
          }
        });
      })();
      (function() {
        numeral17.register("format", "time", {
          regexps: {
            format: /(:)/,
            unformat: /(:)/
          },
          format: function(value, format3, roundingFunction) {
            var hours2 = Math.floor(value / 60 / 60), minutes2 = Math.floor((value - hours2 * 60 * 60) / 60), seconds2 = Math.round(value - hours2 * 60 * 60 - minutes2 * 60);
            return hours2 + ":" + (minutes2 < 10 ? "0" + minutes2 : minutes2) + ":" + (seconds2 < 10 ? "0" + seconds2 : seconds2);
          },
          unformat: function(string) {
            var timeArray = string.split(":"), seconds2 = 0;
            if (timeArray.length === 3) {
              seconds2 = seconds2 + Number(timeArray[0]) * 60 * 60;
              seconds2 = seconds2 + Number(timeArray[1]) * 60;
              seconds2 = seconds2 + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
              seconds2 = seconds2 + Number(timeArray[0]) * 60;
              seconds2 = seconds2 + Number(timeArray[1]);
            }
            return Number(seconds2);
          }
        });
      })();
      return numeral17;
    });
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf18(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf18.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i2, k, ph, pad2, pad_character, pad_length, is_positive, sign3;
        for (i2 = 0; i2 < tree_length; i2++) {
          if (typeof parse_tree[i2] === "string") {
            output += parse_tree[i2];
          } else if (typeof parse_tree[i2] === "object") {
            ph = parse_tree[i2];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf18('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf18("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign3 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign3 = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign3 + arg).length;
              pad2 = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign3 + arg + pad2 : pad_character === "0" ? sign3 + pad2 + arg : pad2 + sign3 + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf18;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf18;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf18,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/papaparse/papaparse.min.js
var require_papaparse_min = __commonJS({
  "node_modules/papaparse/papaparse.min.js"(exports, module2) {
    !function(e2, t2) {
      "function" == typeof define && define.amd ? define([], t2) : "object" == typeof module2 && "undefined" != typeof exports ? module2.exports = t2() : e2.Papa = t2();
    }(exports, function s2() {
      "use strict";
      var f2 = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f2 ? f2 : {};
      var n2 = !f2.document && !!f2.postMessage, o2 = f2.IS_PAPA_WORKER || false, a2 = {}, u = 0, b = { parse: function(e2, t2) {
        var r3 = (t2 = t2 || {}).dynamicTyping || false;
        J(r3) && (t2.dynamicTypingFunction = r3, r3 = {});
        if (t2.dynamicTyping = r3, t2.transform = !!J(t2.transform) && t2.transform, t2.worker && b.WORKERS_SUPPORTED) {
          var i2 = function() {
            if (!b.WORKERS_SUPPORTED) return false;
            var e3 = (r4 = f2.URL || f2.webkitURL || null, i3 = s2.toString(), b.BLOB_URL || (b.BLOB_URL = r4.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i3, ")();"], { type: "text/javascript" })))), t3 = new f2.Worker(e3);
            var r4, i3;
            return t3.onmessage = _3, t3.id = u++, a2[t3.id] = t3;
          }();
          return i2.userStep = t2.step, i2.userChunk = t2.chunk, i2.userComplete = t2.complete, i2.userError = t2.error, t2.step = J(t2.step), t2.chunk = J(t2.chunk), t2.complete = J(t2.complete), t2.error = J(t2.error), delete t2.worker, void i2.postMessage({ input: e2, config: t2, workerId: i2.id });
        }
        var n3 = null;
        b.NODE_STREAM_INPUT, "string" == typeof e2 ? (e2 = function(e3) {
          if (65279 === e3.charCodeAt(0)) return e3.slice(1);
          return e3;
        }(e2), n3 = t2.download ? new l2(t2) : new p(t2)) : true === e2.readable && J(e2.read) && J(e2.on) ? n3 = new g(t2) : (f2.File && e2 instanceof File || e2 instanceof Object) && (n3 = new c2(t2));
        return n3.stream(e2);
      }, unparse: function(e2, t2) {
        var n3 = false, _4 = true, m3 = ",", y2 = "\r\n", s3 = '"', a3 = s3 + s3, r3 = false, i2 = null, o3 = false;
        !function() {
          if ("object" != typeof t2) return;
          "string" != typeof t2.delimiter || b.BAD_DELIMITERS.filter(function(e3) {
            return -1 !== t2.delimiter.indexOf(e3);
          }).length || (m3 = t2.delimiter);
          ("boolean" == typeof t2.quotes || "function" == typeof t2.quotes || Array.isArray(t2.quotes)) && (n3 = t2.quotes);
          "boolean" != typeof t2.skipEmptyLines && "string" != typeof t2.skipEmptyLines || (r3 = t2.skipEmptyLines);
          "string" == typeof t2.newline && (y2 = t2.newline);
          "string" == typeof t2.quoteChar && (s3 = t2.quoteChar);
          "boolean" == typeof t2.header && (_4 = t2.header);
          if (Array.isArray(t2.columns)) {
            if (0 === t2.columns.length) throw new Error("Option columns is empty");
            i2 = t2.columns;
          }
          void 0 !== t2.escapeChar && (a3 = t2.escapeChar + s3);
          ("boolean" == typeof t2.escapeFormulae || t2.escapeFormulae instanceof RegExp) && (o3 = t2.escapeFormulae instanceof RegExp ? t2.escapeFormulae : /^[=+\-@\t\r].*$/);
        }();
        var u2 = new RegExp(Q(s3), "g");
        "string" == typeof e2 && (e2 = JSON.parse(e2));
        if (Array.isArray(e2)) {
          if (!e2.length || Array.isArray(e2[0])) return h3(null, e2, r3);
          if ("object" == typeof e2[0]) return h3(i2 || Object.keys(e2[0]), e2, r3);
        } else if ("object" == typeof e2) return "string" == typeof e2.data && (e2.data = JSON.parse(e2.data)), Array.isArray(e2.data) && (e2.fields || (e2.fields = e2.meta && e2.meta.fields || i2), e2.fields || (e2.fields = Array.isArray(e2.data[0]) ? e2.fields : "object" == typeof e2.data[0] ? Object.keys(e2.data[0]) : []), Array.isArray(e2.data[0]) || "object" == typeof e2.data[0] || (e2.data = [e2.data])), h3(e2.fields || [], e2.data || [], r3);
        throw new Error("Unable to serialize unrecognized input");
        function h3(e3, t3, r4) {
          var i3 = "";
          "string" == typeof e3 && (e3 = JSON.parse(e3)), "string" == typeof t3 && (t3 = JSON.parse(t3));
          var n4 = Array.isArray(e3) && 0 < e3.length, s4 = !Array.isArray(t3[0]);
          if (n4 && _4) {
            for (var a4 = 0; a4 < e3.length; a4++) 0 < a4 && (i3 += m3), i3 += v2(e3[a4], a4);
            0 < t3.length && (i3 += y2);
          }
          for (var o4 = 0; o4 < t3.length; o4++) {
            var u3 = n4 ? e3.length : t3[o4].length, h4 = false, f3 = n4 ? 0 === Object.keys(t3[o4]).length : 0 === t3[o4].length;
            if (r4 && !n4 && (h4 = "greedy" === r4 ? "" === t3[o4].join("").trim() : 1 === t3[o4].length && 0 === t3[o4][0].length), "greedy" === r4 && n4) {
              for (var d3 = [], l3 = 0; l3 < u3; l3++) {
                var c3 = s4 ? e3[l3] : l3;
                d3.push(t3[o4][c3]);
              }
              h4 = "" === d3.join("").trim();
            }
            if (!h4) {
              for (var p2 = 0; p2 < u3; p2++) {
                0 < p2 && !f3 && (i3 += m3);
                var g2 = n4 && s4 ? e3[p2] : p2;
                i3 += v2(t3[o4][g2], p2);
              }
              o4 < t3.length - 1 && (!r4 || 0 < u3 && !f3) && (i3 += y2);
            }
          }
          return i3;
        }
        function v2(e3, t3) {
          if (null == e3) return "";
          if (e3.constructor === Date) return JSON.stringify(e3).slice(1, 25);
          var r4 = false;
          o3 && "string" == typeof e3 && o3.test(e3) && (e3 = "'" + e3, r4 = true);
          var i3 = e3.toString().replace(u2, a3);
          return (r4 = r4 || true === n3 || "function" == typeof n3 && n3(e3, t3) || Array.isArray(n3) && n3[t3] || function(e4, t4) {
            for (var r5 = 0; r5 < t4.length; r5++) if (-1 < e4.indexOf(t4[r5])) return true;
            return false;
          }(i3, b.BAD_DELIMITERS) || -1 < i3.indexOf(m3) || " " === i3.charAt(0) || " " === i3.charAt(i3.length - 1)) ? s3 + i3 + s3 : i3;
        }
      } };
      if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n2 && !!f2.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = r2, b.NetworkStreamer = l2, b.FileStreamer = c2, b.StringStreamer = p, b.ReadableStreamStreamer = g, f2.jQuery) {
        var d2 = f2.jQuery;
        d2.fn.parse = function(o3) {
          var r3 = o3.config || {}, u2 = [];
          return this.each(function(e3) {
            if (!("INPUT" === d2(this).prop("tagName").toUpperCase() && "file" === d2(this).attr("type").toLowerCase() && f2.FileReader) || !this.files || 0 === this.files.length) return true;
            for (var t2 = 0; t2 < this.files.length; t2++) u2.push({ file: this.files[t2], inputElem: this, instanceConfig: d2.extend({}, r3) });
          }), e2(), this;
          function e2() {
            if (0 !== u2.length) {
              var e3, t2, r4, i2, n3 = u2[0];
              if (J(o3.before)) {
                var s3 = o3.before(n3.file, n3.inputElem);
                if ("object" == typeof s3) {
                  if ("abort" === s3.action) return e3 = "AbortError", t2 = n3.file, r4 = n3.inputElem, i2 = s3.reason, void (J(o3.error) && o3.error({ name: e3 }, t2, r4, i2));
                  if ("skip" === s3.action) return void h3();
                  "object" == typeof s3.config && (n3.instanceConfig = d2.extend(n3.instanceConfig, s3.config));
                } else if ("skip" === s3) return void h3();
              }
              var a3 = n3.instanceConfig.complete;
              n3.instanceConfig.complete = function(e4) {
                J(a3) && a3(e4, n3.file, n3.inputElem), h3();
              }, b.parse(n3.file, n3.instanceConfig);
            } else J(o3.complete) && o3.complete();
          }
          function h3() {
            u2.splice(0, 1), e2();
          }
        };
      }
      function h(e2) {
        this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, (function(e3) {
          var t2 = w(e3);
          t2.chunkSize = parseInt(t2.chunkSize), e3.step || e3.chunk || (t2.chunkSize = null);
          this._handle = new r2(t2), (this._handle.streamer = this)._config = t2;
        }).call(this, e2), this.parseChunk = function(e3, t2) {
          if (this.isFirstChunk && J(this._config.beforeFirstChunk)) {
            var r3 = this._config.beforeFirstChunk(e3);
            void 0 !== r3 && (e3 = r3);
          }
          this.isFirstChunk = false, this._halted = false;
          var i2 = this._partialLine + e3;
          this._partialLine = "";
          var n3 = this._handle.parse(i2, this._baseIndex, !this._finished);
          if (!this._handle.paused() && !this._handle.aborted()) {
            var s3 = n3.meta.cursor;
            this._finished || (this._partialLine = i2.substring(s3 - this._baseIndex), this._baseIndex = s3), n3 && n3.data && (this._rowCount += n3.data.length);
            var a3 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
            if (o2) f2.postMessage({ results: n3, workerId: b.WORKER_ID, finished: a3 });
            else if (J(this._config.chunk) && !t2) {
              if (this._config.chunk(n3, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = true);
              n3 = void 0, this._completeResults = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n3.data), this._completeResults.errors = this._completeResults.errors.concat(n3.errors), this._completeResults.meta = n3.meta), this._completed || !a3 || !J(this._config.complete) || n3 && n3.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a3 || n3 && n3.meta.paused || this._nextChunk(), n3;
          }
          this._halted = true;
        }, this._sendError = function(e3) {
          J(this._config.error) ? this._config.error(e3) : o2 && this._config.error && f2.postMessage({ workerId: b.WORKER_ID, error: e3, finished: false });
        };
      }
      function l2(e2) {
        var i2;
        (e2 = e2 || {}).chunkSize || (e2.chunkSize = b.RemoteChunkSize), h.call(this, e2), this._nextChunk = n2 ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(e3) {
          this._input = e3, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished) this._chunkLoaded();
          else {
            if (i2 = new XMLHttpRequest(), this._config.withCredentials && (i2.withCredentials = this._config.withCredentials), n2 || (i2.onload = v(this._chunkLoaded, this), i2.onerror = v(this._chunkError, this)), i2.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n2), this._config.downloadRequestHeaders) {
              var e3 = this._config.downloadRequestHeaders;
              for (var t2 in e3) i2.setRequestHeader(t2, e3[t2]);
            }
            if (this._config.chunkSize) {
              var r3 = this._start + this._config.chunkSize - 1;
              i2.setRequestHeader("Range", "bytes=" + this._start + "-" + r3);
            }
            try {
              i2.send(this._config.downloadRequestBody);
            } catch (e4) {
              this._chunkError(e4.message);
            }
            n2 && 0 === i2.status && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          4 === i2.readyState && (i2.status < 200 || 400 <= i2.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i2.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e3) {
            var t2 = e3.getResponseHeader("Content-Range");
            if (null === t2) return -1;
            return parseInt(t2.substring(t2.lastIndexOf("/") + 1));
          }(i2), this.parseChunk(i2.responseText)));
        }, this._chunkError = function(e3) {
          var t2 = i2.statusText || e3;
          this._sendError(new Error(t2));
        };
      }
      function c2(e2) {
        var i2, n3;
        (e2 = e2 || {}).chunkSize || (e2.chunkSize = b.LocalChunkSize), h.call(this, e2);
        var s3 = "undefined" != typeof FileReader;
        this.stream = function(e3) {
          this._input = e3, n3 = e3.slice || e3.webkitSlice || e3.mozSlice, s3 ? ((i2 = new FileReader()).onload = v(this._chunkLoaded, this), i2.onerror = v(this._chunkError, this)) : i2 = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var e3 = this._input;
          if (this._config.chunkSize) {
            var t2 = Math.min(this._start + this._config.chunkSize, this._input.size);
            e3 = n3.call(e3, this._start, t2);
          }
          var r3 = i2.readAsText(e3, this._config.encoding);
          s3 || this._chunkLoaded({ target: { result: r3 } });
        }, this._chunkLoaded = function(e3) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e3.target.result);
        }, this._chunkError = function() {
          this._sendError(i2.error);
        };
      }
      function p(e2) {
        var r3;
        h.call(this, e2 = e2 || {}), this.stream = function(e3) {
          return r3 = e3, this._nextChunk();
        }, this._nextChunk = function() {
          if (!this._finished) {
            var e3, t2 = this._config.chunkSize;
            return t2 ? (e3 = r3.substring(0, t2), r3 = r3.substring(t2)) : (e3 = r3, r3 = ""), this._finished = !r3, this.parseChunk(e3);
          }
        };
      }
      function g(e2) {
        h.call(this, e2 = e2 || {});
        var t2 = [], r3 = true, i2 = false;
        this.pause = function() {
          h.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          h.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(e3) {
          this._input = e3, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          i2 && 1 === t2.length && (this._finished = true);
        }, this._nextChunk = function() {
          this._checkIsFinished(), t2.length ? this.parseChunk(t2.shift()) : r3 = true;
        }, this._streamData = v(function(e3) {
          try {
            t2.push("string" == typeof e3 ? e3 : e3.toString(this._config.encoding)), r3 && (r3 = false, this._checkIsFinished(), this.parseChunk(t2.shift()));
          } catch (e4) {
            this._streamError(e4);
          }
        }, this), this._streamError = v(function(e3) {
          this._streamCleanUp(), this._sendError(e3);
        }, this), this._streamEnd = v(function() {
          this._streamCleanUp(), i2 = true, this._streamData("");
        }, this), this._streamCleanUp = v(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function r2(m3) {
        var a3, o3, u2, i2 = Math.pow(2, 53), n3 = -i2, s3 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h3 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t2 = this, r3 = 0, f3 = 0, d3 = false, e2 = false, l3 = [], c3 = { data: [], errors: [], meta: {} };
        if (J(m3.step)) {
          var p2 = m3.step;
          m3.step = function(e3) {
            if (c3 = e3, _4()) g2();
            else {
              if (g2(), 0 === c3.data.length) return;
              r3 += e3.data.length, m3.preview && r3 > m3.preview ? o3.abort() : (c3.data = c3.data[0], p2(c3, t2));
            }
          };
        }
        function y2(e3) {
          return "greedy" === m3.skipEmptyLines ? "" === e3.join("").trim() : 1 === e3.length && 0 === e3[0].length;
        }
        function g2() {
          return c3 && u2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), u2 = false), m3.skipEmptyLines && (c3.data = c3.data.filter(function(e3) {
            return !y2(e3);
          })), _4() && function() {
            if (!c3) return;
            function e3(e4, t4) {
              J(m3.transformHeader) && (e4 = m3.transformHeader(e4, t4)), l3.push(e4);
            }
            if (Array.isArray(c3.data[0])) {
              for (var t3 = 0; _4() && t3 < c3.data.length; t3++) c3.data[t3].forEach(e3);
              c3.data.splice(0, 1);
            } else c3.data.forEach(e3);
          }(), function() {
            if (!c3 || !m3.header && !m3.dynamicTyping && !m3.transform) return c3;
            function e3(e4, t4) {
              var r4, i3 = m3.header ? {} : [];
              for (r4 = 0; r4 < e4.length; r4++) {
                var n4 = r4, s4 = e4[r4];
                m3.header && (n4 = r4 >= l3.length ? "__parsed_extra" : l3[r4]), m3.transform && (s4 = m3.transform(s4, n4)), s4 = v2(n4, s4), "__parsed_extra" === n4 ? (i3[n4] = i3[n4] || [], i3[n4].push(s4)) : i3[n4] = s4;
              }
              return m3.header && (r4 > l3.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l3.length + " fields but parsed " + r4, f3 + t4) : r4 < l3.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l3.length + " fields but parsed " + r4, f3 + t4)), i3;
            }
            var t3 = 1;
            !c3.data.length || Array.isArray(c3.data[0]) ? (c3.data = c3.data.map(e3), t3 = c3.data.length) : c3.data = e3(c3.data, 0);
            m3.header && c3.meta && (c3.meta.fields = l3);
            return f3 += t3, c3;
          }();
        }
        function _4() {
          return m3.header && 0 === l3.length;
        }
        function v2(e3, t3) {
          return r4 = e3, m3.dynamicTypingFunction && void 0 === m3.dynamicTyping[r4] && (m3.dynamicTyping[r4] = m3.dynamicTypingFunction(r4)), true === (m3.dynamicTyping[r4] || m3.dynamicTyping) ? "true" === t3 || "TRUE" === t3 || "false" !== t3 && "FALSE" !== t3 && (function(e4) {
            if (s3.test(e4)) {
              var t4 = parseFloat(e4);
              if (n3 < t4 && t4 < i2) return true;
            }
            return false;
          }(t3) ? parseFloat(t3) : h3.test(t3) ? new Date(t3) : "" === t3 ? null : t3) : t3;
          var r4;
        }
        function k(e3, t3, r4, i3) {
          var n4 = { type: e3, code: t3, message: r4 };
          void 0 !== i3 && (n4.row = i3), c3.errors.push(n4);
        }
        this.parse = function(e3, t3, r4) {
          var i3 = m3.quoteChar || '"';
          if (m3.newline || (m3.newline = function(e4, t4) {
            e4 = e4.substring(0, 1048576);
            var r5 = new RegExp(Q(t4) + "([^]*?)" + Q(t4), "gm"), i4 = (e4 = e4.replace(r5, "")).split("\r"), n5 = e4.split("\n"), s5 = 1 < n5.length && n5[0].length < i4[0].length;
            if (1 === i4.length || s5) return "\n";
            for (var a4 = 0, o4 = 0; o4 < i4.length; o4++) "\n" === i4[o4][0] && a4++;
            return a4 >= i4.length / 2 ? "\r\n" : "\r";
          }(e3, i3)), u2 = false, m3.delimiter) J(m3.delimiter) && (m3.delimiter = m3.delimiter(e3), c3.meta.delimiter = m3.delimiter);
          else {
            var n4 = function(e4, t4, r5, i4, n5) {
              var s5, a4, o4, u3;
              n5 = n5 || [",", "	", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
              for (var h4 = 0; h4 < n5.length; h4++) {
                var f4 = n5[h4], d4 = 0, l4 = 0, c4 = 0;
                o4 = void 0;
                for (var p3 = new E({ comments: i4, delimiter: f4, newline: t4, preview: 10 }).parse(e4), g3 = 0; g3 < p3.data.length; g3++) if (r5 && y2(p3.data[g3])) c4++;
                else {
                  var _5 = p3.data[g3].length;
                  l4 += _5, void 0 !== o4 ? 0 < _5 && (d4 += Math.abs(_5 - o4), o4 = _5) : o4 = _5;
                }
                0 < p3.data.length && (l4 /= p3.data.length - c4), (void 0 === a4 || d4 <= a4) && (void 0 === u3 || u3 < l4) && 1.99 < l4 && (a4 = d4, s5 = f4, u3 = l4);
              }
              return { successful: !!(m3.delimiter = s5), bestDelimiter: s5 };
            }(e3, m3.newline, m3.skipEmptyLines, m3.comments, m3.delimitersToGuess);
            n4.successful ? m3.delimiter = n4.bestDelimiter : (u2 = true, m3.delimiter = b.DefaultDelimiter), c3.meta.delimiter = m3.delimiter;
          }
          var s4 = w(m3);
          return m3.preview && m3.header && s4.preview++, a3 = e3, o3 = new E(s4), c3 = o3.parse(a3, t3, r4), g2(), d3 ? { meta: { paused: true } } : c3 || { meta: { paused: false } };
        }, this.paused = function() {
          return d3;
        }, this.pause = function() {
          d3 = true, o3.abort(), a3 = J(m3.chunk) ? "" : a3.substring(o3.getCharIndex());
        }, this.resume = function() {
          t2.streamer._halted ? (d3 = false, t2.streamer.parseChunk(a3, true)) : setTimeout(t2.resume, 3);
        }, this.aborted = function() {
          return e2;
        }, this.abort = function() {
          e2 = true, o3.abort(), c3.meta.aborted = true, J(m3.complete) && m3.complete(c3), a3 = "";
        };
      }
      function Q(e2) {
        return e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function E(j) {
        var z, M = (j = j || {}).delimiter, P = j.newline, U = j.comments, q = j.step, N = j.preview, B = j.fastMode, K = z = void 0 === j.quoteChar || null === j.quoteChar ? '"' : j.quoteChar;
        if (void 0 !== j.escapeChar && (K = j.escapeChar), ("string" != typeof M || -1 < b.BAD_DELIMITERS.indexOf(M)) && (M = ","), U === M) throw new Error("Comment character same as delimiter");
        true === U ? U = "#" : ("string" != typeof U || -1 < b.BAD_DELIMITERS.indexOf(U)) && (U = false), "\n" !== P && "\r" !== P && "\r\n" !== P && (P = "\n");
        var W = 0, H = false;
        this.parse = function(i2, t2, r3) {
          if ("string" != typeof i2) throw new Error("Input must be a string");
          var n3 = i2.length, e2 = M.length, s3 = P.length, a3 = U.length, o3 = J(q), u2 = [], h3 = [], f3 = [], d3 = W = 0;
          if (!i2) return L();
          if (j.header && !t2) {
            var l3 = i2.split(P)[0].split(M), c3 = [], p2 = {}, g2 = false;
            for (var _4 in l3) {
              var m3 = l3[_4];
              J(j.transformHeader) && (m3 = j.transformHeader(m3, _4));
              var y2 = m3, v2 = p2[m3] || 0;
              for (0 < v2 && (g2 = true, y2 = m3 + "_" + v2), p2[m3] = v2 + 1; c3.includes(y2); ) y2 = y2 + "_" + v2;
              c3.push(y2);
            }
            if (g2) {
              var k = i2.split(P);
              k[0] = c3.join(M), i2 = k.join(P);
            }
          }
          if (B || false !== B && -1 === i2.indexOf(z)) {
            for (var b2 = i2.split(P), E2 = 0; E2 < b2.length; E2++) {
              if (f3 = b2[E2], W += f3.length, E2 !== b2.length - 1) W += P.length;
              else if (r3) return L();
              if (!U || f3.substring(0, a3) !== U) {
                if (o3) {
                  if (u2 = [], I2(f3.split(M)), F(), H) return L();
                } else I2(f3.split(M));
                if (N && N <= E2) return u2 = u2.slice(0, N), L(true);
              }
            }
            return L();
          }
          for (var w2 = i2.indexOf(M, W), R = i2.indexOf(P, W), C = new RegExp(Q(K) + Q(z), "g"), S = i2.indexOf(z, W); ; ) if (i2[W] !== z) if (U && 0 === f3.length && i2.substring(W, W + a3) === U) {
            if (-1 === R) return L();
            W = R + s3, R = i2.indexOf(P, W), w2 = i2.indexOf(M, W);
          } else if (-1 !== w2 && (w2 < R || -1 === R)) f3.push(i2.substring(W, w2)), W = w2 + e2, w2 = i2.indexOf(M, W);
          else {
            if (-1 === R) break;
            if (f3.push(i2.substring(W, R)), D(R + s3), o3 && (F(), H)) return L();
            if (N && u2.length >= N) return L(true);
          }
          else for (S = W, W++; ; ) {
            if (-1 === (S = i2.indexOf(z, S + 1))) return r3 || h3.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u2.length, index: W }), T();
            if (S === n3 - 1) return T(i2.substring(W, S).replace(C, z));
            if (z !== K || i2[S + 1] !== K) {
              if (z === K || 0 === S || i2[S - 1] !== K) {
                -1 !== w2 && w2 < S + 1 && (w2 = i2.indexOf(M, S + 1)), -1 !== R && R < S + 1 && (R = i2.indexOf(P, S + 1));
                var O = A(-1 === R ? w2 : Math.min(w2, R));
                if (i2.substr(S + 1 + O, e2) === M) {
                  f3.push(i2.substring(W, S).replace(C, z)), i2[W = S + 1 + O + e2] !== z && (S = i2.indexOf(z, W)), w2 = i2.indexOf(M, W), R = i2.indexOf(P, W);
                  break;
                }
                var x = A(R);
                if (i2.substring(S + 1 + x, S + 1 + x + s3) === P) {
                  if (f3.push(i2.substring(W, S).replace(C, z)), D(S + 1 + x + s3), w2 = i2.indexOf(M, W), S = i2.indexOf(z, W), o3 && (F(), H)) return L();
                  if (N && u2.length >= N) return L(true);
                  break;
                }
                h3.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u2.length, index: W }), S++;
              }
            } else S++;
          }
          return T();
          function I2(e3) {
            u2.push(e3), d3 = W;
          }
          function A(e3) {
            var t3 = 0;
            if (-1 !== e3) {
              var r4 = i2.substring(S + 1, e3);
              r4 && "" === r4.trim() && (t3 = r4.length);
            }
            return t3;
          }
          function T(e3) {
            return r3 || (void 0 === e3 && (e3 = i2.substring(W)), f3.push(e3), W = n3, I2(f3), o3 && F()), L();
          }
          function D(e3) {
            W = e3, I2(f3), f3 = [], R = i2.indexOf(P, W);
          }
          function L(e3) {
            return { data: u2, errors: h3, meta: { delimiter: M, linebreak: P, aborted: H, truncated: !!e3, cursor: d3 + (t2 || 0) } };
          }
          function F() {
            q(L()), u2 = [], h3 = [];
          }
        }, this.abort = function() {
          H = true;
        }, this.getCharIndex = function() {
          return W;
        };
      }
      function _3(e2) {
        var t2 = e2.data, r3 = a2[t2.workerId], i2 = false;
        if (t2.error) r3.userError(t2.error, t2.file);
        else if (t2.results && t2.results.data) {
          var n3 = { abort: function() {
            i2 = true, m2(t2.workerId, { data: [], errors: [], meta: { aborted: true } });
          }, pause: y, resume: y };
          if (J(r3.userStep)) {
            for (var s3 = 0; s3 < t2.results.data.length && (r3.userStep({ data: t2.results.data[s3], errors: t2.results.errors, meta: t2.results.meta }, n3), !i2); s3++) ;
            delete t2.results;
          } else J(r3.userChunk) && (r3.userChunk(t2.results, n3, t2.file), delete t2.results);
        }
        t2.finished && !i2 && m2(t2.workerId, t2.results);
      }
      function m2(e2, t2) {
        var r3 = a2[e2];
        J(r3.userComplete) && r3.userComplete(t2), r3.terminate(), delete a2[e2];
      }
      function y() {
        throw new Error("Not implemented.");
      }
      function w(e2) {
        if ("object" != typeof e2 || null === e2) return e2;
        var t2 = Array.isArray(e2) ? [] : {};
        for (var r3 in e2) t2[r3] = w(e2[r3]);
        return t2;
      }
      function v(e2, t2) {
        return function() {
          e2.apply(t2, arguments);
        };
      }
      function J(e2) {
        return "function" == typeof e2;
      }
      return o2 && (f2.onmessage = function(e2) {
        var t2 = e2.data;
        void 0 === b.WORKER_ID && t2 && (b.WORKER_ID = t2.workerId);
        if ("string" == typeof t2.input) f2.postMessage({ workerId: b.WORKER_ID, results: b.parse(t2.input, t2.config), finished: true });
        else if (f2.File && t2.input instanceof File || t2.input instanceof Object) {
          var r3 = b.parse(t2.input, t2.config);
          r3 && f2.postMessage({ workerId: b.WORKER_ID, results: r3, finished: true });
        }
      }), (l2.prototype = Object.create(h.prototype)).constructor = l2, (c2.prototype = Object.create(h.prototype)).constructor = c2, (p.prototype = Object.create(p.prototype)).constructor = p, (g.prototype = Object.create(h.prototype)).constructor = g, b;
    });
  }
});

// node_modules/handlebars/dist/cjs/handlebars/utils.js
var require_utils = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.extend = extend2;
    exports.indexOf = indexOf2;
    exports.escapeExpression = escapeExpression;
    exports.isEmpty = isEmpty3;
    exports.createFrame = createFrame;
    exports.blockParams = blockParams;
    exports.appendContextPath = appendContextPath;
    var escape = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    var badChars = /[&<>"'`=]/g;
    var possible = /[&<>"'`=]/;
    function escapeChar2(chr) {
      return escape[chr];
    }
    function extend2(obj) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        for (var key in arguments[i2]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i2], key)) {
            obj[key] = arguments[i2][key];
          }
        }
      }
      return obj;
    }
    var toString3 = Object.prototype.toString;
    exports.toString = toString3;
    var isFunction4 = function isFunction5(value) {
      return typeof value === "function";
    };
    if (isFunction4(/x/)) {
      exports.isFunction = isFunction4 = function(value) {
        return typeof value === "function" && toString3.call(value) === "[object Function]";
      };
    }
    exports.isFunction = isFunction4;
    var isArray3 = Array.isArray || function(value) {
      return value && typeof value === "object" ? toString3.call(value) === "[object Array]" : false;
    };
    exports.isArray = isArray3;
    function indexOf2(array, value) {
      for (var i2 = 0, len = array.length; i2 < len; i2++) {
        if (array[i2] === value) {
          return i2;
        }
      }
      return -1;
    }
    function escapeExpression(string) {
      if (typeof string !== "string") {
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return "";
        } else if (!string) {
          return string + "";
        }
        string = "" + string;
      }
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar2);
    }
    function isEmpty3(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray3(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    function createFrame(object2) {
      var frame = extend2({}, object2);
      frame._parent = object2;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + "." : "") + id;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/exception.js
var require_exception = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
    function Exception(message, node) {
      var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
      if (loc) {
        line = loc.start.line;
        endLineNumber = loc.end.line;
        column = loc.start.column;
        endColumn = loc.end.column;
        message += " - " + line + ":" + column;
      }
      var tmp = Error.prototype.constructor.call(this, message);
      for (var idx = 0; idx < errorProps.length; idx++) {
        this[errorProps[idx]] = tmp[errorProps[idx]];
      }
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Exception);
      }
      try {
        if (loc) {
          this.lineNumber = line;
          this.endLineNumber = endLineNumber;
          if (Object.defineProperty) {
            Object.defineProperty(this, "column", {
              value: column,
              enumerable: true
            });
            Object.defineProperty(this, "endColumn", {
              value: endColumn,
              enumerable: true
            });
          } else {
            this.column = column;
            this.endColumn = endColumn;
          }
        }
      } catch (nop) {
      }
    }
    Exception.prototype = new Error();
    exports["default"] = Exception;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
var require_block_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    exports["default"] = function(instance) {
      instance.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse, fn = options.fn;
        if (context === true) {
          return fn(this);
        } else if (context === false || context == null) {
          return inverse(this);
        } else if (_utils.isArray(context)) {
          if (context.length > 0) {
            if (options.ids) {
              options.ids = [options.name];
            }
            return instance.helpers.each(context, options);
          } else {
            return inverse(this);
          }
        } else {
          if (options.data && options.ids) {
            var data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
            options = { data };
          }
          return fn(context, options);
        }
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
var require_each = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("each", function(context, options) {
        if (!options) {
          throw new _exception2["default"]("Must pass iterator to #each");
        }
        var fn = options.fn, inverse = options.inverse, i2 = 0, ret = "", data = void 0, contextPath = void 0;
        if (options.data && options.ids) {
          contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        if (options.data) {
          data = _utils.createFrame(options.data);
        }
        function execIteration(field, index2, last2) {
          if (data) {
            data.key = field;
            data.index = index2;
            data.first = index2 === 0;
            data.last = !!last2;
            if (contextPath) {
              data.contextPath = contextPath + field;
            }
          }
          ret = ret + fn(context[field], {
            data,
            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
          });
        }
        if (context && typeof context === "object") {
          if (_utils.isArray(context)) {
            for (var j = context.length; i2 < j; i2++) {
              if (i2 in context) {
                execIteration(i2, i2, i2 === context.length - 1);
              }
            }
          } else if (typeof Symbol === "function" && context[Symbol.iterator]) {
            var newContext = [];
            var iterator = context[Symbol.iterator]();
            for (var it = iterator.next(); !it.done; it = iterator.next()) {
              newContext.push(it.value);
            }
            context = newContext;
            for (var j = context.length; i2 < j; i2++) {
              execIteration(i2, i2, i2 === context.length - 1);
            }
          } else {
            (function() {
              var priorKey = void 0;
              Object.keys(context).forEach(function(key) {
                if (priorKey !== void 0) {
                  execIteration(priorKey, i2 - 1);
                }
                priorKey = key;
                i2++;
              });
              if (priorKey !== void 0) {
                execIteration(priorKey, i2 - 1, true);
              }
            })();
          }
        }
        if (i2 === 0) {
          ret = inverse(this);
        }
        return ret;
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
var require_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("helperMissing", function() {
        if (arguments.length === 1) {
          return void 0;
        } else {
          throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
        }
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
var require_if = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("if", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#if requires exactly one argument");
        }
        if (_utils.isFunction(conditional)) {
          conditional = conditional.call(this);
        }
        if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
          return options.inverse(this);
        } else {
          return options.fn(this);
        }
      });
      instance.registerHelper("unless", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#unless requires exactly one argument");
        }
        return instance.helpers["if"].call(this, conditional, {
          fn: options.inverse,
          inverse: options.fn,
          hash: options.hash
        });
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
var require_log = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("log", function() {
        var args = [void 0], options = arguments[arguments.length - 1];
        for (var i2 = 0; i2 < arguments.length - 1; i2++) {
          args.push(arguments[i2]);
        }
        var level = 1;
        if (options.hash.level != null) {
          level = options.hash.level;
        } else if (options.data && options.data.level != null) {
          level = options.data.level;
        }
        args[0] = level;
        instance.log.apply(instance, args);
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
var require_lookup = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("lookup", function(obj, field, options) {
        if (!obj) {
          return obj;
        }
        return options.lookupProperty(obj, field);
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
var require_with = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("with", function(context, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#with requires exactly one argument");
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        var fn = options.fn;
        if (!_utils.isEmpty(context)) {
          var data = options.data;
          if (options.data && options.ids) {
            data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
          }
          return fn(context, {
            data,
            blockParams: _utils.blockParams([context], [data && data.contextPath])
          });
        } else {
          return options.inverse(this);
        }
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers.js
var require_helpers = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultHelpers = registerDefaultHelpers;
    exports.moveHelperToHooks = moveHelperToHooks;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _helpersBlockHelperMissing = require_block_helper_missing();
    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    var _helpersEach = require_each();
    var _helpersEach2 = _interopRequireDefault(_helpersEach);
    var _helpersHelperMissing = require_helper_missing();
    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    var _helpersIf = require_if();
    var _helpersIf2 = _interopRequireDefault(_helpersIf);
    var _helpersLog = require_log();
    var _helpersLog2 = _interopRequireDefault(_helpersLog);
    var _helpersLookup = require_lookup();
    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    var _helpersWith = require_with();
    var _helpersWith2 = _interopRequireDefault(_helpersWith);
    function registerDefaultHelpers(instance) {
      _helpersBlockHelperMissing2["default"](instance);
      _helpersEach2["default"](instance);
      _helpersHelperMissing2["default"](instance);
      _helpersIf2["default"](instance);
      _helpersLog2["default"](instance);
      _helpersLookup2["default"](instance);
      _helpersWith2["default"](instance);
    }
    function moveHelperToHooks(instance, helperName, keepHelper) {
      if (instance.helpers[helperName]) {
        instance.hooks[helperName] = instance.helpers[helperName];
        if (!keepHelper) {
          delete instance.helpers[helperName];
        }
      }
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
var require_inline = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    exports["default"] = function(instance) {
      instance.registerDecorator("inline", function(fn, props, container, options) {
        var ret = fn;
        if (!props.partials) {
          props.partials = {};
          ret = function(context, options2) {
            var original = container.partials;
            container.partials = _utils.extend({}, original, props.partials);
            var ret2 = fn(context, options2);
            container.partials = original;
            return ret2;
          };
        }
        props.partials[options.args[0]] = options.fn;
        return ret;
      });
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators.js
var require_decorators = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultDecorators = registerDefaultDecorators;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _decoratorsInline = require_inline();
    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    function registerDefaultDecorators(instance) {
      _decoratorsInline2["default"](instance);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/logger.js
var require_logger = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    var logger = {
      methodMap: ["debug", "info", "warn", "error"],
      level: "info",
      // Maps a given level value to the `methodMap` indexes above.
      lookupLevel: function lookupLevel(level) {
        if (typeof level === "string") {
          var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
          if (levelMap >= 0) {
            level = levelMap;
          } else {
            level = parseInt(level, 10);
          }
        }
        return level;
      },
      // Can be overridden in the host environment
      log: function log2(level) {
        level = logger.lookupLevel(level);
        if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
          var method = logger.methodMap[level];
          if (!console[method]) {
            method = "log";
          }
          for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            message[_key - 1] = arguments[_key];
          }
          console[method].apply(console, message);
        }
      }
    };
    exports["default"] = logger;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
var require_create_new_lookup_object = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createNewLookupObject = createNewLookupObject;
    var _utils = require_utils();
    function createNewLookupObject() {
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
var require_proto_access = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createProtoAccessControl = createProtoAccessControl;
    exports.resultIsAllowed = resultIsAllowed;
    exports.resetLoggedProperties = resetLoggedProperties;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _createNewLookupObject = require_create_new_lookup_object();
    var _logger = require_logger();
    var _logger2 = _interopRequireDefault(_logger);
    var loggedProperties = /* @__PURE__ */ Object.create(null);
    function createProtoAccessControl(runtimeOptions) {
      var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
      defaultMethodWhiteList["constructor"] = false;
      defaultMethodWhiteList["__defineGetter__"] = false;
      defaultMethodWhiteList["__defineSetter__"] = false;
      defaultMethodWhiteList["__lookupGetter__"] = false;
      var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
      defaultPropertyWhiteList["__proto__"] = false;
      return {
        properties: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
          defaultValue: runtimeOptions.allowProtoPropertiesByDefault
        },
        methods: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
          defaultValue: runtimeOptions.allowProtoMethodsByDefault
        }
      };
    }
    function resultIsAllowed(result2, protoAccessControl, propertyName) {
      if (typeof result2 === "function") {
        return checkWhiteList(protoAccessControl.methods, propertyName);
      } else {
        return checkWhiteList(protoAccessControl.properties, propertyName);
      }
    }
    function checkWhiteList(protoAccessControlForType, propertyName) {
      if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
        return protoAccessControlForType.whitelist[propertyName] === true;
      }
      if (protoAccessControlForType.defaultValue !== void 0) {
        return protoAccessControlForType.defaultValue;
      }
      logUnexpecedPropertyAccessOnce(propertyName);
      return false;
    }
    function logUnexpecedPropertyAccessOnce(propertyName) {
      if (loggedProperties[propertyName] !== true) {
        loggedProperties[propertyName] = true;
        _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
      }
    }
    function resetLoggedProperties() {
      Object.keys(loggedProperties).forEach(function(propertyName) {
        delete loggedProperties[propertyName];
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/base.js
var require_base = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.HandlebarsEnvironment = HandlebarsEnvironment;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _helpers = require_helpers();
    var _decorators = require_decorators();
    var _logger = require_logger();
    var _logger2 = _interopRequireDefault(_logger);
    var _internalProtoAccess = require_proto_access();
    var VERSION2 = "4.7.8";
    exports.VERSION = VERSION2;
    var COMPILER_REVISION = 8;
    exports.COMPILER_REVISION = COMPILER_REVISION;
    var LAST_COMPATIBLE_COMPILER_REVISION = 7;
    exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: "<= 1.0.rc.2",
      // 1.0.rc.2 is actually rev2 but doesn't report it
      2: "== 1.0.0-rc.3",
      3: "== 1.0.0-rc.4",
      4: "== 1.x.x",
      5: "== 2.0.0-alpha.x",
      6: ">= 2.0.0-beta.1",
      7: ">= 4.0.0 <4.3.0",
      8: ">= 4.3.0"
    };
    exports.REVISION_CHANGES = REVISION_CHANGES;
    var objectType = "[object Object]";
    function HandlebarsEnvironment(helpers2, partials, decorators) {
      this.helpers = helpers2 || {};
      this.partials = partials || {};
      this.decorators = decorators || {};
      _helpers.registerDefaultHelpers(this);
      _decorators.registerDefaultDecorators(this);
    }
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
      logger: _logger2["default"],
      log: _logger2["default"].log,
      registerHelper: function registerHelper(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple helpers");
          }
          _utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
      registerPartial: function registerPartial(name, partial2) {
        if (_utils.toString.call(name) === objectType) {
          _utils.extend(this.partials, name);
        } else {
          if (typeof partial2 === "undefined") {
            throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
          }
          this.partials[name] = partial2;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      },
      registerDecorator: function registerDecorator(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple decorators");
          }
          _utils.extend(this.decorators, name);
        } else {
          this.decorators[name] = fn;
        }
      },
      unregisterDecorator: function unregisterDecorator(name) {
        delete this.decorators[name];
      },
      /**
       * Reset the memory of illegal property accesses that have already been logged.
       * @deprecated should only be used in handlebars test-cases
       */
      resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
        _internalProtoAccess.resetLoggedProperties();
      }
    };
    var log2 = _logger2["default"].log;
    exports.log = log2;
    exports.createFrame = _utils.createFrame;
    exports.logger = _logger2["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/safe-string.js
var require_safe_string = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function SafeString(string) {
      this.string = string;
    }
    SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
      return "" + this.string;
    };
    exports["default"] = SafeString;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
var require_wrapHelper = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.wrapHelper = wrapHelper;
    function wrapHelper(helper, transformOptionsFn) {
      if (typeof helper !== "function") {
        return helper;
      }
      var wrapper = function wrapper2() {
        var options = arguments[arguments.length - 1];
        arguments[arguments.length - 1] = transformOptionsFn(options);
        return helper.apply(this, arguments);
      };
      return wrapper;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/runtime.js
var require_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.checkRevision = checkRevision;
    exports.template = template2;
    exports.wrapProgram = wrapProgram;
    exports.resolvePartial = resolvePartial;
    exports.invokePartial = invokePartial;
    exports.noop = noop3;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _utils = require_utils();
    var Utils = _interopRequireWildcard(_utils);
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _base = require_base();
    var _helpers = require_helpers();
    var _internalWrapHelper = require_wrapHelper();
    var _internalProtoAccess = require_proto_access();
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
      if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
        return;
      }
      if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
        var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
        throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
      } else {
        throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
      }
    }
    function template2(templateSpec, env) {
      if (!env) {
        throw new _exception2["default"]("No environment passed to template");
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
      }
      templateSpec.main.decorator = templateSpec.main_d;
      env.VM.checkRevision(templateSpec.compiler);
      var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
      function invokePartialWrapper(partial2, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
          if (options.ids) {
            options.ids[0] = true;
          }
        }
        partial2 = env.VM.resolvePartial.call(this, partial2, context, options);
        var extendedOptions = Utils.extend({}, options, {
          hooks: this.hooks,
          protoAccessControl: this.protoAccessControl
        });
        var result2 = env.VM.invokePartial.call(this, partial2, context, extendedOptions);
        if (result2 == null && env.compile) {
          options.partials[options.name] = env.compile(partial2, templateSpec.compilerOptions, env);
          result2 = options.partials[options.name](context, extendedOptions);
        }
        if (result2 != null) {
          if (options.indent) {
            var lines = result2.split("\n");
            for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
              if (!lines[i2] && i2 + 1 === l2) {
                break;
              }
              lines[i2] = options.indent + lines[i2];
            }
            result2 = lines.join("\n");
          }
          return result2;
        } else {
          throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
        }
      }
      var container = {
        strict: function strict(obj, name, loc) {
          if (!obj || !(name in obj)) {
            throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
              loc
            });
          }
          return container.lookupProperty(obj, name);
        },
        lookupProperty: function lookupProperty(parent, propertyName) {
          var result2 = parent[propertyName];
          if (result2 == null) {
            return result2;
          }
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return result2;
          }
          if (_internalProtoAccess.resultIsAllowed(result2, container.protoAccessControl, propertyName)) {
            return result2;
          }
          return void 0;
        },
        lookup: function lookup(depths, name) {
          var len = depths.length;
          for (var i2 = 0; i2 < len; i2++) {
            var result2 = depths[i2] && container.lookupProperty(depths[i2], name);
            if (result2 != null) {
              return depths[i2][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === "function" ? current.call(context) : current;
        },
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
        fn: function fn(i2) {
          var ret2 = templateSpec[i2];
          ret2.decorator = templateSpec[i2 + "_d"];
          return ret2;
        },
        programs: [],
        program: function program(i2, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i2], fn = this.fn(i2);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i2, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i2] = wrapProgram(this, i2, fn);
          }
          return programWrapper;
        },
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        mergeIfNeeded: function mergeIfNeeded(param, common) {
          var obj = param || common;
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
          return obj;
        },
        // An empty object to use as replacement for null-contexts
        nullContext: Object.seal({}),
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
      function ret(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var data = options.data;
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData2(context, data);
        }
        var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
        if (templateSpec.useDepths) {
          if (options.depths) {
            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
          } else {
            depths = [context];
          }
        }
        function main(context2) {
          return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
        }
        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
        return main(context, options);
      }
      ret.isTop = true;
      ret._setup = function(options) {
        if (!options.partial) {
          var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
          wrapHelpersToPassLookupProperty(mergedHelpers, container);
          container.helpers = mergedHelpers;
          if (templateSpec.usePartial) {
            container.partials = container.mergeIfNeeded(options.partials, env.partials);
          }
          if (templateSpec.usePartial || templateSpec.useDecorators) {
            container.decorators = Utils.extend({}, env.decorators, options.decorators);
          }
          container.hooks = {};
          container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
          var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
          _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
          _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
        } else {
          container.protoAccessControl = options.protoAccessControl;
          container.helpers = options.helpers;
          container.partials = options.partials;
          container.decorators = options.decorators;
          container.hooks = options.hooks;
        }
      };
      ret._child = function(i2, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _exception2["default"]("must pass block params");
        }
        if (templateSpec.useDepths && !depths) {
          throw new _exception2["default"]("must pass parent depths");
        }
        return wrapProgram(container, i2, templateSpec[i2], data, 0, blockParams, depths);
      };
      return ret;
    }
    function wrapProgram(container, i2, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var currentDepths = depths;
        if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
          currentDepths = [context].concat(depths);
        }
        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
      }
      prog = executeDecorators(fn, prog, container, depths, data, blockParams);
      prog.program = i2;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    function resolvePartial(partial2, context, options) {
      if (!partial2) {
        if (options.name === "@partial-block") {
          partial2 = options.data["partial-block"];
        } else {
          partial2 = options.partials[options.name];
        }
      } else if (!partial2.call && !options.name) {
        options.name = partial2;
        partial2 = options.partials[partial2];
      }
      return partial2;
    }
    function invokePartial(partial2, context, options) {
      var currentPartialBlock = options.data && options.data["partial-block"];
      options.partial = true;
      if (options.ids) {
        options.data.contextPath = options.ids[0] || options.data.contextPath;
      }
      var partialBlock = void 0;
      if (options.fn && options.fn !== noop3) {
        (function() {
          options.data = _base.createFrame(options.data);
          var fn = options.fn;
          partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
            options2.data = _base.createFrame(options2.data);
            options2.data["partial-block"] = currentPartialBlock;
            return fn(context2, options2);
          };
          if (fn.partials) {
            options.partials = Utils.extend({}, options.partials, fn.partials);
          }
        })();
      }
      if (partial2 === void 0 && partialBlock) {
        partial2 = partialBlock;
      }
      if (partial2 === void 0) {
        throw new _exception2["default"]("The partial " + options.name + " could not be found");
      } else if (partial2 instanceof Function) {
        return partial2(context, options);
      }
    }
    function noop3() {
      return "";
    }
    function initData2(context, data) {
      if (!data || !("root" in data)) {
        data = data ? _base.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
    function executeDecorators(fn, prog, container, depths, data, blockParams) {
      if (fn.decorator) {
        var props = {};
        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
        Utils.extend(prog, props);
      }
      return prog;
    }
    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
      Object.keys(mergedHelpers).forEach(function(helperName) {
        var helper = mergedHelpers[helperName];
        mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
      });
    }
    function passLookupPropertyOption(helper, container) {
      var lookupProperty = container.lookupProperty;
      return _internalWrapHelper.wrapHelper(helper, function(options) {
        return Utils.extend({ lookupProperty }, options);
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
var require_no_conflict = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(Handlebars5) {
      (function() {
        if (typeof globalThis === "object") return;
        Object.prototype.__defineGetter__("__magic__", function() {
          return this;
        });
        __magic__.globalThis = __magic__;
        delete Object.prototype.__magic__;
      })();
      var $Handlebars = globalThis.Handlebars;
      Handlebars5.noConflict = function() {
        if (globalThis.Handlebars === Handlebars5) {
          globalThis.Handlebars = $Handlebars;
        }
        return Handlebars5;
      };
    };
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.runtime.js
var require_handlebars_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _handlebarsBase = require_base();
    var base = _interopRequireWildcard(_handlebarsBase);
    var _handlebarsSafeString = require_safe_string();
    var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
    var _handlebarsException = require_exception();
    var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
    var _handlebarsUtils = require_utils();
    var Utils = _interopRequireWildcard(_handlebarsUtils);
    var _handlebarsRuntime = require_runtime();
    var runtime = _interopRequireWildcard(_handlebarsRuntime);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    function create2() {
      var hb = new base.HandlebarsEnvironment();
      Utils.extend(hb, base);
      hb.SafeString = _handlebarsSafeString2["default"];
      hb.Exception = _handlebarsException2["default"];
      hb.Utils = Utils;
      hb.escapeExpression = Utils.escapeExpression;
      hb.VM = runtime;
      hb.template = function(spec) {
        return runtime.template(spec, hb);
      };
      return hb;
    }
    var inst = create2();
    inst.create = create2;
    _handlebarsNoConflict2["default"](inst);
    inst["default"] = inst;
    exports["default"] = inst;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
var require_ast = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var AST = {
      // Public API used to evaluate derived attributes regarding AST nodes
      helpers: {
        // a mustache is definitely a helper if:
        // * it is an eligible helper, and
        // * it has at least one parameter or hash segment
        helperExpression: function helperExpression(node) {
          return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
        },
        scopedId: function scopedId(path) {
          return /^\.|this\b/.test(path.original);
        },
        // an ID is simple if it only has one part, and that part is not
        // `..` or `this`.
        simpleId: function simpleId(path) {
          return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
        }
      }
    };
    exports["default"] = AST;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
var require_parser = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var handlebars = function() {
      var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
            case 1:
              return $$[$0 - 1];
              break;
            case 2:
              this.$ = yy.prepareProgram($$[$0]);
              break;
            case 3:
              this.$ = $$[$0];
              break;
            case 4:
              this.$ = $$[$0];
              break;
            case 5:
              this.$ = $$[$0];
              break;
            case 6:
              this.$ = $$[$0];
              break;
            case 7:
              this.$ = $$[$0];
              break;
            case 8:
              this.$ = $$[$0];
              break;
            case 9:
              this.$ = {
                type: "CommentStatement",
                value: yy.stripComment($$[$0]),
                strip: yy.stripFlags($$[$0], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 10:
              this.$ = {
                type: "ContentStatement",
                original: $$[$0],
                value: $$[$0],
                loc: yy.locInfo(this._$)
              };
              break;
            case 11:
              this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 12:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
              break;
            case 13:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
              break;
            case 14:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
              break;
            case 15:
              this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 16:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 17:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 18:
              this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
              break;
            case 19:
              var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
              program.chained = true;
              this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
              break;
            case 20:
              this.$ = $$[$0];
              break;
            case 21:
              this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
              break;
            case 22:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 23:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 24:
              this.$ = {
                type: "PartialStatement",
                name: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                indent: "",
                strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 25:
              this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 26:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
              break;
            case 27:
              this.$ = $$[$0];
              break;
            case 28:
              this.$ = $$[$0];
              break;
            case 29:
              this.$ = {
                type: "SubExpression",
                path: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                loc: yy.locInfo(this._$)
              };
              break;
            case 30:
              this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 31:
              this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 32:
              this.$ = yy.id($$[$0 - 1]);
              break;
            case 33:
              this.$ = $$[$0];
              break;
            case 34:
              this.$ = $$[$0];
              break;
            case 35:
              this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 36:
              this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
              break;
            case 37:
              this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
              break;
            case 38:
              this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
              break;
            case 39:
              this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
              break;
            case 40:
              this.$ = $$[$0];
              break;
            case 41:
              this.$ = $$[$0];
              break;
            case 42:
              this.$ = yy.preparePath(true, $$[$0], this._$);
              break;
            case 43:
              this.$ = yy.preparePath(false, $$[$0], this._$);
              break;
            case 44:
              $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
              this.$ = $$[$0 - 2];
              break;
            case 45:
              this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
              break;
            case 46:
              this.$ = [];
              break;
            case 47:
              $$[$0 - 1].push($$[$0]);
              break;
            case 48:
              this.$ = [];
              break;
            case 49:
              $$[$0 - 1].push($$[$0]);
              break;
            case 50:
              this.$ = [];
              break;
            case 51:
              $$[$0 - 1].push($$[$0]);
              break;
            case 58:
              this.$ = [];
              break;
            case 59:
              $$[$0 - 1].push($$[$0]);
              break;
            case 64:
              this.$ = [];
              break;
            case 65:
              $$[$0 - 1].push($$[$0]);
              break;
            case 70:
              this.$ = [];
              break;
            case 71:
              $$[$0 - 1].push($$[$0]);
              break;
            case 78:
              this.$ = [];
              break;
            case 79:
              $$[$0 - 1].push($$[$0]);
              break;
            case 82:
              this.$ = [];
              break;
            case 83:
              $$[$0 - 1].push($$[$0]);
              break;
            case 86:
              this.$ = [];
              break;
            case 87:
              $$[$0 - 1].push($$[$0]);
              break;
            case 90:
              this.$ = [];
              break;
            case 91:
              $$[$0 - 1].push($$[$0]);
              break;
            case 94:
              this.$ = [];
              break;
            case 95:
              $$[$0 - 1].push($$[$0]);
              break;
            case 98:
              this.$ = [$$[$0]];
              break;
            case 99:
              $$[$0 - 1].push($$[$0]);
              break;
            case 100:
              this.$ = [$$[$0]];
              break;
            case 101:
              $$[$0 - 1].push($$[$0]);
              break;
          }
        },
        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse2(input) {
          var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          this.yy.parser = this;
          if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          var ranges = this.lexer.options && this.lexer.options.ranges;
          if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
          function popStack(n2) {
            stack.length = stack.length - 2 * n2;
            vstack.length = vstack.length - n2;
            lstack.length = lstack.length - n2;
          }
          function lex() {
            var token2;
            token2 = self2.lexer.lex() || 1;
            if (typeof token2 !== "number") {
              token2 = self2.symbols_[token2] || token2;
            }
            return token2;
          }
          var symbol, preErrorSymbol, state, action, a2, r2, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();
              }
              action = table[state] && table[state][symbol];
            }
            if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                expected = [];
                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                  expected.push("'" + this.terminals_[p] + "'");
                }
                if (this.lexer.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
              }
            }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
            }
            switch (action[0]) {
              case 1:
                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0) recovering--;
                } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
                }
                break;
              case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                }
                r2 = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                if (typeof r2 !== "undefined") {
                  return r2;
                }
                if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
              case 3:
                return true;
            }
          }
          return true;
        }
      };
      var lexer = function() {
        var lexer2 = {
          EOF: 1,
          parseError: function parseError(str, hash) {
            if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
            } else {
              throw new Error(str);
            }
          },
          setInput: function setInput(input) {
            this._input = input;
            this._more = this._less = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = "";
            this.conditionStack = ["INITIAL"];
            this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
            if (this.options.ranges) this.yylloc.range = [0, 0];
            this.offset = 0;
            return this;
          },
          input: function input() {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
            } else {
              this.yylloc.last_column++;
            }
            if (this.options.ranges) this.yylloc.range[1]++;
            this._input = this._input.slice(1);
            return ch;
          },
          unput: function unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);
            if (lines.length - 1) this.yylineno -= lines.length - 1;
            var r2 = this.yylloc.range;
            this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
            };
            if (this.options.ranges) {
              this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
            }
            return this;
          },
          more: function more() {
            this._more = true;
            return this;
          },
          less: function less(n2) {
            this.unput(this.match.slice(n2));
          },
          pastInput: function pastInput() {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
          },
          upcomingInput: function upcomingInput() {
            var next = this.match;
            if (next.length < 20) {
              next += this._input.substr(0, 20 - next.length);
            }
            return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
          },
          showPosition: function showPosition() {
            var pre = this.pastInput();
            var c2 = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c2 + "^";
          },
          next: function next() {
            if (this.done) {
              return this.EOF;
            }
            if (!this._input) this.done = true;
            var token2, match, tempMatch, index2, col, lines;
            if (!this._more) {
              this.yytext = "";
              this.match = "";
            }
            var rules = this._currentRules();
            for (var i2 = 0; i2 < rules.length; i2++) {
              tempMatch = this._input.match(this.rules[rules[i2]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index2 = i2;
                if (!this.options.flex) break;
              }
            }
            if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines) this.yylineno += lines.length;
              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
              };
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token2 = this.performAction.call(this, this.yy, this, rules[index2], this.conditionStack[this.conditionStack.length - 1]);
              if (this.done && this._input) this.done = false;
              if (token2) return token2;
              else return;
            }
            if (this._input === "") {
              return this.EOF;
            } else {
              return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
            }
          },
          lex: function lex() {
            var r2 = this.next();
            if (typeof r2 !== "undefined") {
              return r2;
            } else {
              return this.lex();
            }
          },
          begin: function begin(condition) {
            this.conditionStack.push(condition);
          },
          popState: function popState() {
            return this.conditionStack.pop();
          },
          _currentRules: function _currentRules() {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          },
          topState: function topState() {
            return this.conditionStack[this.conditionStack.length - 2];
          },
          pushState: function begin(condition) {
            this.begin(condition);
          }
        };
        lexer2.options = {};
        lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          function strip(start, end) {
            return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
          }
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
            case 0:
              if (yy_.yytext.slice(-2) === "\\\\") {
                strip(0, 1);
                this.begin("mu");
              } else if (yy_.yytext.slice(-1) === "\\") {
                strip(0, 1);
                this.begin("emu");
              } else {
                this.begin("mu");
              }
              if (yy_.yytext) return 15;
              break;
            case 1:
              return 15;
              break;
            case 2:
              this.popState();
              return 15;
              break;
            case 3:
              this.begin("raw");
              return 15;
              break;
            case 4:
              this.popState();
              if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                return 15;
              } else {
                strip(5, 9);
                return "END_RAW_BLOCK";
              }
              break;
            case 5:
              return 15;
              break;
            case 6:
              this.popState();
              return 14;
              break;
            case 7:
              return 65;
              break;
            case 8:
              return 68;
              break;
            case 9:
              return 19;
              break;
            case 10:
              this.popState();
              this.begin("raw");
              return 23;
              break;
            case 11:
              return 55;
              break;
            case 12:
              return 60;
              break;
            case 13:
              return 29;
              break;
            case 14:
              return 47;
              break;
            case 15:
              this.popState();
              return 44;
              break;
            case 16:
              this.popState();
              return 44;
              break;
            case 17:
              return 34;
              break;
            case 18:
              return 39;
              break;
            case 19:
              return 51;
              break;
            case 20:
              return 48;
              break;
            case 21:
              this.unput(yy_.yytext);
              this.popState();
              this.begin("com");
              break;
            case 22:
              this.popState();
              return 14;
              break;
            case 23:
              return 48;
              break;
            case 24:
              return 73;
              break;
            case 25:
              return 72;
              break;
            case 26:
              return 72;
              break;
            case 27:
              return 87;
              break;
            case 28:
              break;
            case 29:
              this.popState();
              return 54;
              break;
            case 30:
              this.popState();
              return 33;
              break;
            case 31:
              yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
              return 80;
              break;
            case 32:
              yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
              return 80;
              break;
            case 33:
              return 85;
              break;
            case 34:
              return 82;
              break;
            case 35:
              return 82;
              break;
            case 36:
              return 83;
              break;
            case 37:
              return 84;
              break;
            case 38:
              return 81;
              break;
            case 39:
              return 75;
              break;
            case 40:
              return 77;
              break;
            case 41:
              return 72;
              break;
            case 42:
              yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
              return 72;
              break;
            case 43:
              return "INVALID";
              break;
            case 44:
              return 5;
              break;
          }
        };
        lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
        lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
        return lexer2;
      }();
      parser.lexer = lexer;
      function Parser() {
        this.yy = {};
      }
      Parser.prototype = parser;
      parser.Parser = Parser;
      return new Parser();
    }();
    exports["default"] = handlebars;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
var require_visitor = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function Visitor() {
      this.parents = [];
    }
    Visitor.prototype = {
      constructor: Visitor,
      mutating: false,
      // Visits a given value. If mutating, will replace the value if necessary.
      acceptKey: function acceptKey(node, name) {
        var value = this.accept(node[name]);
        if (this.mutating) {
          if (value && !Visitor.prototype[value.type]) {
            throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
          }
          node[name] = value;
        }
      },
      // Performs an accept operation with added sanity check to ensure
      // required keys are not removed.
      acceptRequired: function acceptRequired(node, name) {
        this.acceptKey(node, name);
        if (!node[name]) {
          throw new _exception2["default"](node.type + " requires " + name);
        }
      },
      // Traverses a given array. If mutating, empty respnses will be removed
      // for child elements.
      acceptArray: function acceptArray(array) {
        for (var i2 = 0, l2 = array.length; i2 < l2; i2++) {
          this.acceptKey(array, i2);
          if (!array[i2]) {
            array.splice(i2, 1);
            i2--;
            l2--;
          }
        }
      },
      accept: function accept(object2) {
        if (!object2) {
          return;
        }
        if (!this[object2.type]) {
          throw new _exception2["default"]("Unknown type: " + object2.type, object2);
        }
        if (this.current) {
          this.parents.unshift(this.current);
        }
        this.current = object2;
        var ret = this[object2.type](object2);
        this.current = this.parents.shift();
        if (!this.mutating || ret) {
          return ret;
        } else if (ret !== false) {
          return object2;
        }
      },
      Program: function Program(program) {
        this.acceptArray(program.body);
      },
      MustacheStatement: visitSubExpression,
      Decorator: visitSubExpression,
      BlockStatement: visitBlock,
      DecoratorBlock: visitBlock,
      PartialStatement: visitPartial,
      PartialBlockStatement: function PartialBlockStatement(partial2) {
        visitPartial.call(this, partial2);
        this.acceptKey(partial2, "program");
      },
      ContentStatement: function ContentStatement() {
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: visitSubExpression,
      PathExpression: function PathExpression() {
      },
      StringLiteral: function StringLiteral() {
      },
      NumberLiteral: function NumberLiteral() {
      },
      BooleanLiteral: function BooleanLiteral() {
      },
      UndefinedLiteral: function UndefinedLiteral() {
      },
      NullLiteral: function NullLiteral() {
      },
      Hash: function Hash(hash) {
        this.acceptArray(hash.pairs);
      },
      HashPair: function HashPair(pair) {
        this.acceptRequired(pair, "value");
      }
    };
    function visitSubExpression(mustache) {
      this.acceptRequired(mustache, "path");
      this.acceptArray(mustache.params);
      this.acceptKey(mustache, "hash");
    }
    function visitBlock(block) {
      visitSubExpression.call(this, block);
      this.acceptKey(block, "program");
      this.acceptKey(block, "inverse");
    }
    function visitPartial(partial2) {
      this.acceptRequired(partial2, "name");
      this.acceptArray(partial2.params);
      this.acceptKey(partial2, "hash");
    }
    exports["default"] = Visitor;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
var require_whitespace_control = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _visitor = require_visitor();
    var _visitor2 = _interopRequireDefault(_visitor);
    function WhitespaceControl() {
      var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
      this.options = options;
    }
    WhitespaceControl.prototype = new _visitor2["default"]();
    WhitespaceControl.prototype.Program = function(program) {
      var doStandalone = !this.options.ignoreStandalone;
      var isRoot = !this.isRootSeen;
      this.isRootSeen = true;
      var body = program.body;
      for (var i2 = 0, l2 = body.length; i2 < l2; i2++) {
        var current = body[i2], strip = this.accept(current);
        if (!strip) {
          continue;
        }
        var _isPrevWhitespace = isPrevWhitespace(body, i2, isRoot), _isNextWhitespace = isNextWhitespace(body, i2, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
        if (strip.close) {
          omitRight(body, i2, true);
        }
        if (strip.open) {
          omitLeft(body, i2, true);
        }
        if (doStandalone && inlineStandalone) {
          omitRight(body, i2);
          if (omitLeft(body, i2)) {
            if (current.type === "PartialStatement") {
              current.indent = /([ \t]+$)/.exec(body[i2 - 1].original)[1];
            }
          }
        }
        if (doStandalone && openStandalone) {
          omitRight((current.program || current.inverse).body);
          omitLeft(body, i2);
        }
        if (doStandalone && closeStandalone) {
          omitRight(body, i2);
          omitLeft((current.inverse || current.program).body);
        }
      }
      return program;
    };
    WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
      this.accept(block.program);
      this.accept(block.inverse);
      var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
      if (inverse && inverse.chained) {
        firstInverse = inverse.body[0].program;
        while (lastInverse.chained) {
          lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
        }
      }
      var strip = {
        open: block.openStrip.open,
        close: block.closeStrip.close,
        // Determine the standalone candiacy. Basically flag our content as being possibly standalone
        // so our parent can determine if we actually are standalone
        openStandalone: isNextWhitespace(program.body),
        closeStandalone: isPrevWhitespace((firstInverse || program).body)
      };
      if (block.openStrip.close) {
        omitRight(program.body, null, true);
      }
      if (inverse) {
        var inverseStrip = block.inverseStrip;
        if (inverseStrip.open) {
          omitLeft(program.body, null, true);
        }
        if (inverseStrip.close) {
          omitRight(firstInverse.body, null, true);
        }
        if (block.closeStrip.open) {
          omitLeft(lastInverse.body, null, true);
        }
        if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
          omitLeft(program.body);
          omitRight(firstInverse.body);
        }
      } else if (block.closeStrip.open) {
        omitLeft(program.body, null, true);
      }
      return strip;
    };
    WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
      return mustache.strip;
    };
    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
      var strip = node.strip || {};
      return {
        inlineStandalone: true,
        open: strip.open,
        close: strip.close
      };
    };
    function isPrevWhitespace(body, i2, isRoot) {
      if (i2 === void 0) {
        i2 = body.length;
      }
      var prev = body[i2 - 1], sibling = body[i2 - 2];
      if (!prev) {
        return isRoot;
      }
      if (prev.type === "ContentStatement") {
        return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
      }
    }
    function isNextWhitespace(body, i2, isRoot) {
      if (i2 === void 0) {
        i2 = -1;
      }
      var next = body[i2 + 1], sibling = body[i2 + 2];
      if (!next) {
        return isRoot;
      }
      if (next.type === "ContentStatement") {
        return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
      }
    }
    function omitRight(body, i2, multiple) {
      var current = body[i2 == null ? 0 : i2 + 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
      current.rightStripped = current.value !== original;
    }
    function omitLeft(body, i2, multiple) {
      var current = body[i2 == null ? body.length - 1 : i2 - 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
      current.leftStripped = current.value !== original;
      return current.leftStripped;
    }
    exports["default"] = WhitespaceControl;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.SourceLocation = SourceLocation;
    exports.id = id;
    exports.stripFlags = stripFlags;
    exports.stripComment = stripComment;
    exports.preparePath = preparePath;
    exports.prepareMustache = prepareMustache;
    exports.prepareRawBlock = prepareRawBlock;
    exports.prepareBlock = prepareBlock;
    exports.prepareProgram = prepareProgram;
    exports.preparePartialBlock = preparePartialBlock;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function validateClose(open, close) {
      close = close.path ? close.path.original : close;
      if (open.path.original !== close) {
        var errorNode = { loc: open.path.loc };
        throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
      }
    }
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    function id(token2) {
      if (/^\[.*\]$/.test(token2)) {
        return token2.substring(1, token2.length - 1);
      } else {
        return token2;
      }
    }
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === "~",
        close: close.charAt(close.length - 3) === "~"
      };
    }
    function stripComment(comment) {
      return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
    }
    function preparePath(data, parts, loc) {
      loc = this.locInfo(loc);
      var original = data ? "@" : "", dig = [], depth = 0;
      for (var i2 = 0, l2 = parts.length; i2 < l2; i2++) {
        var part = parts[i2].part, isLiteral = parts[i2].original !== part;
        original += (parts[i2].separator || "") + part;
        if (!isLiteral && (part === ".." || part === "." || part === "this")) {
          if (dig.length > 0) {
            throw new _exception2["default"]("Invalid path: " + original, { loc });
          } else if (part === "..") {
            depth++;
          }
        } else {
          dig.push(part);
        }
      }
      return {
        type: "PathExpression",
        data,
        depth,
        parts: dig,
        original,
        loc
      };
    }
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
      var decorator = /\*/.test(open);
      return {
        type: decorator ? "Decorator" : "MustacheStatement",
        path,
        params,
        hash,
        escaped,
        strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareRawBlock(openRawBlock, contents, close, locInfo) {
      validateClose(openRawBlock, close);
      locInfo = this.locInfo(locInfo);
      var program = {
        type: "Program",
        body: contents,
        strip: {},
        loc: locInfo
      };
      return {
        type: "BlockStatement",
        path: openRawBlock.path,
        params: openRawBlock.params,
        hash: openRawBlock.hash,
        program,
        openStrip: {},
        inverseStrip: {},
        closeStrip: {},
        loc: locInfo
      };
    }
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      if (close && close.path) {
        validateClose(openBlock, close);
      }
      var decorator = /\*/.test(openBlock.open);
      program.blockParams = openBlock.blockParams;
      var inverse = void 0, inverseStrip = void 0;
      if (inverseAndProgram) {
        if (decorator) {
          throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
        }
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
      return {
        type: decorator ? "DecoratorBlock" : "BlockStatement",
        path: openBlock.path,
        params: openBlock.params,
        hash: openBlock.hash,
        program,
        inverse,
        openStrip: openBlock.strip,
        inverseStrip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareProgram(statements, loc) {
      if (!loc && statements.length) {
        var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
        if (firstLoc && lastLoc) {
          loc = {
            source: firstLoc.source,
            start: {
              line: firstLoc.start.line,
              column: firstLoc.start.column
            },
            end: {
              line: lastLoc.end.line,
              column: lastLoc.end.column
            }
          };
        }
      }
      return {
        type: "Program",
        body: statements,
        strip: {},
        loc
      };
    }
    function preparePartialBlock(open, program, close, locInfo) {
      validateClose(open, close);
      return {
        type: "PartialBlockStatement",
        name: open.path,
        params: open.params,
        hash: open.hash,
        program,
        openStrip: open.strip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
var require_base2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseWithoutProcessing = parseWithoutProcessing;
    exports.parse = parse2;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _parser = require_parser();
    var _parser2 = _interopRequireDefault(_parser);
    var _whitespaceControl = require_whitespace_control();
    var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
    var _helpers = require_helpers2();
    var Helpers = _interopRequireWildcard(_helpers);
    var _utils = require_utils();
    exports.parser = _parser2["default"];
    var yy = {};
    _utils.extend(yy, Helpers);
    function parseWithoutProcessing(input, options) {
      if (input.type === "Program") {
        return input;
      }
      _parser2["default"].yy = yy;
      yy.locInfo = function(locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
      var ast = _parser2["default"].parse(input);
      return ast;
    }
    function parse2(input, options) {
      var ast = parseWithoutProcessing(input, options);
      var strip = new _whitespaceControl2["default"](options);
      return strip.accept(ast);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.Compiler = Compiler;
    exports.precompile = precompile;
    exports.compile = compile2;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils();
    var _ast = require_ast();
    var _ast2 = _interopRequireDefault(_ast);
    var slice2 = [].slice;
    function Compiler() {
    }
    Compiler.prototype = {
      compiler: Compiler,
      equals: function equals(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
        for (var i2 = 0; i2 < len; i2++) {
          var opcode = this.opcodes[i2], otherOpcode = other.opcodes[i2];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
        len = this.children.length;
        for (var i2 = 0; i2 < len; i2++) {
          if (!this.children[i2].equals(other.children[i2])) {
            return false;
          }
        }
        return true;
      },
      guid: 0,
      compile: function compile3(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
        options.blockParams = options.blockParams || [];
        options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          "if": true,
          unless: true,
          "with": true,
          log: true,
          lookup: true
        }, options.knownHelpers);
        return this.accept(program);
      },
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(), result2 = childCompiler.compile(program, this.options), guid = this.guid++;
        this.usePartial = this.usePartial || result2.usePartial;
        this.children[guid] = result2;
        this.useDepths = this.useDepths || result2.useDepths;
        return guid;
      },
      accept: function accept(node) {
        if (!this[node.type]) {
          throw new _exception2["default"]("Unknown type: " + node.type, node);
        }
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
        var body = program.body, bodyLength = body.length;
        for (var i2 = 0; i2 < bodyLength; i2++) {
          this.accept(body[i2]);
        }
        this.options.blockParams.shift();
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
        return this;
      },
      BlockStatement: function BlockStatement(block) {
        transformLiteralToPath(block);
        var program = block.program, inverse = block.inverse;
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
        var type = this.classifySexpr(block);
        if (type === "helper") {
          this.helperSexpr(block, program, inverse);
        } else if (type === "simple") {
          this.simpleSexpr(block);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("blockValue", block.path.original);
        } else {
          this.ambiguousSexpr(block, program, inverse);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("ambiguousBlockValue");
        }
        this.opcode("append");
      },
      DecoratorBlock: function DecoratorBlock(decorator) {
        var program = decorator.program && this.compileProgram(decorator.program);
        var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
        this.useDecorators = true;
        this.opcode("registerDecorator", params.length, path.original);
      },
      PartialStatement: function PartialStatement(partial2) {
        this.usePartial = true;
        var program = partial2.program;
        if (program) {
          program = this.compileProgram(partial2.program);
        }
        var params = partial2.params;
        if (params.length > 1) {
          throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial2);
        } else if (!params.length) {
          if (this.options.explicitPartialContext) {
            this.opcode("pushLiteral", "undefined");
          } else {
            params.push({ type: "PathExpression", parts: [], depth: 0 });
          }
        }
        var partialName = partial2.name.original, isDynamic = partial2.name.type === "SubExpression";
        if (isDynamic) {
          this.accept(partial2.name);
        }
        this.setupFullMustacheParams(partial2, program, void 0, true);
        var indent = partial2.indent || "";
        if (this.options.preventIndent && indent) {
          this.opcode("appendContent", indent);
          indent = "";
        }
        this.opcode("invokePartial", isDynamic, partialName, indent);
        this.opcode("append");
      },
      PartialBlockStatement: function PartialBlockStatement(partialBlock) {
        this.PartialStatement(partialBlock);
      },
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache);
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode("appendEscaped");
        } else {
          this.opcode("append");
        }
      },
      Decorator: function Decorator(decorator) {
        this.DecoratorBlock(decorator);
      },
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode("appendContent", content.value);
        }
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
        if (type === "simple") {
          this.simpleSexpr(sexpr);
        } else if (type === "helper") {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;
        this.opcode("getContext", path.depth);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        path.strict = true;
        this.accept(path);
        this.opcode("invokeAmbiguous", name, isBlock);
      },
      simpleSexpr: function simpleSexpr(sexpr) {
        var path = sexpr.path;
        path.strict = true;
        this.accept(path);
        this.opcode("resolvePossibleLambda");
      },
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
        if (this.options.knownHelpers[name]) {
          this.opcode("invokeKnownHelper", params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
        } else {
          path.strict = true;
          path.falsy = true;
          this.accept(path);
          this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
        }
      },
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode("getContext", path.depth);
        var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
        if (blockParamId) {
          this.opcode("lookupBlockParam", blockParamId, path.parts);
        } else if (!name) {
          this.opcode("pushContext");
        } else if (path.data) {
          this.options.data = true;
          this.opcode("lookupData", path.depth, path.parts, path.strict);
        } else {
          this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
        }
      },
      StringLiteral: function StringLiteral(string) {
        this.opcode("pushString", string.value);
      },
      NumberLiteral: function NumberLiteral(number) {
        this.opcode("pushLiteral", number.value);
      },
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode("pushLiteral", bool.value);
      },
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode("pushLiteral", "undefined");
      },
      NullLiteral: function NullLiteral() {
        this.opcode("pushLiteral", "null");
      },
      Hash: function Hash(hash) {
        var pairs2 = hash.pairs, i2 = 0, l2 = pairs2.length;
        this.opcode("pushHash");
        for (; i2 < l2; i2++) {
          this.pushParam(pairs2[i2].value);
        }
        while (i2--) {
          this.opcode("assignToHash", pairs2[i2].key);
        }
        this.opcode("popHash");
      },
      // HELPERS
      opcode: function opcode(name) {
        this.opcodes.push({
          opcode: name,
          args: slice2.call(arguments, 1),
          loc: this.sourceNode[0].loc
        });
      },
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
        this.useDepths = true;
      },
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
        var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
        var isEligible = !isBlockParam && (isHelper || isSimple);
        if (isEligible && !isHelper) {
          var _name = sexpr.path.parts[0], options = this.options;
          if (options.knownHelpers[_name]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
        if (isHelper) {
          return "helper";
        } else if (isEligible) {
          return "ambiguous";
        } else {
          return "simple";
        }
      },
      pushParams: function pushParams(params) {
        for (var i2 = 0, l2 = params.length; i2 < l2; i2++) {
          this.pushParam(params[i2]);
        }
      },
      pushParam: function pushParam(val) {
        var value = val.value != null ? val.value : val.original || "";
        if (this.stringParams) {
          if (value.replace) {
            value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
          }
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode("getContext", val.depth || 0);
          this.opcode("pushStringParam", value, val.type);
          if (val.type === "SubExpression") {
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = void 0;
            if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join(".");
              this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
            } else {
              value = val.original || value;
              if (value.replace) {
                value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
              }
              this.opcode("pushId", val.type, value);
            }
          }
          this.accept(val);
        }
      },
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode("emptyHash", omitEmpty);
        }
        return params;
      },
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    function precompile(input, options, env) {
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
      }
      options = options || {};
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    function compile2(input, options, env) {
      if (options === void 0) options = {};
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
      }
      options = _utils.extend({}, options);
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var compiled = void 0;
      function compileInput() {
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
        return env.template(templateSpec);
      }
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function(setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function(i2, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i2, data, blockParams, depths);
      };
      return ret;
    }
    function argEquals(a2, b) {
      if (a2 === b) {
        return true;
      }
      if (_utils.isArray(a2) && _utils.isArray(b) && a2.length === b.length) {
        for (var i2 = 0; i2 < a2.length; i2++) {
          if (!argEquals(a2[i2], b[i2])) {
            return false;
          }
        }
        return true;
      }
    }
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        sexpr.path = {
          type: "PathExpression",
          data: false,
          depth: 0,
          parts: [literal.original + ""],
          original: literal.original + "",
          loc: literal.loc
        };
      }
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result2 = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result2 = result2 + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result2);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity2(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity2 : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp2 = strcmp(mappingA.source, mappingB.source);
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalLine - mappingB.originalLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp2 !== 0 || onlyCompareOriginal) {
        return cmp2;
      }
      cmp2 = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp2 !== 0 || onlyCompareGenerated) {
        return cmp2;
      }
      cmp2 = strcmp(mappingA.source, mappingB.source);
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalLine - mappingB.originalLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = strcmp(mappingA.source, mappingB.source);
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalLine - mappingB.originalLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has3 = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set3 = new ArraySet();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set3.add(aArray[i2], aAllowDuplicates);
      }
      return set3;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has3.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has3.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has3.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result2 = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result2 += next;
      }
      return result2;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map5 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map5.file = this._file;
      }
      if (this._sourceRoot != null) {
        map5.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map5.sourcesContent = this._generateSourcesContent(map5.sources, map5.sourceRoot);
      }
      return map5;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp2 = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp2 === 0) {
        return mid;
      } else if (cmp2 > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index2 = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index2 < 0) {
        return -1;
      }
      while (index2 - 1 >= 0) {
        if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
          break;
        }
        --index2;
      }
      return index2;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap2(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r2) {
      if (p < r2) {
        var pivotIndex = randomIntInRange(p, r2);
        var i2 = p - 1;
        swap2(ary, pivotIndex, r2);
        var pivot = ary[r2];
        for (var j = p; j < r2; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i2 += 1;
            swap2(ary, i2, j);
          }
        }
        swap2(ary, i2 + 1, j);
        var q = i2 + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r2);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch2 = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
      var c2 = aStr.charAt(index2);
      return c2 === ";" || c2 === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch2.LEAST_UPPER_BOUND
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version2 = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names2 = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names2.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
        if (this._absoluteSources[i2] == aSource) {
          return i2;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names2 = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names2.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index2 = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index2 < length) {
        if (aStr.charAt(index2) === ";") {
          generatedLine++;
          index2++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index2) === ",") {
          index2++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index2; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index2, end);
          segment = cachedSegments[str];
          if (segment) {
            index2 += str.length;
          } else {
            segment = [];
            while (index2 < end) {
              base64VLQ.decode(aStr, index2, temp);
              value = temp.value;
              index2 = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
        var mapping = this._generatedMappings[index2];
        if (index2 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index2 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._generatedMappings[index2];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index2 = this._findSourceIndex(aSource);
      if (index2 >= 0) {
        return this.sourcesContent[index2];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version2 = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset2 = util.getArg(s2, "offset");
        var offsetLine = util.getArg(offset2, "line");
        var offsetColumn = util.getArg(offset2, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset2;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          for (var j = 0; j < this._sections[i2].consumer.sources.length; j++) {
            sources.push(this._sections[i2].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch2.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp2 = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp2) {
            return cmp2;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk2) {
          this.add(chunk2);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
          this.prepend(aChunk[i2]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk2;
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        chunk2 = this.children[i2];
        if (chunk2[isSourceNode]) {
          chunk2.walk(aFn);
        } else {
          if (chunk2 !== "") {
            aFn(chunk2, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i2;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i2 = 0; i2 < len - 1; i2++) {
          newChildren.push(this.children[i2]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i2]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        if (this.children[i2][isSourceNode]) {
          this.children[i2].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i2 = 0, len = sources.length; i2 < len; i2++) {
        aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk2) {
        str += chunk2;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map5 = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk2, original) {
        generated.code += chunk2;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map5.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map5.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk2.length; idx < length; idx++) {
          if (chunk2.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map5.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map5.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map5 };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
var require_code_gen = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    var SourceNode = void 0;
    try {
      if (typeof define !== "function" || !define.amd) {
        SourceMap = require_source_map();
        SourceNode = SourceMap.SourceNode;
      }
    } catch (err) {
    }
    var SourceMap;
    if (!SourceNode) {
      SourceNode = function(line, column, srcFile, chunks) {
        this.src = "";
        if (chunks) {
          this.add(chunks);
        }
      };
      SourceNode.prototype = {
        add: function add2(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src += chunks;
        },
        prepend: function prepend(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src = chunks + this.src;
        },
        toStringWithSourceMap: function toStringWithSourceMap() {
          return { code: this.toString() };
        },
        toString: function toString3() {
          return this.src;
        }
      };
    }
    function castChunk(chunk2, codeGen, loc) {
      if (_utils.isArray(chunk2)) {
        var ret = [];
        for (var i2 = 0, len = chunk2.length; i2 < len; i2++) {
          ret.push(codeGen.wrap(chunk2[i2], loc));
        }
        return ret;
      } else if (typeof chunk2 === "boolean" || typeof chunk2 === "number") {
        return chunk2 + "";
      }
      return chunk2;
    }
    function CodeGen(srcFile) {
      this.srcFile = srcFile;
      this.source = [];
    }
    CodeGen.prototype = {
      isEmpty: function isEmpty3() {
        return !this.source.length;
      },
      prepend: function prepend(source, loc) {
        this.source.unshift(this.wrap(source, loc));
      },
      push: function push2(source, loc) {
        this.source.push(this.wrap(source, loc));
      },
      merge: function merge2() {
        var source = this.empty();
        this.each(function(line) {
          source.add(["  ", line, "\n"]);
        });
        return source;
      },
      each: function each3(iter) {
        for (var i2 = 0, len = this.source.length; i2 < len; i2++) {
          iter(this.source[i2]);
        }
      },
      empty: function empty() {
        var loc = this.currentLocation || { start: {} };
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
      },
      wrap: function wrap2(chunk2) {
        var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
        if (chunk2 instanceof SourceNode) {
          return chunk2;
        }
        chunk2 = castChunk(chunk2, this, loc);
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk2);
      },
      functionCall: function functionCall(fn, type, params) {
        params = this.generateList(params);
        return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
      },
      quotedString: function quotedString(str) {
        return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
      },
      objectLiteral: function objectLiteral(obj) {
        var _this = this;
        var pairs2 = [];
        Object.keys(obj).forEach(function(key) {
          var value = castChunk(obj[key], _this);
          if (value !== "undefined") {
            pairs2.push([_this.quotedString(key), ":", value]);
          }
        });
        var ret = this.generateList(pairs2);
        ret.prepend("{");
        ret.add("}");
        return ret;
      },
      generateList: function generateList(entries) {
        var ret = this.empty();
        for (var i2 = 0, len = entries.length; i2 < len; i2++) {
          if (i2) {
            ret.add(",");
          }
          ret.add(castChunk(entries[i2], this));
        }
        return ret;
      },
      generateArray: function generateArray(entries) {
        var ret = this.generateList(entries);
        ret.prepend("[");
        ret.add("]");
        return ret;
      }
    };
    exports["default"] = CodeGen;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
var require_javascript_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _base = require_base();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils();
    var _codeGen = require_code_gen();
    var _codeGen2 = _interopRequireDefault(_codeGen);
    function Literal(value) {
      this.value = value;
    }
    function JavaScriptCompiler() {
    }
    JavaScriptCompiler.prototype = {
      // PUBLIC API: You can override these methods in a subclass to provide
      // alternative compiled forms for name lookup and buffering semantics
      nameLookup: function nameLookup(parent, name) {
        return this.internalNameLookup(parent, name);
      },
      depthedLookup: function depthedLookup(name) {
        return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
      },
      compilerInfo: function compilerInfo() {
        var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
        return [revision, versions];
      },
      appendToBuffer: function appendToBuffer(source, location2, explicit) {
        if (!_utils.isArray(source)) {
          source = [source];
        }
        source = this.source.wrap(source, location2);
        if (this.environment.isSimple) {
          return ["return ", source, ";"];
        } else if (explicit) {
          return ["buffer += ", source, ";"];
        } else {
          source.appendToBuffer = true;
          return source;
        }
      },
      initializeBuffer: function initializeBuffer() {
        return this.quotedString("");
      },
      // END PUBLIC API
      internalNameLookup: function internalNameLookup(parent, name) {
        this.lookupPropertyFunctionIsUsed = true;
        return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
      },
      lookupPropertyFunctionIsUsed: false,
      compile: function compile2(environment, options, context, asObject) {
        this.environment = environment;
        this.options = options;
        this.stringParams = this.options.stringParams;
        this.trackIds = this.options.trackIds;
        this.precompile = !asObject;
        this.name = this.environment.name;
        this.isChild = !!context;
        this.context = context || {
          decorators: [],
          programs: [],
          environments: []
        };
        this.preamble();
        this.stackSlot = 0;
        this.stackVars = [];
        this.aliases = {};
        this.registers = { list: [] };
        this.hashes = [];
        this.compileStack = [];
        this.inlineStack = [];
        this.blockParams = [];
        this.compileChildren(environment, options);
        this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
        this.useBlockParams = this.useBlockParams || environment.useBlockParams;
        var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i2 = void 0, l2 = void 0;
        for (i2 = 0, l2 = opcodes.length; i2 < l2; i2++) {
          opcode = opcodes[i2];
          this.source.currentLocation = opcode.loc;
          firstLoc = firstLoc || opcode.loc;
          this[opcode.opcode].apply(this, opcode.args);
        }
        this.source.currentLocation = firstLoc;
        this.pushSource("");
        if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
          throw new _exception2["default"]("Compile completed with content left on stack");
        }
        if (!this.decorators.isEmpty()) {
          this.useDecorators = true;
          this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
          this.decorators.push("return fn;");
          if (asObject) {
            this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
          } else {
            this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
            this.decorators.push("}\n");
            this.decorators = this.decorators.merge();
          }
        } else {
          this.decorators = void 0;
        }
        var fn = this.createFunctionContext(asObject);
        if (!this.isChild) {
          var ret = {
            compiler: this.compilerInfo(),
            main: fn
          };
          if (this.decorators) {
            ret.main_d = this.decorators;
            ret.useDecorators = true;
          }
          var _context = this.context;
          var programs = _context.programs;
          var decorators = _context.decorators;
          for (i2 = 0, l2 = programs.length; i2 < l2; i2++) {
            if (programs[i2]) {
              ret[i2] = programs[i2];
              if (decorators[i2]) {
                ret[i2 + "_d"] = decorators[i2];
                ret.useDecorators = true;
              }
            }
          }
          if (this.environment.usePartial) {
            ret.usePartial = true;
          }
          if (this.options.data) {
            ret.useData = true;
          }
          if (this.useDepths) {
            ret.useDepths = true;
          }
          if (this.useBlockParams) {
            ret.useBlockParams = true;
          }
          if (this.options.compat) {
            ret.compat = true;
          }
          if (!asObject) {
            ret.compiler = JSON.stringify(ret.compiler);
            this.source.currentLocation = { start: { line: 1, column: 0 } };
            ret = this.objectLiteral(ret);
            if (options.srcName) {
              ret = ret.toStringWithSourceMap({ file: options.destName });
              ret.map = ret.map && ret.map.toString();
            } else {
              ret = ret.toString();
            }
          } else {
            ret.compilerOptions = this.options;
          }
          return ret;
        } else {
          return fn;
        }
      },
      preamble: function preamble() {
        this.lastContext = 0;
        this.source = new _codeGen2["default"](this.options.srcName);
        this.decorators = new _codeGen2["default"](this.options.srcName);
      },
      createFunctionContext: function createFunctionContext(asObject) {
        var _this = this;
        var varDeclarations = "";
        var locals = this.stackVars.concat(this.registers.list);
        if (locals.length > 0) {
          varDeclarations += ", " + locals.join(", ");
        }
        var aliasCount = 0;
        Object.keys(this.aliases).forEach(function(alias) {
          var node = _this.aliases[alias];
          if (node.children && node.referenceCount > 1) {
            varDeclarations += ", alias" + ++aliasCount + "=" + alias;
            node.children[0] = "alias" + aliasCount;
          }
        });
        if (this.lookupPropertyFunctionIsUsed) {
          varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
        }
        var params = ["container", "depth0", "helpers", "partials", "data"];
        if (this.useBlockParams || this.useDepths) {
          params.push("blockParams");
        }
        if (this.useDepths) {
          params.push("depths");
        }
        var source = this.mergeSource(varDeclarations);
        if (asObject) {
          params.push(source);
          return Function.apply(this, params);
        } else {
          return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
        }
      },
      mergeSource: function mergeSource(varDeclarations) {
        var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
        this.source.each(function(line) {
          if (line.appendToBuffer) {
            if (bufferStart) {
              line.prepend("  + ");
            } else {
              bufferStart = line;
            }
            bufferEnd = line;
          } else {
            if (bufferStart) {
              if (!sourceSeen) {
                appendFirst = true;
              } else {
                bufferStart.prepend("buffer += ");
              }
              bufferEnd.add(";");
              bufferStart = bufferEnd = void 0;
            }
            sourceSeen = true;
            if (!isSimple) {
              appendOnly = false;
            }
          }
        });
        if (appendOnly) {
          if (bufferStart) {
            bufferStart.prepend("return ");
            bufferEnd.add(";");
          } else if (!sourceSeen) {
            this.source.push('return "";');
          }
        } else {
          varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
          if (bufferStart) {
            bufferStart.prepend("return buffer + ");
            bufferEnd.add(";");
          } else {
            this.source.push("return buffer;");
          }
        }
        if (varDeclarations) {
          this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
        }
        return this.source.merge();
      },
      lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
        return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
      },
      // [blockValue]
      //
      // On stack, before: hash, inverse, program, value
      // On stack, after: return value of blockHelperMissing
      //
      // The purpose of this opcode is to take a block of the form
      // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
      // replace it on the stack with the result of properly
      // invoking blockHelperMissing.
      blockValue: function blockValue(name) {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs(name, 0, params);
        var blockName = this.popStack();
        params.splice(1, 0, blockName);
        this.push(this.source.functionCall(blockHelperMissing, "call", params));
      },
      // [ambiguousBlockValue]
      //
      // On stack, before: hash, inverse, program, value
      // Compiler value, before: lastHelper=value of last found helper, if any
      // On stack, after, if no lastHelper: same as [blockValue]
      // On stack, after, if lastHelper: value
      ambiguousBlockValue: function ambiguousBlockValue() {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs("", 0, params, true);
        this.flushInline();
        var current = this.topStack();
        params.splice(1, 0, current);
        this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
      },
      // [appendContent]
      //
      // On stack, before: ...
      // On stack, after: ...
      //
      // Appends the string value of `content` to the current buffer
      appendContent: function appendContent(content) {
        if (this.pendingContent) {
          content = this.pendingContent + content;
        } else {
          this.pendingLocation = this.source.currentLocation;
        }
        this.pendingContent = content;
      },
      // [append]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Coerces `value` to a String and appends it to the current buffer.
      //
      // If `value` is truthy, or 0, it is coerced into a string and appended
      // Otherwise, the empty string is appended
      append: function append() {
        if (this.isInline()) {
          this.replaceStack(function(current) {
            return [" != null ? ", current, ' : ""'];
          });
          this.pushSource(this.appendToBuffer(this.popStack()));
        } else {
          var local = this.popStack();
          this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
          if (this.environment.isSimple) {
            this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
          }
        }
      },
      // [appendEscaped]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Escape `value` and append it to the buffer
      appendEscaped: function appendEscaped() {
        this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
      },
      // [getContext]
      //
      // On stack, before: ...
      // On stack, after: ...
      // Compiler value, after: lastContext=depth
      //
      // Set the value of the `lastContext` compiler value to the depth
      getContext: function getContext(depth) {
        this.lastContext = depth;
      },
      // [pushContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext, ...
      //
      // Pushes the value of the current context onto the stack.
      pushContext: function pushContext() {
        this.pushStackLiteral(this.contextName(this.lastContext));
      },
      // [lookupOnContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext[name], ...
      //
      // Looks up the value of `name` on the current context and pushes
      // it onto the stack.
      lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
        var i2 = 0;
        if (!scoped && this.options.compat && !this.lastContext) {
          this.push(this.depthedLookup(parts[i2++]));
        } else {
          this.pushContext();
        }
        this.resolvePath("context", parts, i2, falsy, strict);
      },
      // [lookupBlockParam]
      //
      // On stack, before: ...
      // On stack, after: blockParam[name], ...
      //
      // Looks up the value of `parts` on the given block param and pushes
      // it onto the stack.
      lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
        this.useBlockParams = true;
        this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
        this.resolvePath("context", parts, 1);
      },
      // [lookupData]
      //
      // On stack, before: ...
      // On stack, after: data, ...
      //
      // Push the data lookup operator
      lookupData: function lookupData(depth, parts, strict) {
        if (!depth) {
          this.pushStackLiteral("data");
        } else {
          this.pushStackLiteral("container.data(data, " + depth + ")");
        }
        this.resolvePath("data", parts, 0, true, strict);
      },
      resolvePath: function resolvePath(type, parts, i2, falsy, strict) {
        var _this2 = this;
        if (this.options.strict || this.options.assumeObjects) {
          this.push(strictLookup(this.options.strict && strict, this, parts, i2, type));
          return;
        }
        var len = parts.length;
        for (; i2 < len; i2++) {
          this.replaceStack(function(current) {
            var lookup = _this2.nameLookup(current, parts[i2], type);
            if (!falsy) {
              return [" != null ? ", lookup, " : ", current];
            } else {
              return [" && ", lookup];
            }
          });
        }
      },
      // [resolvePossibleLambda]
      //
      // On stack, before: value, ...
      // On stack, after: resolved value, ...
      //
      // If the `value` is a lambda, replace it on the stack by
      // the return value of the lambda
      resolvePossibleLambda: function resolvePossibleLambda() {
        this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
      },
      // [pushStringParam]
      //
      // On stack, before: ...
      // On stack, after: string, currentContext, ...
      //
      // This opcode is designed for use in string mode, which
      // provides the string value of a parameter along with its
      // depth rather than resolving it immediately.
      pushStringParam: function pushStringParam(string, type) {
        this.pushContext();
        this.pushString(type);
        if (type !== "SubExpression") {
          if (typeof string === "string") {
            this.pushString(string);
          } else {
            this.pushStackLiteral(string);
          }
        }
      },
      emptyHash: function emptyHash(omitEmpty) {
        if (this.trackIds) {
          this.push("{}");
        }
        if (this.stringParams) {
          this.push("{}");
          this.push("{}");
        }
        this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
      },
      pushHash: function pushHash() {
        if (this.hash) {
          this.hashes.push(this.hash);
        }
        this.hash = { values: {}, types: [], contexts: [], ids: [] };
      },
      popHash: function popHash() {
        var hash = this.hash;
        this.hash = this.hashes.pop();
        if (this.trackIds) {
          this.push(this.objectLiteral(hash.ids));
        }
        if (this.stringParams) {
          this.push(this.objectLiteral(hash.contexts));
          this.push(this.objectLiteral(hash.types));
        }
        this.push(this.objectLiteral(hash.values));
      },
      // [pushString]
      //
      // On stack, before: ...
      // On stack, after: quotedString(string), ...
      //
      // Push a quoted version of `string` onto the stack
      pushString: function pushString(string) {
        this.pushStackLiteral(this.quotedString(string));
      },
      // [pushLiteral]
      //
      // On stack, before: ...
      // On stack, after: value, ...
      //
      // Pushes a value onto the stack. This operation prevents
      // the compiler from creating a temporary variable to hold
      // it.
      pushLiteral: function pushLiteral(value) {
        this.pushStackLiteral(value);
      },
      // [pushProgram]
      //
      // On stack, before: ...
      // On stack, after: program(guid), ...
      //
      // Push a program expression onto the stack. This takes
      // a compile-time guid and converts it into a runtime-accessible
      // expression.
      pushProgram: function pushProgram(guid) {
        if (guid != null) {
          this.pushStackLiteral(this.programExpression(guid));
        } else {
          this.pushStackLiteral(null);
        }
      },
      // [registerDecorator]
      //
      // On stack, before: hash, program, params..., ...
      // On stack, after: ...
      //
      // Pops off the decorator's parameters, invokes the decorator,
      // and inserts the decorator into the decorators list.
      registerDecorator: function registerDecorator(paramSize, name) {
        var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
        this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
      },
      // [invokeHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // Pops off the helper's parameters, invokes the helper,
      // and pushes the helper's return value onto the stack.
      //
      // If the helper is not found, `helperMissing` is called.
      invokeHelper: function invokeHelper(paramSize, name, isSimple) {
        var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
        var possibleFunctionCalls = [];
        if (isSimple) {
          possibleFunctionCalls.push(helper.name);
        }
        possibleFunctionCalls.push(nonHelper);
        if (!this.options.strict) {
          possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
        }
        var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
        var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
        this.push(functionCall);
      },
      itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
        var result2 = [];
        result2.push(items[0]);
        for (var i2 = 1; i2 < items.length; i2++) {
          result2.push(separator, items[i2]);
        }
        return result2;
      },
      // [invokeKnownHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // This operation is used when the helper is known to exist,
      // so a `helperMissing` fallback is not required.
      invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
        var helper = this.setupHelper(paramSize, name);
        this.push(this.source.functionCall(helper.name, "call", helper.callParams));
      },
      // [invokeAmbiguous]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of disambiguation
      //
      // This operation is used when an expression like `{{foo}}`
      // is provided, but we don't know at compile-time whether it
      // is a helper or a path.
      //
      // This operation emits more code than the other options,
      // and can be avoided by passing the `knownHelpers` and
      // `knownHelpersOnly` flags at compile-time.
      invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
        this.useRegister("helper");
        var nonHelper = this.popStack();
        this.emptyHash();
        var helper = this.setupHelper(0, name, helperCall);
        var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
        var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
        if (!this.options.strict) {
          lookup[0] = "(helper = ";
          lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
        }
        this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
      },
      // [invokePartial]
      //
      // On stack, before: context, ...
      // On stack after: result of partial invocation
      //
      // This operation pops off a context, invokes a partial with that context,
      // and pushes the result of the invocation back.
      invokePartial: function invokePartial(isDynamic, name, indent) {
        var params = [], options = this.setupParams(name, 1, params);
        if (isDynamic) {
          name = this.popStack();
          delete options.name;
        }
        if (indent) {
          options.indent = JSON.stringify(indent);
        }
        options.helpers = "helpers";
        options.partials = "partials";
        options.decorators = "container.decorators";
        if (!isDynamic) {
          params.unshift(this.nameLookup("partials", name, "partial"));
        } else {
          params.unshift(name);
        }
        if (this.options.compat) {
          options.depths = "depths";
        }
        options = this.objectLiteral(options);
        params.push(options);
        this.push(this.source.functionCall("container.invokePartial", "", params));
      },
      // [assignToHash]
      //
      // On stack, before: value, ..., hash, ...
      // On stack, after: ..., hash, ...
      //
      // Pops a value off the stack and assigns it to the current hash
      assignToHash: function assignToHash(key) {
        var value = this.popStack(), context = void 0, type = void 0, id = void 0;
        if (this.trackIds) {
          id = this.popStack();
        }
        if (this.stringParams) {
          type = this.popStack();
          context = this.popStack();
        }
        var hash = this.hash;
        if (context) {
          hash.contexts[key] = context;
        }
        if (type) {
          hash.types[key] = type;
        }
        if (id) {
          hash.ids[key] = id;
        }
        hash.values[key] = value;
      },
      pushId: function pushId(type, name, child) {
        if (type === "BlockParam") {
          this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
        } else if (type === "PathExpression") {
          this.pushString(name);
        } else if (type === "SubExpression") {
          this.pushStackLiteral("true");
        } else {
          this.pushStackLiteral("null");
        }
      },
      // HELPERS
      compiler: JavaScriptCompiler,
      compileChildren: function compileChildren(environment, options) {
        var children = environment.children, child = void 0, compiler = void 0;
        for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
          child = children[i2];
          compiler = new this.compiler();
          var existing = this.matchExistingProgram(child);
          if (existing == null) {
            this.context.programs.push("");
            var index2 = this.context.programs.length;
            child.index = index2;
            child.name = "program" + index2;
            this.context.programs[index2] = compiler.compile(child, options, this.context, !this.precompile);
            this.context.decorators[index2] = compiler.decorators;
            this.context.environments[index2] = child;
            this.useDepths = this.useDepths || compiler.useDepths;
            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
            child.useDepths = this.useDepths;
            child.useBlockParams = this.useBlockParams;
          } else {
            child.index = existing.index;
            child.name = "program" + existing.index;
            this.useDepths = this.useDepths || existing.useDepths;
            this.useBlockParams = this.useBlockParams || existing.useBlockParams;
          }
        }
      },
      matchExistingProgram: function matchExistingProgram(child) {
        for (var i2 = 0, len = this.context.environments.length; i2 < len; i2++) {
          var environment = this.context.environments[i2];
          if (environment && environment.equals(child)) {
            return environment;
          }
        }
      },
      programExpression: function programExpression(guid) {
        var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
        if (this.useBlockParams || this.useDepths) {
          programParams.push("blockParams");
        }
        if (this.useDepths) {
          programParams.push("depths");
        }
        return "container.program(" + programParams.join(", ") + ")";
      },
      useRegister: function useRegister(name) {
        if (!this.registers[name]) {
          this.registers[name] = true;
          this.registers.list.push(name);
        }
      },
      push: function push2(expr) {
        if (!(expr instanceof Literal)) {
          expr = this.source.wrap(expr);
        }
        this.inlineStack.push(expr);
        return expr;
      },
      pushStackLiteral: function pushStackLiteral(item) {
        this.push(new Literal(item));
      },
      pushSource: function pushSource(source) {
        if (this.pendingContent) {
          this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
          this.pendingContent = void 0;
        }
        if (source) {
          this.source.push(source);
        }
      },
      replaceStack: function replaceStack(callback2) {
        var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
        if (!this.isInline()) {
          throw new _exception2["default"]("replaceStack on non-inline");
        }
        var top = this.popStack(true);
        if (top instanceof Literal) {
          stack = [top.value];
          prefix = ["(", stack];
          usedLiteral = true;
        } else {
          createdStack = true;
          var _name = this.incrStack();
          prefix = ["((", this.push(_name), " = ", top, ")"];
          stack = this.topStack();
        }
        var item = callback2.call(this, stack);
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push(prefix.concat(item, ")"));
      },
      incrStack: function incrStack() {
        this.stackSlot++;
        if (this.stackSlot > this.stackVars.length) {
          this.stackVars.push("stack" + this.stackSlot);
        }
        return this.topStackName();
      },
      topStackName: function topStackName() {
        return "stack" + this.stackSlot;
      },
      flushInline: function flushInline() {
        var inlineStack = this.inlineStack;
        this.inlineStack = [];
        for (var i2 = 0, len = inlineStack.length; i2 < len; i2++) {
          var entry = inlineStack[i2];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            var stack = this.incrStack();
            this.pushSource([stack, " = ", entry, ";"]);
            this.compileStack.push(stack);
          }
        }
      },
      isInline: function isInline() {
        return this.inlineStack.length;
      },
      popStack: function popStack(wrapped) {
        var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
        if (!wrapped && item instanceof Literal) {
          return item.value;
        } else {
          if (!inline) {
            if (!this.stackSlot) {
              throw new _exception2["default"]("Invalid stack pop");
            }
            this.stackSlot--;
          }
          return item;
        }
      },
      topStack: function topStack() {
        var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
        if (item instanceof Literal) {
          return item.value;
        } else {
          return item;
        }
      },
      contextName: function contextName(context) {
        if (this.useDepths && context) {
          return "depths[" + context + "]";
        } else {
          return "depth" + context;
        }
      },
      quotedString: function quotedString(str) {
        return this.source.quotedString(str);
      },
      objectLiteral: function objectLiteral(obj) {
        return this.source.objectLiteral(obj);
      },
      aliasable: function aliasable(name) {
        var ret = this.aliases[name];
        if (ret) {
          ret.referenceCount++;
          return ret;
        }
        ret = this.aliases[name] = this.source.wrap(name);
        ret.aliasable = true;
        ret.referenceCount = 1;
        return ret;
      },
      setupHelper: function setupHelper(paramSize, name, blockHelper) {
        var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
        var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
        return {
          params,
          paramsInit,
          name: foundHelper,
          callParams: [callContext].concat(params)
        };
      },
      setupParams: function setupParams(helper, paramSize, params) {
        var options = {}, contexts = [], types2 = [], ids = [], objectArgs = !params, param = void 0;
        if (objectArgs) {
          params = [];
        }
        options.name = this.quotedString(helper);
        options.hash = this.popStack();
        if (this.trackIds) {
          options.hashIds = this.popStack();
        }
        if (this.stringParams) {
          options.hashTypes = this.popStack();
          options.hashContexts = this.popStack();
        }
        var inverse = this.popStack(), program = this.popStack();
        if (program || inverse) {
          options.fn = program || "container.noop";
          options.inverse = inverse || "container.noop";
        }
        var i2 = paramSize;
        while (i2--) {
          param = this.popStack();
          params[i2] = param;
          if (this.trackIds) {
            ids[i2] = this.popStack();
          }
          if (this.stringParams) {
            types2[i2] = this.popStack();
            contexts[i2] = this.popStack();
          }
        }
        if (objectArgs) {
          options.args = this.source.generateArray(params);
        }
        if (this.trackIds) {
          options.ids = this.source.generateArray(ids);
        }
        if (this.stringParams) {
          options.types = this.source.generateArray(types2);
          options.contexts = this.source.generateArray(contexts);
        }
        if (this.options.data) {
          options.data = "data";
        }
        if (this.useBlockParams) {
          options.blockParams = "blockParams";
        }
        return options;
      },
      setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
        var options = this.setupParams(helper, paramSize, params);
        options.loc = JSON.stringify(this.source.currentLocation);
        options = this.objectLiteral(options);
        if (useRegister) {
          this.useRegister("options");
          params.push("options");
          return ["options=", options];
        } else if (params) {
          params.push(options);
          return "";
        } else {
          return options;
        }
      }
    };
    (function() {
      var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
      var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
      for (var i2 = 0, l2 = reservedWords.length; i2 < l2; i2++) {
        compilerWords[reservedWords[i2]] = true;
      }
    })();
    JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
      return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
    };
    function strictLookup(requireTerminal, compiler, parts, i2, type) {
      var stack = compiler.popStack(), len = parts.length;
      if (requireTerminal) {
        len--;
      }
      for (; i2 < len; i2++) {
        stack = compiler.nameLookup(stack, parts[i2], type);
      }
      if (requireTerminal) {
        return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i2]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
      } else {
        return stack;
      }
    }
    exports["default"] = JavaScriptCompiler;
    module2.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.js
var require_handlebars = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.js"(exports, module2) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _handlebarsRuntime = require_handlebars_runtime();
    var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
    var _handlebarsCompilerAst = require_ast();
    var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
    var _handlebarsCompilerBase = require_base2();
    var _handlebarsCompilerCompiler = require_compiler();
    var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
    var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
    var _handlebarsCompilerVisitor = require_visitor();
    var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    var _create = _handlebarsRuntime2["default"].create;
    function create2() {
      var hb = _create();
      hb.compile = function(input, options) {
        return _handlebarsCompilerCompiler.compile(input, options, hb);
      };
      hb.precompile = function(input, options) {
        return _handlebarsCompilerCompiler.precompile(input, options, hb);
      };
      hb.AST = _handlebarsCompilerAst2["default"];
      hb.Compiler = _handlebarsCompilerCompiler.Compiler;
      hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
      hb.Parser = _handlebarsCompilerBase.parser;
      hb.parse = _handlebarsCompilerBase.parse;
      hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
      return hb;
    }
    var inst = create2();
    inst.create = create2;
    _handlebarsNoConflict2["default"](inst);
    inst.Visitor = _handlebarsCompilerVisitor2["default"];
    inst["default"] = inst;
    exports["default"] = inst;
    module2.exports = exports["default"];
  }
});

// node_modules/squirrelly/dist/browser/squirrelly.min.js
var require_squirrelly_min = __commonJS({
  "node_modules/squirrelly/dist/browser/squirrelly.min.js"(exports, module2) {
    !function(e2, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? t2(exports) : "function" == typeof define && define.amd ? define(["exports"], t2) : t2((e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).Sqrl = {});
    }(exports, function(e2) {
      "use strict";
      function t2(e3) {
        var n3, r3, a3 = new Error(e3);
        return n3 = a3, r3 = t2.prototype, Object.setPrototypeOf ? Object.setPrototypeOf(n3, r3) : n3.__proto__ = r3, a3;
      }
      function n2(e3, n3, r3) {
        var a3 = n3.slice(0, r3).split(/\n/), i3 = a3.length, s3 = a3[i3 - 1].length + 1;
        throw t2(e3 += " at line " + i3 + " col " + s3 + ":\n\n  " + n3.split(/\n/)[i3 - 1] + "\n  " + Array(s3).join(" ") + "^");
      }
      t2.prototype = Object.create(Error.prototype, { name: { value: "Squirrelly Error", enumerable: false } });
      var r2 = new Function("return this")().Promise, a2 = false;
      try {
        a2 = new Function("return (async function(){}).constructor")();
      } catch (e3) {
        if (!(e3 instanceof SyntaxError)) throw e3;
      }
      function i2(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }
      function s2(e3, t3, n3) {
        for (var r3 in t3) i2(t3, r3) && (null == t3[r3] || "object" != typeof t3[r3] || "storage" !== r3 && "prefixes" !== r3 || n3 ? e3[r3] = t3[r3] : e3[r3] = s2({}, t3[r3]));
        return e3;
      }
      var c2 = /^async +/, o2 = /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\${)[^\\`])*`/g, l2 = /'(?:\\[\s\w"'\\`]|[^\n\r'\\])*?'/g, f2 = /"(?:\\[\s\w"'\\`]|[^\n\r"\\])*?"/g, u = /[.*+\-?^${}()|[\]\\]/g;
      function p(e3) {
        return u.test(e3) ? e3.replace(u, "\\$&") : e3;
      }
      function h(e3, r3) {
        r3.rmWhitespace && (e3 = e3.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "")), o2.lastIndex = 0, l2.lastIndex = 0, f2.lastIndex = 0;
        var a3 = r3.prefixes, i3 = [a3.h, a3.b, a3.i, a3.r, a3.c, a3.e].reduce(function(e4, t3) {
          return e4 && t3 ? e4 + "|" + p(t3) : t3 ? p(t3) : e4;
        }, ""), s3 = new RegExp("([|()]|=>)|('|\"|`|\\/\\*)|\\s*((\\/)?(-|_)?" + p(r3.tags[1]) + ")", "g"), u2 = new RegExp("([^]*?)" + p(r3.tags[0]) + "(-|_)?\\s*(" + i3 + ")?\\s*", "g"), h3 = 0, d3 = false;
        function g2(t3, a4) {
          var i4, p2 = { f: [] }, g3 = 0, v3 = "c";
          function m4(t4) {
            var a5 = e3.slice(h3, t4), i5 = a5.trim();
            if ("f" === v3) "safe" === i5 ? p2.raw = true : r3.async && c2.test(i5) ? (i5 = i5.replace(c2, ""), p2.f.push([i5, "", true])) : p2.f.push([i5, ""]);
            else if ("fp" === v3) p2.f[p2.f.length - 1][1] += i5;
            else if ("err" === v3) {
              if (i5) {
                var s4 = a5.search(/\S/);
                n2("invalid syntax", e3, h3 + s4);
              }
            } else p2[v3] = i5;
            h3 = t4 + 1;
          }
          for ("h" === a4 || "b" === a4 || "c" === a4 ? v3 = "n" : "r" === a4 && (p2.raw = true, a4 = "i"), s3.lastIndex = h3; null !== (i4 = s3.exec(e3)); ) {
            var y3 = i4[1], x2 = i4[2], b2 = i4[3], w2 = i4[4], F2 = i4[5], S2 = i4.index;
            if (y3) "(" === y3 ? (0 === g3 && ("n" === v3 ? (m4(S2), v3 = "p") : "f" === v3 && (m4(S2), v3 = "fp")), g3++) : ")" === y3 ? 0 === --g3 && "c" !== v3 && (m4(S2), v3 = "err") : 0 === g3 && "|" === y3 ? (m4(S2), v3 = "f") : "=>" === y3 && (m4(S2), h3 += 1, v3 = "res");
            else if (x2) {
              if ("/*" === x2) {
                var I3 = e3.indexOf("*/", s3.lastIndex);
                -1 === I3 && n2("unclosed comment", e3, i4.index), s3.lastIndex = I3 + 2;
              } else if ("'" === x2) {
                l2.lastIndex = i4.index, l2.exec(e3) ? s3.lastIndex = l2.lastIndex : n2("unclosed string", e3, i4.index);
              } else if ('"' === x2) {
                f2.lastIndex = i4.index, f2.exec(e3) ? s3.lastIndex = f2.lastIndex : n2("unclosed string", e3, i4.index);
              } else if ("`" === x2) {
                o2.lastIndex = i4.index, o2.exec(e3) ? s3.lastIndex = o2.lastIndex : n2("unclosed string", e3, i4.index);
              }
            } else if (b2) return m4(S2), h3 = S2 + i4[0].length, u2.lastIndex = h3, d3 = F2, w2 && "h" === a4 && (a4 = "s"), p2.t = a4, p2;
          }
          return n2("unclosed tag", e3, t3), p2;
        }
        var v2 = function i4(s4, o3) {
          s4.b = [], s4.d = [];
          var l3, f3 = false, p2 = [];
          function v3(e4, t3) {
            e4 && (e4 = function(e5, t4, n3, r4) {
              var a4, i5;
              return "string" == typeof t4.autoTrim ? a4 = i5 = t4.autoTrim : Array.isArray(t4.autoTrim) && (a4 = t4.autoTrim[1], i5 = t4.autoTrim[0]), (n3 || false === n3) && (a4 = n3), (r4 || false === r4) && (i5 = r4), "slurp" === a4 && "slurp" === i5 ? e5.trim() : ("_" === a4 || "slurp" === a4 ? e5 = String.prototype.trimLeft ? e5.trimLeft() : e5.replace(/^[\s\uFEFF\xA0]+/, "") : "-" !== a4 && "nl" !== a4 || (e5 = e5.replace(/^(?:\n|\r|\r\n)/, "")), "_" === i5 || "slurp" === i5 ? e5 = String.prototype.trimRight ? e5.trimRight() : e5.replace(/[\s\uFEFF\xA0]+$/, "") : "-" !== i5 && "nl" !== i5 || (e5 = e5.replace(/(?:\n|\r|\r\n)$/, "")), e5);
            }(e4, r3, d3, t3)) && (e4 = e4.replace(/\\|'/g, "\\$&").replace(/\r\n|\n|\r/g, "\\n"), p2.push(e4));
          }
          for (; null !== (l3 = u2.exec(e3)); ) {
            var m4, y3 = l3[1], x2 = l3[2], b2 = l3[3] || "";
            for (var w2 in a3) if (a3[w2] === b2) {
              m4 = w2;
              break;
            }
            v3(y3, x2), h3 = l3.index + l3[0].length, m4 || n2("unrecognized tag type: " + b2, e3, h3);
            var F2 = g2(l3.index, m4), S2 = F2.t;
            if ("h" === S2) {
              var I3 = F2.n || "";
              r3.async && c2.test(I3) && (F2.a = true, F2.n = I3.replace(c2, "")), F2 = i4(F2), p2.push(F2);
            } else if ("c" === S2) {
              if (s4.n === F2.n) return f3 ? (f3.d = p2, s4.b.push(f3)) : s4.d = p2, s4;
              n2("Helper start and end don't match", e3, l3.index + l3[0].length);
            } else if ("b" === S2) {
              f3 ? (f3.d = p2, s4.b.push(f3)) : s4.d = p2;
              var R2 = F2.n || "";
              r3.async && c2.test(R2) && (F2.a = true, F2.n = R2.replace(c2, "")), f3 = F2, p2 = [];
            } else if ("s" === S2) {
              var T2 = F2.n || "";
              r3.async && c2.test(T2) && (F2.a = true, F2.n = T2.replace(c2, "")), p2.push(F2);
            } else p2.push(F2);
          }
          if (!o3) throw t2('unclosed helper "' + s4.n + '"');
          return v3(e3.slice(h3, e3.length), false), s4.d = p2, s4;
        }({ f: [] }, true);
        if (r3.plugins) for (var m3 = 0; m3 < r3.plugins.length; m3++) {
          var y2 = r3.plugins[m3];
          y2.processAST && (v2.d = y2.processAST(v2.d, r3));
        }
        return v2.d;
      }
      function d2(e3, t3) {
        var n3 = h(e3, t3), r3 = "var tR='';" + (t3.useWith ? "with(" + t3.varName + "||{}){" : "") + x(n3, t3) + "if(cb){cb(null,tR)} return tR" + (t3.useWith ? "}" : "");
        if (t3.plugins) for (var a3 = 0; a3 < t3.plugins.length; a3++) {
          var i3 = t3.plugins[a3];
          i3.processFnString && (r3 = i3.processFnString(r3, t3));
        }
        return r3;
      }
      function g(e3, t3) {
        for (var n3 = 0; n3 < t3.length; n3++) {
          var r3 = t3[n3][0], a3 = t3[n3][1];
          e3 = (t3[n3][2] ? "await " : "") + "c.l('F','" + r3 + "')(" + e3, a3 && (e3 += "," + a3), e3 += ")";
        }
        return e3;
      }
      function v(e3, t3, n3, r3, a3, i3) {
        var s3 = "{exec:" + (a3 ? "async " : "") + y(n3, t3, e3) + ",params:[" + r3 + "]";
        return i3 && (s3 += ",name:'" + i3 + "'"), a3 && (s3 += ",async:true"), s3 += "}";
      }
      function m2(e3, t3) {
        for (var n3 = "[", r3 = 0; r3 < e3.length; r3++) {
          var a3 = e3[r3];
          n3 += v(t3, a3.res || "", a3.d, a3.p || "", a3.a, a3.n), r3 < e3.length && (n3 += ",");
        }
        return n3 += "]";
      }
      function y(e3, t3, n3) {
        return "function(" + t3 + "){var tR='';" + x(e3, n3) + "return tR}";
      }
      function x(e3, t3) {
        for (var n3 = 0, r3 = e3.length, a3 = ""; n3 < r3; n3++) {
          var i3 = e3[n3];
          if ("string" == typeof i3) {
            a3 += "tR+='" + i3 + "';";
          } else {
            var s3 = i3.t, c3 = i3.c || "", o3 = i3.f, l3 = i3.n || "", f3 = i3.p || "", u2 = i3.res || "", p2 = i3.b, h3 = !!i3.a;
            if ("i" === s3) {
              t3.defaultFilter && (c3 = "c.l('F','" + t3.defaultFilter + "')(" + c3 + ")");
              var d3 = g(c3, o3);
              !i3.raw && t3.autoEscape && (d3 = "c.l('F','e')(" + d3 + ")"), a3 += "tR+=" + d3 + ";";
            } else if ("h" === s3) if (t3.storage.nativeHelpers.get(l3)) a3 += t3.storage.nativeHelpers.get(l3)(i3, t3);
            else {
              var y2 = (h3 ? "await " : "") + "c.l('H','" + l3 + "')(" + v(t3, u2, i3.d, f3, h3);
              y2 += p2 ? "," + m2(p2, t3) : ",[]", a3 += "tR+=" + g(y2 += ",c)", o3) + ";";
            }
            else "s" === s3 ? a3 += "tR+=" + g((h3 ? "await " : "") + "c.l('H','" + l3 + "')({params:[" + f3 + "]},[],c)", o3) + ";" : "e" === s3 && (a3 += c3 + "\n");
          }
        }
        return a3;
      }
      var b = function() {
        function e3(e4) {
          this.cache = e4;
        }
        return e3.prototype.define = function(e4, t3) {
          this.cache[e4] = t3;
        }, e3.prototype.get = function(e4) {
          return this.cache[e4];
        }, e3.prototype.remove = function(e4) {
          delete this.cache[e4];
        }, e3.prototype.reset = function() {
          this.cache = {};
        }, e3.prototype.load = function(e4) {
          s2(this.cache, e4, true);
        }, e3;
      }();
      function w(e3, n3, r3, a3) {
        if (n3 && n3.length > 0) throw t2((a3 ? "Native" : "") + "Helper '" + e3 + "' doesn't accept blocks");
        if (r3 && r3.length > 0) throw t2((a3 ? "Native" : "") + "Helper '" + e3 + "' doesn't accept filters");
      }
      var F = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
      function S(e3) {
        return F[e3];
      }
      var I2 = new b({}), R = new b({ each: function(e3, t3) {
        var n3 = "", r3 = e3.params[0];
        if (w("each", t3, false), e3.async) return new Promise(function(t4) {
          !function e4(t5, n4, r4, a4, i3) {
            r4(t5[n4], n4).then(function(s3) {
              a4 += s3, n4 === t5.length - 1 ? i3(a4) : e4(t5, n4 + 1, r4, a4, i3);
            });
          }(r3, 0, e3.exec, n3, t4);
        });
        for (var a3 = 0; a3 < r3.length; a3++) n3 += e3.exec(r3[a3], a3);
        return n3;
      }, foreach: function(e3, t3) {
        var n3 = e3.params[0];
        if (w("foreach", t3, false), e3.async) return new Promise(function(t4) {
          !function e4(t5, n4, r4, a4, i3, s3) {
            a4(n4[r4], t5[n4[r4]]).then(function(c3) {
              i3 += c3, r4 === n4.length - 1 ? s3(i3) : e4(t5, n4, r4 + 1, a4, i3, s3);
            });
          }(n3, Object.keys(n3), 0, e3.exec, "", t4);
        });
        var r3 = "";
        for (var a3 in n3) i2(n3, a3) && (r3 += e3.exec(a3, n3[a3]));
        return r3;
      }, include: function(e3, n3, r3) {
        w("include", n3, false);
        var a3 = r3.storage.templates.get(e3.params[0]);
        if (!a3) throw t2('Could not fetch template "' + e3.params[0] + '"');
        return a3(e3.params[1], r3);
      }, extends: function(e3, n3, r3) {
        var a3 = e3.params[1] || {};
        a3.content = e3.exec();
        for (var i3 = 0; i3 < n3.length; i3++) {
          var s3 = n3[i3];
          a3[s3.name] = s3.exec();
        }
        var c3 = r3.storage.templates.get(e3.params[0]);
        if (!c3) throw t2('Could not fetch template "' + e3.params[0] + '"');
        return c3(a3, r3);
      }, useScope: function(e3, t3) {
        return w("useScope", t3, false), e3.exec(e3.params[0]);
      } }), T = new b({ if: function(e3, t3) {
        w("if", false, e3.f, true);
        var n3 = "if(" + e3.p + "){" + x(e3.d, t3) + "}";
        if (e3.b) for (var r3 = 0; r3 < e3.b.length; r3++) {
          var a3 = e3.b[r3];
          "else" === a3.n ? n3 += "else{" + x(a3.d, t3) + "}" : "elif" === a3.n && (n3 += "else if(" + a3.p + "){" + x(a3.d, t3) + "}");
        }
        return n3;
      }, try: function(e3, n3) {
        if (w("try", false, e3.f, true), !e3.b || 1 !== e3.b.length || "catch" !== e3.b[0].n) throw t2("native helper 'try' only accepts 1 block, 'catch'");
        var r3 = "try{" + x(e3.d, n3) + "}", a3 = e3.b[0];
        return r3 += "catch" + (a3.res ? "(" + a3.res + ")" : "") + "{" + x(a3.d, n3) + "}";
      }, block: function(e3, t3) {
        return w("block", e3.b, e3.f, true), "if(!" + t3.varName + "[" + e3.p + "]){tR+=(" + y(e3.d, "", t3) + ")()}else{tR+=" + t3.varName + "[" + e3.p + "]}";
      } }), E = new b({ e: function(e3) {
        var t3 = String(e3);
        return /[&<>"']/.test(t3) ? t3.replace(/[&<>"']/g, S) : t3;
      } }), j = { varName: "it", autoTrim: [false, "nl"], autoEscape: true, defaultFilter: false, tags: ["{{", "}}"], l: function(e3, n3) {
        if ("H" === e3) {
          var r3 = this.storage.helpers.get(n3);
          if (r3) return r3;
          throw t2("Can't find helper '" + n3 + "'");
        }
        if ("F" === e3) {
          var a3 = this.storage.filters.get(n3);
          if (a3) return a3;
          throw t2("Can't find filter '" + n3 + "'");
        }
      }, async: false, storage: { helpers: R, nativeHelpers: T, filters: E, templates: I2 }, prefixes: { h: "@", b: "#", i: "", r: "*", c: "/", e: "!" }, cache: false, plugins: [], useWith: false };
      function H(e3, t3) {
        var n3 = {};
        return s2(n3, j), t3 && s2(n3, t3), e3 && s2(n3, e3), n3.l.bind(n3), n3;
      }
      function O(e3, n3) {
        var r3 = H(n3 || {}), i3 = Function;
        if (r3.async) {
          if (!a2) throw t2("This environment doesn't support async/await");
          i3 = a2;
        }
        try {
          return new i3(r3.varName, "c", "cb", d2(e3, r3));
        } catch (n4) {
          throw n4 instanceof SyntaxError ? t2("Bad template syntax\n\n" + n4.message + "\n" + Array(n4.message.length + 1).join("=") + "\n" + d2(e3, r3)) : n4;
        }
      }
      function _3(e3, t3) {
        var n3;
        return t3.cache && t3.name && t3.storage.templates.get(t3.name) ? t3.storage.templates.get(t3.name) : (n3 = "function" == typeof e3 ? e3 : O(e3, t3), t3.cache && t3.name && t3.storage.templates.define(t3.name, n3), n3);
      }
      j.l.bind(j), e2.compile = O, e2.compileScope = x, e2.compileScopeIntoFunction = y, e2.compileToString = d2, e2.defaultConfig = j, e2.filters = E, e2.getConfig = H, e2.helpers = R, e2.nativeHelpers = T, e2.parse = h, e2.render = function(e3, n3, a3, i3) {
        var s3 = H(a3 || {});
        if (!s3.async) return _3(e3, s3)(n3, s3);
        if (!i3) {
          if ("function" == typeof r2) return new r2(function(t3, r3) {
            try {
              t3(_3(e3, s3)(n3, s3));
            } catch (e4) {
              r3(e4);
            }
          });
          throw t2("Please provide a callback function, this env doesn't support Promises");
        }
        try {
          _3(e3, s3)(n3, s3, i3);
        } catch (e4) {
          return i3(e4);
        }
      }, e2.templates = I2, Object.defineProperty(e2, "__esModule", { value: true });
    });
  }
});

// node_modules/wcdatavis/datavis.js
var import_block_ui = __toESM(require_jquery_blockUI());

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: /* @__PURE__ */ new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s2 = nth % 100;
    if (s2 > 3 && s2 < 21)
      return "th";
    switch (s2 % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
  var t2;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t2);
    t2 = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e2 = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e2.className = className;
  if (content !== void 0)
    e2.textContent = content;
  return e2;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale2) {
  return locale2.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale2) {
    dateObj.setMonth(locale2.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale2) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale2.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale2) {
    dateObj.setMonth(locale2.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds2) {
    dateObj.setSeconds(parseFloat(seconds2));
  },
  U: function(_3, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale2) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale2.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_3, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes2) {
    dateObj.setMinutes(parseFloat(minutes2));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds2) {
    dateObj.setSeconds(parseFloat(seconds2));
  },
  u: function(_3, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale2, options) {
    return locale2.weekdays.shorthand[formats.w(date, locale2, options)];
  },
  F: function(date, locale2, options) {
    return monthToStr(formats.n(date, locale2, options) - 1, false, locale2);
  },
  G: function(date, locale2, options) {
    return pad(formats.h(date, locale2, options));
  },
  H: function(date) {
    return pad(date.getHours());
  },
  J: function(date, locale2) {
    return locale2.ordinal !== void 0 ? date.getDate() + locale2.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale2) {
    return locale2.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale2) {
    return monthToStr(date.getMonth(), true, locale2);
  },
  S: function(date) {
    return pad(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _3, options) {
    return options.getWeek(date);
  },
  Y: function(date) {
    return pad(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale2) {
    return locale2.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale2 = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale2);
    }
    return frmt.split("").map(function(c2, i2, arr) {
      return formats[c2] && arr[i2 - 1] !== "\\" ? formats[c2](dateObj, locale2, config) : c2 !== "\\" ? c2 : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date)
      return void 0;
    var locale2 = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format3 = givenFormat || (config || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = /* @__PURE__ */ new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format3);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i2 = 0, matchIndex = 0, regexStr = ""; i2 < format3.length; i2++) {
          var token2 = format3[i2];
          var isBackSlash = token2 === "\\";
          var escaped = format3[i2 - 1] === "\\" || isBackSlash;
          if (tokenRegex[token2] && !escaped) {
            regexStr += tokenRegex[token2];
            var match = new RegExp(regexStr).exec(date);
            if (match && (matched = true)) {
              ops[token2 !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token2],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn = _a2.fn, val = _a2.val;
          return parsedDate = fn(parsedDate, val, locale2) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours2, minutes2, seconds2) {
  return hours2 * 3600 + minutes2 * 60 + seconds2;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours2 = Math.floor(secondsSinceMidnight / 3600), minutes2 = (secondsSinceMidnight - hours2 * 3600) / 60;
  return [hours2, minutes2, secondsSinceMidnight - hours2 * 3600 - minutes2 * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours2 = config.defaultHour;
  var minutes2 = config.defaultMinute;
  var seconds2 = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours2 < minHour) {
      hours2 = minHour;
    }
    if (hours2 === minHour && minutes2 < minMinutes) {
      minutes2 = minMinutes;
    }
    if (hours2 === minHour && minutes2 === minMinutes && seconds2 < minSeconds)
      seconds2 = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours2 = Math.min(hours2, maxHr);
    if (hours2 === maxHr)
      minutes2 = Math.min(maxMinutes, minutes2);
    if (hours2 === maxHr && minutes2 === maxMinutes)
      seconds2 = config.maxDate.getSeconds();
  }
  return { hours: hours2, minutes: minutes2, seconds: seconds2 };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p))
        t2[p] = s2[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
      r2[k] = a2[j];
  return r2;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self2 = {
    config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
    l10n: default_default
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement;
  self2.createDay = createDay;
  self2.destroy = destroy;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open;
  self2.redraw = redraw;
  self2.set = set3;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init2() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config = self2.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e2) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
      var defaults4 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults4.hours, defaults4.minutes, defaults4.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e2 !== void 0 && e2.type !== "blur") {
      timeWrapper(e2);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours2 = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes2 = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds2 = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours2 = ampm2military(hours2, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours2, minutes2, seconds2);
      if (currentTime > maxBound && currentTime < minBound) {
        var result2 = parseSeconds(minBound);
        hours2 = result2[0];
        minutes2 = result2[1];
        seconds2 = result2[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours2 = Math.min(hours2, maxTime.getHours());
        if (hours2 === maxTime.getHours())
          minutes2 = Math.min(minutes2, maxTime.getMinutes());
        if (minutes2 === maxTime.getMinutes())
          seconds2 = Math.min(seconds2, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours2 = Math.max(hours2, minTime.getHours());
        if (hours2 === minTime.getHours() && minutes2 < minTime.getMinutes())
          minutes2 = minTime.getMinutes();
        if (minutes2 === minTime.getMinutes())
          seconds2 = Math.max(seconds2, minTime.getSeconds());
      }
    }
    setHours(hours2, minutes2, seconds2);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self2.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours2, minutes2, seconds2) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours2 % 24, minutes2, seconds2 || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours2) % 12 + 12 * int(hours2 % 12 === 0) : hours2);
    self2.minuteElement.value = pad(minutes2);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours2 >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds2);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind(element2, ev, handler, options);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el) {
        return bind(el, event, handler, options);
      });
    element2.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce(onResize, 50);
    self2._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self2.daysContainer, "mouseover", function(e2) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e2));
      });
    bind(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind(self2._input, "focus", self2.open);
      bind(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind(self2.monthNav, "click", onMonthNavClick);
      bind(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e2) {
        return getEventTarget(e2).select();
      };
      bind(self2.timeContainer, ["increment"], updateTime);
      bind(self2.timeContainer, "blur", updateTime, { capture: true });
      bind(self2.timeContainer, "click", timeIncrement);
      bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind(self2.amPM, "click", function(e2) {
          updateTime(e2);
        });
      }
    }
    if (self2.config.allowInput) {
      bind(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e2) {
      e2.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e2);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e2) {
    var eventTarget = getEventTarget(e2);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e2, delta, inputElem) {
    var target = e2 && getEventTarget(e2);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i2) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i2;
    dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i2 % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m2 = startMonth; m2 != endMonth; m2 += delta) {
      var month = self2.daysContainer.children[m2];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i2 = startIndex; i2 != endIndex; i2 += delta) {
        var c2 = month.children[i2];
        if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj))
          return c2;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m2 = givenMonth - self2.currentMonth; m2 != endMonth; m2 += loopDelta) {
      var month = self2.daysContainer.children[m2];
      var startIndex = givenMonth - self2.currentMonth === m2 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i2 = startIndex; i2 >= 0 && i2 < numMonthDays && i2 != (delta > 0 ? numMonthDays : -1); i2 += loopDelta) {
        var c2 = month.children[i2];
        if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj) && Math.abs(current.$i - i2) >= Math.abs(delta))
          return focusOnDayElem(c2);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset2) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset2);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth2 = self2.utils.getDaysInMonth(month, year), days2 = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days2.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
      days2.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days2.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days2);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i2 = 0; i2 < self2.config.showMonths; i2++) {
      var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
      d2.setMonth(self2.currentMonth + i2);
      frag.appendChild(buildMonthDays(d2.getFullYear(), d2.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i2 = 0; i2 < 12; i2++) {
      if (!shouldBuildMonth(i2))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i2).getMonth().toString();
      month.textContent = monthToStr(i2, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i2) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind(self2.monthsDropdownContainer, "change", function(e2) {
        var target = getEventTarget(e2);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m2 = self2.config.showMonths; m2--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults4 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults4.hours : military2ampm(defaults4.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults4.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults4.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i2 = self2.config.showMonths; i2--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i2 = self2.config.showMonths; i2--; ) {
      self2.weekdayContainer.children[i2].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a = getDefaultHours(self2.config), hours2 = _a.hours, minutes2 = _a.minutes, seconds2 = _a.seconds;
      setHours(hours2, minutes2, seconds2);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (var i2 = self2._handlers.length; i2--; ) {
      self2._handlers[i2].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_3) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e2) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e2);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (var i2 = 0, d2 = void 0; i2 < array.length; i2++) {
      d2 = array[i2];
      if (typeof d2 === "function" && d2(dateToCheck))
        return bool;
      else if (d2 instanceof Date && dateToCheck !== void 0 && d2.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d2 === "string") {
        var parsed = self2.parseDate(d2, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d2 === "object" && dateToCheck !== void 0 && d2.from && d2.to && dateToCheck.getTime() >= d2.from.getTime() && dateToCheck.getTime() <= d2.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e2) {
    var isInput = e2.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
      self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e2) {
    var eventTarget = getEventTarget(e2);
    var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e2.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e2.keyCode) {
        case 13:
          if (isTimeObj) {
            e2.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e2);
          break;
        case 27:
          e2.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e2.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e2.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e2.keyCode === 39 ? 1 : -1;
              if (!e2.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e2.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e2.preventDefault();
          var delta = e2.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e2.ctrlKey) {
              e2.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e2);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x) {
              return x;
            });
            var i2 = elems.indexOf(eventTarget);
            if (i2 !== -1) {
              var target = elems[i2 + (e2.shiftKey ? -1 : 1)];
              e2.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
            e2.preventDefault();
            self2._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e2.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e2);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
      if (!isEnabled(new Date(t2), true)) {
        containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
        if (t2 < initialDate && (!minRange || t2 > minRange))
          minRange = t2;
        else if (t2 > initialDate && (!maxRange || t2 < maxRange))
          maxRange = t2;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c2) {
          dayElem.classList.remove(c2);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c2) {
        dayElem.classList.remove(c2);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open(e2, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e2) {
        e2.preventDefault();
        var eventTarget = getEventTarget(e2);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d2) {
          return isEnabled(d2);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates) {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates) {
        self2.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i2 = 0; i2 < boolOpts.length; i2++)
      self2.config[boolOpts[i2]] = self2.config[boolOpts[i2]] === true || self2.config[boolOpts[i2]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i2 = 0; i2 < self2.config.plugins.length; i2++) {
      var pluginConf = self2.config.plugins[i2](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self2.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self2.calendarContainer, "rightMost", false);
      toggleClass(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      var sheet = document.styleSheets[i2];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t2 = findParent(getEventTarget(e2), isSelectable);
    if (t2 === void 0)
      return;
    var target = t2;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a2, b) {
          return a2.getTime() - b.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range2 = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range2) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind(self2._input, "focus", self2.open);
          bind(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set3(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self2.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self2.config[option] = value;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option) > -1)
        self2.config[option] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format3) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d2) {
        return self2.parseDate(d2, format3);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self2.parseDate(inputDate, format3)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format3)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map(function(date) {
            return self2.parseDate(date, format3);
          });
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
            return self2.parseDate(date, format3);
          });
          break;
        default:
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d2) {
      return d2 instanceof Date && isEnabled(d2, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a2, b) {
        return a2.getTime() - b.getTime();
      });
  }
  function setDate(date, triggerChange2, format3) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format3 === void 0) {
      format3 = self2.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date, format3);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind(self2.mobileInput, "change", function(e2) {
      self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e2) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e2);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0)
      return;
    var hooks2 = self2.config[event];
    if (hooks2 !== void 0 && hooks2.length > 0) {
      for (var i2 = 0; hooks2[i2] && i2 < hooks2.length; i2++)
        hooks2[i2](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e2 = document.createEvent("Event");
    e2.initEvent(name, true, true);
    return e2;
  }
  function isDateSelected(date) {
    for (var i2 = 0; i2 < self2.selectedDates.length; i2++) {
      var selectedDate = self2.selectedDates[i2];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
        return "" + i2;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i2) {
      var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
      d2.setMonth(self2.currentMonth + i2);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i2].textContent = monthToStr(d2.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d2.getMonth().toString();
      }
      yearElement.value = d2.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format3 = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format3);
    }).filter(function(d2, i2, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d2) === i2;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e2) {
    var eventTarget = getEventTarget(e2);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e2) {
    e2.preventDefault();
    var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min3 = parseFloat(input.getAttribute("min")), max3 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min3) {
        newValue = max3 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max3) {
        newValue = input === self2.hourElement ? newValue - max3 - int(!self2.amPM) : min3;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init2();
  return self2;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances2 = [];
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node = nodes[i2];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances2.push(node._flatpickr);
    } catch (e2) {
      console.error(e2);
    }
  }
  return instances2.length === 1 ? instances2[0] : instances2;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, default_default),
  default: __assign({}, default_default)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days2) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days2 === "string" ? parseInt(days2, 10) : days2));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}

// node_modules/wcdatavis/node_modules/jquery-ui/dist/jquery-ui.min.js
!function(t2) {
  "use strict";
  "function" == typeof define && define.amd ? define(["jquery"], t2) : t2(jQuery);
}(function(V) {
  "use strict";
  V.ui = V.ui || {};
  V.ui.version = "1.14.0";
  var n2, s2, k, x, o2, a2, r2, l2, h, i2, E = 0, N = Array.prototype.hasOwnProperty, c2 = Array.prototype.slice;
  V.cleanData = (n2 = V.cleanData, function(t3) {
    for (var e3, i3, s3 = 0; null != (i3 = t3[s3]); s3++) (e3 = V._data(i3, "events")) && e3.remove && V(i3).triggerHandler("remove");
    n2(t3);
  }), V.widget = function(t3, i3, e3) {
    var s3, n3, o3, a3 = {}, r3 = t3.split(".")[0], l3 = r3 + "-" + (t3 = t3.split(".")[1]);
    return e3 || (e3 = i3, i3 = V.Widget), Array.isArray(e3) && (e3 = V.extend.apply(null, [{}].concat(e3))), V.expr.pseudos[l3.toLowerCase()] = function(t4) {
      return !!V.data(t4, l3);
    }, V[r3] = V[r3] || {}, s3 = V[r3][t3], n3 = V[r3][t3] = function(t4, e4) {
      if (!this || !this._createWidget) return new n3(t4, e4);
      arguments.length && this._createWidget(t4, e4);
    }, V.extend(n3, s3, { version: e3.version, _proto: V.extend({}, e3), _childConstructors: [] }), (o3 = new i3()).options = V.widget.extend({}, o3.options), V.each(e3, function(e4, s4) {
      function n4() {
        return i3.prototype[e4].apply(this, arguments);
      }
      function o4(t4) {
        return i3.prototype[e4].apply(this, t4);
      }
      a3[e4] = "function" != typeof s4 ? s4 : function() {
        var t4, e5 = this._super, i4 = this._superApply;
        return this._super = n4, this._superApply = o4, t4 = s4.apply(this, arguments), this._super = e5, this._superApply = i4, t4;
      };
    }), n3.prototype = V.widget.extend(o3, { widgetEventPrefix: s3 && o3.widgetEventPrefix || t3 }, a3, { constructor: n3, namespace: r3, widgetName: t3, widgetFullName: l3 }), s3 ? (V.each(s3._childConstructors, function(t4, e4) {
      var i4 = e4.prototype;
      V.widget(i4.namespace + "." + i4.widgetName, n3, e4._proto);
    }), delete s3._childConstructors) : i3._childConstructors.push(n3), V.widget.bridge(t3, n3), n3;
  }, V.widget.extend = function(t3) {
    for (var e3, i3, s3 = c2.call(arguments, 1), n3 = 0, o3 = s3.length; n3 < o3; n3++) for (e3 in s3[n3]) i3 = s3[n3][e3], N.call(s3[n3], e3) && void 0 !== i3 && (V.isPlainObject(i3) ? t3[e3] = V.isPlainObject(t3[e3]) ? V.widget.extend({}, t3[e3], i3) : V.widget.extend({}, i3) : t3[e3] = i3);
    return t3;
  }, V.widget.bridge = function(o3, e3) {
    var a3 = e3.prototype.widgetFullName || o3;
    V.fn[o3] = function(i3) {
      var t3 = "string" == typeof i3, s3 = c2.call(arguments, 1), n3 = this;
      return t3 ? this.length || "instance" !== i3 ? this.each(function() {
        var t4, e4 = V.data(this, a3);
        return "instance" === i3 ? (n3 = e4, false) : e4 ? "function" != typeof e4[i3] || "_" === i3.charAt(0) ? V.error("no such method '" + i3 + "' for " + o3 + " widget instance") : (t4 = e4[i3].apply(e4, s3)) !== e4 && void 0 !== t4 ? (n3 = t4 && t4.jquery ? n3.pushStack(t4.get()) : t4, false) : void 0 : V.error("cannot call methods on " + o3 + " prior to initialization; attempted to call method '" + i3 + "'");
      }) : n3 = void 0 : (s3.length && (i3 = V.widget.extend.apply(null, [i3].concat(s3))), this.each(function() {
        var t4 = V.data(this, a3);
        t4 ? (t4.option(i3 || {}), t4._init && t4._init()) : V.data(this, a3, new e3(i3, this));
      })), n3;
    };
  }, V.Widget = function() {
  }, V.Widget._childConstructors = [], V.Widget.prototype = { widgetName: "widget", widgetEventPrefix: "", defaultElement: "<div>", options: { classes: {}, disabled: false, create: null }, _createWidget: function(t3, e3) {
    e3 = V(e3 || this.defaultElement || this)[0], this.element = V(e3), this.uuid = E++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = V(), this.hoverable = V(), this.focusable = V(), this.classesElementLookup = {}, e3 !== this && (V.data(e3, this.widgetFullName, this), this._on(true, this.element, { remove: function(t4) {
      t4.target === e3 && this.destroy();
    } }), this.document = V(e3.style ? e3.ownerDocument : e3.document || e3), this.window = V(this.document[0].defaultView || this.document[0].parentWindow)), this.options = V.widget.extend({}, this.options, this._getCreateOptions(), t3), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init();
  }, _getCreateOptions: function() {
    return {};
  }, _getCreateEventData: V.noop, _create: V.noop, _init: V.noop, destroy: function() {
    var i3 = this;
    this._destroy(), V.each(this.classesElementLookup, function(t3, e3) {
      i3._removeClass(e3, t3);
    }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace);
  }, _destroy: V.noop, widget: function() {
    return this.element;
  }, option: function(t3, e3) {
    var i3, s3, n3, o3 = t3;
    if (0 === arguments.length) return V.widget.extend({}, this.options);
    if ("string" == typeof t3) if (o3 = {}, t3 = (i3 = t3.split(".")).shift(), i3.length) {
      for (s3 = o3[t3] = V.widget.extend({}, this.options[t3]), n3 = 0; n3 < i3.length - 1; n3++) s3[i3[n3]] = s3[i3[n3]] || {}, s3 = s3[i3[n3]];
      if (t3 = i3.pop(), 1 === arguments.length) return void 0 === s3[t3] ? null : s3[t3];
      s3[t3] = e3;
    } else {
      if (1 === arguments.length) return void 0 === this.options[t3] ? null : this.options[t3];
      o3[t3] = e3;
    }
    return this._setOptions(o3), this;
  }, _setOptions: function(t3) {
    for (var e3 in t3) this._setOption(e3, t3[e3]);
    return this;
  }, _setOption: function(t3, e3) {
    return "classes" === t3 && this._setOptionClasses(e3), this.options[t3] = e3, "disabled" === t3 && this._setOptionDisabled(e3), this;
  }, _setOptionClasses: function(t3) {
    var e3, i3, s3;
    for (e3 in t3) s3 = this.classesElementLookup[e3], t3[e3] !== this.options.classes[e3] && s3 && s3.length && (i3 = V(s3.get()), this._removeClass(s3, e3), i3.addClass(this._classes({ element: i3, keys: e3, classes: t3, add: true })));
  }, _setOptionDisabled: function(t3) {
    this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t3), t3 && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"));
  }, enable: function() {
    return this._setOptions({ disabled: false });
  }, disable: function() {
    return this._setOptions({ disabled: true });
  }, _classes: function(n3) {
    var o3 = [], a3 = this;
    function t3(t4, e3) {
      for (var i3, s3 = 0; s3 < t4.length; s3++) i3 = a3.classesElementLookup[t4[s3]] || V(), i3 = n3.add ? (function() {
        var i4 = [];
        n3.element.each(function(t5, e4) {
          V.map(a3.classesElementLookup, function(t6) {
            return t6;
          }).some(function(t6) {
            return t6.is(e4);
          }) || i4.push(e4);
        }), a3._on(V(i4), { remove: "_untrackClassesElement" });
      }(), V(V.uniqueSort(i3.get().concat(n3.element.get())))) : V(i3.not(n3.element).get()), a3.classesElementLookup[t4[s3]] = i3, o3.push(t4[s3]), e3 && n3.classes[t4[s3]] && o3.push(n3.classes[t4[s3]]);
    }
    return (n3 = V.extend({ element: this.element, classes: this.options.classes || {} }, n3)).keys && t3(n3.keys.match(/\S+/g) || [], true), n3.extra && t3(n3.extra.match(/\S+/g) || []), o3.join(" ");
  }, _untrackClassesElement: function(i3) {
    var s3 = this;
    V.each(s3.classesElementLookup, function(t3, e3) {
      -1 !== V.inArray(i3.target, e3) && (s3.classesElementLookup[t3] = V(e3.not(i3.target).get()));
    }), this._off(V(i3.target));
  }, _removeClass: function(t3, e3, i3) {
    return this._toggleClass(t3, e3, i3, false);
  }, _addClass: function(t3, e3, i3) {
    return this._toggleClass(t3, e3, i3, true);
  }, _toggleClass: function(t3, e3, i3, s3) {
    var n3 = "string" == typeof t3 || null === t3, e3 = { extra: n3 ? e3 : i3, keys: n3 ? t3 : e3, element: n3 ? this.element : t3, add: s3 = "boolean" == typeof s3 ? s3 : i3 };
    return e3.element.toggleClass(this._classes(e3), s3), this;
  }, _on: function(n3, o3, t3) {
    var a3, r3 = this;
    "boolean" != typeof n3 && (t3 = o3, o3 = n3, n3 = false), t3 ? (o3 = a3 = V(o3), this.bindings = this.bindings.add(o3)) : (t3 = o3, o3 = this.element, a3 = this.widget()), V.each(t3, function(t4, e3) {
      function i3() {
        if (n3 || true !== r3.options.disabled && !V(this).hasClass("ui-state-disabled")) return ("string" == typeof e3 ? r3[e3] : e3).apply(r3, arguments);
      }
      "string" != typeof e3 && (i3.guid = e3.guid = e3.guid || i3.guid || V.guid++);
      var t4 = t4.match(/^([\w:-]*)\s*(.*)$/), s3 = t4[1] + r3.eventNamespace, t4 = t4[2];
      t4 ? a3.on(s3, t4, i3) : o3.on(s3, i3);
    });
  }, _off: function(t3, e3) {
    e3 = (e3 || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t3.off(e3), this.bindings = V(this.bindings.not(t3).get()), this.focusable = V(this.focusable.not(t3).get()), this.hoverable = V(this.hoverable.not(t3).get());
  }, _delay: function(t3, e3) {
    var i3 = this;
    return setTimeout(function() {
      return ("string" == typeof t3 ? i3[t3] : t3).apply(i3, arguments);
    }, e3 || 0);
  }, _hoverable: function(t3) {
    this.hoverable = this.hoverable.add(t3), this._on(t3, { mouseenter: function(t4) {
      this._addClass(V(t4.currentTarget), null, "ui-state-hover");
    }, mouseleave: function(t4) {
      this._removeClass(V(t4.currentTarget), null, "ui-state-hover");
    } });
  }, _focusable: function(t3) {
    this.focusable = this.focusable.add(t3), this._on(t3, { focusin: function(t4) {
      this._addClass(V(t4.currentTarget), null, "ui-state-focus");
    }, focusout: function(t4) {
      this._removeClass(V(t4.currentTarget), null, "ui-state-focus");
    } });
  }, _trigger: function(t3, e3, i3) {
    var s3, n3, o3 = this.options[t3];
    if (i3 = i3 || {}, (e3 = V.Event(e3)).type = (t3 === this.widgetEventPrefix ? t3 : this.widgetEventPrefix + t3).toLowerCase(), e3.target = this.element[0], n3 = e3.originalEvent) for (s3 in n3) s3 in e3 || (e3[s3] = n3[s3]);
    return this.element.trigger(e3, i3), !("function" == typeof o3 && false === o3.apply(this.element[0], [e3].concat(i3)) || e3.isDefaultPrevented());
  } }, V.each({ show: "fadeIn", hide: "fadeOut" }, function(o3, a3) {
    V.Widget.prototype["_" + o3] = function(e3, t3, i3) {
      var s3, n3 = (t3 = "string" == typeof t3 ? { effect: t3 } : t3) ? true !== t3 && "number" != typeof t3 && t3.effect || a3 : o3;
      "number" == typeof (t3 = t3 || {}) ? t3 = { duration: t3 } : true === t3 && (t3 = {}), s3 = !V.isEmptyObject(t3), t3.complete = i3, t3.delay && e3.delay(t3.delay), s3 && V.effects && V.effects.effect[n3] ? e3[o3](t3) : n3 !== o3 && e3[n3] ? e3[n3](t3.duration, t3.easing, i3) : e3.queue(function(t4) {
        V(this)[o3](), i3 && i3.call(e3[0]), t4();
      });
    };
  }), V.widget;
  function C(t3, e3, i3) {
    return [parseFloat(t3[0]) * (h.test(t3[0]) ? e3 / 100 : 1), parseFloat(t3[1]) * (h.test(t3[1]) ? i3 / 100 : 1)];
  }
  function D(t3, e3) {
    return parseInt(V.css(t3, e3), 10) || 0;
  }
  function I2(t3) {
    return null != t3 && t3 === t3.window;
  }
  k = Math.max, x = Math.abs, o2 = /left|center|right/, a2 = /top|center|bottom/, r2 = /[\+\-]\d+(\.[\d]+)?%?/, l2 = /^\w+/, h = /%$/, i2 = V.fn.position, V.position = { scrollbarWidth: function() {
    var t3, e3, i3;
    return void 0 !== s2 ? s2 : (i3 = (e3 = V("<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'></div></div>")).children()[0], V("body").append(e3), t3 = i3.offsetWidth, e3.css("overflow", "scroll"), t3 === (i3 = i3.offsetWidth) && (i3 = e3[0].clientWidth), e3.remove(), s2 = t3 - i3);
  }, getScrollInfo: function(t3) {
    var e3 = t3.isWindow || t3.isDocument ? "" : t3.element.css("overflow-x"), i3 = t3.isWindow || t3.isDocument ? "" : t3.element.css("overflow-y"), e3 = "scroll" === e3 || "auto" === e3 && t3.width < t3.element[0].scrollWidth;
    return { width: "scroll" === i3 || "auto" === i3 && t3.height < t3.element[0].scrollHeight ? V.position.scrollbarWidth() : 0, height: e3 ? V.position.scrollbarWidth() : 0 };
  }, getWithinInfo: function(t3) {
    var e3 = V(t3 || window), i3 = I2(e3[0]), s3 = !!e3[0] && 9 === e3[0].nodeType;
    return { element: e3, isWindow: i3, isDocument: s3, offset: !i3 && !s3 ? V(t3).offset() : { left: 0, top: 0 }, scrollLeft: e3.scrollLeft(), scrollTop: e3.scrollTop(), width: e3.outerWidth(), height: e3.outerHeight() };
  } }, V.fn.position = function(u2) {
    var d3, p2, f3, g2, m3, _4, v2, b2, y2, w2, t3, e3;
    return u2 && u2.of ? (_4 = "string" == typeof (u2 = V.extend({}, u2)).of ? V(document).find(u2.of) : V(u2.of), v2 = V.position.getWithinInfo(u2.within), b2 = V.position.getScrollInfo(v2), y2 = (u2.collision || "flip").split(" "), w2 = {}, e3 = 9 === (e3 = (t3 = _4)[0]).nodeType ? { width: t3.width(), height: t3.height(), offset: { top: 0, left: 0 } } : I2(e3) ? { width: t3.width(), height: t3.height(), offset: { top: t3.scrollTop(), left: t3.scrollLeft() } } : e3.preventDefault ? { width: 0, height: 0, offset: { top: e3.pageY, left: e3.pageX } } : { width: t3.outerWidth(), height: t3.outerHeight(), offset: t3.offset() }, _4[0].preventDefault && (u2.at = "left top"), p2 = e3.width, f3 = e3.height, m3 = V.extend({}, g2 = e3.offset), V.each(["my", "at"], function() {
      var t4, e4, i3 = (u2[this] || "").split(" ");
      (i3 = 1 === i3.length ? o2.test(i3[0]) ? i3.concat(["center"]) : a2.test(i3[0]) ? ["center"].concat(i3) : ["center", "center"] : i3)[0] = o2.test(i3[0]) ? i3[0] : "center", i3[1] = a2.test(i3[1]) ? i3[1] : "center", t4 = r2.exec(i3[0]), e4 = r2.exec(i3[1]), w2[this] = [t4 ? t4[0] : 0, e4 ? e4[0] : 0], u2[this] = [l2.exec(i3[0])[0], l2.exec(i3[1])[0]];
    }), 1 === y2.length && (y2[1] = y2[0]), "right" === u2.at[0] ? m3.left += p2 : "center" === u2.at[0] && (m3.left += p2 / 2), "bottom" === u2.at[1] ? m3.top += f3 : "center" === u2.at[1] && (m3.top += f3 / 2), d3 = C(w2.at, p2, f3), m3.left += d3[0], m3.top += d3[1], this.each(function() {
      var i3, t4, a3 = V(this), r3 = a3.outerWidth(), l3 = a3.outerHeight(), e4 = D(this, "marginLeft"), s3 = D(this, "marginTop"), n3 = r3 + e4 + D(this, "marginRight") + b2.width, o3 = l3 + s3 + D(this, "marginBottom") + b2.height, h3 = V.extend({}, m3), c3 = C(w2.my, a3.outerWidth(), a3.outerHeight());
      "right" === u2.my[0] ? h3.left -= r3 : "center" === u2.my[0] && (h3.left -= r3 / 2), "bottom" === u2.my[1] ? h3.top -= l3 : "center" === u2.my[1] && (h3.top -= l3 / 2), h3.left += c3[0], h3.top += c3[1], i3 = { marginLeft: e4, marginTop: s3 }, V.each(["left", "top"], function(t5, e5) {
        V.ui.position[y2[t5]] && V.ui.position[y2[t5]][e5](h3, { targetWidth: p2, targetHeight: f3, elemWidth: r3, elemHeight: l3, collisionPosition: i3, collisionWidth: n3, collisionHeight: o3, offset: [d3[0] + c3[0], d3[1] + c3[1]], my: u2.my, at: u2.at, within: v2, elem: a3 });
      }), u2.using && (t4 = function(t5) {
        var e5 = g2.left - h3.left, i4 = e5 + p2 - r3, s4 = g2.top - h3.top, n4 = s4 + f3 - l3, o4 = { target: { element: _4, left: g2.left, top: g2.top, width: p2, height: f3 }, element: { element: a3, left: h3.left, top: h3.top, width: r3, height: l3 }, horizontal: i4 < 0 ? "left" : 0 < e5 ? "right" : "center", vertical: n4 < 0 ? "top" : 0 < s4 ? "bottom" : "middle" };
        p2 < r3 && x(e5 + i4) < p2 && (o4.horizontal = "center"), f3 < l3 && x(s4 + n4) < f3 && (o4.vertical = "middle"), k(x(e5), x(i4)) > k(x(s4), x(n4)) ? o4.important = "horizontal" : o4.important = "vertical", u2.using.call(this, t5, o4);
      }), a3.offset(V.extend(h3, { using: t4 }));
    })) : i2.apply(this, arguments);
  }, V.ui.position = { fit: { left: function(t3, e3) {
    var i3, s3 = e3.within, n3 = s3.isWindow ? s3.scrollLeft : s3.offset.left, s3 = s3.width, o3 = t3.left - e3.collisionPosition.marginLeft, a3 = n3 - o3, r3 = o3 + e3.collisionWidth - s3 - n3;
    e3.collisionWidth > s3 ? 0 < a3 && r3 <= 0 ? (i3 = t3.left + a3 + e3.collisionWidth - s3 - n3, t3.left += a3 - i3) : t3.left = !(0 < r3 && a3 <= 0) && r3 < a3 ? n3 + s3 - e3.collisionWidth : n3 : 0 < a3 ? t3.left += a3 : 0 < r3 ? t3.left -= r3 : t3.left = k(t3.left - o3, t3.left);
  }, top: function(t3, e3) {
    var i3, s3 = e3.within, s3 = s3.isWindow ? s3.scrollTop : s3.offset.top, n3 = e3.within.height, o3 = t3.top - e3.collisionPosition.marginTop, a3 = s3 - o3, r3 = o3 + e3.collisionHeight - n3 - s3;
    e3.collisionHeight > n3 ? 0 < a3 && r3 <= 0 ? (i3 = t3.top + a3 + e3.collisionHeight - n3 - s3, t3.top += a3 - i3) : t3.top = !(0 < r3 && a3 <= 0) && r3 < a3 ? s3 + n3 - e3.collisionHeight : s3 : 0 < a3 ? t3.top += a3 : 0 < r3 ? t3.top -= r3 : t3.top = k(t3.top - o3, t3.top);
  } }, flip: { left: function(t3, e3) {
    var i3 = e3.within, s3 = i3.offset.left + i3.scrollLeft, n3 = i3.width, i3 = i3.isWindow ? i3.scrollLeft : i3.offset.left, o3 = t3.left - e3.collisionPosition.marginLeft, a3 = o3 - i3, o3 = o3 + e3.collisionWidth - n3 - i3, r3 = "left" === e3.my[0] ? -e3.elemWidth : "right" === e3.my[0] ? e3.elemWidth : 0, l3 = "left" === e3.at[0] ? e3.targetWidth : "right" === e3.at[0] ? -e3.targetWidth : 0, h3 = -2 * e3.offset[0];
    a3 < 0 ? ((n3 = t3.left + r3 + l3 + h3 + e3.collisionWidth - n3 - s3) < 0 || n3 < x(a3)) && (t3.left += r3 + l3 + h3) : 0 < o3 && (0 < (s3 = t3.left - e3.collisionPosition.marginLeft + r3 + l3 + h3 - i3) || x(s3) < o3) && (t3.left += r3 + l3 + h3);
  }, top: function(t3, e3) {
    var i3 = e3.within, s3 = i3.offset.top + i3.scrollTop, n3 = i3.height, i3 = i3.isWindow ? i3.scrollTop : i3.offset.top, o3 = t3.top - e3.collisionPosition.marginTop, a3 = o3 - i3, o3 = o3 + e3.collisionHeight - n3 - i3, r3 = "top" === e3.my[1] ? -e3.elemHeight : "bottom" === e3.my[1] ? e3.elemHeight : 0, l3 = "top" === e3.at[1] ? e3.targetHeight : "bottom" === e3.at[1] ? -e3.targetHeight : 0, h3 = -2 * e3.offset[1];
    a3 < 0 ? ((n3 = t3.top + r3 + l3 + h3 + e3.collisionHeight - n3 - s3) < 0 || n3 < x(a3)) && (t3.top += r3 + l3 + h3) : 0 < o3 && (0 < (s3 = t3.top - e3.collisionPosition.marginTop + r3 + l3 + h3 - i3) || x(s3) < o3) && (t3.top += r3 + l3 + h3);
  } }, flipfit: { left: function() {
    V.ui.position.flip.left.apply(this, arguments), V.ui.position.fit.left.apply(this, arguments);
  }, top: function() {
    V.ui.position.flip.top.apply(this, arguments), V.ui.position.fit.top.apply(this, arguments);
  } } };
  V.ui.position, V.extend(V.expr.pseudos, { data: V.expr.createPseudo(function(e3) {
    return function(t3) {
      return !!V.data(t3, e3);
    };
  }) }), V.fn.extend({ disableSelection: (t2 = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown", function() {
    return this.on(t2 + ".ui-disableSelection", function(t3) {
      t3.preventDefault();
    });
  }), enableSelection: function() {
    return this.off(".ui-disableSelection");
  } });
  var t2, u = V, d2 = {}, W = d2.toString, F = /^([\-+])=\s*(\d+\.?\d*)/, L = [{ re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse: function(t3) {
    return [t3[1], t3[2], t3[3], t3[4]];
  } }, { re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse: function(t3) {
    return [2.55 * t3[1], 2.55 * t3[2], 2.55 * t3[3], t3[4]];
  } }, { re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/, parse: function(t3) {
    return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16), t3[4] ? (parseInt(t3[4], 16) / 255).toFixed(2) : 1];
  } }, { re: /#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/, parse: function(t3) {
    return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16), t3[4] ? (parseInt(t3[4] + t3[4], 16) / 255).toFixed(2) : 1];
  } }, { re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, space: "hsla", parse: function(t3) {
    return [t3[1], t3[2] / 100, t3[3] / 100, t3[4]];
  } }], p = u.Color = function(t3, e3, i3, s3) {
    return new u.Color.fn.parse(t3, e3, i3, s3);
  }, f2 = { rgba: { props: { red: { idx: 0, type: "byte" }, green: { idx: 1, type: "byte" }, blue: { idx: 2, type: "byte" } } }, hsla: { props: { hue: { idx: 0, type: "degrees" }, saturation: { idx: 1, type: "percent" }, lightness: { idx: 2, type: "percent" } } } }, R = { byte: { floor: true, max: 255 }, percent: { max: 1 }, degrees: { mod: 360, floor: true } }, g = u.each;
  function m2(t3) {
    return null == t3 ? t3 + "" : "object" == typeof t3 ? d2[W.call(t3)] || "object" : typeof t3;
  }
  function _3(t3, e3, i3) {
    var s3 = R[e3.type] || {};
    return null == t3 ? i3 || !e3.def ? null : e3.def : (t3 = s3.floor ? ~~t3 : parseFloat(t3), s3.mod ? (t3 + s3.mod) % s3.mod : Math.min(s3.max, Math.max(0, t3)));
  }
  function Y2(s3) {
    var n3 = p(), o3 = n3._rgba = [];
    return s3 = s3.toLowerCase(), g(L, function(t3, e3) {
      var i3 = e3.re.exec(s3), i3 = i3 && e3.parse(i3), e3 = e3.space || "rgba";
      if (i3) return i3 = n3[e3](i3), n3[f2[e3].cache] = i3[f2[e3].cache], o3 = n3._rgba = i3._rgba, false;
    }), o3.length ? ("0,0,0,0" === o3.join() && u.extend(o3, y.transparent), n3) : y[s3];
  }
  function v(t3, e3, i3) {
    return 6 * (i3 = (i3 + 1) % 1) < 1 ? t3 + (e3 - t3) * i3 * 6 : 2 * i3 < 1 ? e3 : 3 * i3 < 2 ? t3 + (e3 - t3) * (2 / 3 - i3) * 6 : t3;
  }
  g(f2, function(t3, e3) {
    e3.cache = "_" + t3, e3.props.alpha = { idx: 3, type: "percent", def: 1 };
  }), u.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(t3, e3) {
    d2["[object " + e3 + "]"] = e3.toLowerCase();
  }), (p.fn = u.extend(p.prototype, { parse: function(n3, t3, e3, i3) {
    if (void 0 === n3) return this._rgba = [null, null, null, null], this;
    (n3.jquery || n3.nodeType) && (n3 = u(n3).css(t3), t3 = void 0);
    var o3 = this, s3 = m2(n3), a3 = this._rgba = [];
    return void 0 !== t3 && (n3 = [n3, t3, e3, i3], s3 = "array"), "string" === s3 ? this.parse(Y2(n3) || y._default) : "array" === s3 ? (g(f2.rgba.props, function(t4, e4) {
      a3[e4.idx] = _3(n3[e4.idx], e4);
    }), this) : "object" === s3 ? (n3 instanceof p ? g(f2, function(t4, e4) {
      n3[e4.cache] && (o3[e4.cache] = n3[e4.cache].slice());
    }) : g(f2, function(t4, i4) {
      var s4 = i4.cache;
      g(i4.props, function(t5, e4) {
        if (!o3[s4] && i4.to) {
          if ("alpha" === t5 || null == n3[t5]) return;
          o3[s4] = i4.to(o3._rgba);
        }
        o3[s4][e4.idx] = _3(n3[t5], e4, true);
      }), o3[s4] && u.inArray(null, o3[s4].slice(0, 3)) < 0 && (null == o3[s4][3] && (o3[s4][3] = 1), i4.from) && (o3._rgba = i4.from(o3[s4]));
    }), this) : void 0;
  }, is: function(t3) {
    var n3 = p(t3), o3 = true, a3 = this;
    return g(f2, function(t4, e3) {
      var i3, s3 = n3[e3.cache];
      return s3 && (i3 = a3[e3.cache] || e3.to && e3.to(a3._rgba) || [], g(e3.props, function(t5, e4) {
        if (null != s3[e4.idx]) return o3 = s3[e4.idx] === i3[e4.idx];
      })), o3;
    }), o3;
  }, _space: function() {
    var i3 = [], s3 = this;
    return g(f2, function(t3, e3) {
      s3[e3.cache] && i3.push(t3);
    }), i3.pop();
  }, transition: function(t3, a3) {
    var t3 = (h3 = p(t3))._space(), e3 = f2[t3], i3 = 0 === this.alpha() ? p("transparent") : this, r3 = i3[e3.cache] || e3.to(i3._rgba), l3 = r3.slice(), h3 = h3[e3.cache];
    return g(e3.props, function(t4, e4) {
      var i4 = e4.idx, s3 = r3[i4], n3 = h3[i4], o3 = R[e4.type] || {};
      null !== n3 && (null === s3 ? l3[i4] = n3 : (o3.mod && (n3 - s3 > o3.mod / 2 ? s3 += o3.mod : s3 - n3 > o3.mod / 2 && (s3 -= o3.mod)), l3[i4] = _3((n3 - s3) * a3 + s3, e4)));
    }), this[t3](l3);
  }, blend: function(t3) {
    var e3, i3, s3;
    return 1 === this._rgba[3] ? this : (e3 = this._rgba.slice(), i3 = e3.pop(), s3 = p(t3)._rgba, p(u.map(e3, function(t4, e4) {
      return (1 - i3) * s3[e4] + i3 * t4;
    })));
  }, toRgbaString: function() {
    var t3 = "rgba(", e3 = u.map(this._rgba, function(t4, e4) {
      return null != t4 ? t4 : 2 < e4 ? 1 : 0;
    });
    return 1 === e3[3] && (e3.pop(), t3 = "rgb("), t3 + e3.join(", ") + ")";
  }, toHslaString: function() {
    var t3 = "hsla(", e3 = u.map(this.hsla(), function(t4, e4) {
      return null == t4 && (t4 = 2 < e4 ? 1 : 0), t4 = e4 && e4 < 3 ? Math.round(100 * t4) + "%" : t4;
    });
    return 1 === e3[3] && (e3.pop(), t3 = "hsl("), t3 + e3.join(", ") + ")";
  }, toHexString: function(t3) {
    var e3 = this._rgba.slice(), i3 = e3.pop();
    return t3 && e3.push(~~(255 * i3)), "#" + u.map(e3, function(t4) {
      return ("0" + (t4 || 0).toString(16)).substr(-2);
    }).join("");
  }, toString: function() {
    return this.toRgbaString();
  } })).parse.prototype = p.fn, f2.hsla.to = function(t3) {
    var e3, i3, s3, n3, o3, a3, r3, l3;
    return null == t3[0] || null == t3[1] || null == t3[2] ? [null, null, null, t3[3]] : (e3 = t3[0] / 255, i3 = t3[1] / 255, s3 = t3[2] / 255, t3 = t3[3], n3 = (l3 = Math.max(e3, i3, s3)) - (r3 = Math.min(e3, i3, s3)), a3 = 0.5 * (o3 = l3 + r3), r3 = r3 === l3 ? 0 : e3 === l3 ? 60 * (i3 - s3) / n3 + 360 : i3 === l3 ? 60 * (s3 - e3) / n3 + 120 : 60 * (e3 - i3) / n3 + 240, l3 = 0 == n3 ? 0 : a3 <= 0.5 ? n3 / o3 : n3 / (2 - o3), [Math.round(r3) % 360, l3, a3, null == t3 ? 1 : t3]);
  }, f2.hsla.from = function(t3) {
    var e3, i3, s3;
    return null == t3[0] || null == t3[1] || null == t3[2] ? [null, null, null, t3[3]] : (e3 = t3[0] / 360, s3 = t3[1], i3 = t3[2], t3 = t3[3], s3 = 2 * i3 - (i3 = i3 <= 0.5 ? i3 * (1 + s3) : i3 + s3 - i3 * s3), [Math.round(255 * v(s3, i3, e3 + 1 / 3)), Math.round(255 * v(s3, i3, e3)), Math.round(255 * v(s3, i3, e3 - 1 / 3)), t3]);
  }, g(f2, function(r3, t3) {
    var e3 = t3.props, o3 = t3.cache, a3 = t3.to, l3 = t3.from;
    p.fn[r3] = function(t4) {
      var i3, s3, n3;
      return a3 && !this[o3] && (this[o3] = a3(this._rgba)), void 0 === t4 ? this[o3].slice() : (i3 = m2(t4), s3 = "array" === i3 || "object" === i3 ? t4 : arguments, n3 = this[o3].slice(), g(e3, function(t5, e4) {
        t5 = s3["object" === i3 ? t5 : e4.idx];
        null == t5 && (t5 = n3[e4.idx]), n3[e4.idx] = _3(t5, e4);
      }), l3 ? ((t4 = p(l3(n3)))[o3] = n3, t4) : p(n3));
    }, g(e3, function(o4, a4) {
      p.fn[o4] || (p.fn[o4] = function(t4) {
        var e4 = m2(t4), i3 = "alpha" === o4 ? this._hsla ? "hsla" : "rgba" : r3, s3 = this[i3](), n3 = s3[a4.idx];
        return "undefined" === e4 ? n3 : ("function" === e4 && (e4 = m2(t4 = t4.call(this, n3))), null == t4 && a4.empty ? this : ("string" === e4 && (e4 = F.exec(t4)) && (t4 = n3 + parseFloat(e4[2]) * ("+" === e4[1] ? 1 : -1)), s3[a4.idx] = t4, this[i3](s3)));
      });
    });
  }), (p.hook = function(t3) {
    t3 = t3.split(" ");
    g(t3, function(t4, s3) {
      u.cssHooks[s3] = { set: function(t5, e3) {
        var i3;
        "transparent" === e3 || "string" === m2(e3) && !(i3 = Y2(e3)) || (e3 = (e3 = p(i3 || e3)).toRgbaString()), t5.style[s3] = e3;
      } }, u.fx.step[s3] = function(t5) {
        t5.colorInit || (t5.start = p(t5.elem, s3), t5.end = p(t5.end), t5.colorInit = true), u.cssHooks[s3].set(t5.elem, t5.start.transition(t5.end, t5.pos));
      };
    });
  })("backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor"), u.cssHooks.borderColor = { expand: function(i3) {
    var s3 = {};
    return g(["Top", "Right", "Bottom", "Left"], function(t3, e3) {
      s3["border" + e3 + "Color"] = i3;
    }), s3;
  } };
  var B, j, q, K, U, X, $, G, Q, b, y = u.Color.names = { aqua: "#00ffff", black: "#000000", blue: "#0000ff", fuchsia: "#ff00ff", gray: "#808080", green: "#008000", lime: "#00ff00", maroon: "#800000", navy: "#000080", olive: "#808000", purple: "#800080", red: "#ff0000", silver: "#c0c0c0", teal: "#008080", white: "#ffffff", yellow: "#ffff00", transparent: [null, null, null, 0], _default: "#ffffff" }, w = "ui-effects-", e2 = "ui-effects-style", T = "ui-effects-animated";
  function J(t3) {
    for (var e3, i3 = t3.ownerDocument.defaultView.getComputedStyle(t3), s3 = {}, n3 = i3.length; n3--; ) "string" == typeof i3[e3 = i3[n3]] && (s3[e3.replace(/-([\da-z])/gi, function(t4, e4) {
      return e4.toUpperCase();
    })] = i3[e3]);
    return s3;
  }
  function P(t3, e3, i3, s3) {
    return t3 = { effect: t3 = V.isPlainObject(t3) ? (e3 = t3).effect : t3 }, "function" == typeof (e3 = null == e3 ? {} : e3) && (s3 = e3, i3 = null, e3 = {}), "number" != typeof e3 && !V.fx.speeds[e3] || (s3 = i3, i3 = e3, e3 = {}), "function" == typeof i3 && (s3 = i3, i3 = null), e3 && V.extend(t3, e3), i3 = i3 || e3.duration, t3.duration = V.fx.off ? 0 : "number" == typeof i3 ? i3 : i3 in V.fx.speeds ? V.fx.speeds[i3] : V.fx.speeds._default, t3.complete = s3 || e3.complete, t3;
  }
  function M(t3) {
    return !t3 || "number" == typeof t3 || V.fx.speeds[t3] || "string" == typeof t3 && !V.effects.effect[t3] || "function" == typeof t3 || "object" == typeof t3 && !t3.effect;
  }
  function Z(t3, e3) {
    var i3 = e3.outerWidth(), e3 = e3.outerHeight(), t3 = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/.exec(t3) || ["", 0, i3, e3, 0];
    return { top: parseFloat(t3[1]) || 0, right: "auto" === t3[2] ? i3 : parseFloat(t3[2]), bottom: "auto" === t3[3] ? e3 : parseFloat(t3[3]), left: parseFloat(t3[4]) || 0 };
  }
  V.effects = { effect: {} }, K = ["add", "remove", "toggle"], U = { border: 1, borderBottom: 1, borderColor: 1, borderLeft: 1, borderRight: 1, borderTop: 1, borderWidth: 1, margin: 1, padding: 1 }, V.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function(t3, e3) {
    V.fx.step[e3] = function(t4) {
      ("none" !== t4.end && !t4.setAttr || 1 === t4.pos && !t4.setAttr) && (u.style(t4.elem, e3, t4.end), t4.setAttr = true);
    };
  }), V.effects.animateClass = function(n3, t3, e3, i3) {
    var o3 = V.speed(t3, e3, i3);
    return this.queue(function() {
      var i4 = V(this), t4 = i4.attr("class") || "", e4 = (e4 = o3.children ? i4.find("*").addBack() : i4).map(function() {
        return { el: V(this), start: J(this) };
      }), s3 = function() {
        V.each(K, function(t5, e5) {
          n3[e5] && i4[e5 + "Class"](n3[e5]);
        });
      };
      s3(), e4 = e4.map(function() {
        return this.end = J(this.el[0]), this.diff = function(t5, e5) {
          var i5, s4, n4 = {};
          for (i5 in e5) s4 = e5[i5], t5[i5] === s4 || U[i5] || !V.fx.step[i5] && isNaN(parseFloat(s4)) || (n4[i5] = s4);
          return n4;
        }(this.start, this.end), this;
      }), i4.attr("class", t4), e4 = e4.map(function() {
        var t5 = this, e5 = V.Deferred(), i5 = V.extend({}, o3, { queue: false, complete: function() {
          e5.resolve(t5);
        } });
        return this.el.animate(this.diff, i5), e5.promise();
      }), V.when.apply(V, e4.get()).done(function() {
        s3(), V.each(arguments, function() {
          var e5 = this.el;
          V.each(this.diff, function(t5) {
            e5.css(t5, "");
          });
        }), o3.complete.call(i4[0]);
      });
    });
  }, V.fn.extend({ addClass: (q = V.fn.addClass, function(t3, e3, i3, s3) {
    return e3 ? V.effects.animateClass.call(this, { add: t3 }, e3, i3, s3) : q.apply(this, arguments);
  }), removeClass: (j = V.fn.removeClass, function(t3, e3, i3, s3) {
    return 1 < arguments.length ? V.effects.animateClass.call(this, { remove: t3 }, e3, i3, s3) : j.apply(this, arguments);
  }), toggleClass: (B = V.fn.toggleClass, function(t3, e3, i3, s3, n3) {
    return "boolean" == typeof e3 || void 0 === e3 ? i3 ? V.effects.animateClass.call(this, e3 ? { add: t3 } : { remove: t3 }, i3, s3, n3) : B.apply(this, arguments) : V.effects.animateClass.call(this, { toggle: t3 }, e3, i3, s3);
  }), switchClass: function(t3, e3, i3, s3, n3) {
    return V.effects.animateClass.call(this, { add: e3, remove: t3 }, i3, s3, n3);
  } }), V.expr && V.expr.pseudos && V.expr.pseudos.animated && (V.expr.pseudos.animated = (X = V.expr.pseudos.animated, function(t3) {
    return !!V(t3).data(T) || X(t3);
  })), true === V.uiBackCompat && V.extend(V.effects, { save: function(t3, e3) {
    for (var i3 = 0, s3 = e3.length; i3 < s3; i3++) null !== e3[i3] && t3.data(w + e3[i3], t3[0].style[e3[i3]]);
  }, restore: function(t3, e3) {
    for (var i3, s3 = 0, n3 = e3.length; s3 < n3; s3++) null !== e3[s3] && (i3 = t3.data(w + e3[s3]), t3.css(e3[s3], i3));
  }, setMode: function(t3, e3) {
    return e3 = "toggle" === e3 ? t3.is(":hidden") ? "show" : "hide" : e3;
  }, createWrapper: function(i3) {
    if (i3.parent().is(".ui-effects-wrapper")) return i3.parent();
    var s3 = { width: i3.outerWidth(true), height: i3.outerHeight(true), float: i3.css("float") }, t3 = V("<div></div>").addClass("ui-effects-wrapper").css({ fontSize: "100%", background: "transparent", border: "none", margin: 0, padding: 0 }), e3 = { width: i3.width(), height: i3.height() }, n3 = document.activeElement;
    try {
      n3.id;
    } catch (t4) {
      n3 = document.body;
    }
    return i3.wrap(t3), i3[0] !== n3 && !V.contains(i3[0], n3) || V(n3).trigger("focus"), t3 = i3.parent(), "static" === i3.css("position") ? (t3.css({ position: "relative" }), i3.css({ position: "relative" })) : (V.extend(s3, { position: i3.css("position"), zIndex: i3.css("z-index") }), V.each(["top", "left", "bottom", "right"], function(t4, e4) {
      s3[e4] = i3.css(e4), isNaN(parseInt(s3[e4], 10)) && (s3[e4] = "auto");
    }), i3.css({ position: "relative", top: 0, left: 0, right: "auto", bottom: "auto" })), i3.css(e3), t3.css(s3).show();
  }, removeWrapper: function(t3) {
    var e3 = document.activeElement;
    return t3.parent().is(".ui-effects-wrapper") && (t3.parent().replaceWith(t3), t3[0] !== e3 && !V.contains(t3[0], e3) || V(e3).trigger("focus")), t3;
  } }), V.extend(V.effects, { version: "1.14.0", define: function(t3, e3, i3) {
    return i3 || (i3 = e3, e3 = "effect"), V.effects.effect[t3] = i3, V.effects.effect[t3].mode = e3, i3;
  }, scaledDimensions: function(t3, e3, i3) {
    var s3;
    return 0 === e3 ? { height: 0, width: 0, outerHeight: 0, outerWidth: 0 } : (s3 = "horizontal" !== i3 ? (e3 || 100) / 100 : 1, i3 = "vertical" !== i3 ? (e3 || 100) / 100 : 1, { height: t3.height() * i3, width: t3.width() * s3, outerHeight: t3.outerHeight() * i3, outerWidth: t3.outerWidth() * s3 });
  }, clipToBox: function(t3) {
    return { width: t3.clip.right - t3.clip.left, height: t3.clip.bottom - t3.clip.top, left: t3.clip.left, top: t3.clip.top };
  }, unshift: function(t3, e3, i3) {
    var s3 = t3.queue();
    1 < e3 && s3.splice.apply(s3, [1, 0].concat(s3.splice(e3, i3))), t3.dequeue();
  }, saveStyle: function(t3) {
    t3.data(e2, t3[0].style.cssText);
  }, restoreStyle: function(t3) {
    t3[0].style.cssText = t3.data(e2) || "", t3.removeData(e2);
  }, mode: function(t3, e3) {
    t3 = t3.is(":hidden");
    return "toggle" === e3 && (e3 = t3 ? "show" : "hide"), e3 = (t3 ? "hide" === e3 : "show" === e3) ? "none" : e3;
  }, getBaseline: function(t3, e3) {
    var i3, s3;
    switch (t3[0]) {
      case "top":
        i3 = 0;
        break;
      case "middle":
        i3 = 0.5;
        break;
      case "bottom":
        i3 = 1;
        break;
      default:
        i3 = t3[0] / e3.height;
    }
    switch (t3[1]) {
      case "left":
        s3 = 0;
        break;
      case "center":
        s3 = 0.5;
        break;
      case "right":
        s3 = 1;
        break;
      default:
        s3 = t3[1] / e3.width;
    }
    return { x: s3, y: i3 };
  }, createPlaceholder: function(t3) {
    var e3, i3 = t3.css("position"), s3 = t3.position();
    return t3.css({ marginTop: t3.css("marginTop"), marginBottom: t3.css("marginBottom"), marginLeft: t3.css("marginLeft"), marginRight: t3.css("marginRight") }).outerWidth(t3.outerWidth()).outerHeight(t3.outerHeight()), /^(static|relative)/.test(i3) && (i3 = "absolute", e3 = V("<" + t3[0].nodeName + ">").insertAfter(t3).css({ display: /^(inline|ruby)/.test(t3.css("display")) ? "inline-block" : "block", visibility: "hidden", marginTop: t3.css("marginTop"), marginBottom: t3.css("marginBottom"), marginLeft: t3.css("marginLeft"), marginRight: t3.css("marginRight"), float: t3.css("float") }).outerWidth(t3.outerWidth()).outerHeight(t3.outerHeight()).addClass("ui-effects-placeholder"), t3.data(w + "placeholder", e3)), t3.css({ position: i3, left: s3.left, top: s3.top }), e3;
  }, removePlaceholder: function(t3) {
    var e3 = w + "placeholder", i3 = t3.data(e3);
    i3 && (i3.remove(), t3.removeData(e3));
  }, cleanUp: function(t3) {
    V.effects.restoreStyle(t3), V.effects.removePlaceholder(t3);
  }, setTransition: function(s3, t3, n3, o3) {
    return o3 = o3 || {}, V.each(t3, function(t4, e3) {
      var i3 = s3.cssUnit(e3);
      0 < i3[0] && (o3[e3] = i3[0] * n3 + i3[1]);
    }), o3;
  } }), V.fn.extend({ effect: function() {
    function t3(t4) {
      var e4 = V(this), i4 = V.effects.mode(e4, r3) || o3;
      e4.data(T, true), l3.push(i4), o3 && ("show" === i4 || i4 === o3 && "hide" === i4) && e4.show(), o3 && "none" === i4 || V.effects.saveStyle(e4), "function" == typeof t4 && t4();
    }
    var s3 = P.apply(this, arguments), n3 = V.effects.effect[s3.effect], o3 = n3.mode, e3 = s3.queue, i3 = e3 || "fx", a3 = s3.complete, r3 = s3.mode, l3 = [];
    return V.fx.off || !n3 ? r3 ? this[r3](s3.duration, a3) : this.each(function() {
      a3 && a3.call(this);
    }) : false === e3 ? this.each(t3).each(h3) : this.queue(i3, t3).queue(i3, h3);
    function h3(t4) {
      var e4 = V(this);
      function i4() {
        "function" == typeof a3 && a3.call(e4[0]), "function" == typeof t4 && t4();
      }
      s3.mode = l3.shift(), true !== V.uiBackCompat || o3 ? "none" === s3.mode ? (e4[r3](), i4()) : n3.call(e4[0], s3, function() {
        e4.removeData(T), V.effects.cleanUp(e4), "hide" === s3.mode && e4.hide(), i4();
      }) : (e4.is(":hidden") ? "hide" === r3 : "show" === r3) ? (e4[r3](), i4()) : n3.call(e4[0], s3, i4);
    }
  }, show: (Q = V.fn.show, function(t3) {
    return M(t3) ? Q.apply(this, arguments) : ((t3 = P.apply(this, arguments)).mode = "show", this.effect.call(this, t3));
  }), hide: (G = V.fn.hide, function(t3) {
    return M(t3) ? G.apply(this, arguments) : ((t3 = P.apply(this, arguments)).mode = "hide", this.effect.call(this, t3));
  }), toggle: ($ = V.fn.toggle, function(t3) {
    return M(t3) || "boolean" == typeof t3 ? $.apply(this, arguments) : ((t3 = P.apply(this, arguments)).mode = "toggle", this.effect.call(this, t3));
  }), cssUnit: function(t3) {
    var i3 = this.css(t3), s3 = [];
    return V.each(["em", "px", "%", "pt"], function(t4, e3) {
      0 < i3.indexOf(e3) && (s3 = [parseFloat(i3), e3]);
    }), s3;
  }, cssClip: function(t3) {
    return t3 ? this.css("clip", "rect(" + t3.top + "px " + t3.right + "px " + t3.bottom + "px " + t3.left + "px)") : Z(this.css("clip"), this);
  }, transfer: function(t3, e3) {
    var i3 = V(this), s3 = V(t3.to), n3 = "fixed" === s3.css("position"), o3 = V("body"), a3 = n3 ? o3.scrollTop() : 0, o3 = n3 ? o3.scrollLeft() : 0, r3 = s3.offset(), r3 = { top: r3.top - a3, left: r3.left - o3, height: s3.innerHeight(), width: s3.innerWidth() }, s3 = i3.offset(), l3 = V("<div class='ui-effects-transfer'></div>");
    l3.appendTo("body").addClass(t3.className).css({ top: s3.top - a3, left: s3.left - o3, height: i3.innerHeight(), width: i3.innerWidth(), position: n3 ? "fixed" : "absolute" }).animate(r3, t3.duration, t3.easing, function() {
      l3.remove(), "function" == typeof e3 && e3();
    });
  } }), V.fx.step.clip = function(t3) {
    t3.clipInit || (t3.start = V(t3.elem).cssClip(), "string" == typeof t3.end && (t3.end = Z(t3.end, t3.elem)), t3.clipInit = true), V(t3.elem).cssClip({ top: t3.pos * (t3.end.top - t3.start.top) + t3.start.top, right: t3.pos * (t3.end.right - t3.start.right) + t3.start.right, bottom: t3.pos * (t3.end.bottom - t3.start.bottom) + t3.start.bottom, left: t3.pos * (t3.end.left - t3.start.left) + t3.start.left });
  }, b = {}, V.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function(e3, t3) {
    b[t3] = function(t4) {
      return Math.pow(t4, e3 + 2);
    };
  }), V.extend(b, { Sine: function(t3) {
    return 1 - Math.cos(t3 * Math.PI / 2);
  }, Circ: function(t3) {
    return 1 - Math.sqrt(1 - t3 * t3);
  }, Elastic: function(t3) {
    return 0 === t3 || 1 === t3 ? t3 : -Math.pow(2, 8 * (t3 - 1)) * Math.sin((80 * (t3 - 1) - 7.5) * Math.PI / 15);
  }, Back: function(t3) {
    return t3 * t3 * (3 * t3 - 2);
  }, Bounce: function(t3) {
    for (var e3, i3 = 4; t3 < ((e3 = Math.pow(2, --i3)) - 1) / 11; ) ;
    return 1 / Math.pow(4, 3 - i3) - 7.5625 * Math.pow((3 * e3 - 2) / 22 - t3, 2);
  } }), V.each(b, function(t3, e3) {
    V.easing["easeIn" + t3] = e3, V.easing["easeOut" + t3] = function(t4) {
      return 1 - e3(1 - t4);
    }, V.easing["easeInOut" + t3] = function(t4) {
      return t4 < 0.5 ? e3(2 * t4) / 2 : 1 - e3(-2 * t4 + 2) / 2;
    };
  });
  var tt, et, S, it = V.effects, st = (V.effects.define("blind", "hide", function(t3, e3) {
    var i3 = { up: ["bottom", "top"], vertical: ["bottom", "top"], down: ["top", "bottom"], left: ["right", "left"], horizontal: ["right", "left"], right: ["left", "right"] }, s3 = V(this), n3 = t3.direction || "up", o3 = s3.cssClip(), a3 = { clip: V.extend({}, o3) }, r3 = V.effects.createPlaceholder(s3);
    a3.clip[i3[n3][0]] = a3.clip[i3[n3][1]], "show" === t3.mode && (s3.cssClip(a3.clip), r3 && r3.css(V.effects.clipToBox(a3)), a3.clip = o3), r3 && r3.animate(V.effects.clipToBox(a3), t3.duration, t3.easing), s3.animate(a3, { queue: false, duration: t3.duration, easing: t3.easing, complete: e3 });
  }), V.effects.define("bounce", function(t3, e3) {
    var i3, s3, n3 = V(this), o3 = t3.mode, a3 = "hide" === o3, o3 = "show" === o3, r3 = t3.direction || "up", l3 = t3.distance, h3 = t3.times || 5, c3 = 2 * h3 + (o3 || a3 ? 1 : 0), u2 = t3.duration / c3, d3 = t3.easing, p2 = "up" === r3 || "down" === r3 ? "top" : "left", f3 = "up" === r3 || "left" === r3, g2 = 0, t3 = n3.queue().length;
    for (V.effects.createPlaceholder(n3), r3 = n3.css(p2), l3 = l3 || n3["top" == p2 ? "outerHeight" : "outerWidth"]() / 3, o3 && ((s3 = { opacity: 1 })[p2] = r3, n3.css("opacity", 0).css(p2, f3 ? 2 * -l3 : 2 * l3).animate(s3, u2, d3)), a3 && (l3 /= Math.pow(2, h3 - 1)), (s3 = {})[p2] = r3; g2 < h3; g2++) (i3 = {})[p2] = (f3 ? "-=" : "+=") + l3, n3.animate(i3, u2, d3).animate(s3, u2, d3), l3 = a3 ? 2 * l3 : l3 / 2;
    a3 && ((i3 = { opacity: 0 })[p2] = (f3 ? "-=" : "+=") + l3, n3.animate(i3, u2, d3)), n3.queue(e3), V.effects.unshift(n3, t3, 1 + c3);
  }), V.effects.define("clip", "hide", function(t3, e3) {
    var i3 = {}, s3 = V(this), n3 = t3.direction || "vertical", o3 = "both" === n3, a3 = o3 || "horizontal" === n3, o3 = o3 || "vertical" === n3, n3 = s3.cssClip();
    i3.clip = { top: o3 ? (n3.bottom - n3.top) / 2 : n3.top, right: a3 ? (n3.right - n3.left) / 2 : n3.right, bottom: o3 ? (n3.bottom - n3.top) / 2 : n3.bottom, left: a3 ? (n3.right - n3.left) / 2 : n3.left }, V.effects.createPlaceholder(s3), "show" === t3.mode && (s3.cssClip(i3.clip), i3.clip = n3), s3.animate(i3, { queue: false, duration: t3.duration, easing: t3.easing, complete: e3 });
  }), V.effects.define("drop", "hide", function(t3, e3) {
    var i3, s3 = V(this), n3 = "show" === t3.mode, o3 = t3.direction || "left", a3 = "up" === o3 || "down" === o3 ? "top" : "left", o3 = "up" === o3 || "left" === o3 ? "-=" : "+=", r3 = "+=" == o3 ? "-=" : "+=", l3 = { opacity: 0 };
    V.effects.createPlaceholder(s3), i3 = t3.distance || s3["top" == a3 ? "outerHeight" : "outerWidth"](true) / 2, l3[a3] = o3 + i3, n3 && (s3.css(l3), l3[a3] = r3 + i3, l3.opacity = 1), s3.animate(l3, { queue: false, duration: t3.duration, easing: t3.easing, complete: e3 });
  }), V.effects.define("explode", "hide", function(t3, e3) {
    var i3, s3, n3, o3, a3, r3, l3 = t3.pieces ? Math.round(Math.sqrt(t3.pieces)) : 3, h3 = l3, c3 = V(this), u2 = "show" === t3.mode, d3 = c3.show().css("visibility", "hidden").offset(), p2 = Math.ceil(c3.outerWidth() / h3), f3 = Math.ceil(c3.outerHeight() / l3), g2 = [];
    function m3() {
      g2.push(this), g2.length === l3 * h3 && (c3.css({ visibility: "visible" }), V(g2).remove(), e3());
    }
    for (i3 = 0; i3 < l3; i3++) for (o3 = d3.top + i3 * f3, r3 = i3 - (l3 - 1) / 2, s3 = 0; s3 < h3; s3++) n3 = d3.left + s3 * p2, a3 = s3 - (h3 - 1) / 2, c3.clone().appendTo("body").wrap("<div></div>").css({ position: "absolute", visibility: "visible", left: -s3 * p2, top: -i3 * f3 }).parent().addClass("ui-effects-explode").css({ position: "absolute", overflow: "hidden", width: p2, height: f3, left: n3 + (u2 ? a3 * p2 : 0), top: o3 + (u2 ? r3 * f3 : 0), opacity: u2 ? 0 : 1 }).animate({ left: n3 + (u2 ? 0 : a3 * p2), top: o3 + (u2 ? 0 : r3 * f3), opacity: u2 ? 1 : 0 }, t3.duration || 500, t3.easing, m3);
  }), V.effects.define("fade", "toggle", function(t3, e3) {
    var i3 = "show" === t3.mode;
    V(this).css("opacity", i3 ? 0 : 1).animate({ opacity: i3 ? 1 : 0 }, { queue: false, duration: t3.duration, easing: t3.easing, complete: e3 });
  }), V.effects.define("fold", "hide", function(e3, t3) {
    var i3 = V(this), s3 = e3.mode, n3 = "show" === s3, s3 = "hide" === s3, o3 = e3.size || 15, a3 = /([0-9]+)%/.exec(o3), r3 = !!e3.horizFirst ? ["right", "bottom"] : ["bottom", "right"], l3 = e3.duration / 2, h3 = V.effects.createPlaceholder(i3), c3 = i3.cssClip(), u2 = { clip: V.extend({}, c3) }, d3 = { clip: V.extend({}, c3) }, p2 = [c3[r3[0]], c3[r3[1]]], f3 = i3.queue().length;
    a3 && (o3 = parseInt(a3[1], 10) / 100 * p2[s3 ? 0 : 1]), u2.clip[r3[0]] = o3, d3.clip[r3[0]] = o3, d3.clip[r3[1]] = 0, n3 && (i3.cssClip(d3.clip), h3 && h3.css(V.effects.clipToBox(d3)), d3.clip = c3), i3.queue(function(t4) {
      h3 && h3.animate(V.effects.clipToBox(u2), l3, e3.easing).animate(V.effects.clipToBox(d3), l3, e3.easing), t4();
    }).animate(u2, l3, e3.easing).animate(d3, l3, e3.easing).queue(t3), V.effects.unshift(i3, f3, 4);
  }), V.effects.define("highlight", "show", function(t3, e3) {
    var i3 = V(this), s3 = { backgroundColor: i3.css("backgroundColor") };
    "hide" === t3.mode && (s3.opacity = 0), V.effects.saveStyle(i3), i3.css({ backgroundImage: "none", backgroundColor: t3.color || "#ffff99" }).animate(s3, { queue: false, duration: t3.duration, easing: t3.easing, complete: e3 });
  }), V.effects.define("size", function(s3, e3) {
    var n3, i3 = V(this), t3 = ["fontSize"], o3 = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"], a3 = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"], r3 = s3.mode, l3 = "effect" !== r3, h3 = s3.scale || "both", c3 = s3.origin || ["middle", "center"], u2 = i3.css("position"), d3 = i3.position(), p2 = V.effects.scaledDimensions(i3), f3 = s3.from || p2, g2 = s3.to || V.effects.scaledDimensions(i3, 0);
    V.effects.createPlaceholder(i3), "show" === r3 && (r3 = f3, f3 = g2, g2 = r3), n3 = { from: { y: f3.height / p2.height, x: f3.width / p2.width }, to: { y: g2.height / p2.height, x: g2.width / p2.width } }, "box" !== h3 && "both" !== h3 || (n3.from.y !== n3.to.y && (f3 = V.effects.setTransition(i3, o3, n3.from.y, f3), g2 = V.effects.setTransition(i3, o3, n3.to.y, g2)), n3.from.x !== n3.to.x && (f3 = V.effects.setTransition(i3, a3, n3.from.x, f3), g2 = V.effects.setTransition(i3, a3, n3.to.x, g2))), "content" !== h3 && "both" !== h3 || n3.from.y !== n3.to.y && (f3 = V.effects.setTransition(i3, t3, n3.from.y, f3), g2 = V.effects.setTransition(i3, t3, n3.to.y, g2)), c3 && (r3 = V.effects.getBaseline(c3, p2), f3.top = (p2.outerHeight - f3.outerHeight) * r3.y + d3.top, f3.left = (p2.outerWidth - f3.outerWidth) * r3.x + d3.left, g2.top = (p2.outerHeight - g2.outerHeight) * r3.y + d3.top, g2.left = (p2.outerWidth - g2.outerWidth) * r3.x + d3.left), delete f3.outerHeight, delete f3.outerWidth, i3.css(f3), "content" !== h3 && "both" !== h3 || (o3 = o3.concat(["marginTop", "marginBottom"]).concat(t3), a3 = a3.concat(["marginLeft", "marginRight"]), i3.find("*[width]").each(function() {
      var t4 = V(this), e4 = V.effects.scaledDimensions(t4), i4 = { height: e4.height * n3.from.y, width: e4.width * n3.from.x, outerHeight: e4.outerHeight * n3.from.y, outerWidth: e4.outerWidth * n3.from.x }, e4 = { height: e4.height * n3.to.y, width: e4.width * n3.to.x, outerHeight: e4.height * n3.to.y, outerWidth: e4.width * n3.to.x };
      n3.from.y !== n3.to.y && (i4 = V.effects.setTransition(t4, o3, n3.from.y, i4), e4 = V.effects.setTransition(t4, o3, n3.to.y, e4)), n3.from.x !== n3.to.x && (i4 = V.effects.setTransition(t4, a3, n3.from.x, i4), e4 = V.effects.setTransition(t4, a3, n3.to.x, e4)), l3 && V.effects.saveStyle(t4), t4.css(i4), t4.animate(e4, s3.duration, s3.easing, function() {
        l3 && V.effects.restoreStyle(t4);
      });
    })), i3.animate(g2, { queue: false, duration: s3.duration, easing: s3.easing, complete: function() {
      var t4 = i3.offset();
      0 === g2.opacity && i3.css("opacity", f3.opacity), l3 || (i3.css("position", "static" === u2 ? "relative" : u2).offset(t4), V.effects.saveStyle(i3)), e3();
    } });
  }), V.effects.define("scale", function(t3, e3) {
    var i3 = V(this), s3 = t3.mode, s3 = parseInt(t3.percent, 10) || (0 === parseInt(t3.percent, 10) || "effect" !== s3 ? 0 : 100), i3 = V.extend(true, { from: V.effects.scaledDimensions(i3), to: V.effects.scaledDimensions(i3, s3, t3.direction || "both"), origin: t3.origin || ["middle", "center"] }, t3);
    t3.fade && (i3.from.opacity = 1, i3.to.opacity = 0), V.effects.effect.size.call(this, i3, e3);
  }), V.effects.define("puff", "hide", function(t3, e3) {
    t3 = V.extend(true, {}, t3, { fade: true, percent: parseInt(t3.percent, 10) || 150 });
    V.effects.effect.scale.call(this, t3, e3);
  }), V.effects.define("pulsate", "show", function(t3, e3) {
    var i3 = V(this), s3 = t3.mode, n3 = "show" === s3, o3 = 2 * (t3.times || 5) + (n3 || "hide" === s3 ? 1 : 0), a3 = t3.duration / o3, r3 = 0, l3 = 1, s3 = i3.queue().length;
    for (!n3 && i3.is(":visible") || (i3.css("opacity", 0).show(), r3 = 1); l3 < o3; l3++) i3.animate({ opacity: r3 }, a3, t3.easing), r3 = 1 - r3;
    i3.animate({ opacity: r3 }, a3, t3.easing), i3.queue(e3), V.effects.unshift(i3, s3, 1 + o3);
  }), V.effects.define("shake", function(t3, e3) {
    var i3 = 1, s3 = V(this), n3 = t3.direction || "left", o3 = t3.distance || 20, a3 = t3.times || 3, r3 = 2 * a3 + 1, l3 = Math.round(t3.duration / r3), h3 = "up" === n3 || "down" === n3 ? "top" : "left", n3 = "up" === n3 || "left" === n3, c3 = {}, u2 = {}, d3 = {}, p2 = s3.queue().length;
    for (V.effects.createPlaceholder(s3), c3[h3] = (n3 ? "-=" : "+=") + o3, u2[h3] = (n3 ? "+=" : "-=") + 2 * o3, d3[h3] = (n3 ? "-=" : "+=") + 2 * o3, s3.animate(c3, l3, t3.easing); i3 < a3; i3++) s3.animate(u2, l3, t3.easing).animate(d3, l3, t3.easing);
    s3.animate(u2, l3, t3.easing).animate(c3, l3 / 2, t3.easing).queue(e3), V.effects.unshift(s3, p2, 1 + r3);
  }), V.effects.define("slide", "show", function(t3, e3) {
    var i3, s3, n3 = V(this), o3 = { up: ["bottom", "top"], down: ["top", "bottom"], left: ["right", "left"], right: ["left", "right"] }, a3 = t3.mode, r3 = t3.direction || "left", l3 = "up" === r3 || "down" === r3 ? "top" : "left", h3 = "up" === r3 || "left" === r3, c3 = t3.distance || n3["top" == l3 ? "outerHeight" : "outerWidth"](true), u2 = {};
    V.effects.createPlaceholder(n3), i3 = n3.cssClip(), s3 = n3.position()[l3], u2[l3] = (h3 ? -1 : 1) * c3 + s3, u2.clip = n3.cssClip(), u2.clip[o3[r3][1]] = u2.clip[o3[r3][0]], "show" === a3 && (n3.cssClip(u2.clip), n3.css(l3, u2[l3]), u2.clip = i3, u2[l3] = s3), n3.animate(u2, { queue: false, duration: t3.duration, easing: t3.easing, complete: e3 });
  }), it = true === V.uiBackCompat ? V.effects.define("transfer", function(t3, e3) {
    V(this).transfer(t3, e3);
  }) : it, V.ui.focusable = function(t3, e3) {
    var i3, s3, n3, o3 = t3.nodeName.toLowerCase();
    return "area" === o3 ? (n3 = (i3 = t3.parentNode).name, !(!t3.href || !n3 || "map" !== i3.nodeName.toLowerCase()) && 0 < (i3 = V("img[usemap='#" + n3 + "']")).length && i3.is(":visible")) : (/^(input|select|textarea|button|object)$/.test(o3) ? (s3 = !t3.disabled) && (n3 = V(t3).closest("fieldset")[0]) && (s3 = !n3.disabled) : s3 = "a" === o3 && t3.href || e3, s3 && V(t3).is(":visible") && "visible" === V(t3).css("visibility"));
  }, V.extend(V.expr.pseudos, { focusable: function(t3) {
    return V.ui.focusable(t3, null != V.attr(t3, "tabindex"));
  } }), V.ui.focusable, V.ui.formResetMixin = { _formResetHandler: function() {
    var e3 = V(this);
    setTimeout(function() {
      var t3 = e3.data("ui-form-reset-instances");
      V.each(t3, function() {
        this.refresh();
      });
    });
  }, _bindFormResetHandler: function() {
    var t3;
    this.form = V(this.element.prop("form")), this.form.length && ((t3 = this.form.data("ui-form-reset-instances") || []).length || this.form.on("reset.ui-form-reset", this._formResetHandler), t3.push(this), this.form.data("ui-form-reset-instances", t3));
  }, _unbindFormResetHandler: function() {
    var t3;
    this.form.length && ((t3 = this.form.data("ui-form-reset-instances")).splice(V.inArray(this, t3), 1), t3.length ? this.form.data("ui-form-reset-instances", t3) : this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"));
  } }, V.escapeSelector || (V.escapeSelector = function(t3) {
    return CSS.escape(t3 + "");
  }), V.fn.even && V.fn.odd || V.fn.extend({ even: function() {
    return this.filter(function(t3) {
      return t3 % 2 == 0;
    });
  }, odd: function() {
    return this.filter(function(t3) {
      return t3 % 2 == 1;
    });
  } }), V.ui.keyCode = { BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38 }, V.fn.labels = function() {
    var t3, e3, i3;
    return this.length ? this[0].labels && this[0].labels.length ? this.pushStack(this[0].labels) : (e3 = this.eq(0).parents("label"), (t3 = this.attr("id")) && (i3 = (i3 = this.eq(0).parents().last()).add((i3.length ? i3 : this).siblings()), t3 = "label[for='" + CSS.escape(t3) + "']", e3 = e3.add(i3.find(t3).addBack(t3))), this.pushStack(e3)) : this.pushStack([]);
  }, V.fn.scrollParent = function(t3) {
    var e3 = this.css("position"), i3 = "absolute" === e3, s3 = t3 ? /(auto|scroll|hidden)/ : /(auto|scroll)/, t3 = this.parents().filter(function() {
      var t4 = V(this);
      return (!i3 || "static" !== t4.css("position")) && s3.test(t4.css("overflow") + t4.css("overflow-y") + t4.css("overflow-x"));
    }).eq(0);
    return "fixed" !== e3 && t3.length ? t3 : V(this[0].ownerDocument || document);
  }, V.extend(V.expr.pseudos, { tabbable: function(t3) {
    var e3 = V.attr(t3, "tabindex"), i3 = null != e3;
    return (!i3 || 0 <= e3) && V.ui.focusable(t3, i3);
  } }), V.fn.extend({ uniqueId: (tt = 0, function() {
    return this.each(function() {
      this.id || (this.id = "ui-id-" + ++tt);
    });
  }), removeUniqueId: function() {
    return this.each(function() {
      /^ui-id-\d+$/.test(this.id) && V(this).removeAttr("id");
    });
  } }), V.widget("ui.accordion", { version: "1.14.0", options: { active: 0, animate: {}, classes: { "ui-accordion-header": "ui-corner-top", "ui-accordion-header-collapsed": "ui-corner-all", "ui-accordion-content": "ui-corner-bottom" }, collapsible: false, event: "click", header: function(t3) {
    return t3.find("> li > :first-child").add(t3.find("> :not(li)").filter(function(t4) {
      return t4 % 2 == 0;
    }));
  }, heightStyle: "auto", icons: { activeHeader: "ui-icon-triangle-1-s", header: "ui-icon-triangle-1-e" }, activate: null, beforeActivate: null }, hideProps: { borderTopWidth: "hide", borderBottomWidth: "hide", paddingTop: "hide", paddingBottom: "hide", height: "hide" }, showProps: { borderTopWidth: "show", borderBottomWidth: "show", paddingTop: "show", paddingBottom: "show", height: "show" }, _create: function() {
    var t3 = this.options;
    this.prevShow = this.prevHide = V(), this._addClass("ui-accordion", "ui-widget ui-helper-reset"), this.element.attr("role", "tablist"), t3.collapsible || false !== t3.active && null != t3.active || (t3.active = 0), this._processPanels(), t3.active < 0 && (t3.active += this.headers.length), this._refresh();
  }, _getCreateEventData: function() {
    return { header: this.active, panel: this.active.length ? this.active.next() : V() };
  }, _createIcons: function() {
    var t3, e3 = this.options.icons;
    e3 && (t3 = V("<span>"), this._addClass(t3, "ui-accordion-header-icon", "ui-icon " + e3.header), t3.prependTo(this.headers), t3 = this.active.children(".ui-accordion-header-icon"), this._removeClass(t3, e3.header)._addClass(t3, null, e3.activeHeader)._addClass(this.headers, "ui-accordion-icons"));
  }, _destroyIcons: function() {
    this._removeClass(this.headers, "ui-accordion-icons"), this.headers.children(".ui-accordion-header-icon").remove();
  }, _destroy: function() {
    var t3;
    this.element.removeAttr("role"), this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(), this._destroyIcons(), t3 = this.headers.next().css("display", "").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(), "content" !== this.options.heightStyle && t3.css("height", "");
  }, _setOption: function(t3, e3) {
    "active" === t3 ? this._activate(e3) : ("event" === t3 && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(e3)), this._super(t3, e3), "collapsible" !== t3 || e3 || false !== this.options.active || this._activate(0), "icons" === t3 && (this._destroyIcons(), e3) && this._createIcons());
  }, _setOptionDisabled: function(t3) {
    this._super(t3), this.element.attr("aria-disabled", t3), this._toggleClass(null, "ui-state-disabled", !!t3);
  }, _keydown: function(t3) {
    if (!t3.altKey && !t3.ctrlKey) {
      var e3 = V.ui.keyCode, i3 = this.headers.length, s3 = this.headers.index(t3.target), n3 = false;
      switch (t3.keyCode) {
        case e3.RIGHT:
        case e3.DOWN:
          n3 = this.headers[(s3 + 1) % i3];
          break;
        case e3.LEFT:
        case e3.UP:
          n3 = this.headers[(s3 - 1 + i3) % i3];
          break;
        case e3.SPACE:
        case e3.ENTER:
          this._eventHandler(t3);
          break;
        case e3.HOME:
          n3 = this.headers[0];
          break;
        case e3.END:
          n3 = this.headers[i3 - 1];
      }
      n3 && (V(t3.target).attr("tabIndex", -1), V(n3).attr("tabIndex", 0), V(n3).trigger("focus"), t3.preventDefault());
    }
  }, _panelKeyDown: function(t3) {
    t3.keyCode === V.ui.keyCode.UP && t3.ctrlKey && V(t3.currentTarget).prev().trigger("focus");
  }, refresh: function() {
    var t3 = this.options;
    this._processPanels(), false === t3.active && true === t3.collapsible || !this.headers.length ? (t3.active = false, this.active = V()) : false === t3.active ? this._activate(0) : this.active.length && !V.contains(this.element[0], this.active[0]) ? this.headers.length === this.headers.find(".ui-state-disabled").length ? (t3.active = false, this.active = V()) : this._activate(Math.max(0, t3.active - 1)) : t3.active = this.headers.index(this.active), this._destroyIcons(), this._refresh();
  }, _processPanels: function() {
    var t3 = this.headers, e3 = this.panels;
    "function" == typeof this.options.header ? this.headers = this.options.header(this.element) : this.headers = this.element.find(this.options.header), this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed", "ui-state-default"), this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide(), this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content"), e3 && (this._off(t3.not(this.headers)), this._off(e3.not(this.panels)));
  }, _refresh: function() {
    var i3, t3 = this.options, e3 = t3.heightStyle, s3 = this.element.parent();
    this.active = this._findActive(t3.active), this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")._removeClass(this.active, "ui-accordion-header-collapsed"), this._addClass(this.active.next(), "ui-accordion-content-active"), this.active.next().show(), this.headers.attr("role", "tab").each(function() {
      var t4 = V(this), e4 = t4.uniqueId().attr("id"), i4 = t4.next(), s4 = i4.uniqueId().attr("id");
      t4.attr("aria-controls", s4), i4.attr("aria-labelledby", e4);
    }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({ "aria-selected": "false", "aria-expanded": "false", tabIndex: -1 }).next().attr({ "aria-hidden": "true" }).hide(), this.active.length ? this.active.attr({ "aria-selected": "true", "aria-expanded": "true", tabIndex: 0 }).next().attr({ "aria-hidden": "false" }) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(t3.event), "fill" === e3 ? (i3 = s3.height(), this.element.siblings(":visible").each(function() {
      var t4 = V(this), e4 = t4.css("position");
      "absolute" !== e4 && "fixed" !== e4 && (i3 -= t4.outerHeight(true));
    }), this.headers.each(function() {
      i3 -= V(this).outerHeight(true);
    }), this.headers.next().each(function() {
      V(this).height(Math.max(0, i3 - V(this).innerHeight() + V(this).height()));
    }).css("overflow", "auto")) : "auto" === e3 && (i3 = 0, this.headers.next().each(function() {
      var t4 = V(this).is(":visible");
      t4 || V(this).show(), i3 = Math.max(i3, V(this).css("height", "").height()), t4 || V(this).hide();
    }).height(i3));
  }, _activate: function(t3) {
    t3 = this._findActive(t3)[0];
    t3 !== this.active[0] && (t3 = t3 || this.active[0], this._eventHandler({ target: t3, currentTarget: t3, preventDefault: V.noop }));
  }, _findActive: function(t3) {
    return "number" == typeof t3 ? this.headers.eq(t3) : V();
  }, _setupEvents: function(t3) {
    var i3 = { keydown: "_keydown" };
    t3 && V.each(t3.split(" "), function(t4, e3) {
      i3[e3] = "_eventHandler";
    }), this._off(this.headers.add(this.headers.next())), this._on(this.headers, i3), this._on(this.headers.next(), { keydown: "_panelKeyDown" }), this._hoverable(this.headers), this._focusable(this.headers);
  }, _eventHandler: function(t3) {
    var e3 = this.options, i3 = this.active, s3 = V(t3.currentTarget), n3 = s3[0] === i3[0], o3 = n3 && e3.collapsible, a3 = o3 ? V() : s3.next(), r3 = i3.next(), r3 = { oldHeader: i3, oldPanel: r3, newHeader: o3 ? V() : s3, newPanel: a3 };
    t3.preventDefault(), n3 && !e3.collapsible || false === this._trigger("beforeActivate", t3, r3) || (e3.active = !o3 && this.headers.index(s3), this.active = n3 ? V() : s3, this._toggle(r3), this._removeClass(i3, "ui-accordion-header-active", "ui-state-active"), e3.icons && (a3 = i3.children(".ui-accordion-header-icon"), this._removeClass(a3, null, e3.icons.activeHeader)._addClass(a3, null, e3.icons.header)), n3) || (this._removeClass(s3, "ui-accordion-header-collapsed")._addClass(s3, "ui-accordion-header-active", "ui-state-active"), e3.icons && (t3 = s3.children(".ui-accordion-header-icon"), this._removeClass(t3, null, e3.icons.header)._addClass(t3, null, e3.icons.activeHeader)), this._addClass(s3.next(), "ui-accordion-content-active"));
  }, _toggle: function(t3) {
    var e3 = t3.newPanel, i3 = this.prevShow.length ? this.prevShow : t3.oldPanel;
    this.prevShow.add(this.prevHide).stop(true, true), this.prevShow = e3, this.prevHide = i3, this.options.animate ? this._animate(e3, i3, t3) : (i3.hide(), e3.show(), this._toggleComplete(t3)), i3.attr({ "aria-hidden": "true" }), i3.prev().attr({ "aria-selected": "false", "aria-expanded": "false" }), e3.length && i3.length ? i3.prev().attr({ tabIndex: -1, "aria-expanded": "false" }) : e3.length && this.headers.filter(function() {
      return 0 === parseInt(V(this).attr("tabIndex"), 10);
    }).attr("tabIndex", -1), e3.attr("aria-hidden", "false").prev().attr({ "aria-selected": "true", "aria-expanded": "true", tabIndex: 0 });
  }, _animate: function(t3, i3, e3) {
    function s3() {
      o3._toggleComplete(e3);
    }
    var n3, o3 = this, a3 = 0, r3 = t3.css("box-sizing"), l3 = t3.length && (!i3.length || t3.index() < i3.index()), h3 = this.options.animate || {}, l3 = l3 && h3.down || h3, c3 = (c3 = "string" == typeof l3 ? l3 : c3) || l3.easing || h3.easing, u2 = (u2 = "number" == typeof l3 ? l3 : u2) || l3.duration || h3.duration;
    return i3.length ? t3.length ? (n3 = t3.show().outerHeight(), i3.animate(this.hideProps, { duration: u2, easing: c3, step: function(t4, e4) {
      e4.now = Math.round(t4);
    } }), void t3.hide().animate(this.showProps, { duration: u2, easing: c3, complete: s3, step: function(t4, e4) {
      e4.now = Math.round(t4), "height" !== e4.prop ? "content-box" === r3 && (a3 += e4.now) : "content" !== o3.options.heightStyle && (e4.now = Math.round(n3 - i3.outerHeight() - a3), a3 = 0);
    } })) : i3.animate(this.hideProps, u2, c3, s3) : t3.animate(this.showProps, u2, c3, s3);
  }, _toggleComplete: function(t3) {
    var e3 = t3.oldPanel, i3 = e3.prev();
    this._removeClass(e3, "ui-accordion-content-active"), this._removeClass(i3, "ui-accordion-header-active")._addClass(i3, "ui-accordion-header-collapsed"), this._trigger("activate", null, t3);
  } }), V.widget("ui.menu", { version: "1.14.0", defaultElement: "<ul>", delay: 300, options: { icons: { submenu: "ui-icon-caret-1-e" }, items: "> *", menus: "ul", position: { my: "left top", at: "right top" }, role: "menu", blur: null, focus: null, select: null }, _create: function() {
    this.activeMenu = this.element, this.mouseHandled = false, this.lastMousePosition = { x: null, y: null }, this.element.uniqueId().attr({ role: this.options.role, tabIndex: 0 }), this._addClass("ui-menu", "ui-widget ui-widget-content"), this._on({ "mousedown .ui-menu-item": function(t3) {
      t3.preventDefault(), this._activateItem(t3);
    }, "click .ui-menu-item": function(t3) {
      var e3 = V(t3.target), i3 = V(this.document[0].activeElement);
      !this.mouseHandled && e3.not(".ui-state-disabled").length && (this.select(t3), t3.isPropagationStopped() || (this.mouseHandled = true), e3.has(".ui-menu").length ? this.expand(t3) : !this.element.is(":focus") && i3.closest(".ui-menu").length && (this.element.trigger("focus", [true]), this.active) && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer));
    }, "mouseenter .ui-menu-item": "_activateItem", "mousemove .ui-menu-item": "_activateItem", mouseleave: "collapseAll", "mouseleave .ui-menu": "collapseAll", focus: function(t3, e3) {
      var i3 = this.active || this._menuItems().first();
      e3 || this.focus(t3, i3);
    }, blur: function(t3) {
      this._delay(function() {
        V.contains(this.element[0], this.document[0].activeElement) || this.collapseAll(t3);
      });
    }, keydown: "_keydown" }), this.refresh(), this._on(this.document, { click: function(t3) {
      this._closeOnDocumentClick(t3) && this.collapseAll(t3, true), this.mouseHandled = false;
    } });
  }, _activateItem: function(t3) {
    var e3, i3;
    this.previousFilter || t3.clientX === this.lastMousePosition.x && t3.clientY === this.lastMousePosition.y || (this.lastMousePosition = { x: t3.clientX, y: t3.clientY }, e3 = V(t3.target).closest(".ui-menu-item"), i3 = V(t3.currentTarget), e3[0] !== i3[0]) || i3.is(".ui-state-active") || (this._removeClass(i3.siblings().children(".ui-state-active"), null, "ui-state-active"), this.focus(t3, i3));
  }, _destroy: function() {
    var t3 = this.element.find(".ui-menu-item").removeAttr("role aria-disabled").children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
    this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(), t3.children().each(function() {
      var t4 = V(this);
      t4.data("ui-menu-submenu-caret") && t4.remove();
    });
  }, _keydown: function(t3) {
    var e3, i3, s3, n3 = true;
    switch (t3.keyCode) {
      case V.ui.keyCode.PAGE_UP:
        this.previousPage(t3);
        break;
      case V.ui.keyCode.PAGE_DOWN:
        this.nextPage(t3);
        break;
      case V.ui.keyCode.HOME:
        this._move("first", "first", t3);
        break;
      case V.ui.keyCode.END:
        this._move("last", "last", t3);
        break;
      case V.ui.keyCode.UP:
        this.previous(t3);
        break;
      case V.ui.keyCode.DOWN:
        this.next(t3);
        break;
      case V.ui.keyCode.LEFT:
        this.collapse(t3);
        break;
      case V.ui.keyCode.RIGHT:
        this.active && !this.active.is(".ui-state-disabled") && this.expand(t3);
        break;
      case V.ui.keyCode.ENTER:
      case V.ui.keyCode.SPACE:
        this._activate(t3);
        break;
      case V.ui.keyCode.ESCAPE:
        this.collapse(t3);
        break;
      default:
        e3 = this.previousFilter || "", s3 = n3 = false, i3 = 96 <= t3.keyCode && t3.keyCode <= 105 ? (t3.keyCode - 96).toString() : String.fromCharCode(t3.keyCode), clearTimeout(this.filterTimer), i3 === e3 ? s3 = true : i3 = e3 + i3, e3 = this._filterMenuItems(i3), (e3 = s3 && -1 !== e3.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : e3).length || (i3 = String.fromCharCode(t3.keyCode), e3 = this._filterMenuItems(i3)), e3.length ? (this.focus(t3, e3), this.previousFilter = i3, this.filterTimer = this._delay(function() {
          delete this.previousFilter;
        }, 1e3)) : delete this.previousFilter;
    }
    n3 && t3.preventDefault();
  }, _activate: function(t3) {
    this.active && !this.active.is(".ui-state-disabled") && (this.active.children("[aria-haspopup='true']").length ? this.expand(t3) : this.select(t3));
  }, refresh: function() {
    var t3, e3, s3 = this, n3 = this.options.icons.submenu, i3 = this.element.find(this.options.menus);
    this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length), t3 = i3.filter(":not(.ui-menu)").hide().attr({ role: this.options.role, "aria-hidden": "true", "aria-expanded": "false" }).each(function() {
      var t4 = V(this), e4 = t4.prev(), i4 = V("<span>").data("ui-menu-submenu-caret", true);
      s3._addClass(i4, "ui-menu-icon", "ui-icon " + n3), e4.attr("aria-haspopup", "true").prepend(i4), t4.attr("aria-labelledby", e4.attr("id"));
    }), this._addClass(t3, "ui-menu", "ui-widget ui-widget-content ui-front"), (t3 = i3.add(this.element).find(this.options.items)).not(".ui-menu-item").each(function() {
      var t4 = V(this);
      s3._isDivider(t4) && s3._addClass(t4, "ui-menu-divider", "ui-widget-content");
    }), e3 = (i3 = t3.not(".ui-menu-item, .ui-menu-divider")).children().not(".ui-menu").uniqueId().attr({ tabIndex: -1, role: this._itemRole() }), this._addClass(i3, "ui-menu-item")._addClass(e3, "ui-menu-item-wrapper"), t3.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !V.contains(this.element[0], this.active[0]) && this.blur();
  }, _itemRole: function() {
    return { menu: "menuitem", listbox: "option" }[this.options.role];
  }, _setOption: function(t3, e3) {
    var i3;
    "icons" === t3 && (i3 = this.element.find(".ui-menu-icon"), this._removeClass(i3, null, this.options.icons.submenu)._addClass(i3, null, e3.submenu)), this._super(t3, e3);
  }, _setOptionDisabled: function(t3) {
    this._super(t3), this.element.attr("aria-disabled", String(t3)), this._toggleClass(null, "ui-state-disabled", !!t3);
  }, focus: function(t3, e3) {
    var i3;
    this.blur(t3, t3 && "focus" === t3.type), this._scrollIntoView(e3), this.active = e3.first(), i3 = this.active.children(".ui-menu-item-wrapper"), this._addClass(i3, null, "ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", i3.attr("id")), i3 = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"), this._addClass(i3, null, "ui-state-active"), t3 && "keydown" === t3.type ? this._close() : this.timer = this._delay(function() {
      this._close();
    }, this.delay), (i3 = e3.children(".ui-menu")).length && t3 && /^mouse/.test(t3.type) && this._startOpening(i3), this.activeMenu = e3.parent(), this._trigger("focus", t3, { item: e3 });
  }, _scrollIntoView: function(t3) {
    var e3, i3, s3;
    this._hasScroll() && (e3 = parseFloat(V.css(this.activeMenu[0], "borderTopWidth")) || 0, i3 = parseFloat(V.css(this.activeMenu[0], "paddingTop")) || 0, e3 = t3.offset().top - this.activeMenu.offset().top - e3 - i3, i3 = this.activeMenu.scrollTop(), s3 = this.activeMenu.height(), t3 = t3.outerHeight(), e3 < 0 ? this.activeMenu.scrollTop(i3 + e3) : s3 < e3 + t3 && this.activeMenu.scrollTop(i3 + e3 - s3 + t3));
  }, blur: function(t3, e3) {
    e3 || clearTimeout(this.timer), this.active && (this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active"), this._trigger("blur", t3, { item: this.active }), this.active = null);
  }, _startOpening: function(t3) {
    clearTimeout(this.timer), "true" === t3.attr("aria-hidden") && (this.timer = this._delay(function() {
      this._close(), this._open(t3);
    }, this.delay));
  }, _open: function(t3) {
    var e3 = V.extend({ of: this.active }, this.options.position);
    clearTimeout(this.timer), this.element.find(".ui-menu").not(t3.parents(".ui-menu")).hide().attr("aria-hidden", "true"), t3.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(e3);
  }, collapseAll: function(e3, i3) {
    clearTimeout(this.timer), this.timer = this._delay(function() {
      var t3 = i3 ? this.element : V(e3 && e3.target).closest(this.element.find(".ui-menu"));
      t3.length || (t3 = this.element), this._close(t3), this.blur(e3), this._removeClass(t3.find(".ui-state-active"), null, "ui-state-active"), this.activeMenu = t3;
    }, i3 ? 0 : this.delay);
  }, _close: function(t3) {
    (t3 = t3 || (this.active ? this.active.parent() : this.element)).find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false");
  }, _closeOnDocumentClick: function(t3) {
    return !V(t3.target).closest(".ui-menu").length;
  }, _isDivider: function(t3) {
    return !/[^\-\u2014\u2013\s]/.test(t3.text());
  }, collapse: function(t3) {
    var e3 = this.active && this.active.parent().closest(".ui-menu-item", this.element);
    e3 && e3.length && (this._close(), this.focus(t3, e3));
  }, expand: function(t3) {
    var e3 = this.active && this._menuItems(this.active.children(".ui-menu")).first();
    e3 && e3.length && (this._open(e3.parent()), this._delay(function() {
      this.focus(t3, e3);
    }));
  }, next: function(t3) {
    this._move("next", "first", t3);
  }, previous: function(t3) {
    this._move("prev", "last", t3);
  }, isFirstItem: function() {
    return this.active && !this.active.prevAll(".ui-menu-item").length;
  }, isLastItem: function() {
    return this.active && !this.active.nextAll(".ui-menu-item").length;
  }, _menuItems: function(t3) {
    return (t3 || this.element).find(this.options.items).filter(".ui-menu-item");
  }, _move: function(t3, e3, i3) {
    var s3;
    (s3 = this.active ? "first" === t3 || "last" === t3 ? this.active["first" === t3 ? "prevAll" : "nextAll"](".ui-menu-item").last() : this.active[t3 + "All"](".ui-menu-item").first() : s3) && s3.length && this.active || (s3 = this._menuItems(this.activeMenu)[e3]()), this.focus(i3, s3);
  }, nextPage: function(t3) {
    var e3, i3, s3;
    this.active ? this.isLastItem() || (this._hasScroll() ? (i3 = this.active.offset().top, s3 = this.element.innerHeight(), 0 === V.fn.jquery.indexOf("3.2.") && (s3 += this.element[0].offsetHeight - this.element.outerHeight()), this.active.nextAll(".ui-menu-item").each(function() {
      return (e3 = V(this)).offset().top - i3 - s3 < 0;
    }), this.focus(t3, e3)) : this.focus(t3, this._menuItems(this.activeMenu)[this.active ? "last" : "first"]())) : this.next(t3);
  }, previousPage: function(t3) {
    var e3, i3, s3;
    this.active ? this.isFirstItem() || (this._hasScroll() ? (i3 = this.active.offset().top, s3 = this.element.innerHeight(), 0 === V.fn.jquery.indexOf("3.2.") && (s3 += this.element[0].offsetHeight - this.element.outerHeight()), this.active.prevAll(".ui-menu-item").each(function() {
      return 0 < (e3 = V(this)).offset().top - i3 + s3;
    }), this.focus(t3, e3)) : this.focus(t3, this._menuItems(this.activeMenu).first())) : this.next(t3);
  }, _hasScroll: function() {
    return this.element.outerHeight() < this.element.prop("scrollHeight");
  }, select: function(t3) {
    this.active = this.active || V(t3.target).closest(".ui-menu-item");
    var e3 = { item: this.active };
    this.active.has(".ui-menu").length || this.collapseAll(t3, true), this._trigger("select", t3, e3);
  }, _filterMenuItems: function(t3) {
    var t3 = t3.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), e3 = new RegExp("^" + t3, "i");
    return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() {
      return e3.test(String.prototype.trim.call(V(this).children(".ui-menu-item-wrapper").text()));
    });
  } }), V.widget("ui.autocomplete", { version: "1.14.0", defaultElement: "<input>", options: { appendTo: null, autoFocus: false, delay: 300, minLength: 1, position: { my: "left top", at: "left bottom", collision: "none" }, source: null, change: null, close: null, focus: null, open: null, response: null, search: null, select: null }, requestIndex: 0, pending: 0, liveRegionTimer: null, _create: function() {
    var i3, s3, n3, t3 = this.element[0].nodeName.toLowerCase(), e3 = "textarea" === t3, t3 = "input" === t3;
    this.isMultiLine = e3 || !t3 && "true" === this.element.prop("contentEditable"), this.valueMethod = this.element[e3 || t3 ? "val" : "text"], this.isNewMenu = true, this._addClass("ui-autocomplete-input"), this.element.attr("autocomplete", "off"), this._on(this.element, { keydown: function(t4) {
      if (this.element.prop("readOnly")) s3 = n3 = i3 = true;
      else {
        s3 = n3 = i3 = false;
        var e4 = V.ui.keyCode;
        switch (t4.keyCode) {
          case e4.PAGE_UP:
            i3 = true, this._move("previousPage", t4);
            break;
          case e4.PAGE_DOWN:
            i3 = true, this._move("nextPage", t4);
            break;
          case e4.UP:
            i3 = true, this._keyEvent("previous", t4);
            break;
          case e4.DOWN:
            i3 = true, this._keyEvent("next", t4);
            break;
          case e4.ENTER:
            this.menu.active && (i3 = true, t4.preventDefault(), this.menu.select(t4));
            break;
          case e4.TAB:
            this.menu.active && this.menu.select(t4);
            break;
          case e4.ESCAPE:
            this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(t4), t4.preventDefault());
            break;
          default:
            s3 = true, this._searchTimeout(t4);
        }
      }
    }, keypress: function(t4) {
      if (i3) i3 = false, this.isMultiLine && !this.menu.element.is(":visible") || t4.preventDefault();
      else if (!s3) {
        var e4 = V.ui.keyCode;
        switch (t4.keyCode) {
          case e4.PAGE_UP:
            this._move("previousPage", t4);
            break;
          case e4.PAGE_DOWN:
            this._move("nextPage", t4);
            break;
          case e4.UP:
            this._keyEvent("previous", t4);
            break;
          case e4.DOWN:
            this._keyEvent("next", t4);
        }
      }
    }, input: function(t4) {
      n3 ? (n3 = false, t4.preventDefault()) : this._searchTimeout(t4);
    }, focus: function() {
      this.selectedItem = null, this.previous = this._value();
    }, blur: function(t4) {
      clearTimeout(this.searching), this.close(t4), this._change(t4);
    } }), this._initSource(), this.menu = V("<ul>").appendTo(this._appendTo()).menu({ role: null }).hide().menu("instance"), this._addClass(this.menu.element, "ui-autocomplete", "ui-front"), this._on(this.menu.element, { mousedown: function(t4) {
      t4.preventDefault();
    }, menufocus: function(t4, e4) {
      var i4, s4;
      this.isNewMenu && (this.isNewMenu = false, t4.originalEvent) && /^mouse/.test(t4.originalEvent.type) ? (this.menu.blur(), this.document.one("mousemove", function() {
        V(t4.target).trigger(t4.originalEvent);
      })) : (s4 = e4.item.data("ui-autocomplete-item"), false !== this._trigger("focus", t4, { item: s4 }) && t4.originalEvent && /^key/.test(t4.originalEvent.type) && this._value(s4.value), (i4 = e4.item.attr("aria-label") || s4.value) && String.prototype.trim.call(i4).length && (clearTimeout(this.liveRegionTimer), this.liveRegionTimer = this._delay(function() {
        this.liveRegion.html(V("<div>").text(i4));
      }, 100)));
    }, menuselect: function(t4, e4) {
      var e4 = e4.item.data("ui-autocomplete-item"), i4 = this.previous;
      this.element[0] !== this.document[0].activeElement && (this.element.trigger("focus"), this.previous = i4), false !== this._trigger("select", t4, { item: e4 }) && this._value(e4.value), this.term = this._value(), this.close(t4), this.selectedItem = e4;
    } }), this.liveRegion = V("<div>", { role: "status", "aria-live": "assertive", "aria-relevant": "additions" }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this._on(this.window, { beforeunload: function() {
      this.element.removeAttr("autocomplete");
    } });
  }, _destroy: function() {
    clearTimeout(this.searching), this.element.removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove();
  }, _setOption: function(t3, e3) {
    this._super(t3, e3), "source" === t3 && this._initSource(), "appendTo" === t3 && this.menu.element.appendTo(this._appendTo()), "disabled" === t3 && e3 && this.xhr && this.xhr.abort();
  }, _isEventTargetInWidget: function(t3) {
    var e3 = this.menu.element[0];
    return t3.target === this.element[0] || t3.target === e3 || V.contains(e3, t3.target);
  }, _closeOnClickOutside: function(t3) {
    this._isEventTargetInWidget(t3) || this.close();
  }, _appendTo: function() {
    var t3 = this.options.appendTo;
    return t3 = (t3 = (t3 = t3 && (t3.jquery || t3.nodeType ? V(t3) : this.document.find(t3).eq(0))) && t3[0] ? t3 : this.element.closest(".ui-front, dialog")).length ? t3 : this.document[0].body;
  }, _initSource: function() {
    var i3, s3, n3 = this;
    Array.isArray(this.options.source) ? (i3 = this.options.source, this.source = function(t3, e3) {
      e3(V.ui.autocomplete.filter(i3, t3.term));
    }) : "string" == typeof this.options.source ? (s3 = this.options.source, this.source = function(t3, e3) {
      n3.xhr && n3.xhr.abort(), n3.xhr = V.ajax({ url: s3, data: t3, dataType: "json", success: function(t4) {
        e3(t4);
      }, error: function() {
        e3([]);
      } });
    }) : this.source = this.options.source;
  }, _searchTimeout: function(s3) {
    clearTimeout(this.searching), this.searching = this._delay(function() {
      var t3 = this.term === this._value(), e3 = this.menu.element.is(":visible"), i3 = s3.altKey || s3.ctrlKey || s3.metaKey || s3.shiftKey;
      t3 && (e3 || i3) || (this.selectedItem = null, this.search(null, s3));
    }, this.options.delay);
  }, search: function(t3, e3) {
    return t3 = null != t3 ? t3 : this._value(), this.term = this._value(), t3.length < this.options.minLength ? this.close(e3) : false !== this._trigger("search", e3) ? this._search(t3) : void 0;
  }, _search: function(t3) {
    this.pending++, this._addClass("ui-autocomplete-loading"), this.cancelSearch = false, this.source({ term: t3 }, this._response());
  }, _response: function() {
    var e3 = ++this.requestIndex;
    return (function(t3) {
      e3 === this.requestIndex && this.__response(t3), this.pending--, this.pending || this._removeClass("ui-autocomplete-loading");
    }).bind(this);
  }, __response: function(t3) {
    t3 = t3 && this._normalize(t3), this._trigger("response", null, { content: t3 }), !this.options.disabled && t3 && t3.length && !this.cancelSearch ? (this._suggest(t3), this._trigger("open")) : this._close();
  }, close: function(t3) {
    this.cancelSearch = true, this._close(t3);
  }, _close: function(t3) {
    this._off(this.document, "mousedown"), this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = true, this._trigger("close", t3));
  }, _change: function(t3) {
    this.previous !== this._value() && this._trigger("change", t3, { item: this.selectedItem });
  }, _normalize: function(t3) {
    return t3.length && t3[0].label && t3[0].value ? t3 : V.map(t3, function(t4) {
      return "string" == typeof t4 ? { label: t4, value: t4 } : V.extend({}, t4, { label: t4.label || t4.value, value: t4.value || t4.label });
    });
  }, _suggest: function(t3) {
    var e3 = this.menu.element.empty();
    this._renderMenu(e3, t3), this.isNewMenu = true, this.menu.refresh(), e3.show(), this._resizeMenu(), e3.position(V.extend({ of: this.element }, this.options.position)), this.options.autoFocus && this.menu.next(), this._on(this.document, { mousedown: "_closeOnClickOutside" });
  }, _resizeMenu: function() {
    var t3 = this.menu.element;
    t3.outerWidth(Math.max(t3.width("").outerWidth() + 1, this.element.outerWidth()));
  }, _renderMenu: function(i3, t3) {
    var s3 = this;
    V.each(t3, function(t4, e3) {
      s3._renderItemData(i3, e3);
    });
  }, _renderItemData: function(t3, e3) {
    return this._renderItem(t3, e3).data("ui-autocomplete-item", e3);
  }, _renderItem: function(t3, e3) {
    return V("<li>").append(V("<div>").text(e3.label)).appendTo(t3);
  }, _move: function(t3, e3) {
    this.menu.element.is(":visible") ? this.menu.isFirstItem() && /^previous/.test(t3) || this.menu.isLastItem() && /^next/.test(t3) ? (this.isMultiLine || this._value(this.term), this.menu.blur()) : this.menu[t3](e3) : this.search(null, e3);
  }, widget: function() {
    return this.menu.element;
  }, _value: function() {
    return this.valueMethod.apply(this.element, arguments);
  }, _keyEvent: function(t3, e3) {
    this.isMultiLine && !this.menu.element.is(":visible") || (this._move(t3, e3), e3.preventDefault());
  } }), V.extend(V.ui.autocomplete, { escapeRegex: function(t3) {
    return t3.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }, filter: function(t3, e3) {
    var i3 = new RegExp(V.ui.autocomplete.escapeRegex(e3), "i");
    return V.grep(t3, function(t4) {
      return i3.test(t4.label || t4.value || t4);
    });
  } }), V.widget("ui.autocomplete", V.ui.autocomplete, { options: { messages: { noResults: "No search results.", results: function(t3) {
    return t3 + (1 < t3 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
  } } }, __response: function(t3) {
    var e3;
    this._superApply(arguments), this.options.disabled || this.cancelSearch || (e3 = t3 && t3.length ? this.options.messages.results(t3.length) : this.options.messages.noResults, clearTimeout(this.liveRegionTimer), this.liveRegionTimer = this._delay(function() {
      this.liveRegion.html(V("<div>").text(e3));
    }, 100));
  } }), V.ui.autocomplete, /ui-corner-([a-z]){2,6}/g);
  V.widget("ui.controlgroup", { version: "1.14.0", defaultElement: "<div>", options: { direction: "horizontal", disabled: null, onlyVisible: true, items: { button: "input[type=button], input[type=submit], input[type=reset], button, a", controlgroupLabel: ".ui-controlgroup-label", checkboxradio: "input[type='checkbox'], input[type='radio']", selectmenu: "select", spinner: ".ui-spinner-input" } }, _create: function() {
    this._enhance();
  }, _enhance: function() {
    this.element.attr("role", "toolbar"), this.refresh();
  }, _destroy: function() {
    this._callChildMethod("destroy"), this.childWidgets.removeData("ui-controlgroup-data"), this.element.removeAttr("role"), this.options.items.controlgroupLabel && this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap();
  }, _initWidgets: function() {
    var o3 = this, a3 = [];
    V.each(this.options.items, function(s3, t3) {
      var e3, n3 = {};
      t3 && ("controlgroupLabel" === s3 ? ((e3 = o3.element.find(t3)).each(function() {
        var t4 = V(this);
        t4.children(".ui-controlgroup-label-contents").length || t4.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>");
      }), o3._addClass(e3, null, "ui-widget ui-widget-content ui-state-default"), a3 = a3.concat(e3.get())) : V.fn[s3] && (n3 = o3["_" + s3 + "Options"] ? o3["_" + s3 + "Options"]("middle") : { classes: {} }, o3.element.find(t3).each(function() {
        var t4 = V(this), e4 = t4[s3]("instance"), i3 = V.widget.extend({}, n3);
        "button" === s3 && t4.parent(".ui-spinner").length || ((e4 = e4 || t4[s3]()[s3]("instance")) && (i3.classes = o3._resolveClassesValues(i3.classes, e4)), t4[s3](i3), i3 = t4[s3]("widget"), V.data(i3[0], "ui-controlgroup-data", e4 || t4[s3]("instance")), a3.push(i3[0]));
      })));
    }), this.childWidgets = V(V.uniqueSort(a3)), this._addClass(this.childWidgets, "ui-controlgroup-item");
  }, _callChildMethod: function(e3) {
    this.childWidgets.each(function() {
      var t3 = V(this).data("ui-controlgroup-data");
      t3 && t3[e3] && t3[e3]();
    });
  }, _updateCornerClass: function(t3, e3) {
    e3 = this._buildSimpleOptions(e3, "label").classes.label;
    this._removeClass(t3, null, "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all"), this._addClass(t3, null, e3);
  }, _buildSimpleOptions: function(t3, e3) {
    var i3 = "vertical" === this.options.direction, s3 = { classes: {} };
    return s3.classes[e3] = { middle: "", first: "ui-corner-" + (i3 ? "top" : "left"), last: "ui-corner-" + (i3 ? "bottom" : "right"), only: "ui-corner-all" }[t3], s3;
  }, _spinnerOptions: function(t3) {
    t3 = this._buildSimpleOptions(t3, "ui-spinner");
    return t3.classes["ui-spinner-up"] = "", t3.classes["ui-spinner-down"] = "", t3;
  }, _buttonOptions: function(t3) {
    return this._buildSimpleOptions(t3, "ui-button");
  }, _checkboxradioOptions: function(t3) {
    return this._buildSimpleOptions(t3, "ui-checkboxradio-label");
  }, _selectmenuOptions: function(t3) {
    var e3 = "vertical" === this.options.direction;
    return { width: e3 && "auto", classes: { middle: { "ui-selectmenu-button-open": "", "ui-selectmenu-button-closed": "" }, first: { "ui-selectmenu-button-open": "ui-corner-" + (e3 ? "top" : "tl"), "ui-selectmenu-button-closed": "ui-corner-" + (e3 ? "top" : "left") }, last: { "ui-selectmenu-button-open": e3 ? "" : "ui-corner-tr", "ui-selectmenu-button-closed": "ui-corner-" + (e3 ? "bottom" : "right") }, only: { "ui-selectmenu-button-open": "ui-corner-top", "ui-selectmenu-button-closed": "ui-corner-all" } }[t3] };
  }, _resolveClassesValues: function(i3, s3) {
    var n3 = {};
    return V.each(i3, function(t3) {
      var e3 = s3.options.classes[t3] || "", e3 = String.prototype.trim.call(e3.replace(st, ""));
      n3[t3] = (e3 + " " + i3[t3]).replace(/\s+/g, " ");
    }), n3;
  }, _setOption: function(t3, e3) {
    "direction" === t3 && this._removeClass("ui-controlgroup-" + this.options.direction), this._super(t3, e3), "disabled" === t3 ? this._callChildMethod(e3 ? "disable" : "enable") : this.refresh();
  }, refresh: function() {
    var n3, o3 = this;
    this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction), "horizontal" === this.options.direction && this._addClass(null, "ui-helper-clearfix"), this._initWidgets(), n3 = this.childWidgets, (n3 = this.options.onlyVisible ? n3.filter(":visible") : n3).length && (V.each(["first", "last"], function(t3, e3) {
      var i3, s3 = n3[e3]().data("ui-controlgroup-data");
      s3 && o3["_" + s3.widgetName + "Options"] ? ((i3 = o3["_" + s3.widgetName + "Options"](1 === n3.length ? "only" : e3)).classes = o3._resolveClassesValues(i3.classes, s3), s3.element[s3.widgetName](i3)) : o3._updateCornerClass(n3[e3](), e3);
    }), this._callChildMethod("refresh"));
  } }), V.widget("ui.checkboxradio", [V.ui.formResetMixin, { version: "1.14.0", options: { disabled: null, label: null, icon: true, classes: { "ui-checkboxradio-label": "ui-corner-all", "ui-checkboxradio-icon": "ui-corner-all" } }, _getCreateOptions: function() {
    var t3, e3 = this._super() || {};
    return this._readType(), t3 = this.element.labels(), this.label = V(t3[t3.length - 1]), this.label.length || V.error("No label found for checkboxradio widget"), this.originalLabel = "", (t3 = this.label.contents().not(this.element[0])).length && (this.originalLabel += t3.clone().wrapAll("<div></div>").parent().html()), this.originalLabel && (e3.label = this.originalLabel), null != (t3 = this.element[0].disabled) && (e3.disabled = t3), e3;
  }, _create: function() {
    var t3 = this.element[0].checked;
    this._bindFormResetHandler(), null == this.options.disabled && (this.options.disabled = this.element[0].disabled), this._setOption("disabled", this.options.disabled), this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible"), this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget"), "radio" === this.type && this._addClass(this.label, "ui-checkboxradio-radio-label"), this.options.label && this.options.label !== this.originalLabel ? this._updateLabel() : this.originalLabel && (this.options.label = this.originalLabel), this._enhance(), t3 && this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active"), this._on({ change: "_toggleClasses", focus: function() {
      this._addClass(this.label, null, "ui-state-focus ui-visual-focus");
    }, blur: function() {
      this._removeClass(this.label, null, "ui-state-focus ui-visual-focus");
    } });
  }, _readType: function() {
    var t3 = this.element[0].nodeName.toLowerCase();
    this.type = this.element[0].type, "input" === t3 && /radio|checkbox/.test(this.type) || V.error("Can't create checkboxradio on element.nodeName=" + t3 + " and element.type=" + this.type);
  }, _enhance: function() {
    this._updateIcon(this.element[0].checked);
  }, widget: function() {
    return this.label;
  }, _getRadioGroup: function() {
    var t3 = this.element[0].name, e3 = "input[name='" + CSS.escape(t3) + "']";
    return t3 ? (this.form.length ? V(this.form[0].elements).filter(e3) : V(e3).filter(function() {
      return 0 === V(V(this).prop("form")).length;
    })).not(this.element) : V([]);
  }, _toggleClasses: function() {
    var t3 = this.element[0].checked;
    this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t3), this.options.icon && "checkbox" === this.type && this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", t3)._toggleClass(this.icon, null, "ui-icon-blank", !t3), "radio" === this.type && this._getRadioGroup().each(function() {
      var t4 = V(this).checkboxradio("instance");
      t4 && t4._removeClass(t4.label, "ui-checkboxradio-checked", "ui-state-active");
    });
  }, _destroy: function() {
    this._unbindFormResetHandler(), this.icon && (this.icon.remove(), this.iconSpace.remove());
  }, _setOption: function(t3, e3) {
    "label" === t3 && !e3 || (this._super(t3, e3), "disabled" === t3 ? (this._toggleClass(this.label, null, "ui-state-disabled", e3), this.element[0].disabled = e3) : this.refresh());
  }, _updateIcon: function(t3) {
    var e3 = "ui-icon ui-icon-background ";
    this.options.icon ? (this.icon || (this.icon = V("<span>"), this.iconSpace = V("<span> </span>"), this._addClass(this.iconSpace, "ui-checkboxradio-icon-space")), "checkbox" === this.type ? (e3 += t3 ? "ui-icon-check ui-state-checked" : "ui-icon-blank", this._removeClass(this.icon, null, t3 ? "ui-icon-blank" : "ui-icon-check")) : e3 += "ui-icon-blank", this._addClass(this.icon, "ui-checkboxradio-icon", e3), t3 || this._removeClass(this.icon, null, "ui-icon-check ui-state-checked"), this.icon.prependTo(this.label).after(this.iconSpace)) : void 0 !== this.icon && (this.icon.remove(), this.iconSpace.remove(), delete this.icon);
  }, _updateLabel: function() {
    var t3 = this.label.contents().not(this.element[0]);
    this.icon && (t3 = t3.not(this.icon[0])), (t3 = this.iconSpace ? t3.not(this.iconSpace[0]) : t3).remove(), this.label.append(this.options.label);
  }, refresh: function() {
    var t3 = this.element[0].checked, e3 = this.element[0].disabled;
    this._updateIcon(t3), this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t3), null !== this.options.label && this._updateLabel(), e3 !== this.options.disabled && this._setOptions({ disabled: e3 });
  } }]), V.ui.checkboxradio, V.widget("ui.button", { version: "1.14.0", defaultElement: "<button>", options: { classes: { "ui-button": "ui-corner-all" }, disabled: null, icon: null, iconPosition: "beginning", label: null, showLabel: true }, _getCreateOptions: function() {
    var t3, e3 = this._super() || {};
    return this.isInput = this.element.is("input"), null != (t3 = this.element[0].disabled) && (e3.disabled = t3), this.originalLabel = this.isInput ? this.element.val() : this.element.html(), this.originalLabel && (e3.label = this.originalLabel), e3;
  }, _create: function() {
    !this.option.showLabel & !this.options.icon && (this.options.showLabel = true), null == this.options.disabled && (this.options.disabled = this.element[0].disabled || false), this.hasTitle = !!this.element.attr("title"), this.options.label && this.options.label !== this.originalLabel && (this.isInput ? this.element.val(this.options.label) : this.element.html(this.options.label)), this._addClass("ui-button", "ui-widget"), this._setOption("disabled", this.options.disabled), this._enhance(), this.element.is("a") && this._on({ keyup: function(t3) {
      t3.keyCode === V.ui.keyCode.SPACE && (t3.preventDefault(), this.element[0].click ? this.element[0].click() : this.element.trigger("click"));
    } });
  }, _enhance: function() {
    this.element.is("button") || this.element.attr("role", "button"), this.options.icon && (this._updateIcon("icon", this.options.icon), this._updateTooltip());
  }, _updateTooltip: function() {
    this.title = this.element.attr("title"), this.options.showLabel || this.title || this.element.attr("title", this.options.label);
  }, _updateIcon: function(t3, e3) {
    var t3 = "iconPosition" !== t3, i3 = t3 ? this.options.iconPosition : e3, s3 = "top" === i3 || "bottom" === i3;
    this.icon ? t3 && this._removeClass(this.icon, null, this.options.icon) : (this.icon = V("<span>"), this._addClass(this.icon, "ui-button-icon", "ui-icon"), this.options.showLabel || this._addClass("ui-button-icon-only")), t3 && this._addClass(this.icon, null, e3), this._attachIcon(i3), s3 ? (this._addClass(this.icon, null, "ui-widget-icon-block"), this.iconSpace && this.iconSpace.remove()) : (this.iconSpace || (this.iconSpace = V("<span> </span>"), this._addClass(this.iconSpace, "ui-button-icon-space")), this._removeClass(this.icon, null, "ui-wiget-icon-block"), this._attachIconSpace(i3));
  }, _destroy: function() {
    this.element.removeAttr("role"), this.icon && this.icon.remove(), this.iconSpace && this.iconSpace.remove(), this.hasTitle || this.element.removeAttr("title");
  }, _attachIconSpace: function(t3) {
    this.icon[/^(?:end|bottom)/.test(t3) ? "before" : "after"](this.iconSpace);
  }, _attachIcon: function(t3) {
    this.element[/^(?:end|bottom)/.test(t3) ? "append" : "prepend"](this.icon);
  }, _setOptions: function(t3) {
    var e3 = (void 0 === t3.showLabel ? this.options : t3).showLabel, i3 = (void 0 === t3.icon ? this.options : t3).icon;
    e3 || i3 || (t3.showLabel = true), this._super(t3);
  }, _setOption: function(t3, e3) {
    "icon" === t3 && (e3 ? this._updateIcon(t3, e3) : this.icon && (this.icon.remove(), this.iconSpace) && this.iconSpace.remove()), "iconPosition" === t3 && this._updateIcon(t3, e3), "showLabel" === t3 && (this._toggleClass("ui-button-icon-only", null, !e3), this._updateTooltip()), "label" === t3 && (this.isInput ? this.element.val(e3) : (this.element.html(e3), this.icon && (this._attachIcon(this.options.iconPosition), this._attachIconSpace(this.options.iconPosition)))), this._super(t3, e3), "disabled" === t3 && (this._toggleClass(null, "ui-state-disabled", e3), this.element[0].disabled = e3) && this.element.trigger("blur");
  }, refresh: function() {
    var t3 = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
    t3 !== this.options.disabled && this._setOptions({ disabled: t3 }), this._updateTooltip();
  } }), true === V.uiBackCompat && (V.widget("ui.button", V.ui.button, { options: { text: true, icons: { primary: null, secondary: null } }, _create: function() {
    this.options.showLabel && !this.options.text && (this.options.showLabel = this.options.text), !this.options.showLabel && this.options.text && (this.options.text = this.options.showLabel), this.options.icon || !this.options.icons.primary && !this.options.icons.secondary ? this.options.icon && (this.options.icons.primary = this.options.icon) : this.options.icons.primary ? this.options.icon = this.options.icons.primary : (this.options.icon = this.options.icons.secondary, this.options.iconPosition = "end"), this._super();
  }, _setOption: function(t3, e3) {
    "text" === t3 ? this._super("showLabel", e3) : ("showLabel" === t3 && (this.options.text = e3), "icon" === t3 && (this.options.icons.primary = e3), "icons" === t3 && (e3.primary ? (this._super("icon", e3.primary), this._super("iconPosition", "beginning")) : e3.secondary && (this._super("icon", e3.secondary), this._super("iconPosition", "end"))), this._superApply(arguments));
  } }), V.fn.button = (et = V.fn.button, function(i3) {
    var t3 = "string" == typeof i3, s3 = Array.prototype.slice.call(arguments, 1), n3 = this;
    return t3 ? this.length || "instance" !== i3 ? this.each(function() {
      var t4, e3 = V(this).attr("type"), e3 = V.data(this, "ui-" + ("checkbox" !== e3 && "radio" !== e3 ? "button" : "checkboxradio"));
      return "instance" === i3 ? (n3 = e3, false) : e3 ? "function" != typeof e3[i3] || "_" === i3.charAt(0) ? V.error("no such method '" + i3 + "' for button widget instance") : (t4 = e3[i3].apply(e3, s3)) !== e3 && void 0 !== t4 ? (n3 = t4 && t4.jquery ? n3.pushStack(t4.get()) : t4, false) : void 0 : V.error("cannot call methods on button prior to initialization; attempted to call method '" + i3 + "'");
    }) : n3 = void 0 : (s3.length && (i3 = V.widget.extend.apply(null, [i3].concat(s3))), this.each(function() {
      var t4 = V(this).attr("type"), t4 = "checkbox" !== t4 && "radio" !== t4 ? "button" : "checkboxradio", e3 = V.data(this, "ui-" + t4);
      e3 ? (e3.option(i3 || {}), e3._init && e3._init()) : "button" == t4 ? et.call(V(this), i3) : V(this).checkboxradio(V.extend({ icon: false }, i3));
    })), n3;
  }), V.fn.buttonset = function() {
    return V.ui.controlgroup || V.error("Controlgroup widget missing"), "option" === arguments[0] && "items" === arguments[1] && arguments[2] ? this.controlgroup.apply(this, [arguments[0], "items.button", arguments[2]]) : "option" === arguments[0] && "items" === arguments[1] ? this.controlgroup.apply(this, [arguments[0], "items.button"]) : ("object" == typeof arguments[0] && arguments[0].items && (arguments[0].items = { button: arguments[0].items }), this.controlgroup.apply(this, arguments));
  }), V.ui.button;
  function nt() {
    this._curInst = null, this._keyEvent = false, this._disabledInputs = [], this._datepickerShowing = false, this._inDialog = false, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = { closeText: "Done", prevText: "Prev", nextText: "Next", currentText: "Today", monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], weekHeader: "Wk", dateFormat: "mm/dd/yy", firstDay: 0, isRTL: false, showMonthAfterYear: false, yearSuffix: "", selectMonthLabel: "Select month", selectYearLabel: "Select year" }, this._defaults = { showOn: "focus", showAnim: "fadeIn", showOptions: {}, defaultDate: null, appendText: "", buttonText: "...", buttonImage: "", buttonImageOnly: false, hideIfNoPrevNext: false, navigationAsDateFormat: false, gotoCurrent: false, changeMonth: false, changeYear: false, yearRange: "c-10:c+10", showOtherMonths: false, selectOtherMonths: false, showWeek: false, calculateWeek: this.iso8601Week, shortYearCutoff: "+10", minDate: null, maxDate: null, duration: "fast", beforeShowDay: null, beforeShow: null, onSelect: null, onChangeMonthYear: null, onClose: null, onUpdateDatepicker: null, numberOfMonths: 1, showCurrentAtPos: 0, stepMonths: 1, stepBigMonths: 12, altField: "", altFormat: "", constrainInput: true, showButtonPanel: false, autoSize: false, disabled: false }, V.extend(this._defaults, this.regional[""]), this.regional.en = V.extend(true, {}, this.regional[""]), this.regional["en-US"] = V.extend(true, {}, this.regional.en), this.dpDiv = ot(V("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
  }
  function ot(t3) {
    var e3 = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
    return t3.on("mouseout", e3, function() {
      V(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && V(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && V(this).removeClass("ui-datepicker-next-hover");
    }).on("mouseover", e3, at);
  }
  function at() {
    V.datepicker._isDisabledDatepicker((S.inline ? S.dpDiv.parent() : S.input)[0]) || (V(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), V(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && V(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && V(this).addClass("ui-datepicker-next-hover"));
  }
  function H(t3, e3) {
    for (var i3 in V.extend(t3, e3), e3) null == e3[i3] && (t3[i3] = e3[i3]);
  }
  V.extend(V.ui, { datepicker: { version: "1.14.0" } }), V.extend(nt.prototype, { markerClassName: "hasDatepicker", maxRows: 4, _widgetDatepicker: function() {
    return this.dpDiv;
  }, setDefaults: function(t3) {
    return H(this._defaults, t3 || {}), this;
  }, _attachDatepicker: function(t3, e3) {
    var i3, s3 = t3.nodeName.toLowerCase(), n3 = "div" === s3 || "span" === s3;
    t3.id || (this.uuid += 1, t3.id = "dp" + this.uuid), (i3 = this._newInst(V(t3), n3)).settings = V.extend({}, e3 || {}), "input" === s3 ? this._connectDatepicker(t3, i3) : n3 && this._inlineDatepicker(t3, i3);
  }, _newInst: function(t3, e3) {
    return { id: t3[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"), input: t3, selectedDay: 0, selectedMonth: 0, selectedYear: 0, drawMonth: 0, drawYear: 0, inline: e3, dpDiv: e3 ? ot(V("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv };
  }, _connectDatepicker: function(t3, e3) {
    var i3 = V(t3);
    e3.append = V([]), e3.trigger = V([]), i3.hasClass(this.markerClassName) || (this._attachments(i3, e3), i3.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp), this._autoSize(e3), V.data(t3, "datepicker", e3), e3.settings.disabled && this._disableDatepicker(t3));
  }, _attachments: function(t3, e3) {
    var i3, s3 = this._get(e3, "appendText"), n3 = this._get(e3, "isRTL");
    e3.append && e3.append.remove(), s3 && (e3.append = V("<span>").addClass(this._appendClass).text(s3), t3[n3 ? "before" : "after"](e3.append)), t3.off("focus", this._showDatepicker), e3.trigger && e3.trigger.remove(), "focus" !== (s3 = this._get(e3, "showOn")) && "both" !== s3 || t3.on("focus", this._showDatepicker), "button" !== s3 && "both" !== s3 || (s3 = this._get(e3, "buttonText"), i3 = this._get(e3, "buttonImage"), this._get(e3, "buttonImageOnly") ? e3.trigger = V("<img>").addClass(this._triggerClass).attr({ src: i3, alt: s3, title: s3 }) : (e3.trigger = V("<button type='button'>").addClass(this._triggerClass), i3 ? e3.trigger.html(V("<img>").attr({ src: i3, alt: s3, title: s3 })) : e3.trigger.text(s3)), t3[n3 ? "before" : "after"](e3.trigger), e3.trigger.on("click", function() {
      return V.datepicker._datepickerShowing && V.datepicker._lastInput === t3[0] ? V.datepicker._hideDatepicker() : (V.datepicker._datepickerShowing && V.datepicker._lastInput !== t3[0] && V.datepicker._hideDatepicker(), V.datepicker._showDatepicker(t3[0])), false;
    }));
  }, _autoSize: function(t3) {
    var e3, i3, s3, n3, o3, a3;
    this._get(t3, "autoSize") && !t3.inline && (o3 = new Date(2009, 11, 20), (a3 = this._get(t3, "dateFormat")).match(/[DM]/) && (o3.setMonth((e3 = function(t4) {
      for (n3 = s3 = i3 = 0; n3 < t4.length; n3++) t4[n3].length > i3 && (i3 = t4[n3].length, s3 = n3);
      return s3;
    })(this._get(t3, a3.match(/MM/) ? "monthNames" : "monthNamesShort"))), o3.setDate(e3(this._get(t3, a3.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - o3.getDay())), t3.input.attr("size", this._formatDate(t3, o3).length));
  }, _inlineDatepicker: function(t3, e3) {
    var i3 = V(t3);
    i3.hasClass(this.markerClassName) || (i3.addClass(this.markerClassName).append(e3.dpDiv), V.data(t3, "datepicker", e3), this._setDate(e3, this._getDefaultDate(e3), true), this._updateDatepicker(e3), this._updateAlternate(e3), e3.settings.disabled && this._disableDatepicker(t3), e3.dpDiv.css("display", "block"));
  }, _dialogDatepicker: function(t3, e3, i3, s3, n3) {
    var o3, a3 = this._dialogInst;
    return a3 || (this.uuid += 1, o3 = "dp" + this.uuid, this._dialogInput = V("<input type='text' id='" + o3 + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.on("keydown", this._doKeyDown), V("body").append(this._dialogInput), (a3 = this._dialogInst = this._newInst(this._dialogInput, false)).settings = {}, V.data(this._dialogInput[0], "datepicker", a3)), H(a3.settings, s3 || {}), e3 = e3 && e3.constructor === Date ? this._formatDate(a3, e3) : e3, this._dialogInput.val(e3), this._pos = n3 ? n3.length ? n3 : [n3.pageX, n3.pageY] : null, this._pos || (o3 = document.documentElement.clientWidth, s3 = document.documentElement.clientHeight, e3 = document.documentElement.scrollLeft || document.body.scrollLeft, n3 = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [o3 / 2 - 100 + e3, s3 / 2 - 150 + n3]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), a3.settings.onSelect = i3, this._inDialog = true, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), V.blockUI && V.blockUI(this.dpDiv), V.data(this._dialogInput[0], "datepicker", a3), this;
  }, _destroyDatepicker: function(t3) {
    var e3, i3 = V(t3), s3 = V.data(t3, "datepicker");
    i3.hasClass(this.markerClassName) && (e3 = t3.nodeName.toLowerCase(), V.removeData(t3, "datepicker"), "input" === e3 ? (s3.append.remove(), s3.trigger.remove(), i3.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp)) : "div" !== e3 && "span" !== e3 || i3.removeClass(this.markerClassName).empty(), V.datepicker._hideDatepicker(), S === s3) && (S = null, this._curInst = null);
  }, _enableDatepicker: function(e3) {
    var t3, i3 = V(e3), s3 = V.data(e3, "datepicker");
    i3.hasClass(this.markerClassName) && ("input" === (t3 = e3.nodeName.toLowerCase()) ? (e3.disabled = false, s3.trigger.filter("button").each(function() {
      this.disabled = false;
    }).end().filter("img").css({ opacity: "1.0", cursor: "" })) : "div" !== t3 && "span" !== t3 || ((s3 = i3.children("." + this._inlineClass)).children().removeClass("ui-state-disabled"), s3.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false)), this._disabledInputs = V.map(this._disabledInputs, function(t4) {
      return t4 === e3 ? null : t4;
    }));
  }, _disableDatepicker: function(e3) {
    var t3, i3 = V(e3), s3 = V.data(e3, "datepicker");
    i3.hasClass(this.markerClassName) && ("input" === (t3 = e3.nodeName.toLowerCase()) ? (e3.disabled = true, s3.trigger.filter("button").each(function() {
      this.disabled = true;
    }).end().filter("img").css({ opacity: "0.5", cursor: "default" })) : "div" !== t3 && "span" !== t3 || ((s3 = i3.children("." + this._inlineClass)).children().addClass("ui-state-disabled"), s3.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true)), this._disabledInputs = V.map(this._disabledInputs, function(t4) {
      return t4 === e3 ? null : t4;
    }), this._disabledInputs[this._disabledInputs.length] = e3);
  }, _isDisabledDatepicker: function(t3) {
    if (t3) {
      for (var e3 = 0; e3 < this._disabledInputs.length; e3++) if (this._disabledInputs[e3] === t3) return true;
    }
    return false;
  }, _getInst: function(t3) {
    try {
      return V.data(t3, "datepicker");
    } catch (t4) {
      throw "Missing instance data for this datepicker";
    }
  }, _optionDatepicker: function(t3, e3, i3) {
    var s3, n3, o3 = this._getInst(t3);
    if (2 === arguments.length && "string" == typeof e3) return "defaults" === e3 ? V.extend({}, V.datepicker._defaults) : o3 ? "all" === e3 ? V.extend({}, o3.settings) : this._get(o3, e3) : null;
    s3 = e3 || {}, "string" == typeof e3 && ((s3 = {})[e3] = i3), o3 && (this._curInst === o3 && this._hideDatepicker(), e3 = this._getDateDatepicker(t3, true), i3 = this._getMinMaxDate(o3, "min"), n3 = this._getMinMaxDate(o3, "max"), H(o3.settings, s3), null !== i3 && void 0 !== s3.dateFormat && void 0 === s3.minDate && (o3.settings.minDate = this._formatDate(o3, i3)), null !== n3 && void 0 !== s3.dateFormat && void 0 === s3.maxDate && (o3.settings.maxDate = this._formatDate(o3, n3)), "disabled" in s3 && (s3.disabled ? this._disableDatepicker(t3) : this._enableDatepicker(t3)), this._attachments(V(t3), o3), this._autoSize(o3), this._setDate(o3, e3), this._updateAlternate(o3), this._updateDatepicker(o3));
  }, _changeDatepicker: function(t3, e3, i3) {
    this._optionDatepicker(t3, e3, i3);
  }, _refreshDatepicker: function(t3) {
    t3 = this._getInst(t3);
    t3 && this._updateDatepicker(t3);
  }, _setDateDatepicker: function(t3, e3) {
    t3 = this._getInst(t3);
    t3 && (this._setDate(t3, e3), this._updateDatepicker(t3), this._updateAlternate(t3));
  }, _getDateDatepicker: function(t3, e3) {
    t3 = this._getInst(t3);
    return t3 && !t3.inline && this._setDateFromField(t3, e3), t3 ? this._getDate(t3) : null;
  }, _doKeyDown: function(t3) {
    var e3, i3, s3 = V.datepicker._getInst(t3.target), n3 = true, o3 = s3.dpDiv.is(".ui-datepicker-rtl");
    if (s3._keyEvent = true, V.datepicker._datepickerShowing) switch (t3.keyCode) {
      case 9:
        V.datepicker._hideDatepicker(), n3 = false;
        break;
      case 13:
        return (i3 = V("td." + V.datepicker._dayOverClass + ":not(." + V.datepicker._currentClass + ")", s3.dpDiv))[0] && V.datepicker._selectDay(t3.target, s3.selectedMonth, s3.selectedYear, i3[0]), (i3 = V.datepicker._get(s3, "onSelect")) ? (e3 = V.datepicker._formatDate(s3), i3.apply(s3.input ? s3.input[0] : null, [e3, s3])) : V.datepicker._hideDatepicker(), false;
      case 27:
        V.datepicker._hideDatepicker();
        break;
      case 33:
        V.datepicker._adjustDate(t3.target, t3.ctrlKey ? -V.datepicker._get(s3, "stepBigMonths") : -V.datepicker._get(s3, "stepMonths"), "M");
        break;
      case 34:
        V.datepicker._adjustDate(t3.target, t3.ctrlKey ? +V.datepicker._get(s3, "stepBigMonths") : +V.datepicker._get(s3, "stepMonths"), "M");
        break;
      case 35:
        (t3.ctrlKey || t3.metaKey) && V.datepicker._clearDate(t3.target), n3 = t3.ctrlKey || t3.metaKey;
        break;
      case 36:
        (t3.ctrlKey || t3.metaKey) && V.datepicker._gotoToday(t3.target), n3 = t3.ctrlKey || t3.metaKey;
        break;
      case 37:
        (t3.ctrlKey || t3.metaKey) && V.datepicker._adjustDate(t3.target, o3 ? 1 : -1, "D"), n3 = t3.ctrlKey || t3.metaKey, t3.originalEvent.altKey && V.datepicker._adjustDate(t3.target, t3.ctrlKey ? -V.datepicker._get(s3, "stepBigMonths") : -V.datepicker._get(s3, "stepMonths"), "M");
        break;
      case 38:
        (t3.ctrlKey || t3.metaKey) && V.datepicker._adjustDate(t3.target, -7, "D"), n3 = t3.ctrlKey || t3.metaKey;
        break;
      case 39:
        (t3.ctrlKey || t3.metaKey) && V.datepicker._adjustDate(t3.target, o3 ? -1 : 1, "D"), n3 = t3.ctrlKey || t3.metaKey, t3.originalEvent.altKey && V.datepicker._adjustDate(t3.target, t3.ctrlKey ? +V.datepicker._get(s3, "stepBigMonths") : +V.datepicker._get(s3, "stepMonths"), "M");
        break;
      case 40:
        (t3.ctrlKey || t3.metaKey) && V.datepicker._adjustDate(t3.target, 7, "D"), n3 = t3.ctrlKey || t3.metaKey;
        break;
      default:
        n3 = false;
    }
    else 36 === t3.keyCode && t3.ctrlKey ? V.datepicker._showDatepicker(this) : n3 = false;
    n3 && (t3.preventDefault(), t3.stopPropagation());
  }, _doKeyPress: function(t3) {
    var e3, i3 = V.datepicker._getInst(t3.target);
    if (V.datepicker._get(i3, "constrainInput")) return i3 = V.datepicker._possibleChars(V.datepicker._get(i3, "dateFormat")), e3 = String.fromCharCode(null == t3.charCode ? t3.keyCode : t3.charCode), t3.ctrlKey || t3.metaKey || e3 < " " || !i3 || -1 < i3.indexOf(e3);
  }, _doKeyUp: function(t3) {
    t3 = V.datepicker._getInst(t3.target);
    if (t3.input.val() !== t3.lastVal) try {
      V.datepicker.parseDate(V.datepicker._get(t3, "dateFormat"), t3.input ? t3.input.val() : null, V.datepicker._getFormatConfig(t3)) && (V.datepicker._setDateFromField(t3), V.datepicker._updateAlternate(t3), V.datepicker._updateDatepicker(t3));
    } catch (t4) {
    }
    return true;
  }, _showDatepicker: function(t3) {
    var e3, i3, s3, n3;
    "input" !== (t3 = t3.target || t3).nodeName.toLowerCase() && (t3 = V("input", t3.parentNode)[0]), V.datepicker._isDisabledDatepicker(t3) || V.datepicker._lastInput === t3 || (n3 = V.datepicker._getInst(t3), V.datepicker._curInst && V.datepicker._curInst !== n3 && (V.datepicker._curInst.dpDiv.stop(true, true), n3) && V.datepicker._datepickerShowing && V.datepicker._hideDatepicker(V.datepicker._curInst.input[0]), false === (i3 = (i3 = V.datepicker._get(n3, "beforeShow")) ? i3.apply(t3, [t3, n3]) : {})) || (H(n3.settings, i3), n3.lastVal = null, V.datepicker._lastInput = t3, V.datepicker._setDateFromField(n3), V.datepicker._inDialog && (t3.value = ""), V.datepicker._pos || (V.datepicker._pos = V.datepicker._findPos(t3), V.datepicker._pos[1] += t3.offsetHeight), e3 = false, V(t3).parents().each(function() {
      return !(e3 |= "fixed" === V(this).css("position"));
    }), i3 = { left: V.datepicker._pos[0], top: V.datepicker._pos[1] }, V.datepicker._pos = null, n3.dpDiv.empty(), n3.dpDiv.css({ position: "absolute", display: "block", top: "-1000px" }), V.datepicker._updateDatepicker(n3), i3 = V.datepicker._checkOffset(n3, i3, e3), n3.dpDiv.css({ position: V.datepicker._inDialog && V.blockUI ? "static" : e3 ? "fixed" : "absolute", display: "none", left: i3.left + "px", top: i3.top + "px" }), n3.inline) || (i3 = V.datepicker._get(n3, "showAnim"), s3 = V.datepicker._get(n3, "duration"), n3.dpDiv.css("z-index", function(t4) {
      for (var e4; t4.length && t4[0] !== document; ) {
        if (("absolute" === (e4 = t4.css("position")) || "relative" === e4 || "fixed" === e4) && (e4 = parseInt(t4.css("zIndex"), 10), !isNaN(e4)) && 0 !== e4) return e4;
        t4 = t4.parent();
      }
      return 0;
    }(V(t3)) + 1), V.datepicker._datepickerShowing = true, V.effects && V.effects.effect[i3] ? n3.dpDiv.show(i3, V.datepicker._get(n3, "showOptions"), s3) : n3.dpDiv[i3 || "show"](i3 ? s3 : null), V.datepicker._shouldFocusInput(n3) && n3.input.trigger("focus"), V.datepicker._curInst = n3);
  }, _updateDatepicker: function(t3) {
    this.maxRows = 4, (S = t3).dpDiv.empty().append(this._generateHTML(t3)), this._attachHandlers(t3);
    var e3, i3 = this._getNumberOfMonths(t3), s3 = i3[1], n3 = t3.dpDiv.find("." + this._dayOverClass + " a"), o3 = V.datepicker._get(t3, "onUpdateDatepicker");
    0 < n3.length && at.apply(n3.get(0)), t3.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), 1 < s3 && t3.dpDiv.addClass("ui-datepicker-multi-" + s3).css("width", 17 * s3 + "em"), t3.dpDiv[(1 !== i3[0] || 1 !== i3[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), t3.dpDiv[(this._get(t3, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), t3 === V.datepicker._curInst && V.datepicker._datepickerShowing && V.datepicker._shouldFocusInput(t3) && t3.input.trigger("focus"), t3.yearshtml && (e3 = t3.yearshtml, setTimeout(function() {
      e3 === t3.yearshtml && t3.yearshtml && t3.dpDiv.find("select.ui-datepicker-year").first().replaceWith(t3.yearshtml), e3 = t3.yearshtml = null;
    }, 0)), o3 && o3.apply(t3.input ? t3.input[0] : null, [t3]);
  }, _shouldFocusInput: function(t3) {
    return t3.input && t3.input.is(":visible") && !t3.input.is(":disabled");
  }, _checkOffset: function(t3, e3, i3) {
    var s3 = t3.dpDiv.outerWidth(), n3 = t3.dpDiv.outerHeight(), o3 = t3.input ? t3.input.outerWidth() : 0, a3 = t3.input ? t3.input.outerHeight() : 0, r3 = document.documentElement.clientWidth + (i3 ? 0 : V(document).scrollLeft()), l3 = document.documentElement.clientHeight + (i3 ? 0 : V(document).scrollTop());
    return e3.left -= this._get(t3, "isRTL") ? s3 - o3 : 0, e3.left -= i3 && e3.left === t3.input.offset().left ? V(document).scrollLeft() : 0, e3.top -= i3 && e3.top === t3.input.offset().top + a3 ? V(document).scrollTop() : 0, e3.left -= Math.min(e3.left, e3.left + s3 > r3 && s3 < r3 ? Math.abs(e3.left + s3 - r3) : 0), e3.top -= Math.min(e3.top, e3.top + n3 > l3 && n3 < l3 ? Math.abs(n3 + a3) : 0), e3;
  }, _findPos: function(t3) {
    for (var e3 = this._getInst(t3), i3 = this._get(e3, "isRTL"); t3 && ("hidden" === t3.type || 1 !== t3.nodeType || V.expr.pseudos.hidden(t3)); ) t3 = t3[i3 ? "previousSibling" : "nextSibling"];
    return [(e3 = V(t3).offset()).left, e3.top];
  }, _hideDatepicker: function(t3) {
    var e3, i3, s3 = this._curInst;
    !s3 || t3 && s3 !== V.data(t3, "datepicker") || this._datepickerShowing && (t3 = this._get(s3, "showAnim"), i3 = this._get(s3, "duration"), e3 = function() {
      V.datepicker._tidyDialog(s3);
    }, V.effects && V.effects.effect[t3] ? s3.dpDiv.hide(t3, V.datepicker._get(s3, "showOptions"), i3, e3) : s3.dpDiv["slideDown" === t3 ? "slideUp" : "fadeIn" === t3 ? "fadeOut" : "hide"](t3 ? i3 : null, e3), t3 || e3(), this._datepickerShowing = false, (i3 = this._get(s3, "onClose")) && i3.apply(s3.input ? s3.input[0] : null, [s3.input ? s3.input.val() : "", s3]), this._lastInput = null, this._inDialog && (this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" }), V.blockUI) && (V.unblockUI(), V("body").append(this.dpDiv)), this._inDialog = false);
  }, _tidyDialog: function(t3) {
    t3.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar");
  }, _checkExternalClick: function(t3) {
    var e3;
    V.datepicker._curInst && (t3 = V(t3.target), e3 = V.datepicker._getInst(t3[0]), !(t3[0].id === V.datepicker._mainDivId || 0 !== t3.parents("#" + V.datepicker._mainDivId).length || t3.hasClass(V.datepicker.markerClassName) || t3.closest("." + V.datepicker._triggerClass).length || !V.datepicker._datepickerShowing || V.datepicker._inDialog && V.blockUI) || t3.hasClass(V.datepicker.markerClassName) && V.datepicker._curInst !== e3) && V.datepicker._hideDatepicker();
  }, _adjustDate: function(t3, e3, i3) {
    var t3 = V(t3), s3 = this._getInst(t3[0]);
    this._isDisabledDatepicker(t3[0]) || (this._adjustInstDate(s3, e3, i3), this._updateDatepicker(s3));
  }, _gotoToday: function(t3) {
    var e3, t3 = V(t3), i3 = this._getInst(t3[0]);
    this._get(i3, "gotoCurrent") && i3.currentDay ? (i3.selectedDay = i3.currentDay, i3.drawMonth = i3.selectedMonth = i3.currentMonth, i3.drawYear = i3.selectedYear = i3.currentYear) : (e3 = /* @__PURE__ */ new Date(), i3.selectedDay = e3.getDate(), i3.drawMonth = i3.selectedMonth = e3.getMonth(), i3.drawYear = i3.selectedYear = e3.getFullYear()), this._notifyChange(i3), this._adjustDate(t3);
  }, _selectMonthYear: function(t3, e3, i3) {
    var t3 = V(t3), s3 = this._getInst(t3[0]);
    s3["selected" + ("M" === i3 ? "Month" : "Year")] = s3["draw" + ("M" === i3 ? "Month" : "Year")] = parseInt(e3.options[e3.selectedIndex].value, 10), this._notifyChange(s3), this._adjustDate(t3);
  }, _selectDay: function(t3, e3, i3, s3) {
    var n3 = V(t3);
    V(s3).hasClass(this._unselectableClass) || this._isDisabledDatepicker(n3[0]) || ((n3 = this._getInst(n3[0])).selectedDay = n3.currentDay = parseInt(V("a", s3).attr("data-date")), n3.selectedMonth = n3.currentMonth = e3, n3.selectedYear = n3.currentYear = i3, this._selectDate(t3, this._formatDate(n3, n3.currentDay, n3.currentMonth, n3.currentYear)));
  }, _clearDate: function(t3) {
    t3 = V(t3);
    this._selectDate(t3, "");
  }, _selectDate: function(t3, e3) {
    var i3, t3 = V(t3), t3 = this._getInst(t3[0]);
    e3 = null != e3 ? e3 : this._formatDate(t3), t3.input && t3.input.val(e3), this._updateAlternate(t3), (i3 = this._get(t3, "onSelect")) ? i3.apply(t3.input ? t3.input[0] : null, [e3, t3]) : t3.input && t3.input.trigger("change"), t3.inline ? this._updateDatepicker(t3) : (this._hideDatepicker(), this._lastInput = t3.input[0], "object" != typeof t3.input[0] && t3.input.trigger("focus"), this._lastInput = null);
  }, _updateAlternate: function(t3) {
    var e3, i3, s3 = this._get(t3, "altField");
    s3 && (i3 = this._get(t3, "altFormat") || this._get(t3, "dateFormat"), e3 = this._getDate(t3), i3 = this.formatDate(i3, e3, this._getFormatConfig(t3)), V(document).find(s3).val(i3));
  }, noWeekends: function(t3) {
    t3 = t3.getDay();
    return [0 < t3 && t3 < 6, ""];
  }, iso8601Week: function(t3) {
    var e3, t3 = new Date(t3.getTime());
    return t3.setDate(t3.getDate() + 4 - (t3.getDay() || 7)), e3 = t3.getTime(), t3.setMonth(0), t3.setDate(1), Math.floor(Math.round((e3 - t3) / 864e5) / 7) + 1;
  }, parseDate: function(e3, n3, t3) {
    if (null == e3 || null == n3) throw "Invalid arguments";
    if ("" === (n3 = "object" == typeof n3 ? n3.toString() : n3 + "")) return null;
    for (var i3, s3, o3 = 0, a3 = (t3 ? t3.shortYearCutoff : null) || this._defaults.shortYearCutoff, a3 = "string" != typeof a3 ? a3 : (/* @__PURE__ */ new Date()).getFullYear() % 100 + parseInt(a3, 10), r3 = (t3 ? t3.dayNamesShort : null) || this._defaults.dayNamesShort, l3 = (t3 ? t3.dayNames : null) || this._defaults.dayNames, h3 = (t3 ? t3.monthNamesShort : null) || this._defaults.monthNamesShort, c3 = (t3 ? t3.monthNames : null) || this._defaults.monthNames, u2 = -1, d3 = -1, p2 = -1, f3 = -1, g2 = false, m3 = function(t4) {
      t4 = y2 + 1 < e3.length && e3.charAt(y2 + 1) === t4;
      return t4 && y2++, t4;
    }, _4 = function(t4) {
      var e4 = m3(t4), e4 = "@" === t4 ? 14 : "!" === t4 ? 20 : "y" === t4 && e4 ? 4 : "o" === t4 ? 3 : 2, t4 = new RegExp("^\\d{" + ("y" === t4 ? e4 : 1) + "," + e4 + "}"), e4 = n3.substring(o3).match(t4);
      if (e4) return o3 += e4[0].length, parseInt(e4[0], 10);
      throw "Missing number at position " + o3;
    }, v2 = function(t4, e4, i4) {
      var s4 = -1, t4 = V.map(m3(t4) ? i4 : e4, function(t5, e5) {
        return [[e5, t5]];
      }).sort(function(t5, e5) {
        return -(t5[1].length - e5[1].length);
      });
      if (V.each(t4, function(t5, e5) {
        var i5 = e5[1];
        if (n3.substr(o3, i5.length).toLowerCase() === i5.toLowerCase()) return s4 = e5[0], o3 += i5.length, false;
      }), -1 !== s4) return s4 + 1;
      throw "Unknown name at position " + o3;
    }, b2 = function() {
      if (n3.charAt(o3) !== e3.charAt(y2)) throw "Unexpected literal at position " + o3;
      o3++;
    }, y2 = 0; y2 < e3.length; y2++) if (g2) "'" !== e3.charAt(y2) || m3("'") ? b2() : g2 = false;
    else switch (e3.charAt(y2)) {
      case "d":
        p2 = _4("d");
        break;
      case "D":
        v2("D", r3, l3);
        break;
      case "o":
        f3 = _4("o");
        break;
      case "m":
        d3 = _4("m");
        break;
      case "M":
        d3 = v2("M", h3, c3);
        break;
      case "y":
        u2 = _4("y");
        break;
      case "@":
        u2 = (s3 = new Date(_4("@"))).getFullYear(), d3 = s3.getMonth() + 1, p2 = s3.getDate();
        break;
      case "!":
        u2 = (s3 = new Date((_4("!") - this._ticksTo1970) / 1e4)).getFullYear(), d3 = s3.getMonth() + 1, p2 = s3.getDate();
        break;
      case "'":
        m3("'") ? b2() : g2 = true;
        break;
      default:
        b2();
    }
    if (o3 < n3.length && (t3 = n3.substr(o3), !/^\s+/.test(t3))) throw "Extra/unparsed characters found in date: " + t3;
    if (-1 === u2 ? u2 = (/* @__PURE__ */ new Date()).getFullYear() : u2 < 100 && (u2 += (/* @__PURE__ */ new Date()).getFullYear() - (/* @__PURE__ */ new Date()).getFullYear() % 100 + (u2 <= a3 ? 0 : -100)), -1 < f3) for (d3 = 1, p2 = f3; ; ) {
      if (p2 <= (i3 = this._getDaysInMonth(u2, d3 - 1))) break;
      d3++, p2 -= i3;
    }
    if ((s3 = this._daylightSavingAdjust(new Date(u2, d3 - 1, p2))).getFullYear() !== u2 || s3.getMonth() + 1 !== d3 || s3.getDate() !== p2) throw "Invalid date";
    return s3;
  }, ATOM: "yy-mm-dd", COOKIE: "D, dd M yy", ISO_8601: "yy-mm-dd", RFC_822: "D, d M y", RFC_850: "DD, dd-M-y", RFC_1036: "D, d M y", RFC_1123: "D, d M yy", RFC_2822: "D, d M yy", RSS: "D, d M y", TICKS: "!", TIMESTAMP: "@", W3C: "yy-mm-dd", _ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7, formatDate: function(e3, t3, i3) {
    if (!t3) return "";
    function s3(t4, e4, i4) {
      var s4 = "" + e4;
      if (c3(t4)) for (; s4.length < i4; ) s4 = "0" + s4;
      return s4;
    }
    function n3(t4, e4, i4, s4) {
      return (c3(t4) ? s4 : i4)[e4];
    }
    var o3, a3 = (i3 ? i3.dayNamesShort : null) || this._defaults.dayNamesShort, r3 = (i3 ? i3.dayNames : null) || this._defaults.dayNames, l3 = (i3 ? i3.monthNamesShort : null) || this._defaults.monthNamesShort, h3 = (i3 ? i3.monthNames : null) || this._defaults.monthNames, c3 = function(t4) {
      t4 = o3 + 1 < e3.length && e3.charAt(o3 + 1) === t4;
      return t4 && o3++, t4;
    }, u2 = "", d3 = false;
    if (t3) for (o3 = 0; o3 < e3.length; o3++) if (d3) "'" !== e3.charAt(o3) || c3("'") ? u2 += e3.charAt(o3) : d3 = false;
    else switch (e3.charAt(o3)) {
      case "d":
        u2 += s3("d", t3.getDate(), 2);
        break;
      case "D":
        u2 += n3("D", t3.getDay(), a3, r3);
        break;
      case "o":
        u2 += s3("o", Math.round((new Date(t3.getFullYear(), t3.getMonth(), t3.getDate()).getTime() - new Date(t3.getFullYear(), 0, 0).getTime()) / 864e5), 3);
        break;
      case "m":
        u2 += s3("m", t3.getMonth() + 1, 2);
        break;
      case "M":
        u2 += n3("M", t3.getMonth(), l3, h3);
        break;
      case "y":
        u2 += c3("y") ? t3.getFullYear() : (t3.getFullYear() % 100 < 10 ? "0" : "") + t3.getFullYear() % 100;
        break;
      case "@":
        u2 += t3.getTime();
        break;
      case "!":
        u2 += 1e4 * t3.getTime() + this._ticksTo1970;
        break;
      case "'":
        c3("'") ? u2 += "'" : d3 = true;
        break;
      default:
        u2 += e3.charAt(o3);
    }
    return u2;
  }, _possibleChars: function(e3) {
    for (var t3 = "", i3 = false, s3 = function(t4) {
      t4 = n3 + 1 < e3.length && e3.charAt(n3 + 1) === t4;
      return t4 && n3++, t4;
    }, n3 = 0; n3 < e3.length; n3++) if (i3) "'" !== e3.charAt(n3) || s3("'") ? t3 += e3.charAt(n3) : i3 = false;
    else switch (e3.charAt(n3)) {
      case "d":
      case "m":
      case "y":
      case "@":
        t3 += "0123456789";
        break;
      case "D":
      case "M":
        return null;
      case "'":
        s3("'") ? t3 += "'" : i3 = true;
        break;
      default:
        t3 += e3.charAt(n3);
    }
    return t3;
  }, _get: function(t3, e3) {
    return (void 0 !== t3.settings[e3] ? t3.settings : this._defaults)[e3];
  }, _setDateFromField: function(t3, e3) {
    if (t3.input.val() !== t3.lastVal) {
      var i3 = this._get(t3, "dateFormat"), s3 = t3.lastVal = t3.input ? t3.input.val() : null, n3 = this._getDefaultDate(t3), o3 = n3, a3 = this._getFormatConfig(t3);
      try {
        o3 = this.parseDate(i3, s3, a3) || n3;
      } catch (t4) {
        s3 = e3 ? "" : s3;
      }
      t3.selectedDay = o3.getDate(), t3.drawMonth = t3.selectedMonth = o3.getMonth(), t3.drawYear = t3.selectedYear = o3.getFullYear(), t3.currentDay = s3 ? o3.getDate() : 0, t3.currentMonth = s3 ? o3.getMonth() : 0, t3.currentYear = s3 ? o3.getFullYear() : 0, this._adjustInstDate(t3);
    }
  }, _getDefaultDate: function(t3) {
    return this._restrictMinMax(t3, this._determineDate(t3, this._get(t3, "defaultDate"), /* @__PURE__ */ new Date()));
  }, _determineDate: function(r3, t3, e3) {
    var i3, s3 = null == t3 || "" === t3 ? e3 : "string" == typeof t3 ? function(t4) {
      try {
        return V.datepicker.parseDate(V.datepicker._get(r3, "dateFormat"), t4, V.datepicker._getFormatConfig(r3));
      } catch (t5) {
      }
      for (var e4 = (t4.toLowerCase().match(/^c/) ? V.datepicker._getDate(r3) : null) || /* @__PURE__ */ new Date(), i4 = e4.getFullYear(), s4 = e4.getMonth(), n3 = e4.getDate(), o3 = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, a3 = o3.exec(t4); a3; ) {
        switch (a3[2] || "d") {
          case "d":
          case "D":
            n3 += parseInt(a3[1], 10);
            break;
          case "w":
          case "W":
            n3 += 7 * parseInt(a3[1], 10);
            break;
          case "m":
          case "M":
            s4 += parseInt(a3[1], 10), n3 = Math.min(n3, V.datepicker._getDaysInMonth(i4, s4));
            break;
          case "y":
          case "Y":
            i4 += parseInt(a3[1], 10), n3 = Math.min(n3, V.datepicker._getDaysInMonth(i4, s4));
        }
        a3 = o3.exec(t4);
      }
      return new Date(i4, s4, n3);
    }(t3) : "number" == typeof t3 ? isNaN(t3) ? e3 : (s3 = t3, (i3 = /* @__PURE__ */ new Date()).setDate(i3.getDate() + s3), i3) : new Date(t3.getTime());
    return (s3 = s3 && "Invalid Date" === s3.toString() ? e3 : s3) && (s3.setHours(0), s3.setMinutes(0), s3.setSeconds(0), s3.setMilliseconds(0)), this._daylightSavingAdjust(s3);
  }, _daylightSavingAdjust: function(t3) {
    return t3 ? (t3.setHours(12 < t3.getHours() ? t3.getHours() + 2 : 0), t3) : null;
  }, _setDate: function(t3, e3, i3) {
    var s3 = !e3, n3 = t3.selectedMonth, o3 = t3.selectedYear, e3 = this._restrictMinMax(t3, this._determineDate(t3, e3, /* @__PURE__ */ new Date()));
    t3.selectedDay = t3.currentDay = e3.getDate(), t3.drawMonth = t3.selectedMonth = t3.currentMonth = e3.getMonth(), t3.drawYear = t3.selectedYear = t3.currentYear = e3.getFullYear(), n3 === t3.selectedMonth && o3 === t3.selectedYear || i3 || this._notifyChange(t3), this._adjustInstDate(t3), t3.input && t3.input.val(s3 ? "" : this._formatDate(t3));
  }, _getDate: function(t3) {
    return !t3.currentYear || t3.input && "" === t3.input.val() ? null : this._daylightSavingAdjust(new Date(t3.currentYear, t3.currentMonth, t3.currentDay));
  }, _attachHandlers: function(t3) {
    var e3 = this._get(t3, "stepMonths"), i3 = "#" + t3.id.replace(/\\\\/g, "\\");
    t3.dpDiv.find("[data-handler]").map(function() {
      var t4 = { prev: function() {
        V.datepicker._adjustDate(i3, -e3, "M");
      }, next: function() {
        V.datepicker._adjustDate(i3, +e3, "M");
      }, hide: function() {
        V.datepicker._hideDatepicker();
      }, today: function() {
        V.datepicker._gotoToday(i3);
      }, selectDay: function() {
        return V.datepicker._selectDay(i3, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), false;
      }, selectMonth: function() {
        return V.datepicker._selectMonthYear(i3, this, "M"), false;
      }, selectYear: function() {
        return V.datepicker._selectMonthYear(i3, this, "Y"), false;
      } };
      V(this).on(this.getAttribute("data-event"), t4[this.getAttribute("data-handler")]);
    });
  }, _generateHTML: function(t3) {
    var e3, i3, s3, n3, o3, N2, W2, F2, L2, a3, r3, R2, l3, h3, c3, u2, d3, p2, f3, g2, m3, _4, Y3, v2, b2, B2, y2, j2, q2, w2, k2, x2, C2 = /* @__PURE__ */ new Date(), K2 = this._daylightSavingAdjust(new Date(C2.getFullYear(), C2.getMonth(), C2.getDate())), D2 = this._get(t3, "isRTL"), C2 = this._get(t3, "showButtonPanel"), I3 = this._get(t3, "hideIfNoPrevNext"), T2 = this._get(t3, "navigationAsDateFormat"), P2 = this._getNumberOfMonths(t3), M2 = this._get(t3, "showCurrentAtPos"), S2 = this._get(t3, "stepMonths"), U2 = 1 !== P2[0] || 1 !== P2[1], H2 = this._daylightSavingAdjust(t3.currentDay ? new Date(t3.currentYear, t3.currentMonth, t3.currentDay) : new Date(9999, 9, 9)), z2 = this._getMinMaxDate(t3, "min"), O2 = this._getMinMaxDate(t3, "max"), A2 = t3.drawMonth - M2, E2 = t3.drawYear;
    if (A2 < 0 && (A2 += 12, E2--), O2) for (e3 = this._daylightSavingAdjust(new Date(O2.getFullYear(), O2.getMonth() - P2[0] * P2[1] + 1, O2.getDate())), e3 = z2 && e3 < z2 ? z2 : e3; this._daylightSavingAdjust(new Date(E2, A2, 1)) > e3; ) --A2 < 0 && (A2 = 11, E2--);
    for (t3.drawMonth = A2, t3.drawYear = E2, M2 = this._get(t3, "prevText"), M2 = T2 ? this.formatDate(M2, this._daylightSavingAdjust(new Date(E2, A2 - S2, 1)), this._getFormatConfig(t3)) : M2, i3 = this._canAdjustMonth(t3, -1, E2, A2) ? V("<a>").attr({ class: "ui-datepicker-prev ui-corner-all", "data-handler": "prev", "data-event": "click", title: M2 }).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (D2 ? "e" : "w")).text(M2))[0].outerHTML : I3 ? "" : V("<a>").attr({ class: "ui-datepicker-prev ui-corner-all ui-state-disabled", title: M2 }).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (D2 ? "e" : "w")).text(M2))[0].outerHTML, M2 = this._get(t3, "nextText"), M2 = T2 ? this.formatDate(M2, this._daylightSavingAdjust(new Date(E2, A2 + S2, 1)), this._getFormatConfig(t3)) : M2, s3 = this._canAdjustMonth(t3, 1, E2, A2) ? V("<a>").attr({ class: "ui-datepicker-next ui-corner-all", "data-handler": "next", "data-event": "click", title: M2 }).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (D2 ? "w" : "e")).text(M2))[0].outerHTML : I3 ? "" : V("<a>").attr({ class: "ui-datepicker-next ui-corner-all ui-state-disabled", title: M2 }).append(V("<span>").attr("class", "ui-icon ui-icon-circle-triangle-" + (D2 ? "w" : "e")).text(M2))[0].outerHTML, S2 = this._get(t3, "currentText"), I3 = this._get(t3, "gotoCurrent") && t3.currentDay ? H2 : K2, S2 = T2 ? this.formatDate(S2, I3, this._getFormatConfig(t3)) : S2, M2 = "", t3.inline || (M2 = V("<button>").attr({ type: "button", class: "ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all", "data-handler": "hide", "data-event": "click" }).text(this._get(t3, "closeText"))[0].outerHTML), T2 = "", C2 && (T2 = V("<div class='ui-datepicker-buttonpane ui-widget-content'>").append(D2 ? M2 : "").append(this._isInRange(t3, I3) ? V("<button>").attr({ type: "button", class: "ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all", "data-handler": "today", "data-event": "click" }).text(S2) : "").append(D2 ? "" : M2)[0].outerHTML), n3 = parseInt(this._get(t3, "firstDay"), 10), n3 = isNaN(n3) ? 0 : n3, o3 = this._get(t3, "showWeek"), N2 = this._get(t3, "dayNames"), W2 = this._get(t3, "dayNamesMin"), F2 = this._get(t3, "monthNames"), L2 = this._get(t3, "monthNamesShort"), a3 = this._get(t3, "beforeShowDay"), r3 = this._get(t3, "showOtherMonths"), R2 = this._get(t3, "selectOtherMonths"), l3 = this._getDefaultDate(t3), h3 = "", u2 = 0; u2 < P2[0]; u2++) {
      for (d3 = "", this.maxRows = 4, p2 = 0; p2 < P2[1]; p2++) {
        if (f3 = this._daylightSavingAdjust(new Date(E2, A2, t3.selectedDay)), g2 = " ui-corner-all", m3 = "", U2) {
          if (m3 += "<div class='ui-datepicker-group", 1 < P2[1]) switch (p2) {
            case 0:
              m3 += " ui-datepicker-group-first", g2 = " ui-corner-" + (D2 ? "right" : "left");
              break;
            case P2[1] - 1:
              m3 += " ui-datepicker-group-last", g2 = " ui-corner-" + (D2 ? "left" : "right");
              break;
            default:
              m3 += " ui-datepicker-group-middle", g2 = "";
          }
          m3 += "'>";
        }
        for (m3 += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + g2 + "'>" + (/all|left/.test(g2) && 0 === u2 ? D2 ? s3 : i3 : "") + (/all|right/.test(g2) && 0 === u2 ? D2 ? i3 : s3 : "") + this._generateMonthYearHeader(t3, A2, E2, z2, O2, 0 < u2 || 0 < p2, F2, L2) + "</div><table class='ui-datepicker-calendar'><thead><tr>", _4 = o3 ? "<th class='ui-datepicker-week-col'>" + this._get(t3, "weekHeader") + "</th>" : "", c3 = 0; c3 < 7; c3++) _4 += "<th scope='col'" + (5 <= (c3 + n3 + 6) % 7 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + N2[Y3 = (c3 + n3) % 7] + "'>" + W2[Y3] + "</span></th>";
        for (m3 += _4 + "</tr></thead><tbody>", b2 = this._getDaysInMonth(E2, A2), E2 === t3.selectedYear && A2 === t3.selectedMonth && (t3.selectedDay = Math.min(t3.selectedDay, b2)), v2 = (this._getFirstDayOfMonth(E2, A2) - n3 + 7) % 7, b2 = Math.ceil((v2 + b2) / 7), B2 = U2 && this.maxRows > b2 ? this.maxRows : b2, this.maxRows = B2, y2 = this._daylightSavingAdjust(new Date(E2, A2, 1 - v2)), j2 = 0; j2 < B2; j2++) {
          for (m3 += "<tr>", q2 = o3 ? "<td class='ui-datepicker-week-col'>" + this._get(t3, "calculateWeek")(y2) + "</td>" : "", c3 = 0; c3 < 7; c3++) w2 = a3 ? a3.apply(t3.input ? t3.input[0] : null, [y2]) : [true, ""], x2 = (k2 = y2.getMonth() !== A2) && !R2 || !w2[0] || z2 && y2 < z2 || O2 && O2 < y2, q2 += "<td class='" + (5 <= (c3 + n3 + 6) % 7 ? " ui-datepicker-week-end" : "") + (k2 ? " ui-datepicker-other-month" : "") + (y2.getTime() === f3.getTime() && A2 === t3.selectedMonth && t3._keyEvent || l3.getTime() === y2.getTime() && l3.getTime() === f3.getTime() ? " " + this._dayOverClass : "") + (x2 ? " " + this._unselectableClass + " ui-state-disabled" : "") + (k2 && !r3 ? "" : " " + w2[1] + (y2.getTime() === H2.getTime() ? " " + this._currentClass : "") + (y2.getTime() === K2.getTime() ? " ui-datepicker-today" : "")) + "'" + (k2 && !r3 || !w2[2] ? "" : " title='" + w2[2].replace(/'/g, "&#39;") + "'") + (x2 ? "" : " data-handler='selectDay' data-event='click' data-month='" + y2.getMonth() + "' data-year='" + y2.getFullYear() + "'") + ">" + (k2 && !r3 ? "&#xa0;" : x2 ? "<span class='ui-state-default'>" + y2.getDate() + "</span>" : "<a class='ui-state-default" + (y2.getTime() === K2.getTime() ? " ui-state-highlight" : "") + (y2.getTime() === H2.getTime() ? " ui-state-active" : "") + (k2 ? " ui-priority-secondary" : "") + "' href='#' aria-current='" + (y2.getTime() === H2.getTime() ? "true" : "false") + "' data-date='" + y2.getDate() + "'>" + y2.getDate() + "</a>") + "</td>", y2.setDate(y2.getDate() + 1), y2 = this._daylightSavingAdjust(y2);
          m3 += q2 + "</tr>";
        }
        11 < ++A2 && (A2 = 0, E2++), d3 += m3 += "</tbody></table>" + (U2 ? "</div>" + (0 < P2[0] && p2 === P2[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
      }
      h3 += d3;
    }
    return h3 += T2, t3._keyEvent = false, h3;
  }, _generateMonthYearHeader: function(t3, e3, i3, s3, n3, o3, a3, r3) {
    var l3, h3, c3, u2, d3, p2, f3 = this._get(t3, "changeMonth"), g2 = this._get(t3, "changeYear"), m3 = this._get(t3, "showMonthAfterYear"), _4 = this._get(t3, "selectMonthLabel"), v2 = this._get(t3, "selectYearLabel"), b2 = "<div class='ui-datepicker-title'>", y2 = "";
    if (o3 || !f3) y2 += "<span class='ui-datepicker-month'>" + a3[e3] + "</span>";
    else {
      for (l3 = s3 && s3.getFullYear() === i3, h3 = n3 && n3.getFullYear() === i3, y2 += "<select class='ui-datepicker-month' aria-label='" + _4 + "' data-handler='selectMonth' data-event='change'>", c3 = 0; c3 < 12; c3++) (!l3 || c3 >= s3.getMonth()) && (!h3 || c3 <= n3.getMonth()) && (y2 += "<option value='" + c3 + "'" + (c3 === e3 ? " selected='selected'" : "") + ">" + r3[c3] + "</option>");
      y2 += "</select>";
    }
    if (m3 || (b2 += y2 + (!o3 && f3 && g2 ? "" : "&#xa0;")), !t3.yearshtml) if (t3.yearshtml = "", o3 || !g2) b2 += "<span class='ui-datepicker-year'>" + i3 + "</span>";
    else {
      for (a3 = this._get(t3, "yearRange").split(":"), u2 = (/* @__PURE__ */ new Date()).getFullYear(), d3 = (_4 = function(t4) {
        t4 = t4.match(/c[+\-].*/) ? i3 + parseInt(t4.substring(1), 10) : t4.match(/[+\-].*/) ? u2 + parseInt(t4, 10) : parseInt(t4, 10);
        return isNaN(t4) ? u2 : t4;
      })(a3[0]), p2 = Math.max(d3, _4(a3[1] || "")), d3 = s3 ? Math.max(d3, s3.getFullYear()) : d3, p2 = n3 ? Math.min(p2, n3.getFullYear()) : p2, t3.yearshtml += "<select class='ui-datepicker-year' aria-label='" + v2 + "' data-handler='selectYear' data-event='change'>"; d3 <= p2; d3++) t3.yearshtml += "<option value='" + d3 + "'" + (d3 === i3 ? " selected='selected'" : "") + ">" + d3 + "</option>";
      t3.yearshtml += "</select>", b2 += t3.yearshtml, t3.yearshtml = null;
    }
    return b2 += this._get(t3, "yearSuffix"), m3 && (b2 += (!o3 && f3 && g2 ? "" : "&#xa0;") + y2), b2 += "</div>";
  }, _adjustInstDate: function(t3, e3, i3) {
    var s3 = t3.selectedYear + ("Y" === i3 ? e3 : 0), n3 = t3.selectedMonth + ("M" === i3 ? e3 : 0), e3 = Math.min(t3.selectedDay, this._getDaysInMonth(s3, n3)) + ("D" === i3 ? e3 : 0), s3 = this._restrictMinMax(t3, this._daylightSavingAdjust(new Date(s3, n3, e3)));
    t3.selectedDay = s3.getDate(), t3.drawMonth = t3.selectedMonth = s3.getMonth(), t3.drawYear = t3.selectedYear = s3.getFullYear(), "M" !== i3 && "Y" !== i3 || this._notifyChange(t3);
  }, _restrictMinMax: function(t3, e3) {
    var i3 = this._getMinMaxDate(t3, "min"), t3 = this._getMinMaxDate(t3, "max"), i3 = i3 && e3 < i3 ? i3 : e3;
    return t3 && t3 < i3 ? t3 : i3;
  }, _notifyChange: function(t3) {
    var e3 = this._get(t3, "onChangeMonthYear");
    e3 && e3.apply(t3.input ? t3.input[0] : null, [t3.selectedYear, t3.selectedMonth + 1, t3]);
  }, _getNumberOfMonths: function(t3) {
    t3 = this._get(t3, "numberOfMonths");
    return null == t3 ? [1, 1] : "number" == typeof t3 ? [1, t3] : t3;
  }, _getMinMaxDate: function(t3, e3) {
    return this._determineDate(t3, this._get(t3, e3 + "Date"), null);
  }, _getDaysInMonth: function(t3, e3) {
    return 32 - this._daylightSavingAdjust(new Date(t3, e3, 32)).getDate();
  }, _getFirstDayOfMonth: function(t3, e3) {
    return new Date(t3, e3, 1).getDay();
  }, _canAdjustMonth: function(t3, e3, i3, s3) {
    var n3 = this._getNumberOfMonths(t3), i3 = this._daylightSavingAdjust(new Date(i3, s3 + (e3 < 0 ? e3 : n3[0] * n3[1]), 1));
    return e3 < 0 && i3.setDate(this._getDaysInMonth(i3.getFullYear(), i3.getMonth())), this._isInRange(t3, i3);
  }, _isInRange: function(t3, e3) {
    var i3, s3 = this._getMinMaxDate(t3, "min"), n3 = this._getMinMaxDate(t3, "max"), o3 = null, a3 = null, t3 = this._get(t3, "yearRange");
    return t3 && (t3 = t3.split(":"), i3 = (/* @__PURE__ */ new Date()).getFullYear(), o3 = parseInt(t3[0], 10), a3 = parseInt(t3[1], 10), t3[0].match(/[+\-].*/) && (o3 += i3), t3[1].match(/[+\-].*/)) && (a3 += i3), (!s3 || e3.getTime() >= s3.getTime()) && (!n3 || e3.getTime() <= n3.getTime()) && (!o3 || e3.getFullYear() >= o3) && (!a3 || e3.getFullYear() <= a3);
  }, _getFormatConfig: function(t3) {
    var e3 = this._get(t3, "shortYearCutoff");
    return { shortYearCutoff: "string" != typeof e3 ? e3 : (/* @__PURE__ */ new Date()).getFullYear() % 100 + parseInt(e3, 10), dayNamesShort: this._get(t3, "dayNamesShort"), dayNames: this._get(t3, "dayNames"), monthNamesShort: this._get(t3, "monthNamesShort"), monthNames: this._get(t3, "monthNames") };
  }, _formatDate: function(t3, e3, i3, s3) {
    e3 || (t3.currentDay = t3.selectedDay, t3.currentMonth = t3.selectedMonth, t3.currentYear = t3.selectedYear);
    s3 = e3 ? "object" == typeof e3 ? e3 : this._daylightSavingAdjust(new Date(s3, i3, e3)) : this._daylightSavingAdjust(new Date(t3.currentYear, t3.currentMonth, t3.currentDay));
    return this.formatDate(this._get(t3, "dateFormat"), s3, this._getFormatConfig(t3));
  } }), V.fn.datepicker = function(t3) {
    if (!this.length) return this;
    V.datepicker.initialized || (V(document).on("mousedown", V.datepicker._checkExternalClick), V.datepicker.initialized = true), 0 === V("#" + V.datepicker._mainDivId).length && V("body").append(V.datepicker.dpDiv);
    var e3 = Array.prototype.slice.call(arguments, 1);
    return "string" == typeof t3 && ("isDisabled" === t3 || "getDate" === t3 || "widget" === t3) || "option" === t3 && 2 === arguments.length && "string" == typeof arguments[1] ? V.datepicker["_" + t3 + "Datepicker"].apply(V.datepicker, [this[0]].concat(e3)) : this.each(function() {
      "string" == typeof t3 ? V.datepicker["_" + t3 + "Datepicker"].apply(V.datepicker, [this].concat(e3)) : V.datepicker._attachDatepicker(this, t3);
    });
  }, V.datepicker = new nt(), V.datepicker.initialized = false, V.datepicker.uuid = (/* @__PURE__ */ new Date()).getTime(), V.datepicker.version = "1.14.0";
  V.datepicker;
  var z = false;
  V(document).on("mouseup", function() {
    z = false;
  }), V.widget("ui.mouse", { version: "1.14.0", options: { cancel: "input, textarea, button, select, option", distance: 1, delay: 0 }, _mouseInit: function() {
    var e3 = this;
    this.element.on("mousedown." + this.widgetName, function(t3) {
      return e3._mouseDown(t3);
    }).on("click." + this.widgetName, function(t3) {
      if (true === V.data(t3.target, e3.widgetName + ".preventClickEvent")) return V.removeData(t3.target, e3.widgetName + ".preventClickEvent"), t3.stopImmediatePropagation(), false;
    }), this.started = false;
  }, _mouseDestroy: function() {
    this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
  }, _mouseDown: function(t3) {
    var e3, i3, s3;
    if (!z) return this._mouseMoved = false, this._mouseStarted && this._mouseUp(t3), i3 = 1 === (this._mouseDownEvent = t3).which, s3 = "string" == typeof (e3 = this).options.cancel && V(t3.target).closest(this.options.cancel).length, i3 && !s3 && this._mouseCapture(t3) && (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
      e3.mouseDelayMet = true;
    }, this.options.delay)), this._mouseDistanceMet(t3) && this._mouseDelayMet(t3) && (this._mouseStarted = false !== this._mouseStart(t3), !this._mouseStarted) ? t3.preventDefault() : (true === V.data(t3.target, this.widgetName + ".preventClickEvent") && V.removeData(t3.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function(t4) {
      return e3._mouseMove(t4);
    }, this._mouseUpDelegate = function(t4) {
      return e3._mouseUp(t4);
    }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), t3.preventDefault(), z = true)), true;
  }, _mouseMove: function(t3) {
    if (this._mouseMoved && !t3.which) {
      if (t3.originalEvent.altKey || t3.originalEvent.ctrlKey || t3.originalEvent.metaKey || t3.originalEvent.shiftKey) this.ignoreMissingWhich = true;
      else if (!this.ignoreMissingWhich) return this._mouseUp(t3);
    }
    return (t3.which || t3.button) && (this._mouseMoved = true), this._mouseStarted ? (this._mouseDrag(t3), t3.preventDefault()) : (this._mouseDistanceMet(t3) && this._mouseDelayMet(t3) && (this._mouseStarted = false !== this._mouseStart(this._mouseDownEvent, t3), this._mouseStarted ? this._mouseDrag(t3) : this._mouseUp(t3)), !this._mouseStarted);
  }, _mouseUp: function(t3) {
    this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = false, t3.target === this._mouseDownEvent.target && V.data(t3.target, this.widgetName + ".preventClickEvent", true), this._mouseStop(t3)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = false, z = false, t3.preventDefault();
  }, _mouseDistanceMet: function(t3) {
    return Math.max(Math.abs(this._mouseDownEvent.pageX - t3.pageX), Math.abs(this._mouseDownEvent.pageY - t3.pageY)) >= this.options.distance;
  }, _mouseDelayMet: function() {
    return this.mouseDelayMet;
  }, _mouseStart: function() {
  }, _mouseDrag: function() {
  }, _mouseStop: function() {
  }, _mouseCapture: function() {
    return true;
  } }), V.ui.plugin = { add: function(t3, e3, i3) {
    var s3, n3 = V.ui[t3].prototype;
    for (s3 in i3) n3.plugins[s3] = n3.plugins[s3] || [], n3.plugins[s3].push([e3, i3[s3]]);
  }, call: function(t3, e3, i3, s3) {
    var n3, o3 = t3.plugins[e3];
    if (o3 && (s3 || t3.element[0].parentNode && 11 !== t3.element[0].parentNode.nodeType)) for (n3 = 0; n3 < o3.length; n3++) t3.options[o3[n3][0]] && o3[n3][1].apply(t3.element, i3);
  } }, V.widget("ui.draggable", V.ui.mouse, { version: "1.14.0", widgetEventPrefix: "drag", options: { addClasses: true, appendTo: "parent", axis: false, connectToSortable: false, containment: false, cursor: "auto", cursorAt: false, grid: false, handle: false, helper: "original", iframeFix: false, opacity: false, refreshPositions: false, revert: false, revertDuration: 500, scope: "default", scroll: true, scrollSensitivity: 20, scrollSpeed: 20, snap: false, snapMode: "both", snapTolerance: 20, stack: false, zIndex: false, drag: null, start: null, stop: null }, _create: function() {
    "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this._addClass("ui-draggable"), this._setHandleClassName(), this._mouseInit();
  }, _setOption: function(t3, e3) {
    this._super(t3, e3), "handle" === t3 && (this._removeHandleClassName(), this._setHandleClassName());
  }, _destroy: function() {
    (this.helper || this.element).is(".ui-draggable-dragging") ? this.destroyOnClear = true : (this._removeHandleClassName(), this._mouseDestroy());
  }, _mouseCapture: function(t3) {
    var e3 = this.options;
    return !(this.helper || e3.disabled || 0 < V(t3.target).closest(".ui-resizable-handle").length || (this.handle = this._getHandle(t3), !this.handle) || (this._blurActiveElement(t3), this._blockFrames(true === e3.iframeFix ? "iframe" : e3.iframeFix), 0));
  }, _blockFrames: function(t3) {
    this.iframeBlocks = this.document.find(t3).map(function() {
      var t4 = V(this);
      return V("<div>").css("position", "absolute").appendTo(t4.parent()).outerWidth(t4.outerWidth()).outerHeight(t4.outerHeight()).offset(t4.offset())[0];
    });
  }, _unblockFrames: function() {
    this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
  }, _blurActiveElement: function(t3) {
    var e3 = this.document[0].activeElement;
    V(t3.target).closest(e3).length || V(e3).trigger("blur");
  }, _mouseStart: function(t3) {
    var e3 = this.options;
    return this.helper = this._createHelper(t3), this._addClass(this.helper, "ui-draggable-dragging"), this._cacheHelperProportions(), V.ui.ddmanager && (V.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(true), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = 0 < this.helper.parents().filter(function() {
      return "fixed" === V(this).css("position");
    }).length, this.positionAbs = this.element.offset(), this._refreshOffsets(t3), this.originalPosition = this.position = this._generatePosition(t3, false), this.originalPageX = t3.pageX, this.originalPageY = t3.pageY, e3.cursorAt && this._adjustOffsetFromHelper(e3.cursorAt), this._setContainment(), false === this._trigger("start", t3) ? (this._clear(), false) : (this._cacheHelperProportions(), V.ui.ddmanager && !e3.dropBehaviour && V.ui.ddmanager.prepareOffsets(this, t3), this._mouseDrag(t3, true), V.ui.ddmanager && V.ui.ddmanager.dragStart(this, t3), true);
  }, _refreshOffsets: function(t3) {
    this.offset = { top: this.positionAbs.top - this.margins.top, left: this.positionAbs.left - this.margins.left, scroll: false, parent: this._getParentOffset(), relative: this._getRelativeOffset() }, this.offset.click = { left: t3.pageX - this.offset.left, top: t3.pageY - this.offset.top };
  }, _mouseDrag: function(t3, e3) {
    if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(t3, true), this.positionAbs = this._convertPositionTo("absolute"), !e3) {
      e3 = this._uiHash();
      if (false === this._trigger("drag", t3, e3)) return this._mouseUp(new V.Event("mouseup", t3)), false;
      this.position = e3.position;
    }
    return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", V.ui.ddmanager && V.ui.ddmanager.drag(this, t3), false;
  }, _mouseStop: function(t3) {
    var e3 = this, i3 = false;
    return V.ui.ddmanager && !this.options.dropBehaviour && (i3 = V.ui.ddmanager.drop(this, t3)), this.dropped && (i3 = this.dropped, this.dropped = false), "invalid" === this.options.revert && !i3 || "valid" === this.options.revert && i3 || true === this.options.revert || "function" == typeof this.options.revert && this.options.revert.call(this.element, i3) ? V(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
      false !== e3._trigger("stop", t3) && e3._clear();
    }) : false !== this._trigger("stop", t3) && this._clear(), false;
  }, _mouseUp: function(t3) {
    return this._unblockFrames(), V.ui.ddmanager && V.ui.ddmanager.dragStop(this, t3), this.handleElement.is(t3.target) && this.element.trigger("focus"), V.ui.mouse.prototype._mouseUp.call(this, t3);
  }, cancel: function() {
    return this.helper.is(".ui-draggable-dragging") ? this._mouseUp(new V.Event("mouseup", { target: this.element[0] })) : this._clear(), this;
  }, _getHandle: function(t3) {
    return !this.options.handle || !!V(t3.target).closest(this.element.find(this.options.handle)).length;
  }, _setHandleClassName: function() {
    this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this._addClass(this.handleElement, "ui-draggable-handle");
  }, _removeHandleClassName: function() {
    this._removeClass(this.handleElement, "ui-draggable-handle");
  }, _createHelper: function(t3) {
    var e3 = this.options, i3 = "function" == typeof e3.helper, t3 = i3 ? V(e3.helper.apply(this.element[0], [t3])) : "clone" === e3.helper ? this.element.clone().removeAttr("id") : this.element;
    return t3.parents("body").length || t3.appendTo("parent" === e3.appendTo ? this.element[0].parentNode : e3.appendTo), i3 && t3[0] === this.element[0] && this._setPositionRelative(), t3[0] === this.element[0] || /(fixed|absolute)/.test(t3.css("position")) || t3.css("position", "absolute"), t3;
  }, _setPositionRelative: function() {
    /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative");
  }, _adjustOffsetFromHelper: function(t3) {
    "string" == typeof t3 && (t3 = t3.split(" ")), "left" in (t3 = Array.isArray(t3) ? { left: +t3[0], top: +t3[1] || 0 } : t3) && (this.offset.click.left = t3.left + this.margins.left), "right" in t3 && (this.offset.click.left = this.helperProportions.width - t3.right + this.margins.left), "top" in t3 && (this.offset.click.top = t3.top + this.margins.top), "bottom" in t3 && (this.offset.click.top = this.helperProportions.height - t3.bottom + this.margins.top);
  }, _isRootNode: function(t3) {
    return /(html|body)/i.test(t3.tagName) || t3 === this.document[0];
  }, _getParentOffset: function() {
    var t3 = this.offsetParent.offset(), e3 = this.document[0];
    return "absolute" === this.cssPosition && this.scrollParent[0] !== e3 && V.contains(this.scrollParent[0], this.offsetParent[0]) && (t3.left += this.scrollParent.scrollLeft(), t3.top += this.scrollParent.scrollTop()), { top: (t3 = this._isRootNode(this.offsetParent[0]) ? { top: 0, left: 0 } : t3).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: t3.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0) };
  }, _getRelativeOffset: function() {
    var t3, e3;
    return "relative" !== this.cssPosition ? { top: 0, left: 0 } : (t3 = this.element.position(), e3 = this._isRootNode(this.scrollParent[0]), { top: t3.top - (parseInt(this.helper.css("top"), 10) || 0) + (e3 ? 0 : this.scrollParent.scrollTop()), left: t3.left - (parseInt(this.helper.css("left"), 10) || 0) + (e3 ? 0 : this.scrollParent.scrollLeft()) });
  }, _cacheMargins: function() {
    this.margins = { left: parseInt(this.element.css("marginLeft"), 10) || 0, top: parseInt(this.element.css("marginTop"), 10) || 0, right: parseInt(this.element.css("marginRight"), 10) || 0, bottom: parseInt(this.element.css("marginBottom"), 10) || 0 };
  }, _cacheHelperProportions: function() {
    this.helperProportions = { width: this.helper.outerWidth(), height: this.helper.outerHeight() };
  }, _setContainment: function() {
    var t3, e3 = this.options, i3 = this.document[0];
    this.relativeContainer = null, e3.containment ? "window" === e3.containment ? this.containment = [V(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, V(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, V(window).scrollLeft() + V(window).width() - this.helperProportions.width - this.margins.left, V(window).scrollTop() + (V(window).height() || i3.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : "document" === e3.containment ? this.containment = [0, 0, V(i3).width() - this.helperProportions.width - this.margins.left, (V(i3).height() || i3.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : e3.containment.constructor === Array ? this.containment = e3.containment : ("parent" === e3.containment && (e3.containment = this.helper[0].parentNode), (e3 = (i3 = V(e3.containment))[0]) && (t3 = /(scroll|auto)/.test(i3.css("overflow")), this.containment = [(parseInt(i3.css("borderLeftWidth"), 10) || 0) + (parseInt(i3.css("paddingLeft"), 10) || 0), (parseInt(i3.css("borderTopWidth"), 10) || 0) + (parseInt(i3.css("paddingTop"), 10) || 0), (t3 ? Math.max(e3.scrollWidth, e3.offsetWidth) : e3.offsetWidth) - (parseInt(i3.css("borderRightWidth"), 10) || 0) - (parseInt(i3.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (t3 ? Math.max(e3.scrollHeight, e3.offsetHeight) : e3.offsetHeight) - (parseInt(i3.css("borderBottomWidth"), 10) || 0) - (parseInt(i3.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = i3)) : this.containment = null;
  }, _convertPositionTo: function(t3, e3) {
    e3 = e3 || this.position;
    var t3 = "absolute" === t3 ? 1 : -1, i3 = this._isRootNode(this.scrollParent[0]);
    return { top: e3.top + this.offset.relative.top * t3 + this.offset.parent.top * t3 - ("fixed" === this.cssPosition ? -this.offset.scroll.top : i3 ? 0 : this.offset.scroll.top) * t3, left: e3.left + this.offset.relative.left * t3 + this.offset.parent.left * t3 - ("fixed" === this.cssPosition ? -this.offset.scroll.left : i3 ? 0 : this.offset.scroll.left) * t3 };
  }, _generatePosition: function(t3, e3) {
    var i3, s3 = this.options, n3 = this._isRootNode(this.scrollParent[0]), o3 = t3.pageX, a3 = t3.pageY;
    return n3 && this.offset.scroll || (this.offset.scroll = { top: this.scrollParent.scrollTop(), left: this.scrollParent.scrollLeft() }), { top: (a3 = e3 && (this.containment && (i3 = this.relativeContainer ? (e3 = this.relativeContainer.offset(), [this.containment[0] + e3.left, this.containment[1] + e3.top, this.containment[2] + e3.left, this.containment[3] + e3.top]) : this.containment, t3.pageX - this.offset.click.left < i3[0] && (o3 = i3[0] + this.offset.click.left), t3.pageY - this.offset.click.top < i3[1] && (a3 = i3[1] + this.offset.click.top), t3.pageX - this.offset.click.left > i3[2] && (o3 = i3[2] + this.offset.click.left), t3.pageY - this.offset.click.top > i3[3]) && (a3 = i3[3] + this.offset.click.top), s3.grid && (e3 = s3.grid[1] ? this.originalPageY + Math.round((a3 - this.originalPageY) / s3.grid[1]) * s3.grid[1] : this.originalPageY, a3 = !i3 || e3 - this.offset.click.top >= i3[1] || e3 - this.offset.click.top > i3[3] ? e3 : e3 - this.offset.click.top >= i3[1] ? e3 - s3.grid[1] : e3 + s3.grid[1], t3 = s3.grid[0] ? this.originalPageX + Math.round((o3 - this.originalPageX) / s3.grid[0]) * s3.grid[0] : this.originalPageX, o3 = !i3 || t3 - this.offset.click.left >= i3[0] || t3 - this.offset.click.left > i3[2] ? t3 : t3 - this.offset.click.left >= i3[0] ? t3 - s3.grid[0] : t3 + s3.grid[0]), "y" === s3.axis && (o3 = this.originalPageX), "x" === s3.axis) ? this.originalPageY : a3) - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : n3 ? 0 : this.offset.scroll.top), left: o3 - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : n3 ? 0 : this.offset.scroll.left) };
  }, _clear: function() {
    this._removeClass(this.helper, "ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = false, this.destroyOnClear && this.destroy();
  }, _trigger: function(t3, e3, i3) {
    return i3 = i3 || this._uiHash(), V.ui.plugin.call(this, t3, [e3, i3, this], true), /^(drag|start|stop)/.test(t3) && (this.positionAbs = this._convertPositionTo("absolute"), i3.offset = this.positionAbs), V.Widget.prototype._trigger.call(this, t3, e3, i3);
  }, plugins: {}, _uiHash: function() {
    return { helper: this.helper, position: this.position, originalPosition: this.originalPosition, offset: this.positionAbs };
  } }), V.ui.plugin.add("draggable", "connectToSortable", { start: function(e3, t3, i3) {
    var s3 = V.extend({}, t3, { item: i3.element });
    i3.sortables = [], V(i3.options.connectToSortable).each(function() {
      var t4 = V(this).sortable("instance");
      t4 && !t4.options.disabled && (i3.sortables.push(t4), t4.refreshPositions(), t4._trigger("activate", e3, s3));
    });
  }, stop: function(e3, t3, i3) {
    var s3 = V.extend({}, t3, { item: i3.element });
    i3.cancelHelperRemoval = false, V.each(i3.sortables, function() {
      var t4 = this;
      t4.isOver ? (t4.isOver = 0, i3.cancelHelperRemoval = true, t4.cancelHelperRemoval = false, t4._storedCSS = { position: t4.placeholder.css("position"), top: t4.placeholder.css("top"), left: t4.placeholder.css("left") }, t4._mouseStop(e3), t4.options.helper = t4.options._helper) : (t4.cancelHelperRemoval = true, t4._trigger("deactivate", e3, s3));
    });
  }, drag: function(i3, s3, n3) {
    V.each(n3.sortables, function() {
      var t3 = false, e3 = this;
      e3.positionAbs = n3.positionAbs, e3.helperProportions = n3.helperProportions, e3.offset.click = n3.offset.click, e3._intersectsWith(e3.containerCache) && (t3 = true, V.each(n3.sortables, function() {
        return this.positionAbs = n3.positionAbs, this.helperProportions = n3.helperProportions, this.offset.click = n3.offset.click, t3 = this !== e3 && this._intersectsWith(this.containerCache) && V.contains(e3.element[0], this.element[0]) ? false : t3;
      })), t3 ? (e3.isOver || (e3.isOver = 1, n3._parent = s3.helper.parent(), e3.currentItem = s3.helper.appendTo(e3.element).data("ui-sortable-item", true), e3.options._helper = e3.options.helper, e3.options.helper = function() {
        return s3.helper[0];
      }, i3.target = e3.currentItem[0], e3._mouseCapture(i3, true), e3._mouseStart(i3, true, true), e3.offset.click.top = n3.offset.click.top, e3.offset.click.left = n3.offset.click.left, e3.offset.parent.left -= n3.offset.parent.left - e3.offset.parent.left, e3.offset.parent.top -= n3.offset.parent.top - e3.offset.parent.top, n3._trigger("toSortable", i3), n3.dropped = e3.element, V.each(n3.sortables, function() {
        this.refreshPositions();
      }), n3.currentItem = n3.element, e3.fromOutside = n3), e3.currentItem && (e3._mouseDrag(i3), s3.position = e3.position)) : e3.isOver && (e3.isOver = 0, e3.cancelHelperRemoval = true, e3.options._revert = e3.options.revert, e3.options.revert = false, e3._trigger("out", i3, e3._uiHash(e3)), e3._mouseStop(i3, true), e3.options.revert = e3.options._revert, e3.options.helper = e3.options._helper, e3.placeholder && e3.placeholder.remove(), s3.helper.appendTo(n3._parent), n3._refreshOffsets(i3), s3.position = n3._generatePosition(i3, true), n3._trigger("fromSortable", i3), n3.dropped = false, V.each(n3.sortables, function() {
        this.refreshPositions();
      }));
    });
  } }), V.ui.plugin.add("draggable", "cursor", { start: function(t3, e3, i3) {
    var s3 = V("body"), i3 = i3.options;
    s3.css("cursor") && (i3._cursor = s3.css("cursor")), s3.css("cursor", i3.cursor);
  }, stop: function(t3, e3, i3) {
    i3 = i3.options;
    i3._cursor && V("body").css("cursor", i3._cursor);
  } }), V.ui.plugin.add("draggable", "opacity", { start: function(t3, e3, i3) {
    e3 = V(e3.helper), i3 = i3.options;
    e3.css("opacity") && (i3._opacity = e3.css("opacity")), e3.css("opacity", i3.opacity);
  }, stop: function(t3, e3, i3) {
    i3 = i3.options;
    i3._opacity && V(e3.helper).css("opacity", i3._opacity);
  } }), V.ui.plugin.add("draggable", "scroll", { start: function(t3, e3, i3) {
    i3.scrollParentNotHidden || (i3.scrollParentNotHidden = i3.helper.scrollParent(false)), i3.scrollParentNotHidden[0] !== i3.document[0] && "HTML" !== i3.scrollParentNotHidden[0].tagName && (i3.overflowOffset = i3.scrollParentNotHidden.offset());
  }, drag: function(t3, e3, i3) {
    var s3 = i3.options, n3 = false, o3 = i3.scrollParentNotHidden[0], a3 = i3.document[0];
    o3 !== a3 && "HTML" !== o3.tagName ? (s3.axis && "x" === s3.axis || (i3.overflowOffset.top + o3.offsetHeight - t3.pageY < s3.scrollSensitivity ? o3.scrollTop = n3 = o3.scrollTop + s3.scrollSpeed : t3.pageY - i3.overflowOffset.top < s3.scrollSensitivity && (o3.scrollTop = n3 = o3.scrollTop - s3.scrollSpeed)), s3.axis && "y" === s3.axis || (i3.overflowOffset.left + o3.offsetWidth - t3.pageX < s3.scrollSensitivity ? o3.scrollLeft = n3 = o3.scrollLeft + s3.scrollSpeed : t3.pageX - i3.overflowOffset.left < s3.scrollSensitivity && (o3.scrollLeft = n3 = o3.scrollLeft - s3.scrollSpeed))) : (s3.axis && "x" === s3.axis || (t3.pageY - V(a3).scrollTop() < s3.scrollSensitivity ? n3 = V(a3).scrollTop(V(a3).scrollTop() - s3.scrollSpeed) : V(window).height() - (t3.pageY - V(a3).scrollTop()) < s3.scrollSensitivity && (n3 = V(a3).scrollTop(V(a3).scrollTop() + s3.scrollSpeed))), s3.axis && "y" === s3.axis || (t3.pageX - V(a3).scrollLeft() < s3.scrollSensitivity ? n3 = V(a3).scrollLeft(V(a3).scrollLeft() - s3.scrollSpeed) : V(window).width() - (t3.pageX - V(a3).scrollLeft()) < s3.scrollSensitivity && (n3 = V(a3).scrollLeft(V(a3).scrollLeft() + s3.scrollSpeed)))), false !== n3 && V.ui.ddmanager && !s3.dropBehaviour && V.ui.ddmanager.prepareOffsets(i3, t3);
  } }), V.ui.plugin.add("draggable", "snap", { start: function(t3, e3, i3) {
    var s3 = i3.options;
    i3.snapElements = [], V(s3.snap.constructor !== String ? s3.snap.items || ":data(ui-draggable)" : s3.snap).each(function() {
      var t4 = V(this), e4 = t4.offset();
      this !== i3.element[0] && i3.snapElements.push({ item: this, width: t4.outerWidth(), height: t4.outerHeight(), top: e4.top, left: e4.left });
    });
  }, drag: function(t3, e3, i3) {
    for (var s3, n3, o3, a3, r3, l3, h3, c3, u2, d3 = i3.options, p2 = d3.snapTolerance, f3 = e3.offset.left, g2 = f3 + i3.helperProportions.width, m3 = e3.offset.top, _4 = m3 + i3.helperProportions.height, v2 = i3.snapElements.length - 1; 0 <= v2; v2--) l3 = (r3 = i3.snapElements[v2].left - i3.margins.left) + i3.snapElements[v2].width, c3 = (h3 = i3.snapElements[v2].top - i3.margins.top) + i3.snapElements[v2].height, g2 < r3 - p2 || l3 + p2 < f3 || _4 < h3 - p2 || c3 + p2 < m3 || !V.contains(i3.snapElements[v2].item.ownerDocument, i3.snapElements[v2].item) ? (i3.snapElements[v2].snapping && i3.options.snap.release && i3.options.snap.release.call(i3.element, t3, V.extend(i3._uiHash(), { snapItem: i3.snapElements[v2].item })), i3.snapElements[v2].snapping = false) : ("inner" !== d3.snapMode && (s3 = Math.abs(h3 - _4) <= p2, n3 = Math.abs(c3 - m3) <= p2, o3 = Math.abs(r3 - g2) <= p2, a3 = Math.abs(l3 - f3) <= p2, s3 && (e3.position.top = i3._convertPositionTo("relative", { top: h3 - i3.helperProportions.height, left: 0 }).top), n3 && (e3.position.top = i3._convertPositionTo("relative", { top: c3, left: 0 }).top), o3 && (e3.position.left = i3._convertPositionTo("relative", { top: 0, left: r3 - i3.helperProportions.width }).left), a3) && (e3.position.left = i3._convertPositionTo("relative", { top: 0, left: l3 }).left), u2 = s3 || n3 || o3 || a3, "outer" !== d3.snapMode && (s3 = Math.abs(h3 - m3) <= p2, n3 = Math.abs(c3 - _4) <= p2, o3 = Math.abs(r3 - f3) <= p2, a3 = Math.abs(l3 - g2) <= p2, s3 && (e3.position.top = i3._convertPositionTo("relative", { top: h3, left: 0 }).top), n3 && (e3.position.top = i3._convertPositionTo("relative", { top: c3 - i3.helperProportions.height, left: 0 }).top), o3 && (e3.position.left = i3._convertPositionTo("relative", { top: 0, left: r3 }).left), a3) && (e3.position.left = i3._convertPositionTo("relative", { top: 0, left: l3 - i3.helperProportions.width }).left), !i3.snapElements[v2].snapping && (s3 || n3 || o3 || a3 || u2) && i3.options.snap.snap && i3.options.snap.snap.call(i3.element, t3, V.extend(i3._uiHash(), { snapItem: i3.snapElements[v2].item })), i3.snapElements[v2].snapping = s3 || n3 || o3 || a3 || u2);
  } }), V.ui.plugin.add("draggable", "stack", { start: function(t3, e3, i3) {
    var s3, i3 = i3.options, i3 = V.makeArray(V(i3.stack)).sort(function(t4, e4) {
      return (parseInt(V(t4).css("zIndex"), 10) || 0) - (parseInt(V(e4).css("zIndex"), 10) || 0);
    });
    i3.length && (s3 = parseInt(V(i3[0]).css("zIndex"), 10) || 0, V(i3).each(function(t4) {
      V(this).css("zIndex", s3 + t4);
    }), this.css("zIndex", s3 + i3.length));
  } }), V.ui.plugin.add("draggable", "zIndex", { start: function(t3, e3, i3) {
    e3 = V(e3.helper), i3 = i3.options;
    e3.css("zIndex") && (i3._zIndex = e3.css("zIndex")), e3.css("zIndex", i3.zIndex);
  }, stop: function(t3, e3, i3) {
    i3 = i3.options;
    i3._zIndex && V(e3.helper).css("zIndex", i3._zIndex);
  } }), V.ui.draggable, V.widget("ui.resizable", V.ui.mouse, { version: "1.14.0", widgetEventPrefix: "resize", options: { alsoResize: false, animate: false, animateDuration: "slow", animateEasing: "swing", aspectRatio: false, autoHide: false, classes: { "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se" }, containment: false, ghost: false, grid: false, handles: "e,s,se", helper: false, maxHeight: null, maxWidth: null, minHeight: 10, minWidth: 10, zIndex: 90, resize: null, start: null, stop: null }, _num: function(t3) {
    return parseFloat(t3) || 0;
  }, _isNumber: function(t3) {
    return !isNaN(parseFloat(t3));
  }, _hasScroll: function(t3, e3) {
    if ("hidden" === V(t3).css("overflow")) return false;
    var e3 = e3 && "left" === e3 ? "scrollLeft" : "scrollTop", i3 = false;
    if (0 < t3[e3]) return true;
    try {
      t3[e3] = 1, i3 = 0 < t3[e3], t3[e3] = 0;
    } catch (t4) {
    }
    return i3;
  }, _create: function() {
    var t3, e3 = this.options, i3 = this;
    this._addClass("ui-resizable"), V.extend(this, { _aspectRatio: !!e3.aspectRatio, aspectRatio: e3.aspectRatio, originalElement: this.element, _proportionallyResizeElements: [], _helper: e3.helper || e3.ghost || e3.animate ? e3.helper || "ui-resizable-helper" : null }), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(V("<div class='ui-wrapper'></div>").css({ overflow: "hidden", position: this.element.css("position"), width: this.element.outerWidth(), height: this.element.outerHeight(), top: this.element.css("top"), left: this.element.css("left") })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), this.elementIsWrapper = true, t3 = { marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom"), marginLeft: this.originalElement.css("marginLeft") }, this.element.css(t3), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" })), this._proportionallyResize()), this._setupHandles(), e3.autoHide && V(this.element).on("mouseenter", function() {
      e3.disabled || (i3._removeClass("ui-resizable-autohide"), i3._handles.show());
    }).on("mouseleave", function() {
      e3.disabled || i3.resizing || (i3._addClass("ui-resizable-autohide"), i3._handles.hide());
    }), this._mouseInit();
  }, _destroy: function() {
    this._mouseDestroy(), this._addedHandles.remove();
    function t3(t4) {
      V(t4).removeData("resizable").removeData("ui-resizable").off(".resizable");
    }
    var e3;
    return this.elementIsWrapper && (t3(this.element), e3 = this.element, this.originalElement.css({ position: e3.css("position"), width: e3.outerWidth(), height: e3.outerHeight(), top: e3.css("top"), left: e3.css("left") }).insertAfter(e3), e3.remove()), this.originalElement.css("resize", this.originalResizeStyle), t3(this.originalElement), this;
  }, _setOption: function(t3, e3) {
    switch (this._super(t3, e3), t3) {
      case "handles":
        this._removeHandles(), this._setupHandles();
        break;
      case "aspectRatio":
        this._aspectRatio = !!e3;
    }
  }, _setupHandles: function() {
    var t3, e3, i3, s3, n3, o3 = this.options, a3 = this;
    if (this.handles = o3.handles || (V(".ui-resizable-handle", this.element).length ? { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" } : "e,s,se"), this._handles = V(), this._addedHandles = V(), this.handles.constructor === String) for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), i3 = this.handles.split(","), this.handles = {}, e3 = 0; e3 < i3.length; e3++) s3 = "ui-resizable-" + (t3 = String.prototype.trim.call(i3[e3])), n3 = V("<div>"), this._addClass(n3, "ui-resizable-handle " + s3), n3.css({ zIndex: o3.zIndex }), this.handles[t3] = ".ui-resizable-" + t3, this.element.children(this.handles[t3]).length || (this.element.append(n3), this._addedHandles = this._addedHandles.add(n3));
    this._renderAxis = function(t4) {
      var e4, i4, s4;
      for (e4 in t4 = t4 || this.element, this.handles) this.handles[e4].constructor === String ? this.handles[e4] = this.element.children(this.handles[e4]).first().show() : (this.handles[e4].jquery || this.handles[e4].nodeType) && (this.handles[e4] = V(this.handles[e4]), this._on(this.handles[e4], { mousedown: a3._mouseDown })), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (s4 = V(this.handles[e4], this.element), s4 = /sw|ne|nw|se|n|s/.test(e4) ? s4.outerHeight() : s4.outerWidth(), i4 = ["padding", /ne|nw|n/.test(e4) ? "Top" : /se|sw|s/.test(e4) ? "Bottom" : /^e$/.test(e4) ? "Right" : "Left"].join(""), t4.css(i4, s4), this._proportionallyResize()), this._handles = this._handles.add(this.handles[e4]);
    }, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), this._handles.disableSelection(), this._handles.on("mouseover", function() {
      a3.resizing || (this.className && (n3 = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), a3.axis = n3 && n3[1] ? n3[1] : "se");
    }), o3.autoHide && (this._handles.hide(), this._addClass("ui-resizable-autohide"));
  }, _removeHandles: function() {
    this._addedHandles.remove();
  }, _mouseCapture: function(t3) {
    var e3, i3, s3 = false;
    for (e3 in this.handles) (i3 = V(this.handles[e3])[0]) !== t3.target && !V.contains(i3, t3.target) || (s3 = true);
    return !this.options.disabled && s3;
  }, _mouseStart: function(t3) {
    var e3, i3, s3 = this.options, n3 = this.element;
    return this.resizing = true, this._renderProxy(), e3 = this._num(this.helper.css("left")), i3 = this._num(this.helper.css("top")), s3.containment && (e3 += V(s3.containment).scrollLeft() || 0, i3 += V(s3.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = { left: e3, top: i3 }, this.size = this._helper ? { width: this.helper.width(), height: this.helper.height() } : { width: n3.width(), height: n3.height() }, this.originalSize = this._helper ? { width: n3.outerWidth(), height: n3.outerHeight() } : { width: n3.width(), height: n3.height() }, this.sizeDiff = { width: n3.outerWidth() - n3.width(), height: n3.outerHeight() - n3.height() }, this.originalPosition = { left: e3, top: i3 }, this.originalMousePosition = { left: t3.pageX, top: t3.pageY }, this.aspectRatio = "number" == typeof s3.aspectRatio ? s3.aspectRatio : this.originalSize.width / this.originalSize.height || 1, n3 = V(".ui-resizable-" + this.axis).css("cursor"), V("body").css("cursor", "auto" === n3 ? this.axis + "-resize" : n3), this._addClass("ui-resizable-resizing"), this._propagate("start", t3), true;
  }, _mouseDrag: function(t3) {
    var e3 = this.originalMousePosition, i3 = this.axis, s3 = t3.pageX - e3.left || 0, e3 = t3.pageY - e3.top || 0, i3 = this._change[i3];
    return this._updatePrevProperties(), i3 && (i3 = i3.apply(this, [t3, s3, e3]), this._updateVirtualBoundaries(t3.shiftKey), (this._aspectRatio || t3.shiftKey) && (i3 = this._updateRatio(i3, t3)), i3 = this._respectSize(i3, t3), this._updateCache(i3), this._propagate("resize", t3), s3 = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), V.isEmptyObject(s3) || (this._updatePrevProperties(), this._trigger("resize", t3, this.ui()), this._applyChanges())), false;
  }, _mouseStop: function(t3) {
    this.resizing = false;
    var e3, i3, s3, n3 = this.options, o3 = this;
    return this._helper && (i3 = (e3 = (i3 = this._proportionallyResizeElements).length && /textarea/i.test(i3[0].nodeName)) && this._hasScroll(i3[0], "left") ? 0 : o3.sizeDiff.height, e3 = e3 ? 0 : o3.sizeDiff.width, e3 = { width: o3.helper.width() - e3, height: o3.helper.height() - i3 }, i3 = parseFloat(o3.element.css("left")) + (o3.position.left - o3.originalPosition.left) || null, s3 = parseFloat(o3.element.css("top")) + (o3.position.top - o3.originalPosition.top) || null, n3.animate || this.element.css(V.extend(e3, { top: s3, left: i3 })), o3.helper.height(o3.size.height), o3.helper.width(o3.size.width), this._helper) && !n3.animate && this._proportionallyResize(), V("body").css("cursor", "auto"), this._removeClass("ui-resizable-resizing"), this._propagate("stop", t3), this._helper && this.helper.remove(), false;
  }, _updatePrevProperties: function() {
    this.prevPosition = { top: this.position.top, left: this.position.left }, this.prevSize = { width: this.size.width, height: this.size.height };
  }, _applyChanges: function() {
    var t3 = {};
    return this.position.top !== this.prevPosition.top && (t3.top = this.position.top + "px"), this.position.left !== this.prevPosition.left && (t3.left = this.position.left + "px"), this.helper.css(t3), this.size.width !== this.prevSize.width && (t3.width = this.size.width + "px", this.helper.width(t3.width)), this.size.height !== this.prevSize.height && (t3.height = this.size.height + "px", this.helper.height(t3.height)), t3;
  }, _updateVirtualBoundaries: function(t3) {
    var e3, i3, s3, n3 = this.options, n3 = { minWidth: this._isNumber(n3.minWidth) ? n3.minWidth : 0, maxWidth: this._isNumber(n3.maxWidth) ? n3.maxWidth : 1 / 0, minHeight: this._isNumber(n3.minHeight) ? n3.minHeight : 0, maxHeight: this._isNumber(n3.maxHeight) ? n3.maxHeight : 1 / 0 };
    (this._aspectRatio || t3) && (t3 = n3.minHeight * this.aspectRatio, i3 = n3.minWidth / this.aspectRatio, e3 = n3.maxHeight * this.aspectRatio, s3 = n3.maxWidth / this.aspectRatio, n3.minWidth < t3 && (n3.minWidth = t3), n3.minHeight < i3 && (n3.minHeight = i3), e3 < n3.maxWidth && (n3.maxWidth = e3), s3 < n3.maxHeight) && (n3.maxHeight = s3), this._vBoundaries = n3;
  }, _updateCache: function(t3) {
    this.offset = this.helper.offset(), this._isNumber(t3.left) && (this.position.left = t3.left), this._isNumber(t3.top) && (this.position.top = t3.top), this._isNumber(t3.height) && (this.size.height = t3.height), this._isNumber(t3.width) && (this.size.width = t3.width);
  }, _updateRatio: function(t3) {
    var e3 = this.position, i3 = this.size, s3 = this.axis;
    return this._isNumber(t3.height) ? t3.width = t3.height * this.aspectRatio : this._isNumber(t3.width) && (t3.height = t3.width / this.aspectRatio), "sw" === s3 && (t3.left = e3.left + (i3.width - t3.width), t3.top = null), "nw" === s3 && (t3.top = e3.top + (i3.height - t3.height), t3.left = e3.left + (i3.width - t3.width)), t3;
  }, _respectSize: function(t3) {
    var e3 = this._vBoundaries, i3 = this.axis, s3 = this._isNumber(t3.width) && e3.maxWidth && e3.maxWidth < t3.width, n3 = this._isNumber(t3.height) && e3.maxHeight && e3.maxHeight < t3.height, o3 = this._isNumber(t3.width) && e3.minWidth && e3.minWidth > t3.width, a3 = this._isNumber(t3.height) && e3.minHeight && e3.minHeight > t3.height, r3 = this.originalPosition.left + this.originalSize.width, l3 = this.originalPosition.top + this.originalSize.height, h3 = /sw|nw|w/.test(i3), i3 = /nw|ne|n/.test(i3);
    return o3 && (t3.width = e3.minWidth), a3 && (t3.height = e3.minHeight), s3 && (t3.width = e3.maxWidth), n3 && (t3.height = e3.maxHeight), o3 && h3 && (t3.left = r3 - e3.minWidth), s3 && h3 && (t3.left = r3 - e3.maxWidth), a3 && i3 && (t3.top = l3 - e3.minHeight), n3 && i3 && (t3.top = l3 - e3.maxHeight), t3.width || t3.height || t3.left || !t3.top ? t3.width || t3.height || t3.top || !t3.left || (t3.left = null) : t3.top = null, t3;
  }, _getPaddingPlusBorderDimensions: function(t3) {
    for (var e3 = 0, i3 = [], s3 = [t3.css("borderTopWidth"), t3.css("borderRightWidth"), t3.css("borderBottomWidth"), t3.css("borderLeftWidth")], n3 = [t3.css("paddingTop"), t3.css("paddingRight"), t3.css("paddingBottom"), t3.css("paddingLeft")]; e3 < 4; e3++) i3[e3] = parseFloat(s3[e3]) || 0, i3[e3] += parseFloat(n3[e3]) || 0;
    return { height: i3[0] + i3[2], width: i3[1] + i3[3] };
  }, _proportionallyResize: function() {
    if (this._proportionallyResizeElements.length) for (var t3, e3 = 0, i3 = this.helper || this.element; e3 < this._proportionallyResizeElements.length; e3++) t3 = this._proportionallyResizeElements[e3], this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(t3)), t3.css({ height: i3.height() - this.outerDimensions.height || 0, width: i3.width() - this.outerDimensions.width || 0 });
  }, _renderProxy: function() {
    var t3 = this.element, e3 = this.options;
    this.elementOffset = t3.offset(), this._helper ? (this.helper = this.helper || V("<div></div>").css({ overflow: "hidden" }), this._addClass(this.helper, this._helper), this.helper.css({ width: this.element.outerWidth(), height: this.element.outerHeight(), position: "absolute", left: this.elementOffset.left + "px", top: this.elementOffset.top + "px", zIndex: ++e3.zIndex }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element;
  }, _change: { e: function(t3, e3) {
    return { width: this.originalSize.width + e3 };
  }, w: function(t3, e3) {
    var i3 = this.originalSize;
    return { left: this.originalPosition.left + e3, width: i3.width - e3 };
  }, n: function(t3, e3, i3) {
    var s3 = this.originalSize;
    return { top: this.originalPosition.top + i3, height: s3.height - i3 };
  }, s: function(t3, e3, i3) {
    return { height: this.originalSize.height + i3 };
  }, se: function(t3, e3, i3) {
    return V.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [t3, e3, i3]));
  }, sw: function(t3, e3, i3) {
    return V.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [t3, e3, i3]));
  }, ne: function(t3, e3, i3) {
    return V.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [t3, e3, i3]));
  }, nw: function(t3, e3, i3) {
    return V.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [t3, e3, i3]));
  } }, _propagate: function(t3, e3) {
    V.ui.plugin.call(this, t3, [e3, this.ui()]), "resize" !== t3 && this._trigger(t3, e3, this.ui());
  }, plugins: {}, ui: function() {
    return { originalElement: this.originalElement, element: this.element, helper: this.helper, position: this.position, size: this.size, originalSize: this.originalSize, originalPosition: this.originalPosition };
  } }), V.ui.plugin.add("resizable", "animate", { stop: function(e3) {
    var i3 = V(this).resizable("instance"), t3 = i3.options, s3 = i3._proportionallyResizeElements, n3 = s3.length && /textarea/i.test(s3[0].nodeName), o3 = n3 && i3._hasScroll(s3[0], "left") ? 0 : i3.sizeDiff.height, n3 = n3 ? 0 : i3.sizeDiff.width, n3 = { width: i3.size.width - n3, height: i3.size.height - o3 }, o3 = parseFloat(i3.element.css("left")) + (i3.position.left - i3.originalPosition.left) || null, a3 = parseFloat(i3.element.css("top")) + (i3.position.top - i3.originalPosition.top) || null;
    i3.element.animate(V.extend(n3, a3 && o3 ? { top: a3, left: o3 } : {}), { duration: t3.animateDuration, easing: t3.animateEasing, step: function() {
      var t4 = { width: parseFloat(i3.element.css("width")), height: parseFloat(i3.element.css("height")), top: parseFloat(i3.element.css("top")), left: parseFloat(i3.element.css("left")) };
      s3 && s3.length && V(s3[0]).css({ width: t4.width, height: t4.height }), i3._updateCache(t4), i3._propagate("resize", e3);
    } });
  } }), V.ui.plugin.add("resizable", "containment", { start: function() {
    var i3, s3, t3, e3, n3 = V(this).resizable("instance"), o3 = n3.options, a3 = n3.element, o3 = o3.containment, a3 = o3 instanceof V ? o3.get(0) : /parent/.test(o3) ? a3.parent().get(0) : o3;
    a3 && (n3.containerElement = V(a3), /document/.test(o3) || o3 === document ? (n3.containerOffset = { left: 0, top: 0 }, n3.containerPosition = { left: 0, top: 0 }, n3.parentData = { element: V(document), left: 0, top: 0, width: V(document).width(), height: V(document).height() || document.body.parentNode.scrollHeight }) : (i3 = V(a3), s3 = [], V(["Top", "Right", "Left", "Bottom"]).each(function(t4, e4) {
      s3[t4] = n3._num(i3.css("padding" + e4));
    }), n3.containerOffset = i3.offset(), n3.containerPosition = i3.position(), n3.containerSize = { height: i3.innerHeight() - s3[3], width: i3.innerWidth() - s3[1] }, o3 = n3.containerOffset, e3 = n3.containerSize.height, t3 = n3.containerSize.width, t3 = n3._hasScroll(a3, "left") ? a3.scrollWidth : t3, e3 = n3._hasScroll(a3) ? a3.scrollHeight : e3, n3.parentData = { element: a3, left: o3.left, top: o3.top, width: t3, height: e3 }));
  }, resize: function(t3) {
    var e3 = V(this).resizable("instance"), i3 = e3.options, s3 = e3.containerOffset, n3 = e3.position, t3 = e3._aspectRatio || t3.shiftKey, o3 = { top: 0, left: 0 }, a3 = e3.containerElement, r3 = true;
    a3[0] !== document && /static/.test(a3.css("position")) && (o3 = s3), n3.left < (e3._helper ? s3.left : 0) && (e3.size.width = e3.size.width + (e3._helper ? e3.position.left - s3.left : e3.position.left - o3.left), t3 && (e3.size.height = e3.size.width / e3.aspectRatio, r3 = false), e3.position.left = i3.helper ? s3.left : 0), n3.top < (e3._helper ? s3.top : 0) && (e3.size.height = e3.size.height + (e3._helper ? e3.position.top - s3.top : e3.position.top), t3 && (e3.size.width = e3.size.height * e3.aspectRatio, r3 = false), e3.position.top = e3._helper ? s3.top : 0), a3 = e3.containerElement.get(0) === e3.element.parent().get(0), i3 = /relative|absolute/.test(e3.containerElement.css("position")), a3 && i3 ? (e3.offset.left = e3.parentData.left + e3.position.left, e3.offset.top = e3.parentData.top + e3.position.top) : (e3.offset.left = e3.element.offset().left, e3.offset.top = e3.element.offset().top), n3 = Math.abs(e3.sizeDiff.width + (e3._helper ? e3.offset.left - o3.left : e3.offset.left - s3.left)), a3 = Math.abs(e3.sizeDiff.height + (e3._helper ? e3.offset.top - o3.top : e3.offset.top - s3.top)), n3 + e3.size.width >= e3.parentData.width && (e3.size.width = e3.parentData.width - n3, t3) && (e3.size.height = e3.size.width / e3.aspectRatio, r3 = false), a3 + e3.size.height >= e3.parentData.height && (e3.size.height = e3.parentData.height - a3, t3) && (e3.size.width = e3.size.height * e3.aspectRatio, r3 = false), r3 || (e3.position.left = e3.prevPosition.left, e3.position.top = e3.prevPosition.top, e3.size.width = e3.prevSize.width, e3.size.height = e3.prevSize.height);
  }, stop: function() {
    var t3 = V(this).resizable("instance"), e3 = t3.options, i3 = t3.containerOffset, s3 = t3.containerPosition, n3 = t3.containerElement, o3 = V(t3.helper), a3 = o3.offset(), r3 = o3.outerWidth() - t3.sizeDiff.width, o3 = o3.outerHeight() - t3.sizeDiff.height;
    t3._helper && !e3.animate && /relative/.test(n3.css("position")) && V(this).css({ left: a3.left - s3.left - i3.left, width: r3, height: o3 }), t3._helper && !e3.animate && /static/.test(n3.css("position")) && V(this).css({ left: a3.left - s3.left - i3.left, width: r3, height: o3 });
  } }), V.ui.plugin.add("resizable", "alsoResize", { start: function() {
    var t3 = V(this).resizable("instance").options;
    V(t3.alsoResize).each(function() {
      var t4 = V(this);
      t4.data("ui-resizable-alsoresize", { width: parseFloat(t4.css("width")), height: parseFloat(t4.css("height")), left: parseFloat(t4.css("left")), top: parseFloat(t4.css("top")) });
    });
  }, resize: function(t3, i3) {
    var e3 = V(this).resizable("instance"), s3 = e3.options, n3 = e3.originalSize, o3 = e3.originalPosition, a3 = { height: e3.size.height - n3.height || 0, width: e3.size.width - n3.width || 0, top: e3.position.top - o3.top || 0, left: e3.position.left - o3.left || 0 };
    V(s3.alsoResize).each(function() {
      var t4 = V(this), s4 = V(this).data("ui-resizable-alsoresize"), n4 = {}, e4 = t4.parents(i3.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
      V.each(e4, function(t5, e5) {
        var i4 = (s4[e5] || 0) + (a3[e5] || 0);
        i4 && 0 <= i4 && (n4[e5] = i4 || null);
      }), t4.css(n4);
    });
  }, stop: function() {
    V(this).removeData("ui-resizable-alsoresize");
  } }), V.ui.plugin.add("resizable", "ghost", { start: function() {
    var t3 = V(this).resizable("instance"), e3 = t3.size;
    t3.ghost = t3.originalElement.clone(), t3.ghost.css({ opacity: 0.25, display: "block", position: "relative", height: e3.height, width: e3.width, margin: 0, left: 0, top: 0 }), t3._addClass(t3.ghost, "ui-resizable-ghost"), true === V.uiBackCompat && "string" == typeof t3.options.ghost && t3.ghost.addClass(this.options.ghost), t3.ghost.appendTo(t3.helper);
  }, resize: function() {
    var t3 = V(this).resizable("instance");
    t3.ghost && t3.ghost.css({ position: "relative", height: t3.size.height, width: t3.size.width });
  }, stop: function() {
    var t3 = V(this).resizable("instance");
    t3.ghost && t3.helper && t3.helper.get(0).removeChild(t3.ghost.get(0));
  } }), V.ui.plugin.add("resizable", "grid", { resize: function() {
    var t3, e3 = V(this).resizable("instance"), i3 = e3.options, s3 = e3.size, n3 = e3.originalSize, o3 = e3.originalPosition, a3 = e3.axis, r3 = "number" == typeof i3.grid ? [i3.grid, i3.grid] : i3.grid, l3 = r3[0] || 1, h3 = r3[1] || 1, c3 = Math.round((s3.width - n3.width) / l3) * l3, s3 = Math.round((s3.height - n3.height) / h3) * h3, u2 = n3.width + c3, d3 = n3.height + s3, p2 = i3.maxWidth && i3.maxWidth < u2, f3 = i3.maxHeight && i3.maxHeight < d3, g2 = i3.minWidth && i3.minWidth > u2, m3 = i3.minHeight && i3.minHeight > d3;
    i3.grid = r3, g2 && (u2 += l3), m3 && (d3 += h3), p2 && (u2 -= l3), f3 && (d3 -= h3), /^(se|s|e)$/.test(a3) ? (e3.size.width = u2, e3.size.height = d3) : /^(ne)$/.test(a3) ? (e3.size.width = u2, e3.size.height = d3, e3.position.top = o3.top - s3) : /^(sw)$/.test(a3) ? (e3.size.width = u2, e3.size.height = d3, e3.position.left = o3.left - c3) : ((d3 - h3 <= 0 || u2 - l3 <= 0) && (t3 = e3._getPaddingPlusBorderDimensions(this)), 0 < d3 - h3 ? (e3.size.height = d3, e3.position.top = o3.top - s3) : (d3 = h3 - t3.height, e3.size.height = d3, e3.position.top = o3.top + n3.height - d3), 0 < u2 - l3 ? (e3.size.width = u2, e3.position.left = o3.left - c3) : (u2 = l3 - t3.width, e3.size.width = u2, e3.position.left = o3.left + n3.width - u2));
  } }), V.ui.resizable, V.widget("ui.dialog", { version: "1.14.0", options: { appendTo: "body", autoOpen: true, buttons: [], classes: { "ui-dialog": "ui-corner-all", "ui-dialog-titlebar": "ui-corner-all" }, closeOnEscape: true, closeText: "Close", draggable: true, hide: null, height: "auto", maxHeight: null, maxWidth: null, minHeight: 150, minWidth: 150, modal: false, position: { my: "center", at: "center", of: window, collision: "fit", using: function(t3) {
    var e3 = V(this).css(t3).offset().top;
    e3 < 0 && V(this).css("top", t3.top - e3);
  } }, resizable: true, show: null, title: null, width: 300, beforeClose: null, close: null, drag: null, dragStart: null, dragStop: null, focus: null, open: null, resize: null, resizeStart: null, resizeStop: null }, sizeRelatedOptions: { buttons: true, height: true, maxHeight: true, maxWidth: true, minHeight: true, minWidth: true, width: true }, resizableRelatedOptions: { maxHeight: true, maxWidth: true, minHeight: true, minWidth: true }, _create: function() {
    this.originalCss = { display: this.element[0].style.display, width: this.element[0].style.width, minHeight: this.element[0].style.minHeight, maxHeight: this.element[0].style.maxHeight, height: this.element[0].style.height }, this.originalPosition = { parent: this.element.parent(), index: this.element.parent().children().index(this.element) }, this.originalTitle = this.element.attr("title"), null == this.options.title && null != this.originalTitle && (this.options.title = this.originalTitle), this.options.disabled && (this.options.disabled = false), this._createWrapper(), this.element.show().removeAttr("title").appendTo(this.uiDialog), this._addClass("ui-dialog-content", "ui-widget-content"), this._createTitlebar(), this._createButtonPane(), this.options.draggable && V.fn.draggable && this._makeDraggable(), this.options.resizable && V.fn.resizable && this._makeResizable(), this._isOpen = false, this._trackFocus();
  }, _init: function() {
    this.options.autoOpen && this.open();
  }, _appendTo: function() {
    var t3 = this.options.appendTo;
    return t3 && (t3.jquery || t3.nodeType) ? V(t3) : this.document.find(t3 || "body").eq(0);
  }, _destroy: function() {
    var t3, e3 = this.originalPosition;
    this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId().css(this.originalCss).detach(), this.uiDialog.remove(), this.originalTitle && this.element.attr("title", this.originalTitle), (t3 = e3.parent.children().eq(e3.index)).length && t3[0] !== this.element[0] ? t3.before(this.element) : e3.parent.append(this.element);
  }, widget: function() {
    return this.uiDialog;
  }, disable: V.noop, enable: V.noop, close: function(t3) {
    var e3 = this;
    this._isOpen && false !== this._trigger("beforeClose", t3) && (this._isOpen = false, this._focusedElement = null, this._destroyOverlay(), this._untrackInstance(), this.opener.filter(":focusable").trigger("focus").length || V(this.document[0].activeElement).trigger("blur"), this._hide(this.uiDialog, this.options.hide, function() {
      e3._trigger("close", t3);
    }));
  }, isOpen: function() {
    return this._isOpen;
  }, moveToTop: function() {
    this._moveToTop();
  }, _moveToTop: function(t3, e3) {
    var i3 = false, s3 = this.uiDialog.siblings(".ui-front:visible").map(function() {
      return +V(this).css("z-index");
    }).get(), s3 = Math.max.apply(null, s3);
    return s3 >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", s3 + 1), i3 = true), i3 && !e3 && this._trigger("focus", t3), i3;
  }, open: function() {
    var t3 = this;
    this._isOpen ? this._moveToTop() && this._focusTabbable() : (this._isOpen = true, this.opener = V(this.document[0].activeElement), this._size(), this._position(), this._createOverlay(), this._moveToTop(null, true), this.overlay && this.overlay.css("z-index", this.uiDialog.css("z-index") - 1), this._show(this.uiDialog, this.options.show, function() {
      t3._focusTabbable(), t3._trigger("focus");
    }), this._makeFocusTarget(), this._trigger("open"));
  }, _focusTabbable: function() {
    var t3 = this._focusedElement;
    (t3 = (t3 = (t3 = (t3 = (t3 = t3 || this.element.find("[autofocus]")).length ? t3 : this.element.find(":tabbable")).length ? t3 : this.uiDialogButtonPane.find(":tabbable")).length ? t3 : this.uiDialogTitlebarClose.filter(":tabbable")).length ? t3 : this.uiDialog).eq(0).trigger("focus");
  }, _restoreTabbableFocus: function() {
    var t3 = this.document[0].activeElement;
    this.uiDialog[0] === t3 || V.contains(this.uiDialog[0], t3) || this._focusTabbable();
  }, _keepFocus: function(t3) {
    t3.preventDefault(), this._restoreTabbableFocus();
  }, _createWrapper: function() {
    this.uiDialog = V("<div>").hide().attr({ tabIndex: -1, role: "dialog", "aria-modal": this.options.modal ? "true" : null }).appendTo(this._appendTo()), this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front"), this._on(this.uiDialog, { keydown: function(t3) {
      var e3, i3, s3;
      this.options.closeOnEscape && !t3.isDefaultPrevented() && t3.keyCode && t3.keyCode === V.ui.keyCode.ESCAPE ? (t3.preventDefault(), this.close(t3)) : t3.keyCode !== V.ui.keyCode.TAB || t3.isDefaultPrevented() || (e3 = this.uiDialog.find(":tabbable"), i3 = e3.first(), s3 = e3.last(), t3.target !== s3[0] && t3.target !== this.uiDialog[0] || t3.shiftKey ? t3.target !== i3[0] && t3.target !== this.uiDialog[0] || !t3.shiftKey || (this._delay(function() {
        s3.trigger("focus");
      }), t3.preventDefault()) : (this._delay(function() {
        i3.trigger("focus");
      }), t3.preventDefault()));
    }, mousedown: function(t3) {
      this._moveToTop(t3) && this._focusTabbable();
    } }), this.element.find("[aria-describedby]").length || this.uiDialog.attr({ "aria-describedby": this.element.uniqueId().attr("id") });
  }, _createTitlebar: function() {
    var t3;
    this.uiDialogTitlebar = V("<div>"), this._addClass(this.uiDialogTitlebar, "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix"), this._on(this.uiDialogTitlebar, { mousedown: function(t4) {
      V(t4.target).closest(".ui-dialog-titlebar-close") || this.uiDialog.trigger("focus");
    } }), this.uiDialogTitlebarClose = V("<button type='button'></button>").button({ label: V("<a>").text(this.options.closeText).html(), icon: "ui-icon-closethick", showLabel: false }).appendTo(this.uiDialogTitlebar), this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close"), this._on(this.uiDialogTitlebarClose, { click: function(t4) {
      t4.preventDefault(), this.close(t4);
    } }), t3 = V("<span>").uniqueId().prependTo(this.uiDialogTitlebar), this._addClass(t3, "ui-dialog-title"), this._title(t3), this.uiDialogTitlebar.prependTo(this.uiDialog), this.uiDialog.attr({ "aria-labelledby": t3.attr("id") });
  }, _title: function(t3) {
    this.options.title ? t3.text(this.options.title) : t3.html("&#160;");
  }, _createButtonPane: function() {
    this.uiDialogButtonPane = V("<div>"), this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane", "ui-widget-content ui-helper-clearfix"), this.uiButtonSet = V("<div>").appendTo(this.uiDialogButtonPane), this._addClass(this.uiButtonSet, "ui-dialog-buttonset"), this._createButtons();
  }, _createButtons: function() {
    var s3 = this, t3 = this.options.buttons;
    this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), V.isEmptyObject(t3) || Array.isArray(t3) && !t3.length ? this._removeClass(this.uiDialog, "ui-dialog-buttons") : (V.each(t3, function(t4, e3) {
      var i3;
      e3 = V.extend({ type: "button" }, e3 = "function" == typeof e3 ? { click: e3, text: t4 } : e3), i3 = e3.click, t4 = { icon: e3.icon, iconPosition: e3.iconPosition, showLabel: e3.showLabel, icons: e3.icons, text: e3.text }, delete e3.click, delete e3.icon, delete e3.iconPosition, delete e3.showLabel, delete e3.icons, "boolean" == typeof e3.text && delete e3.text, V("<button></button>", e3).button(t4).appendTo(s3.uiButtonSet).on("click", function() {
        i3.apply(s3.element[0], arguments);
      });
    }), this._addClass(this.uiDialog, "ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog));
  }, _makeDraggable: function() {
    var n3 = this, o3 = this.options;
    function a3(t3) {
      return { position: t3.position, offset: t3.offset };
    }
    this.uiDialog.draggable({ cancel: ".ui-dialog-content, .ui-dialog-titlebar-close", handle: ".ui-dialog-titlebar", containment: "document", start: function(t3, e3) {
      n3._addClass(V(this), "ui-dialog-dragging"), n3._blockFrames(), n3._trigger("dragStart", t3, a3(e3));
    }, drag: function(t3, e3) {
      n3._trigger("drag", t3, a3(e3));
    }, stop: function(t3, e3) {
      var i3 = e3.offset.left - n3.document.scrollLeft(), s3 = e3.offset.top - n3.document.scrollTop();
      o3.position = { my: "left top", at: "left" + (0 <= i3 ? "+" : "") + i3 + " top" + (0 <= s3 ? "+" : "") + s3, of: n3.window }, n3._removeClass(V(this), "ui-dialog-dragging"), n3._unblockFrames(), n3._trigger("dragStop", t3, a3(e3));
    } });
  }, _makeResizable: function() {
    var n3 = this, o3 = this.options, t3 = o3.resizable, e3 = this.uiDialog.css("position"), t3 = "string" == typeof t3 ? t3 : "n,e,s,w,se,sw,ne,nw";
    function a3(t4) {
      return { originalPosition: t4.originalPosition, originalSize: t4.originalSize, position: t4.position, size: t4.size };
    }
    this.uiDialog.resizable({ cancel: ".ui-dialog-content", containment: "document", alsoResize: this.element, maxWidth: o3.maxWidth, maxHeight: o3.maxHeight, minWidth: o3.minWidth, minHeight: this._minHeight(), handles: t3, start: function(t4, e4) {
      n3._addClass(V(this), "ui-dialog-resizing"), n3._blockFrames(), n3._trigger("resizeStart", t4, a3(e4));
    }, resize: function(t4, e4) {
      n3._trigger("resize", t4, a3(e4));
    }, stop: function(t4, e4) {
      var i3 = n3.uiDialog.offset(), s3 = i3.left - n3.document.scrollLeft(), i3 = i3.top - n3.document.scrollTop();
      o3.height = n3.uiDialog.height(), o3.width = n3.uiDialog.width(), o3.position = { my: "left top", at: "left" + (0 <= s3 ? "+" : "") + s3 + " top" + (0 <= i3 ? "+" : "") + i3, of: n3.window }, n3._removeClass(V(this), "ui-dialog-resizing"), n3._unblockFrames(), n3._trigger("resizeStop", t4, a3(e4));
    } }).css("position", e3);
  }, _trackFocus: function() {
    this._on(this.widget(), { focusin: function(t3) {
      this._makeFocusTarget(), this._focusedElement = V(t3.target);
    } });
  }, _makeFocusTarget: function() {
    this._untrackInstance(), this._trackingInstances().unshift(this);
  }, _untrackInstance: function() {
    var t3 = this._trackingInstances(), e3 = V.inArray(this, t3);
    -1 !== e3 && t3.splice(e3, 1);
  }, _trackingInstances: function() {
    var t3 = this.document.data("ui-dialog-instances");
    return t3 || this.document.data("ui-dialog-instances", t3 = []), t3;
  }, _minHeight: function() {
    var t3 = this.options;
    return "auto" === t3.height ? t3.minHeight : Math.min(t3.minHeight, t3.height);
  }, _position: function() {
    var t3 = this.uiDialog.is(":visible");
    t3 || this.uiDialog.show(), this.uiDialog.position(this.options.position), t3 || this.uiDialog.hide();
  }, _setOptions: function(t3) {
    var i3 = this, s3 = false, n3 = {};
    V.each(t3, function(t4, e3) {
      i3._setOption(t4, e3), t4 in i3.sizeRelatedOptions && (s3 = true), t4 in i3.resizableRelatedOptions && (n3[t4] = e3);
    }), s3 && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", n3);
  }, _setOption: function(t3, e3) {
    var i3, s3 = this.uiDialog;
    "disabled" !== t3 && (this._super(t3, e3), "appendTo" === t3 && this.uiDialog.appendTo(this._appendTo()), "buttons" === t3 && this._createButtons(), "closeText" === t3 && this.uiDialogTitlebarClose.button({ label: V("<a>").text("" + this.options.closeText).html() }), "draggable" === t3 && ((i3 = s3.is(":data(ui-draggable)")) && !e3 && s3.draggable("destroy"), !i3) && e3 && this._makeDraggable(), "position" === t3 && this._position(), "resizable" === t3 && ((i3 = s3.is(":data(ui-resizable)")) && !e3 && s3.resizable("destroy"), i3 && "string" == typeof e3 && s3.resizable("option", "handles", e3), i3 || false === e3 || this._makeResizable()), "title" === t3 && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")), "modal" === t3) && s3.attr("aria-modal", e3 ? "true" : null);
  }, _size: function() {
    var t3, e3, i3, s3 = this.options;
    this.element.show().css({ width: "auto", minHeight: 0, maxHeight: "none", height: 0 }), s3.minWidth > s3.width && (s3.width = s3.minWidth), t3 = this.uiDialog.css({ height: "auto", width: s3.width }).outerHeight(), e3 = Math.max(0, s3.minHeight - t3), i3 = "number" == typeof s3.maxHeight ? Math.max(0, s3.maxHeight - t3) : "none", "auto" === s3.height ? this.element.css({ minHeight: e3, maxHeight: i3, height: "auto" }) : this.element.height(Math.max(0, s3.height - t3)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight());
  }, _blockFrames: function() {
    this.iframeBlocks = this.document.find("iframe").map(function() {
      var t3 = V(this);
      return V("<div>").css({ position: "absolute", width: t3.outerWidth(), height: t3.outerHeight() }).appendTo(t3.parent()).offset(t3.offset())[0];
    });
  }, _unblockFrames: function() {
    this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
  }, _allowInteraction: function(t3) {
    return !!V(t3.target).closest(".ui-dialog").length || !!V(t3.target).closest(".ui-datepicker").length;
  }, _createOverlay: function() {
    var i3;
    this.options.modal && (i3 = true, this._delay(function() {
      i3 = false;
    }), this.document.data("ui-dialog-overlays") || this.document.on("focusin.ui-dialog", (function(t3) {
      var e3;
      i3 || (e3 = this._trackingInstances()[0])._allowInteraction(t3) || (t3.preventDefault(), e3._focusTabbable());
    }).bind(this)), this.overlay = V("<div>").appendTo(this._appendTo()), this._addClass(this.overlay, null, "ui-widget-overlay ui-front"), this._on(this.overlay, { mousedown: "_keepFocus" }), this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1));
  }, _destroyOverlay: function() {
    var t3;
    this.options.modal && this.overlay && ((t3 = this.document.data("ui-dialog-overlays") - 1) ? this.document.data("ui-dialog-overlays", t3) : (this.document.off("focusin.ui-dialog"), this.document.removeData("ui-dialog-overlays")), this.overlay.remove(), this.overlay = null);
  } }), true === V.uiBackCompat && V.widget("ui.dialog", V.ui.dialog, { options: { dialogClass: "" }, _createWrapper: function() {
    this._super(), this.uiDialog.addClass(this.options.dialogClass);
  }, _setOption: function(t3, e3) {
    "dialogClass" === t3 && this.uiDialog.removeClass(this.options.dialogClass).addClass(e3), this._superApply(arguments);
  } }), V.ui.dialog;
  function rt(t3, e3, i3) {
    return e3 <= t3 && t3 < e3 + i3;
  }
  V.widget("ui.droppable", { version: "1.14.0", widgetEventPrefix: "drop", options: { accept: "*", addClasses: true, greedy: false, scope: "default", tolerance: "intersect", activate: null, deactivate: null, drop: null, out: null, over: null }, _create: function() {
    var t3, e3 = this.options, i3 = e3.accept;
    this.isover = false, this.isout = true, this.accept = "function" == typeof i3 ? i3 : function(t4) {
      return t4.is(i3);
    }, this.proportions = function() {
      if (!arguments.length) return t3 = t3 || { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };
      t3 = arguments[0];
    }, this._addToManager(e3.scope), e3.addClasses && this._addClass("ui-droppable");
  }, _addToManager: function(t3) {
    V.ui.ddmanager.droppables[t3] = V.ui.ddmanager.droppables[t3] || [], V.ui.ddmanager.droppables[t3].push(this);
  }, _splice: function(t3) {
    for (var e3 = 0; e3 < t3.length; e3++) t3[e3] === this && t3.splice(e3, 1);
  }, _destroy: function() {
    var t3 = V.ui.ddmanager.droppables[this.options.scope];
    this._splice(t3);
  }, _setOption: function(t3, e3) {
    var i3;
    "accept" === t3 ? this.accept = "function" == typeof e3 ? e3 : function(t4) {
      return t4.is(e3);
    } : "scope" === t3 && (i3 = V.ui.ddmanager.droppables[this.options.scope], this._splice(i3), this._addToManager(e3)), this._super(t3, e3);
  }, _activate: function(t3) {
    var e3 = V.ui.ddmanager.current;
    this._addActiveClass(), e3 && this._trigger("activate", t3, this.ui(e3));
  }, _deactivate: function(t3) {
    var e3 = V.ui.ddmanager.current;
    this._removeActiveClass(), e3 && this._trigger("deactivate", t3, this.ui(e3));
  }, _over: function(t3) {
    var e3 = V.ui.ddmanager.current;
    e3 && (e3.currentItem || e3.element)[0] !== this.element[0] && this.accept.call(this.element[0], e3.currentItem || e3.element) && (this._addHoverClass(), this._trigger("over", t3, this.ui(e3)));
  }, _out: function(t3) {
    var e3 = V.ui.ddmanager.current;
    e3 && (e3.currentItem || e3.element)[0] !== this.element[0] && this.accept.call(this.element[0], e3.currentItem || e3.element) && (this._removeHoverClass(), this._trigger("out", t3, this.ui(e3)));
  }, _drop: function(e3, t3) {
    var i3 = t3 || V.ui.ddmanager.current, s3 = false;
    return !(!i3 || (i3.currentItem || i3.element)[0] === this.element[0] || (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
      var t4 = V(this).droppable("instance");
      if (t4.options.greedy && !t4.options.disabled && t4.options.scope === i3.options.scope && t4.accept.call(t4.element[0], i3.currentItem || i3.element) && V.ui.intersect(i3, V.extend(t4, { offset: t4.element.offset() }), t4.options.tolerance, e3)) return !(s3 = true);
    }), s3) || !this.accept.call(this.element[0], i3.currentItem || i3.element)) && (this._removeActiveClass(), this._removeHoverClass(), this._trigger("drop", e3, this.ui(i3)), this.element);
  }, ui: function(t3) {
    return { draggable: t3.currentItem || t3.element, helper: t3.helper, position: t3.position, offset: t3.positionAbs };
  }, _addHoverClass: function() {
    this._addClass("ui-droppable-hover");
  }, _removeHoverClass: function() {
    this._removeClass("ui-droppable-hover");
  }, _addActiveClass: function() {
    this._addClass("ui-droppable-active");
  }, _removeActiveClass: function() {
    this._removeClass("ui-droppable-active");
  } }), V.ui.intersect = function(t3, e3, i3, s3) {
    if (!e3.offset) return false;
    var n3 = (t3.positionAbs || t3.position.absolute).left + t3.margins.left, o3 = (t3.positionAbs || t3.position.absolute).top + t3.margins.top, a3 = n3 + t3.helperProportions.width, r3 = o3 + t3.helperProportions.height, l3 = e3.offset.left, h3 = e3.offset.top, c3 = l3 + e3.proportions().width, u2 = h3 + e3.proportions().height;
    switch (i3) {
      case "fit":
        return l3 <= n3 && a3 <= c3 && h3 <= o3 && r3 <= u2;
      case "intersect":
        return l3 < n3 + t3.helperProportions.width / 2 && a3 - t3.helperProportions.width / 2 < c3 && h3 < o3 + t3.helperProportions.height / 2 && r3 - t3.helperProportions.height / 2 < u2;
      case "pointer":
        return rt(s3.pageY, h3, e3.proportions().height) && rt(s3.pageX, l3, e3.proportions().width);
      case "touch":
        return (h3 <= o3 && o3 <= u2 || h3 <= r3 && r3 <= u2 || o3 < h3 && u2 < r3) && (l3 <= n3 && n3 <= c3 || l3 <= a3 && a3 <= c3 || n3 < l3 && c3 < a3);
      default:
        return false;
    }
  }, V.ui.ddmanager = { current: null, droppables: { default: [] }, prepareOffsets: function(t3, e3) {
    var i3, s3, n3 = V.ui.ddmanager.droppables[t3.options.scope] || [], o3 = e3 ? e3.type : null, a3 = (t3.currentItem || t3.element).find(":data(ui-droppable)").addBack();
    t: for (i3 = 0; i3 < n3.length; i3++) if (!(n3[i3].options.disabled || t3 && !n3[i3].accept.call(n3[i3].element[0], t3.currentItem || t3.element))) {
      for (s3 = 0; s3 < a3.length; s3++) if (a3[s3] === n3[i3].element[0]) {
        n3[i3].proportions().height = 0;
        continue t;
      }
      n3[i3].visible = "none" !== n3[i3].element.css("display"), n3[i3].visible && ("mousedown" === o3 && n3[i3]._activate.call(n3[i3], e3), n3[i3].offset = n3[i3].element.offset(), n3[i3].proportions({ width: n3[i3].element[0].offsetWidth, height: n3[i3].element[0].offsetHeight }));
    }
  }, drop: function(t3, e3) {
    var i3 = false;
    return V.each((V.ui.ddmanager.droppables[t3.options.scope] || []).slice(), function() {
      this.options && (!this.options.disabled && this.visible && V.ui.intersect(t3, this, this.options.tolerance, e3) && (i3 = this._drop.call(this, e3) || i3), !this.options.disabled) && this.visible && this.accept.call(this.element[0], t3.currentItem || t3.element) && (this.isout = true, this.isover = false, this._deactivate.call(this, e3));
    }), i3;
  }, dragStart: function(t3, e3) {
    t3.element.parentsUntil("body").on("scroll.droppable", function() {
      t3.options.refreshPositions || V.ui.ddmanager.prepareOffsets(t3, e3);
    });
  }, drag: function(n3, o3) {
    n3.options.refreshPositions && V.ui.ddmanager.prepareOffsets(n3, o3), V.each(V.ui.ddmanager.droppables[n3.options.scope] || [], function() {
      var t3, e3, i3, s3;
      this.options.disabled || this.greedyChild || !this.visible || (s3 = !(s3 = V.ui.intersect(n3, this, this.options.tolerance, o3)) && this.isover ? "isout" : s3 && !this.isover ? "isover" : null) && (this.options.greedy && (e3 = this.options.scope, (i3 = this.element.parents(":data(ui-droppable)").filter(function() {
        return V(this).droppable("instance").options.scope === e3;
      })).length) && ((t3 = V(i3[0]).droppable("instance")).greedyChild = "isover" === s3), t3 && "isover" === s3 && (t3.isover = false, t3.isout = true, t3._out.call(t3, o3)), this[s3] = true, this["isout" === s3 ? "isover" : "isout"] = false, this["isover" === s3 ? "_over" : "_out"].call(this, o3), t3) && "isout" === s3 && (t3.isout = false, t3.isover = true, t3._over.call(t3, o3));
    });
  }, dragStop: function(t3, e3) {
    t3.element.parentsUntil("body").off("scroll.droppable"), t3.options.refreshPositions || V.ui.ddmanager.prepareOffsets(t3, e3);
  } }, true === V.uiBackCompat && V.widget("ui.droppable", V.ui.droppable, { options: { hoverClass: false, activeClass: false }, _addActiveClass: function() {
    this._super(), this.options.activeClass && this.element.addClass(this.options.activeClass);
  }, _removeActiveClass: function() {
    this._super(), this.options.activeClass && this.element.removeClass(this.options.activeClass);
  }, _addHoverClass: function() {
    this._super(), this.options.hoverClass && this.element.addClass(this.options.hoverClass);
  }, _removeHoverClass: function() {
    this._super(), this.options.hoverClass && this.element.removeClass(this.options.hoverClass);
  } });
  V.ui.droppable, V.widget("ui.progressbar", { version: "1.14.0", options: { classes: { "ui-progressbar": "ui-corner-all", "ui-progressbar-value": "ui-corner-left", "ui-progressbar-complete": "ui-corner-right" }, max: 100, value: 0, change: null, complete: null }, min: 0, _create: function() {
    this.oldValue = this.options.value = this._constrainedValue(), this.element.attr({ role: "progressbar", "aria-valuemin": this.min }), this._addClass("ui-progressbar", "ui-widget ui-widget-content"), this.valueDiv = V("<div>").appendTo(this.element), this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header"), this._refreshValue();
  }, _destroy: function() {
    this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"), this.valueDiv.remove();
  }, value: function(t3) {
    if (void 0 === t3) return this.options.value;
    this.options.value = this._constrainedValue(t3), this._refreshValue();
  }, _constrainedValue: function(t3) {
    return void 0 === t3 && (t3 = this.options.value), this.indeterminate = false === t3, "number" != typeof t3 && (t3 = 0), !this.indeterminate && Math.min(this.options.max, Math.max(this.min, t3));
  }, _setOptions: function(t3) {
    var e3 = t3.value;
    delete t3.value, this._super(t3), this.options.value = this._constrainedValue(e3), this._refreshValue();
  }, _setOption: function(t3, e3) {
    "max" === t3 && (e3 = Math.max(this.min, e3)), this._super(t3, e3);
  }, _setOptionDisabled: function(t3) {
    this._super(t3), this.element.attr("aria-disabled", t3), this._toggleClass(null, "ui-state-disabled", !!t3);
  }, _percentage: function() {
    return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
  }, _refreshValue: function() {
    var t3 = this.options.value, e3 = this._percentage();
    this.valueDiv.toggle(this.indeterminate || t3 > this.min).width(e3.toFixed(0) + "%"), this._toggleClass(this.valueDiv, "ui-progressbar-complete", null, t3 === this.options.max)._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), this.overlayDiv || (this.overlayDiv = V("<div>").appendTo(this.valueDiv), this._addClass(this.overlayDiv, "ui-progressbar-overlay"))) : (this.element.attr({ "aria-valuemax": this.options.max, "aria-valuenow": t3 }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== t3 && (this.oldValue = t3, this._trigger("change")), t3 === this.options.max && this._trigger("complete");
  } }), V.widget("ui.selectable", V.ui.mouse, { version: "1.14.0", options: { appendTo: "body", autoRefresh: true, distance: 0, filter: "*", tolerance: "touch", selected: null, selecting: null, start: null, stop: null, unselected: null, unselecting: null }, _create: function() {
    var i3 = this;
    this._addClass("ui-selectable"), this.dragged = false, this.refresh = function() {
      i3.elementPos = V(i3.element[0]).offset(), i3.selectees = V(i3.options.filter, i3.element[0]), i3._addClass(i3.selectees, "ui-selectee"), i3.selectees.each(function() {
        var t3 = V(this), e3 = t3.offset(), e3 = { left: e3.left - i3.elementPos.left, top: e3.top - i3.elementPos.top };
        V.data(this, "selectable-item", { element: this, $element: t3, left: e3.left, top: e3.top, right: e3.left + t3.outerWidth(), bottom: e3.top + t3.outerHeight(), startselected: false, selected: t3.hasClass("ui-selected"), selecting: t3.hasClass("ui-selecting"), unselecting: t3.hasClass("ui-unselecting") });
      });
    }, this.refresh(), this._mouseInit(), this.helper = V("<div>"), this._addClass(this.helper, "ui-selectable-helper");
  }, _destroy: function() {
    this.selectees.removeData("selectable-item"), this._mouseDestroy();
  }, _mouseStart: function(i3) {
    var s3 = this, t3 = this.options;
    this.opos = [i3.pageX, i3.pageY], this.elementPos = V(this.element[0]).offset(), this.options.disabled || (this.selectees = V(t3.filter, this.element[0]), this._trigger("start", i3), V(t3.appendTo).append(this.helper), this.helper.css({ left: i3.pageX, top: i3.pageY, width: 0, height: 0 }), t3.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function() {
      var t4 = V.data(this, "selectable-item");
      t4.startselected = true, i3.metaKey || i3.ctrlKey || (s3._removeClass(t4.$element, "ui-selected"), t4.selected = false, s3._addClass(t4.$element, "ui-unselecting"), t4.unselecting = true, s3._trigger("unselecting", i3, { unselecting: t4.element }));
    }), V(i3.target).parents().addBack().each(function() {
      var t4, e3 = V.data(this, "selectable-item");
      if (e3) return t4 = !i3.metaKey && !i3.ctrlKey || !e3.$element.hasClass("ui-selected"), s3._removeClass(e3.$element, t4 ? "ui-unselecting" : "ui-selected")._addClass(e3.$element, t4 ? "ui-selecting" : "ui-unselecting"), e3.unselecting = !t4, e3.selecting = t4, (e3.selected = t4) ? s3._trigger("selecting", i3, { selecting: e3.element }) : s3._trigger("unselecting", i3, { unselecting: e3.element }), false;
    }));
  }, _mouseDrag: function(s3) {
    var t3, n3, o3, a3, r3, l3, h3;
    if (this.dragged = true, !this.options.disabled) return o3 = (n3 = this).options, a3 = this.opos[0], r3 = this.opos[1], l3 = s3.pageX, h3 = s3.pageY, l3 < a3 && (t3 = l3, l3 = a3, a3 = t3), h3 < r3 && (t3 = h3, h3 = r3, r3 = t3), this.helper.css({ left: a3, top: r3, width: l3 - a3, height: h3 - r3 }), this.selectees.each(function() {
      var t4 = V.data(this, "selectable-item"), e3 = false, i3 = {};
      t4 && t4.element !== n3.element[0] && (i3.left = t4.left + n3.elementPos.left, i3.right = t4.right + n3.elementPos.left, i3.top = t4.top + n3.elementPos.top, i3.bottom = t4.bottom + n3.elementPos.top, "touch" === o3.tolerance ? e3 = !(l3 < i3.left || i3.right < a3 || h3 < i3.top || i3.bottom < r3) : "fit" === o3.tolerance && (e3 = a3 < i3.left && i3.right < l3 && r3 < i3.top && i3.bottom < h3), e3 ? (t4.selected && (n3._removeClass(t4.$element, "ui-selected"), t4.selected = false), t4.unselecting && (n3._removeClass(t4.$element, "ui-unselecting"), t4.unselecting = false), t4.selecting || (n3._addClass(t4.$element, "ui-selecting"), t4.selecting = true, n3._trigger("selecting", s3, { selecting: t4.element }))) : (t4.selecting && ((s3.metaKey || s3.ctrlKey) && t4.startselected ? (n3._removeClass(t4.$element, "ui-selecting"), t4.selecting = false, n3._addClass(t4.$element, "ui-selected"), t4.selected = true) : (n3._removeClass(t4.$element, "ui-selecting"), t4.selecting = false, t4.startselected && (n3._addClass(t4.$element, "ui-unselecting"), t4.unselecting = true), n3._trigger("unselecting", s3, { unselecting: t4.element }))), !t4.selected || s3.metaKey || s3.ctrlKey || t4.startselected || (n3._removeClass(t4.$element, "ui-selected"), t4.selected = false, n3._addClass(t4.$element, "ui-unselecting"), t4.unselecting = true, n3._trigger("unselecting", s3, { unselecting: t4.element }))));
    }), false;
  }, _mouseStop: function(e3) {
    var i3 = this;
    return this.dragged = false, V(".ui-unselecting", this.element[0]).each(function() {
      var t3 = V.data(this, "selectable-item");
      i3._removeClass(t3.$element, "ui-unselecting"), t3.unselecting = false, t3.startselected = false, i3._trigger("unselected", e3, { unselected: t3.element });
    }), V(".ui-selecting", this.element[0]).each(function() {
      var t3 = V.data(this, "selectable-item");
      i3._removeClass(t3.$element, "ui-selecting")._addClass(t3.$element, "ui-selected"), t3.selecting = false, t3.selected = true, t3.startselected = true, i3._trigger("selected", e3, { selected: t3.element });
    }), this._trigger("stop", e3), this.helper.remove(), false;
  } }), V.widget("ui.selectmenu", [V.ui.formResetMixin, { version: "1.14.0", defaultElement: "<select>", options: { appendTo: null, classes: { "ui-selectmenu-button-open": "ui-corner-top", "ui-selectmenu-button-closed": "ui-corner-all" }, disabled: null, icons: { button: "ui-icon-triangle-1-s" }, position: { my: "left top", at: "left bottom", collision: "none" }, width: false, change: null, close: null, focus: null, open: null, select: null }, _create: function() {
    var t3 = this.element.uniqueId().attr("id");
    this.ids = { element: t3, button: t3 + "-button", menu: t3 + "-menu" }, this._drawButton(), this._drawMenu(), this._bindFormResetHandler(), this._rendered = false, this.menuItems = V();
  }, _drawButton: function() {
    var t3, e3 = this, i3 = this._parseOption(this.element.find("option:selected"), this.element[0].selectedIndex);
    this.labels = this.element.labels().attr("for", this.ids.button), this._on(this.labels, { click: function(t4) {
      this.button.trigger("focus"), t4.preventDefault();
    } }), this.element.hide(), this.button = V("<span>", { tabindex: this.options.disabled ? -1 : 0, id: this.ids.button, role: "combobox", "aria-expanded": "false", "aria-autocomplete": "list", "aria-owns": this.ids.menu, "aria-haspopup": "true", title: this.element.attr("title") }).insertAfter(this.element), this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed", "ui-button ui-widget"), t3 = V("<span>").appendTo(this.button), this._addClass(t3, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button), this.buttonItem = this._renderButtonItem(i3).appendTo(this.button), false !== this.options.width && this._resizeButton(), this._on(this.button, this._buttonEvents), this.button.one("focusin", function() {
      e3._rendered || e3._refreshMenu();
    });
  }, _drawMenu: function() {
    var i3 = this;
    this.menu = V("<ul>", { "aria-hidden": "true", "aria-labelledby": this.ids.button, id: this.ids.menu }), this.menuWrap = V("<div>").append(this.menu), this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front"), this.menuWrap.appendTo(this._appendTo()), this.menuInstance = this.menu.menu({ classes: { "ui-menu": "ui-corner-bottom" }, role: "listbox", select: function(t3, e3) {
      t3.preventDefault(), i3._select(e3.item.data("ui-selectmenu-item"), t3);
    }, focus: function(t3, e3) {
      e3 = e3.item.data("ui-selectmenu-item");
      null != i3.focusIndex && e3.index !== i3.focusIndex && (i3._trigger("focus", t3, { item: e3 }), i3.isOpen || i3._select(e3, t3)), i3.focusIndex = e3.index, i3.button.attr("aria-activedescendant", i3.menuItems.eq(e3.index).attr("id"));
    } }).menu("instance"), this.menuInstance._off(this.menu, "mouseleave"), this.menuInstance._closeOnDocumentClick = function() {
      return false;
    }, this.menuInstance._isDivider = function() {
      return false;
    };
  }, refresh: function() {
    this._refreshMenu(), this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item") || {})), null === this.options.width && this._resizeButton();
  }, _refreshMenu: function() {
    var t3 = this.element.find("option");
    this.menu.empty(), this._parseOptions(t3), this._renderMenu(this.menu, this.items), this.menuInstance.refresh(), this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"), this._rendered = true, t3.length && (t3 = this._getSelectedItem(), this.menuInstance.focus(null, t3), this._setAria(t3.data("ui-selectmenu-item")), this._setOption("disabled", this.element.prop("disabled")));
  }, open: function(t3) {
    this.options.disabled || (this._rendered ? (this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active"), this.menuInstance.focus(null, this._getSelectedItem())) : this._refreshMenu(), this.menuItems.length && (this.isOpen = true, this._toggleAttr(), this._resizeMenu(), this._position(), this._on(this.document, this._documentClick), this._trigger("open", t3)));
  }, _position: function() {
    this.menuWrap.position(V.extend({ of: this.button }, this.options.position));
  }, close: function(t3) {
    this.isOpen && (this.isOpen = false, this._toggleAttr(), this.range = null, this._off(this.document), this._trigger("close", t3));
  }, widget: function() {
    return this.button;
  }, menuWidget: function() {
    return this.menu;
  }, _renderButtonItem: function(t3) {
    var e3 = V("<span>");
    return this._setText(e3, t3.label), this._addClass(e3, "ui-selectmenu-text"), e3;
  }, _renderMenu: function(s3, t3) {
    var n3 = this, o3 = "";
    V.each(t3, function(t4, e3) {
      var i3;
      e3.optgroup !== o3 && (i3 = V("<li>", { text: e3.optgroup }), n3._addClass(i3, "ui-selectmenu-optgroup", "ui-menu-divider" + (e3.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : "")), i3.appendTo(s3), o3 = e3.optgroup), n3._renderItemData(s3, e3);
    });
  }, _renderItemData: function(t3, e3) {
    return this._renderItem(t3, e3).data("ui-selectmenu-item", e3);
  }, _renderItem: function(t3, e3) {
    var i3 = V("<li>"), s3 = V("<div>", { title: e3.element.attr("title") });
    return e3.disabled && this._addClass(i3, null, "ui-state-disabled"), e3.hidden ? i3.prop("hidden", true) : this._setText(s3, e3.label), i3.append(s3).appendTo(t3);
  }, _setText: function(t3, e3) {
    e3 ? t3.text(e3) : t3.html("&#160;");
  }, _move: function(t3, e3) {
    var i3, s3 = ".ui-menu-item";
    this.isOpen ? i3 = this.menuItems.eq(this.focusIndex).parent("li") : (i3 = this.menuItems.eq(this.element[0].selectedIndex).parent("li"), s3 += ":not(.ui-state-disabled)"), (i3 = "first" === t3 || "last" === t3 ? i3["first" === t3 ? "prevAll" : "nextAll"](s3).eq(-1) : i3[t3 + "All"](s3).eq(0)).length && this.menuInstance.focus(e3, i3);
  }, _getSelectedItem: function() {
    return this.menuItems.eq(this.element[0].selectedIndex).parent("li");
  }, _toggle: function(t3) {
    this[this.isOpen ? "close" : "open"](t3);
  }, _setSelection: function() {
    var t3;
    this.range && ((t3 = window.getSelection()).removeAllRanges(), t3.addRange(this.range));
  }, _documentClick: { mousedown: function(t3) {
    !this.isOpen || V(t3.target).closest(".ui-selectmenu-menu, #" + CSS.escape(this.ids.button)).length || this.close(t3);
  } }, _buttonEvents: { mousedown: function() {
    var t3 = window.getSelection();
    t3.rangeCount && (this.range = t3.getRangeAt(0));
  }, click: function(t3) {
    this._setSelection(), this._toggle(t3);
  }, keydown: function(t3) {
    var e3 = true;
    switch (t3.keyCode) {
      case V.ui.keyCode.TAB:
      case V.ui.keyCode.ESCAPE:
        this.close(t3), e3 = false;
        break;
      case V.ui.keyCode.ENTER:
        this.isOpen && this._selectFocusedItem(t3);
        break;
      case V.ui.keyCode.UP:
        t3.altKey ? this._toggle(t3) : this._move("prev", t3);
        break;
      case V.ui.keyCode.DOWN:
        t3.altKey ? this._toggle(t3) : this._move("next", t3);
        break;
      case V.ui.keyCode.SPACE:
        this.isOpen ? this._selectFocusedItem(t3) : this._toggle(t3);
        break;
      case V.ui.keyCode.LEFT:
        this._move("prev", t3);
        break;
      case V.ui.keyCode.RIGHT:
        this._move("next", t3);
        break;
      case V.ui.keyCode.HOME:
      case V.ui.keyCode.PAGE_UP:
        this._move("first", t3);
        break;
      case V.ui.keyCode.END:
      case V.ui.keyCode.PAGE_DOWN:
        this._move("last", t3);
        break;
      default:
        this.menu.trigger(t3), e3 = false;
    }
    e3 && t3.preventDefault();
  } }, _selectFocusedItem: function(t3) {
    var e3 = this.menuItems.eq(this.focusIndex).parent("li");
    e3.hasClass("ui-state-disabled") || this._select(e3.data("ui-selectmenu-item"), t3);
  }, _select: function(t3, e3) {
    var i3 = this.element[0].selectedIndex;
    this.element[0].selectedIndex = t3.index, this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(t3)), this._setAria(t3), this._trigger("select", e3, { item: t3 }), t3.index !== i3 && this._trigger("change", e3, { item: t3 }), this.close(e3);
  }, _setAria: function(t3) {
    t3 = this.menuItems.eq(t3.index).attr("id");
    this.button.attr({ "aria-labelledby": t3, "aria-activedescendant": t3 }), this.menu.attr("aria-activedescendant", t3);
  }, _setOption: function(t3, e3) {
    var i3;
    "icons" === t3 && (i3 = this.button.find("span.ui-icon"), this._removeClass(i3, null, this.options.icons.button)._addClass(i3, null, e3.button)), this._super(t3, e3), "appendTo" === t3 && this.menuWrap.appendTo(this._appendTo()), "width" === t3 && this._resizeButton();
  }, _setOptionDisabled: function(t3) {
    this._super(t3), this.menuInstance.option("disabled", t3), this.button.attr("aria-disabled", t3), this._toggleClass(this.button, null, "ui-state-disabled", t3), this.element.prop("disabled", t3), t3 ? (this.button.attr("tabindex", -1), this.close()) : this.button.attr("tabindex", 0);
  }, _appendTo: function() {
    var t3 = this.options.appendTo;
    return t3 = (t3 = (t3 = t3 && (t3.jquery || t3.nodeType ? V(t3) : this.document.find(t3).eq(0))) && t3[0] ? t3 : this.element.closest(".ui-front, dialog")).length ? t3 : this.document[0].body;
  }, _toggleAttr: function() {
    this.button.attr("aria-expanded", this.isOpen), this._removeClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open"))._addClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "open" : "closed"))._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen), this.menu.attr("aria-hidden", !this.isOpen);
  }, _resizeButton: function() {
    var t3 = this.options.width;
    false === t3 ? this.button.css("width", "") : (null === t3 && (t3 = this.element.show().outerWidth(), this.element.hide()), this.button.outerWidth(t3));
  }, _resizeMenu: function() {
    this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth()));
  }, _getCreateOptions: function() {
    var t3 = this._super();
    return t3.disabled = this.element.prop("disabled"), t3;
  }, _parseOptions: function(t3) {
    var i3 = this, s3 = [];
    t3.each(function(t4, e3) {
      s3.push(i3._parseOption(V(e3), t4));
    }), this.items = s3;
  }, _parseOption: function(t3, e3) {
    var i3 = t3.parent("optgroup");
    return { element: t3, index: e3, value: t3.val(), label: t3.text(), hidden: i3.prop("hidden") || t3.prop("hidden"), optgroup: i3.attr("label") || "", disabled: i3.prop("disabled") || t3.prop("disabled") };
  }, _destroy: function() {
    this._unbindFormResetHandler(), this.menuWrap.remove(), this.button.remove(), this.element.show(), this.element.removeUniqueId(), this.labels.attr("for", this.ids.element);
  } }]), V.widget("ui.slider", V.ui.mouse, { version: "1.14.0", widgetEventPrefix: "slide", options: { animate: false, classes: { "ui-slider": "ui-corner-all", "ui-slider-handle": "ui-corner-all", "ui-slider-range": "ui-corner-all ui-widget-header" }, distance: 0, max: 100, min: 0, orientation: "horizontal", range: false, step: 1, value: 0, values: null, change: null, slide: null, start: null, stop: null }, numPages: 5, _create: function() {
    this._keySliding = false, this._mouseSliding = false, this._animateOff = true, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = false;
  }, _refresh: function() {
    this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue();
  }, _createHandles: function() {
    var t3, e3 = this.options, i3 = this.element.find(".ui-slider-handle"), s3 = [], n3 = e3.values && e3.values.length || 1;
    for (i3.length > n3 && (i3.slice(n3).remove(), i3 = i3.slice(0, n3)), t3 = i3.length; t3 < n3; t3++) s3.push("<span tabindex='0'></span>");
    this.handles = i3.add(V(s3.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each(function(t4) {
      V(this).data("ui-slider-handle-index", t4).attr("tabIndex", 0);
    });
  }, _createRange: function() {
    var t3 = this.options;
    t3.range ? (true === t3.range && (t3.values ? t3.values.length && 2 !== t3.values.length ? t3.values = [t3.values[0], t3.values[0]] : Array.isArray(t3.values) && (t3.values = t3.values.slice(0)) : t3.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({ left: "", bottom: "" })) : (this.range = V("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== t3.range && "max" !== t3.range || this._addClass(this.range, "ui-slider-range-" + t3.range)) : (this.range && this.range.remove(), this.range = null);
  }, _setupEvents: function() {
    this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles);
  }, _destroy: function() {
    this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy();
  }, _mouseCapture: function(t3) {
    var i3, s3, n3, o3, e3, a3, r3 = this, l3 = this.options;
    return !l3.disabled && (this.elementSize = { width: this.element.outerWidth(), height: this.element.outerHeight() }, this.elementOffset = this.element.offset(), e3 = { x: t3.pageX, y: t3.pageY }, i3 = this._normValueFromMouse(e3), s3 = this._valueMax() - this._valueMin() + 1, this.handles.each(function(t4) {
      var e4 = Math.abs(i3 - r3.values(t4));
      (e4 < s3 || s3 === e4 && (t4 === r3._lastChangedValue || r3.values(t4) === l3.min)) && (s3 = e4, n3 = V(this), o3 = t4);
    }), false !== this._start(t3, o3)) && (this._mouseSliding = true, this._handleIndex = o3, this._addClass(n3, null, "ui-state-active"), n3.trigger("focus"), e3 = n3.offset(), a3 = !V(t3.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = a3 ? { left: 0, top: 0 } : { left: t3.pageX - e3.left - n3.width() / 2, top: t3.pageY - e3.top - n3.height() / 2 - (parseInt(n3.css("borderTopWidth"), 10) || 0) - (parseInt(n3.css("borderBottomWidth"), 10) || 0) + (parseInt(n3.css("marginTop"), 10) || 0) }, this.handles.hasClass("ui-state-hover") || this._slide(t3, o3, i3), this._animateOff = true);
  }, _mouseStart: function() {
    return true;
  }, _mouseDrag: function(t3) {
    var e3 = { x: t3.pageX, y: t3.pageY }, e3 = this._normValueFromMouse(e3);
    return this._slide(t3, this._handleIndex, e3), false;
  }, _mouseStop: function(t3) {
    return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = false, this._stop(t3, this._handleIndex), this._change(t3, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = false;
  }, _detectOrientation: function() {
    this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal";
  }, _normValueFromMouse: function(t3) {
    var e3, t3 = "horizontal" === this.orientation ? (e3 = this.elementSize.width, t3.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (e3 = this.elementSize.height, t3.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), t3 = t3 / e3;
    return (t3 = 1 < t3 ? 1 : t3) < 0 && (t3 = 0), "vertical" === this.orientation && (t3 = 1 - t3), e3 = this._valueMax() - this._valueMin(), t3 = this._valueMin() + t3 * e3, this._trimAlignValue(t3);
  }, _uiHash: function(t3, e3, i3) {
    var s3 = { handle: this.handles[t3], handleIndex: t3, value: void 0 !== e3 ? e3 : this.value() };
    return this._hasMultipleValues() && (s3.value = void 0 !== e3 ? e3 : this.values(t3), s3.values = i3 || this.values()), s3;
  }, _hasMultipleValues: function() {
    return this.options.values && this.options.values.length;
  }, _start: function(t3, e3) {
    return this._trigger("start", t3, this._uiHash(e3));
  }, _slide: function(t3, e3, i3) {
    var s3, n3 = this.value(), o3 = this.values();
    this._hasMultipleValues() && (s3 = this.values(e3 ? 0 : 1), n3 = this.values(e3), 2 === this.options.values.length && true === this.options.range && (i3 = 0 === e3 ? Math.min(s3, i3) : Math.max(s3, i3)), o3[e3] = i3), i3 !== n3 && false !== this._trigger("slide", t3, this._uiHash(e3, i3, o3)) && (this._hasMultipleValues() ? this.values(e3, i3) : this.value(i3));
  }, _stop: function(t3, e3) {
    this._trigger("stop", t3, this._uiHash(e3));
  }, _change: function(t3, e3) {
    this._keySliding || this._mouseSliding || (this._lastChangedValue = e3, this._trigger("change", t3, this._uiHash(e3)));
  }, value: function(t3) {
    if (!arguments.length) return this._value();
    this.options.value = this._trimAlignValue(t3), this._refreshValue(), this._change(null, 0);
  }, values: function(t3, e3) {
    var i3, s3, n3;
    if (1 < arguments.length) this.options.values[t3] = this._trimAlignValue(e3), this._refreshValue(), this._change(null, t3);
    else {
      if (!arguments.length) return this._values();
      if (!Array.isArray(t3)) return this._hasMultipleValues() ? this._values(t3) : this.value();
      for (i3 = this.options.values, s3 = t3, n3 = 0; n3 < i3.length; n3 += 1) i3[n3] = this._trimAlignValue(s3[n3]), this._change(null, n3);
      this._refreshValue();
    }
  }, _setOption: function(t3, e3) {
    var i3, s3 = 0;
    switch ("range" === t3 && true === this.options.range && ("min" === e3 ? (this.options.value = this._values(0), this.options.values = null) : "max" === e3 && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), Array.isArray(this.options.values) && (s3 = this.options.values.length), this._super(t3, e3), t3) {
      case "orientation":
        this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(e3), this.handles.css("horizontal" === e3 ? "bottom" : "left", "");
        break;
      case "value":
        this._animateOff = true, this._refreshValue(), this._change(null, 0), this._animateOff = false;
        break;
      case "values":
        for (this._animateOff = true, this._refreshValue(), i3 = s3 - 1; 0 <= i3; i3--) this._change(null, i3);
        this._animateOff = false;
        break;
      case "step":
      case "min":
      case "max":
        this._animateOff = true, this._calculateNewMax(), this._refreshValue(), this._animateOff = false;
        break;
      case "range":
        this._animateOff = true, this._refresh(), this._animateOff = false;
    }
  }, _setOptionDisabled: function(t3) {
    this._super(t3), this._toggleClass(null, "ui-state-disabled", !!t3);
  }, _value: function() {
    var t3 = this.options.value;
    return this._trimAlignValue(t3);
  }, _values: function(t3) {
    var e3, i3;
    if (arguments.length) return t3 = this.options.values[t3], this._trimAlignValue(t3);
    if (this._hasMultipleValues()) {
      for (e3 = this.options.values.slice(), i3 = 0; i3 < e3.length; i3 += 1) e3[i3] = this._trimAlignValue(e3[i3]);
      return e3;
    }
    return [];
  }, _trimAlignValue: function(t3) {
    var e3, i3;
    return t3 <= this._valueMin() ? this._valueMin() : t3 >= this._valueMax() ? this._valueMax() : (e3 = 0 < this.options.step ? this.options.step : 1, i3 = t3 - (t3 = (t3 - this._valueMin()) % e3), 2 * Math.abs(t3) >= e3 && (i3 += 0 < t3 ? e3 : -e3), parseFloat(i3.toFixed(5)));
  }, _calculateNewMax: function() {
    var t3 = this.options.max, e3 = this._valueMin(), i3 = this.options.step;
    (t3 = Math.round((t3 - e3) / i3) * i3 + e3) > this.options.max && (t3 -= i3), this.max = parseFloat(t3.toFixed(this._precision()));
  }, _precision: function() {
    var t3 = this._precisionOf(this.options.step);
    return t3 = null !== this.options.min ? Math.max(t3, this._precisionOf(this.options.min)) : t3;
  }, _precisionOf: function(t3) {
    var t3 = t3.toString(), e3 = t3.indexOf(".");
    return -1 === e3 ? 0 : t3.length - e3 - 1;
  }, _valueMin: function() {
    return this.options.min;
  }, _valueMax: function() {
    return this.max;
  }, _refreshRange: function(t3) {
    "vertical" === t3 && this.range.css({ width: "", left: "" }), "horizontal" === t3 && this.range.css({ height: "", bottom: "" });
  }, _refreshValue: function() {
    var e3, i3, t3, s3, n3, o3 = this.options.range, a3 = this.options, r3 = this, l3 = !this._animateOff && a3.animate, h3 = {};
    this._hasMultipleValues() ? this.handles.each(function(t4) {
      i3 = (r3.values(t4) - r3._valueMin()) / (r3._valueMax() - r3._valueMin()) * 100, h3["horizontal" === r3.orientation ? "left" : "bottom"] = i3 + "%", V(this).stop(1, 1)[l3 ? "animate" : "css"](h3, a3.animate), true === r3.options.range && ("horizontal" === r3.orientation ? (0 === t4 && r3.range.stop(1, 1)[l3 ? "animate" : "css"]({ left: i3 + "%" }, a3.animate), 1 === t4 && r3.range[l3 ? "animate" : "css"]({ width: i3 - e3 + "%" }, { queue: false, duration: a3.animate })) : (0 === t4 && r3.range.stop(1, 1)[l3 ? "animate" : "css"]({ bottom: i3 + "%" }, a3.animate), 1 === t4 && r3.range[l3 ? "animate" : "css"]({ height: i3 - e3 + "%" }, { queue: false, duration: a3.animate }))), e3 = i3;
    }) : (t3 = this.value(), s3 = this._valueMin(), n3 = this._valueMax(), i3 = n3 !== s3 ? (t3 - s3) / (n3 - s3) * 100 : 0, h3["horizontal" === this.orientation ? "left" : "bottom"] = i3 + "%", this.handle.stop(1, 1)[l3 ? "animate" : "css"](h3, a3.animate), "min" === o3 && "horizontal" === this.orientation && this.range.stop(1, 1)[l3 ? "animate" : "css"]({ width: i3 + "%" }, a3.animate), "max" === o3 && "horizontal" === this.orientation && this.range.stop(1, 1)[l3 ? "animate" : "css"]({ width: 100 - i3 + "%" }, a3.animate), "min" === o3 && "vertical" === this.orientation && this.range.stop(1, 1)[l3 ? "animate" : "css"]({ height: i3 + "%" }, a3.animate), "max" === o3 && "vertical" === this.orientation && this.range.stop(1, 1)[l3 ? "animate" : "css"]({ height: 100 - i3 + "%" }, a3.animate));
  }, _handleEvents: { keydown: function(t3) {
    var e3, i3, s3, n3 = V(t3.target).data("ui-slider-handle-index");
    switch (t3.keyCode) {
      case V.ui.keyCode.HOME:
      case V.ui.keyCode.END:
      case V.ui.keyCode.PAGE_UP:
      case V.ui.keyCode.PAGE_DOWN:
      case V.ui.keyCode.UP:
      case V.ui.keyCode.RIGHT:
      case V.ui.keyCode.DOWN:
      case V.ui.keyCode.LEFT:
        if (t3.preventDefault(), this._keySliding || (this._keySliding = true, this._addClass(V(t3.target), null, "ui-state-active"), false !== this._start(t3, n3))) break;
        return;
    }
    switch (s3 = this.options.step, e3 = i3 = this._hasMultipleValues() ? this.values(n3) : this.value(), t3.keyCode) {
      case V.ui.keyCode.HOME:
        i3 = this._valueMin();
        break;
      case V.ui.keyCode.END:
        i3 = this._valueMax();
        break;
      case V.ui.keyCode.PAGE_UP:
        i3 = this._trimAlignValue(e3 + (this._valueMax() - this._valueMin()) / this.numPages);
        break;
      case V.ui.keyCode.PAGE_DOWN:
        i3 = this._trimAlignValue(e3 - (this._valueMax() - this._valueMin()) / this.numPages);
        break;
      case V.ui.keyCode.UP:
      case V.ui.keyCode.RIGHT:
        if (e3 === this._valueMax()) return;
        i3 = this._trimAlignValue(e3 + s3);
        break;
      case V.ui.keyCode.DOWN:
      case V.ui.keyCode.LEFT:
        if (e3 === this._valueMin()) return;
        i3 = this._trimAlignValue(e3 - s3);
    }
    this._slide(t3, n3, i3);
  }, keyup: function(t3) {
    var e3 = V(t3.target).data("ui-slider-handle-index");
    this._keySliding && (this._keySliding = false, this._stop(t3, e3), this._change(t3, e3), this._removeClass(V(t3.target), null, "ui-state-active"));
  } } }), V.widget("ui.sortable", V.ui.mouse, { version: "1.14.0", widgetEventPrefix: "sort", ready: false, options: { appendTo: "parent", axis: false, connectWith: false, containment: false, cursor: "auto", cursorAt: false, dropOnEmpty: true, forcePlaceholderSize: false, forceHelperSize: false, grid: false, handle: false, helper: "original", items: "> *", opacity: false, placeholder: false, revert: false, scroll: true, scrollSensitivity: 20, scrollSpeed: 20, scope: "default", tolerance: "intersect", zIndex: 1e3, activate: null, beforeStop: null, change: null, deactivate: null, out: null, over: null, receive: null, remove: null, sort: null, start: null, stop: null, update: null }, _isOverAxis: function(t3, e3, i3) {
    return e3 <= t3 && t3 < e3 + i3;
  }, _isFloating: function(t3) {
    return /left|right/.test(t3.css("float")) || /inline|table-cell/.test(t3.css("display"));
  }, _create: function() {
    this.containerCache = {}, this._addClass("ui-sortable"), this.refresh(), this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), this.ready = true;
  }, _setOption: function(t3, e3) {
    this._super(t3, e3), "handle" === t3 && this._setHandleClassName();
  }, _setHandleClassName: function() {
    var t3 = this;
    this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle"), V.each(this.items, function() {
      t3._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle");
    });
  }, _destroy: function() {
    this._mouseDestroy();
    for (var t3 = this.items.length - 1; 0 <= t3; t3--) this.items[t3].item.removeData(this.widgetName + "-item");
    return this;
  }, _mouseCapture: function(t3, e3) {
    var i3 = null, s3 = false, n3 = this;
    return !(this.reverting || this.options.disabled || "static" === this.options.type || (this._refreshItems(t3), V(t3.target).parents().each(function() {
      if (V.data(this, n3.widgetName + "-item") === n3) return i3 = V(this), false;
    }), !(i3 = V.data(t3.target, n3.widgetName + "-item") === n3 ? V(t3.target) : i3)) || (this.options.handle && !e3 && (V(this.options.handle, i3).find("*").addBack().each(function() {
      this === t3.target && (s3 = true);
    }), !s3) || (this.currentItem = i3, this._removeCurrentsFromItems(), 0)));
  }, _mouseStart: function(t3, e3, i3) {
    var s3, n3, o3 = this.options;
    if ((this.currentContainer = this).refreshPositions(), this.appendTo = V("parent" !== o3.appendTo ? o3.appendTo : this.currentItem.parent()), this.helper = this._createHelper(t3), this._cacheHelperProportions(), this._cacheMargins(), this.offset = this.currentItem.offset(), this.offset = { top: this.offset.top - this.margins.top, left: this.offset.left - this.margins.left }, V.extend(this.offset, { click: { left: t3.pageX - this.offset.left, top: t3.pageY - this.offset.top }, relative: this._getRelativeOffset() }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), o3.cursorAt && this._adjustOffsetFromHelper(o3.cursorAt), this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), this.scrollParent = this.placeholder.scrollParent(), V.extend(this.offset, { parent: this._getParentOffset() }), o3.containment && this._setContainment(), o3.cursor && "auto" !== o3.cursor && (n3 = this.document.find("body"), this._storedStylesheet = V("<style>*{ cursor: " + o3.cursor + " !important; }</style>").appendTo(n3)), o3.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o3.zIndex)), o3.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", o3.opacity)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", t3, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !i3) for (s3 = this.containers.length - 1; 0 <= s3; s3--) this.containers[s3]._trigger("activate", t3, this._uiHash(this));
    return V.ui.ddmanager && (V.ui.ddmanager.current = this), V.ui.ddmanager && !o3.dropBehaviour && V.ui.ddmanager.prepareOffsets(this, t3), this.dragging = true, this._addClass(this.helper, "ui-sortable-helper"), this.helper.parent().is(this.appendTo) || (this.helper.detach().appendTo(this.appendTo), this.offset.parent = this._getParentOffset()), this.position = this.originalPosition = this._generatePosition(t3), this.originalPageX = t3.pageX, this.originalPageY = t3.pageY, this.lastPositionAbs = this.positionAbs = this._convertPositionTo("absolute"), this._mouseDrag(t3), true;
  }, _scroll: function(t3) {
    var e3 = this.options, i3 = false;
    return this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t3.pageY < e3.scrollSensitivity ? this.scrollParent[0].scrollTop = i3 = this.scrollParent[0].scrollTop + e3.scrollSpeed : t3.pageY - this.overflowOffset.top < e3.scrollSensitivity && (this.scrollParent[0].scrollTop = i3 = this.scrollParent[0].scrollTop - e3.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - t3.pageX < e3.scrollSensitivity ? this.scrollParent[0].scrollLeft = i3 = this.scrollParent[0].scrollLeft + e3.scrollSpeed : t3.pageX - this.overflowOffset.left < e3.scrollSensitivity && (this.scrollParent[0].scrollLeft = i3 = this.scrollParent[0].scrollLeft - e3.scrollSpeed)) : (t3.pageY - this.document.scrollTop() < e3.scrollSensitivity ? i3 = this.document.scrollTop(this.document.scrollTop() - e3.scrollSpeed) : this.window.height() - (t3.pageY - this.document.scrollTop()) < e3.scrollSensitivity && (i3 = this.document.scrollTop(this.document.scrollTop() + e3.scrollSpeed)), t3.pageX - this.document.scrollLeft() < e3.scrollSensitivity ? i3 = this.document.scrollLeft(this.document.scrollLeft() - e3.scrollSpeed) : this.window.width() - (t3.pageX - this.document.scrollLeft()) < e3.scrollSensitivity && (i3 = this.document.scrollLeft(this.document.scrollLeft() + e3.scrollSpeed))), i3;
  }, _mouseDrag: function(t3) {
    var e3, i3, s3, n3, o3 = this.options;
    for (this.position = this._generatePosition(t3), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), o3.scroll && false !== this._scroll(t3) && (this._refreshItemPositions(true), V.ui.ddmanager) && !o3.dropBehaviour && V.ui.ddmanager.prepareOffsets(this, t3), this.dragDirection = { vertical: this._getDragVerticalDirection(), horizontal: this._getDragHorizontalDirection() }, e3 = this.items.length - 1; 0 <= e3; e3--) if (s3 = (i3 = this.items[e3]).item[0], (n3 = this._intersectsWithPointer(i3)) && i3.instance === this.currentContainer && !(s3 === this.currentItem[0] || this.placeholder[1 === n3 ? "next" : "prev"]()[0] === s3 || V.contains(this.placeholder[0], s3) || "semi-dynamic" === this.options.type && V.contains(this.element[0], s3))) {
      if (this.direction = 1 === n3 ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(i3)) break;
      this._rearrange(t3, i3), this._trigger("change", t3, this._uiHash());
      break;
    }
    return this._contactContainers(t3), V.ui.ddmanager && V.ui.ddmanager.drag(this, t3), this._trigger("sort", t3, this._uiHash()), this.lastPositionAbs = this.positionAbs, false;
  }, _mouseStop: function(t3, e3) {
    var i3, s3, n3, o3;
    if (t3) return V.ui.ddmanager && !this.options.dropBehaviour && V.ui.ddmanager.drop(this, t3), this.options.revert ? (s3 = (i3 = this).placeholder.offset(), o3 = {}, (n3 = this.options.axis) && "x" !== n3 || (o3.left = s3.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), n3 && "y" !== n3 || (o3.top = s3.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = true, V(this.helper).animate(o3, parseInt(this.options.revert, 10) || 500, function() {
      i3._clear(t3);
    })) : this._clear(t3, e3), false;
  }, cancel: function() {
    if (this.dragging) {
      this._mouseUp(new V.Event("mouseup", { target: null })), "original" === this.options.helper ? (this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")) : this.currentItem.show();
      for (var t3 = this.containers.length - 1; 0 <= t3; t3--) this.containers[t3]._trigger("deactivate", null, this._uiHash(this)), this.containers[t3].containerCache.over && (this.containers[t3]._trigger("out", null, this._uiHash(this)), this.containers[t3].containerCache.over = 0);
    }
    return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), V.extend(this, { helper: null, dragging: false, reverting: false, _noFinalSort: null }), this.domPosition.prev ? V(this.domPosition.prev).after(this.currentItem) : V(this.domPosition.parent).prepend(this.currentItem)), this;
  }, serialize: function(e3) {
    var t3 = this._getItemsAsjQuery(e3 && e3.connected), i3 = [];
    return e3 = e3 || {}, V(t3).each(function() {
      var t4 = (V(e3.item || this).attr(e3.attribute || "id") || "").match(e3.expression || /(.+)[\-=_](.+)/);
      t4 && i3.push((e3.key || t4[1] + "[]") + "=" + (e3.key && e3.expression ? t4[1] : t4[2]));
    }), !i3.length && e3.key && i3.push(e3.key + "="), i3.join("&");
  }, toArray: function(t3) {
    var e3 = this._getItemsAsjQuery(t3 && t3.connected), i3 = [];
    return t3 = t3 || {}, e3.each(function() {
      i3.push(V(t3.item || this).attr(t3.attribute || "id") || "");
    }), i3;
  }, _intersectsWith: function(t3) {
    var e3 = this.positionAbs.left, i3 = e3 + this.helperProportions.width, s3 = this.positionAbs.top, n3 = s3 + this.helperProportions.height, o3 = t3.left, a3 = o3 + t3.width, r3 = t3.top, l3 = r3 + t3.height, h3 = this.offset.click.top, c3 = this.offset.click.left, h3 = "x" === this.options.axis || r3 < s3 + h3 && s3 + h3 < l3, c3 = "y" === this.options.axis || o3 < e3 + c3 && e3 + c3 < a3;
    return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > t3[this.floating ? "width" : "height"] ? h3 && c3 : o3 < e3 + this.helperProportions.width / 2 && i3 - this.helperProportions.width / 2 < a3 && r3 < s3 + this.helperProportions.height / 2 && n3 - this.helperProportions.height / 2 < l3;
  }, _intersectsWithPointer: function(t3) {
    var e3 = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, t3.top, t3.height), t3 = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, t3.left, t3.width);
    return !(!e3 || !t3) && (e3 = this.dragDirection.vertical, t3 = this.dragDirection.horizontal, this.floating ? "right" === t3 || "down" === e3 ? 2 : 1 : e3 && ("down" === e3 ? 2 : 1));
  }, _intersectsWithSides: function(t3) {
    var e3 = this._isOverAxis(this.positionAbs.top + this.offset.click.top, t3.top + t3.height / 2, t3.height), t3 = this._isOverAxis(this.positionAbs.left + this.offset.click.left, t3.left + t3.width / 2, t3.width), i3 = this.dragDirection.vertical, s3 = this.dragDirection.horizontal;
    return this.floating && s3 ? "right" === s3 && t3 || "left" === s3 && !t3 : i3 && ("down" === i3 && e3 || "up" === i3 && !e3);
  }, _getDragVerticalDirection: function() {
    var t3 = this.positionAbs.top - this.lastPositionAbs.top;
    return 0 != t3 && (0 < t3 ? "down" : "up");
  }, _getDragHorizontalDirection: function() {
    var t3 = this.positionAbs.left - this.lastPositionAbs.left;
    return 0 != t3 && (0 < t3 ? "right" : "left");
  }, refresh: function(t3) {
    return this._refreshItems(t3), this._setHandleClassName(), this.refreshPositions(), this;
  }, _connectWith: function() {
    var t3 = this.options;
    return t3.connectWith.constructor === String ? [t3.connectWith] : t3.connectWith;
  }, _getItemsAsjQuery: function(t3) {
    var e3, i3, s3, n3, o3 = [], a3 = [], r3 = this._connectWith();
    if (r3 && t3) for (e3 = r3.length - 1; 0 <= e3; e3--) for (i3 = (s3 = V(r3[e3], this.document[0])).length - 1; 0 <= i3; i3--) (n3 = V.data(s3[i3], this.widgetFullName)) && n3 !== this && !n3.options.disabled && a3.push(["function" == typeof n3.options.items ? n3.options.items.call(n3.element) : V(n3.options.items, n3.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), n3]);
    function l3() {
      o3.push(this);
    }
    for (a3.push(["function" == typeof this.options.items ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : V(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), e3 = a3.length - 1; 0 <= e3; e3--) a3[e3][0].each(l3);
    return V(o3);
  }, _removeCurrentsFromItems: function() {
    var i3 = this.currentItem.find(":data(" + this.widgetName + "-item)");
    this.items = V.grep(this.items, function(t3) {
      for (var e3 = 0; e3 < i3.length; e3++) if (i3[e3] === t3.item[0]) return false;
      return true;
    });
  }, _refreshItems: function(t3) {
    this.items = [], this.containers = [this];
    var e3, i3, s3, n3, o3, a3, r3, l3, h3 = this.items, c3 = [["function" == typeof this.options.items ? this.options.items.call(this.element[0], t3, { item: this.currentItem }) : V(this.options.items, this.element), this]], u2 = this._connectWith();
    if (u2 && this.ready) for (e3 = u2.length - 1; 0 <= e3; e3--) for (i3 = (s3 = V(u2[e3], this.document[0])).length - 1; 0 <= i3; i3--) (n3 = V.data(s3[i3], this.widgetFullName)) && n3 !== this && !n3.options.disabled && (c3.push(["function" == typeof n3.options.items ? n3.options.items.call(n3.element[0], t3, { item: this.currentItem }) : V(n3.options.items, n3.element), n3]), this.containers.push(n3));
    for (e3 = c3.length - 1; 0 <= e3; e3--) for (o3 = c3[e3][1], l3 = (a3 = c3[e3][i3 = 0]).length; i3 < l3; i3++) (r3 = V(a3[i3])).data(this.widgetName + "-item", o3), h3.push({ item: r3, instance: o3, width: 0, height: 0, left: 0, top: 0 });
  }, _refreshItemPositions: function(t3) {
    for (var e3, i3, s3 = this.items.length - 1; 0 <= s3; s3--) e3 = this.items[s3], this.currentContainer && e3.instance !== this.currentContainer && e3.item[0] !== this.currentItem[0] || (i3 = this.options.toleranceElement ? V(this.options.toleranceElement, e3.item) : e3.item, t3 || (e3.width = i3.outerWidth(), e3.height = i3.outerHeight()), i3 = i3.offset(), e3.left = i3.left, e3.top = i3.top);
  }, refreshPositions: function(t3) {
    var e3, i3;
    if (this.floating = !!this.items.length && ("x" === this.options.axis || this._isFloating(this.items[0].item)), this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset()), this._refreshItemPositions(t3), this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);
    else for (e3 = this.containers.length - 1; 0 <= e3; e3--) i3 = this.containers[e3].element.offset(), this.containers[e3].containerCache.left = i3.left, this.containers[e3].containerCache.top = i3.top, this.containers[e3].containerCache.width = this.containers[e3].element.outerWidth(), this.containers[e3].containerCache.height = this.containers[e3].element.outerHeight();
    return this;
  }, _createPlaceholder: function(i3) {
    var s3, n3, o3 = (i3 = i3 || this).options;
    o3.placeholder && o3.placeholder.constructor !== String || (s3 = o3.placeholder, n3 = i3.currentItem[0].nodeName.toLowerCase(), o3.placeholder = { element: function() {
      var t3 = V("<" + n3 + ">", i3.document[0]);
      return i3._addClass(t3, "ui-sortable-placeholder", s3 || i3.currentItem[0].className)._removeClass(t3, "ui-sortable-helper"), "tbody" === n3 ? i3._createTrPlaceholder(i3.currentItem.find("tr").eq(0), V("<tr>", i3.document[0]).appendTo(t3)) : "tr" === n3 ? i3._createTrPlaceholder(i3.currentItem, t3) : "img" === n3 && t3.attr("src", i3.currentItem.attr("src")), s3 || t3.css("visibility", "hidden"), t3;
    }, update: function(t3, e3) {
      s3 && !o3.forcePlaceholderSize || (e3.height() && (!o3.forcePlaceholderSize || "tbody" !== n3 && "tr" !== n3) || e3.height(i3.currentItem.innerHeight() - parseInt(i3.currentItem.css("paddingTop") || 0, 10) - parseInt(i3.currentItem.css("paddingBottom") || 0, 10)), e3.width()) || e3.width(i3.currentItem.innerWidth() - parseInt(i3.currentItem.css("paddingLeft") || 0, 10) - parseInt(i3.currentItem.css("paddingRight") || 0, 10));
    } }), i3.placeholder = V(o3.placeholder.element.call(i3.element, i3.currentItem)), i3.currentItem.after(i3.placeholder), o3.placeholder.update(i3, i3.placeholder);
  }, _createTrPlaceholder: function(t3, e3) {
    var i3 = this;
    t3.children().each(function() {
      V("<td>&#160;</td>", i3.document[0]).attr("colspan", V(this).attr("colspan") || 1).appendTo(e3);
    });
  }, _contactContainers: function(t3) {
    for (var e3, i3, s3, n3, o3, a3, r3, l3, h3, c3 = null, u2 = null, d3 = this.containers.length - 1; 0 <= d3; d3--) V.contains(this.currentItem[0], this.containers[d3].element[0]) || (this._intersectsWith(this.containers[d3].containerCache) ? c3 && V.contains(this.containers[d3].element[0], c3.element[0]) || (c3 = this.containers[d3], u2 = d3) : this.containers[d3].containerCache.over && (this.containers[d3]._trigger("out", t3, this._uiHash(this)), this.containers[d3].containerCache.over = 0));
    if (c3) if (1 === this.containers.length) this.containers[u2].containerCache.over || (this.containers[u2]._trigger("over", t3, this._uiHash(this)), this.containers[u2].containerCache.over = 1);
    else {
      for (i3 = 1e4, s3 = null, n3 = (l3 = c3.floating || this._isFloating(this.currentItem)) ? "left" : "top", o3 = l3 ? "width" : "height", h3 = l3 ? "pageX" : "pageY", e3 = this.items.length - 1; 0 <= e3; e3--) V.contains(this.containers[u2].element[0], this.items[e3].item[0]) && this.items[e3].item[0] !== this.currentItem[0] && (a3 = this.items[e3].item.offset()[n3], r3 = false, t3[h3] - a3 > this.items[e3][o3] / 2 && (r3 = true), Math.abs(t3[h3] - a3) < i3) && (i3 = Math.abs(t3[h3] - a3), s3 = this.items[e3], this.direction = r3 ? "up" : "down");
      (s3 || this.options.dropOnEmpty) && (this.currentContainer === this.containers[u2] ? this.currentContainer.containerCache.over || (this.containers[u2]._trigger("over", t3, this._uiHash()), this.currentContainer.containerCache.over = 1) : (s3 ? this._rearrange(t3, s3, null, true) : this._rearrange(t3, null, this.containers[u2].element, true), this._trigger("change", t3, this._uiHash()), this.containers[u2]._trigger("change", t3, this._uiHash(this)), this.currentContainer = this.containers[u2], this.options.placeholder.update(this.currentContainer, this.placeholder), this.scrollParent = this.placeholder.scrollParent(), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this.containers[u2]._trigger("over", t3, this._uiHash(this)), this.containers[u2].containerCache.over = 1));
    }
  }, _createHelper: function(t3) {
    var e3 = this.options, t3 = "function" == typeof e3.helper ? V(e3.helper.apply(this.element[0], [t3, this.currentItem])) : "clone" === e3.helper ? this.currentItem.clone() : this.currentItem;
    return t3.parents("body").length || this.appendTo[0].appendChild(t3[0]), t3[0] === this.currentItem[0] && (this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") }), t3[0].style.width && !e3.forceHelperSize || t3.width(this.currentItem.width()), t3[0].style.height && !e3.forceHelperSize || t3.height(this.currentItem.height()), t3;
  }, _adjustOffsetFromHelper: function(t3) {
    "string" == typeof t3 && (t3 = t3.split(" ")), "left" in (t3 = Array.isArray(t3) ? { left: +t3[0], top: +t3[1] || 0 } : t3) && (this.offset.click.left = t3.left + this.margins.left), "right" in t3 && (this.offset.click.left = this.helperProportions.width - t3.right + this.margins.left), "top" in t3 && (this.offset.click.top = t3.top + this.margins.top), "bottom" in t3 && (this.offset.click.top = this.helperProportions.height - t3.bottom + this.margins.top);
  }, _getParentOffset: function() {
    this.offsetParent = this.helper.offsetParent();
    var t3 = this.offsetParent.offset();
    return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && V.contains(this.scrollParent[0], this.offsetParent[0]) && (t3.left += this.scrollParent.scrollLeft(), t3.top += this.scrollParent.scrollTop()), { top: (t3 = this.offsetParent[0] === this.document[0].body ? { top: 0, left: 0 } : t3).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: t3.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0) };
  }, _getRelativeOffset: function() {
    var t3;
    return "relative" === this.cssPosition ? { top: (t3 = this.currentItem.position()).top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(), left: t3.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft() } : { top: 0, left: 0 };
  }, _cacheMargins: function() {
    this.margins = { left: parseInt(this.currentItem.css("marginLeft"), 10) || 0, top: parseInt(this.currentItem.css("marginTop"), 10) || 0 };
  }, _cacheHelperProportions: function() {
    this.helperProportions = { width: this.helper.outerWidth(), height: this.helper.outerHeight() };
  }, _setContainment: function() {
    var t3, e3, i3 = this.options;
    "parent" === i3.containment && (i3.containment = this.helper[0].parentNode), "document" !== i3.containment && "window" !== i3.containment || (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === i3.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === i3.containment ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(i3.containment) || (t3 = V(i3.containment)[0], i3 = V(i3.containment).offset(), e3 = "hidden" !== V(t3).css("overflow"), this.containment = [i3.left + (parseInt(V(t3).css("borderLeftWidth"), 10) || 0) + (parseInt(V(t3).css("paddingLeft"), 10) || 0) - this.margins.left, i3.top + (parseInt(V(t3).css("borderTopWidth"), 10) || 0) + (parseInt(V(t3).css("paddingTop"), 10) || 0) - this.margins.top, i3.left + (e3 ? Math.max(t3.scrollWidth, t3.offsetWidth) : t3.offsetWidth) - (parseInt(V(t3).css("borderLeftWidth"), 10) || 0) - (parseInt(V(t3).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, i3.top + (e3 ? Math.max(t3.scrollHeight, t3.offsetHeight) : t3.offsetHeight) - (parseInt(V(t3).css("borderTopWidth"), 10) || 0) - (parseInt(V(t3).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top]);
  }, _convertPositionTo: function(t3, e3) {
    e3 = e3 || this.position;
    var t3 = "absolute" === t3 ? 1 : -1, i3 = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && V.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, s3 = /(html|body)/i.test(i3[0].tagName);
    return { top: e3.top + this.offset.relative.top * t3 + this.offset.parent.top * t3 - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : s3 ? 0 : i3.scrollTop()) * t3, left: e3.left + this.offset.relative.left * t3 + this.offset.parent.left * t3 - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : s3 ? 0 : i3.scrollLeft()) * t3 };
  }, _generatePosition: function(t3) {
    var e3 = this.options, i3 = t3.pageX, s3 = t3.pageY, n3 = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && V.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, o3 = /(html|body)/i.test(n3[0].tagName);
    return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (t3.pageX - this.offset.click.left < this.containment[0] && (i3 = this.containment[0] + this.offset.click.left), t3.pageY - this.offset.click.top < this.containment[1] && (s3 = this.containment[1] + this.offset.click.top), t3.pageX - this.offset.click.left > this.containment[2] && (i3 = this.containment[2] + this.offset.click.left), t3.pageY - this.offset.click.top > this.containment[3]) && (s3 = this.containment[3] + this.offset.click.top), e3.grid) && (t3 = this.originalPageY + Math.round((s3 - this.originalPageY) / e3.grid[1]) * e3.grid[1], s3 = !this.containment || t3 - this.offset.click.top >= this.containment[1] && t3 - this.offset.click.top <= this.containment[3] ? t3 : t3 - this.offset.click.top >= this.containment[1] ? t3 - e3.grid[1] : t3 + e3.grid[1], t3 = this.originalPageX + Math.round((i3 - this.originalPageX) / e3.grid[0]) * e3.grid[0], i3 = !this.containment || t3 - this.offset.click.left >= this.containment[0] && t3 - this.offset.click.left <= this.containment[2] ? t3 : t3 - this.offset.click.left >= this.containment[0] ? t3 - e3.grid[0] : t3 + e3.grid[0]), { top: s3 - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : o3 ? 0 : n3.scrollTop()), left: i3 - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : o3 ? 0 : n3.scrollLeft()) };
  }, _rearrange: function(t3, e3, i3, s3) {
    i3 ? i3[0].appendChild(this.placeholder[0]) : e3.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? e3.item[0] : e3.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
    var n3 = this.counter;
    this._delay(function() {
      n3 === this.counter && this.refreshPositions(!s3);
    });
  }, _clear: function(t3, e3) {
    this.reverting = false;
    var i3, s3 = [];
    if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
      for (i3 in this._storedCSS) "auto" !== this._storedCSS[i3] && "static" !== this._storedCSS[i3] || (this._storedCSS[i3] = "");
      this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper");
    } else this.currentItem.show();
    function n3(e4, i4, s4) {
      return function(t4) {
        s4._trigger(e4, t4, i4._uiHash(i4));
      };
    }
    for (this.fromOutside && !e3 && s3.push(function(t4) {
      this._trigger("receive", t4, this._uiHash(this.fromOutside));
    }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || e3 || s3.push(function(t4) {
      this._trigger("update", t4, this._uiHash());
    }), this === this.currentContainer || e3 || (s3.push(function(t4) {
      this._trigger("remove", t4, this._uiHash());
    }), s3.push((function(e4) {
      return function(t4) {
        e4._trigger("receive", t4, this._uiHash(this));
      };
    }).call(this, this.currentContainer)), s3.push((function(e4) {
      return function(t4) {
        e4._trigger("update", t4, this._uiHash(this));
      };
    }).call(this, this.currentContainer))), i3 = this.containers.length - 1; 0 <= i3; i3--) e3 || s3.push(n3("deactivate", this, this.containers[i3])), this.containers[i3].containerCache.over && (s3.push(n3("out", this, this.containers[i3])), this.containers[i3].containerCache.over = 0);
    if (this._storedStylesheet && (this._storedStylesheet.remove(), this._storedStylesheet = null), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = false, e3 || this._trigger("beforeStop", t3, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null), !e3) {
      for (i3 = 0; i3 < s3.length; i3++) s3[i3].call(this, t3);
      this._trigger("stop", t3, this._uiHash());
    }
    return this.fromOutside = false, !this.cancelHelperRemoval;
  }, _trigger: function() {
    false === V.Widget.prototype._trigger.apply(this, arguments) && this.cancel();
  }, _uiHash: function(t3) {
    var e3 = t3 || this;
    return { helper: e3.helper, placeholder: e3.placeholder || V([]), position: e3.position, originalPosition: e3.originalPosition, offset: e3.positionAbs, item: e3.currentItem, sender: t3 ? t3.element : null };
  } });
  function O(e3) {
    return function() {
      var t3 = this.element.val();
      e3.apply(this, arguments), this._refresh(), t3 !== this.element.val() && this._trigger("change");
    };
  }
  V.widget("ui.spinner", { version: "1.14.0", defaultElement: "<input>", widgetEventPrefix: "spin", options: { classes: { "ui-spinner": "ui-corner-all", "ui-spinner-down": "ui-corner-br", "ui-spinner-up": "ui-corner-tr" }, culture: null, icons: { down: "ui-icon-triangle-1-s", up: "ui-icon-triangle-1-n" }, incremental: true, max: null, min: null, numberFormat: null, page: 10, step: 1, change: null, spin: null, start: null, stop: null }, _create: function() {
    this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), "" !== this.value() && this._value(this.element.val(), true), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, { beforeunload: function() {
      this.element.removeAttr("autocomplete");
    } });
  }, _getCreateOptions: function() {
    var s3 = this._super(), n3 = this.element;
    return V.each(["min", "max", "step"], function(t3, e3) {
      var i3 = n3.attr(e3);
      null != i3 && i3.length && (s3[e3] = i3);
    }), s3;
  }, _events: { keydown: function(t3) {
    this._start(t3) && this._keydown(t3) && t3.preventDefault();
  }, keyup: "_stop", focus: function() {
    this.previous = this.element.val();
  }, blur: function(t3) {
    this._stop(), this._refresh(), this.previous !== this.element.val() && this._trigger("change", t3);
  }, mousewheel: function(t3, e3) {
    var i3 = this.document[0].activeElement;
    if (this.element[0] === i3 && e3) {
      if (!this.spinning && !this._start(t3)) return false;
      this._spin((0 < e3 ? 1 : -1) * this.options.step, t3), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function() {
        this.spinning && this._stop(t3);
      }, 100), t3.preventDefault();
    }
  }, "mousedown .ui-spinner-button": function(t3) {
    var e3;
    e3 = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val(), t3.preventDefault(), (function() {
      this.element[0] !== this.document[0].activeElement && (this.element.trigger("focus"), this.previous = e3);
    }).call(this), false !== this._start(t3) && this._repeat(null, V(t3.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t3);
  }, "mouseup .ui-spinner-button": "_stop", "mouseenter .ui-spinner-button": function(t3) {
    if (V(t3.currentTarget).hasClass("ui-state-active")) return false !== this._start(t3) && void this._repeat(null, V(t3.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t3);
  }, "mouseleave .ui-spinner-button": "_stop" }, _enhance: function() {
    this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>");
  }, _draw: function() {
    this._enhance(), this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content"), this._addClass("ui-spinner-input"), this.element.attr("role", "spinbutton"), this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", true).button({ classes: { "ui-button": "" } }), this._removeClass(this.buttons, "ui-corner-all"), this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up"), this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down"), this.buttons.first().button({ icon: this.options.icons.up, showLabel: false }), this.buttons.last().button({ icon: this.options.icons.down, showLabel: false }), this.buttons.height() > Math.ceil(0.5 * this.uiSpinner.height()) && 0 < this.uiSpinner.height() && this.uiSpinner.height(this.uiSpinner.height());
  }, _keydown: function(t3) {
    var e3 = this.options, i3 = V.ui.keyCode;
    switch (t3.keyCode) {
      case i3.UP:
        return this._repeat(null, 1, t3), true;
      case i3.DOWN:
        return this._repeat(null, -1, t3), true;
      case i3.PAGE_UP:
        return this._repeat(null, e3.page, t3), true;
      case i3.PAGE_DOWN:
        return this._repeat(null, -e3.page, t3), true;
    }
    return false;
  }, _start: function(t3) {
    return !(!this.spinning && false === this._trigger("start", t3)) && (this.counter || (this.counter = 1), this.spinning = true);
  }, _repeat: function(t3, e3, i3) {
    t3 = t3 || 500, clearTimeout(this.timer), this.timer = this._delay(function() {
      this._repeat(40, e3, i3);
    }, t3), this._spin(e3 * this.options.step, i3);
  }, _spin: function(t3, e3) {
    var i3 = this.value() || 0;
    this.counter || (this.counter = 1), i3 = this._adjustValue(i3 + t3 * this._increment(this.counter)), this.spinning && false === this._trigger("spin", e3, { value: i3 }) || (this._value(i3), this.counter++);
  }, _increment: function(t3) {
    var e3 = this.options.incremental;
    return e3 ? "function" == typeof e3 ? e3(t3) : Math.floor(t3 * t3 * t3 / 5e4 - t3 * t3 / 500 + 17 * t3 / 200 + 1) : 1;
  }, _precision: function() {
    var t3 = this._precisionOf(this.options.step);
    return t3 = null !== this.options.min ? Math.max(t3, this._precisionOf(this.options.min)) : t3;
  }, _precisionOf: function(t3) {
    var t3 = t3.toString(), e3 = t3.indexOf(".");
    return -1 === e3 ? 0 : t3.length - e3 - 1;
  }, _adjustValue: function(t3) {
    var e3 = this.options, i3 = null !== e3.min ? e3.min : 0, s3 = t3 - i3;
    return t3 = i3 + Math.round(s3 / e3.step) * e3.step, t3 = parseFloat(t3.toFixed(this._precision())), null !== e3.max && t3 > e3.max ? e3.max : null !== e3.min && t3 < e3.min ? e3.min : t3;
  }, _stop: function(t3) {
    this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = false, this._trigger("stop", t3));
  }, _setOption: function(t3, e3) {
    var i3;
    "culture" === t3 || "numberFormat" === t3 ? (i3 = this._parse(this.element.val()), this.options[t3] = e3, this.element.val(this._format(i3))) : ("max" !== t3 && "min" !== t3 && "step" !== t3 || "string" == typeof e3 && (e3 = this._parse(e3)), "icons" === t3 && (i3 = this.buttons.first().find(".ui-icon"), this._removeClass(i3, null, this.options.icons.up), this._addClass(i3, null, e3.up), i3 = this.buttons.last().find(".ui-icon"), this._removeClass(i3, null, this.options.icons.down), this._addClass(i3, null, e3.down)), this._super(t3, e3));
  }, _setOptionDisabled: function(t3) {
    this._super(t3), this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!t3), this.element.prop("disabled", !!t3), this.buttons.button(t3 ? "disable" : "enable");
  }, _setOptions: O(function(t3) {
    this._super(t3);
  }), _parse: function(t3) {
    return "" === (t3 = "string" == typeof t3 && "" !== t3 ? window.Globalize && this.options.numberFormat ? Globalize.parseFloat(t3, 10, this.options.culture) : +t3 : t3) || isNaN(t3) ? null : t3;
  }, _format: function(t3) {
    return "" === t3 ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(t3, this.options.numberFormat, this.options.culture) : t3;
  }, _refresh: function() {
    this.element.attr({ "aria-valuemin": this.options.min, "aria-valuemax": this.options.max, "aria-valuenow": this._parse(this.element.val()) });
  }, isValid: function() {
    var t3 = this.value();
    return null !== t3 && t3 === this._adjustValue(t3);
  }, _value: function(t3, e3) {
    var i3;
    "" !== t3 && null !== (i3 = this._parse(t3)) && (e3 || (i3 = this._adjustValue(i3)), t3 = this._format(i3)), this.element.val(t3), this._refresh();
  }, _destroy: function() {
    this.element.prop("disabled", false).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"), this.uiSpinner.replaceWith(this.element);
  }, stepUp: O(function(t3) {
    this._stepUp(t3);
  }), _stepUp: function(t3) {
    this._start() && (this._spin((t3 || 1) * this.options.step), this._stop());
  }, stepDown: O(function(t3) {
    this._stepDown(t3);
  }), _stepDown: function(t3) {
    this._start() && (this._spin((t3 || 1) * -this.options.step), this._stop());
  }, pageUp: O(function(t3) {
    this._stepUp((t3 || 1) * this.options.page);
  }), pageDown: O(function(t3) {
    this._stepDown((t3 || 1) * this.options.page);
  }), value: function(t3) {
    if (!arguments.length) return this._parse(this.element.val());
    O(this._value).call(this, t3);
  }, widget: function() {
    return this.uiSpinner;
  } }), true === V.uiBackCompat && V.widget("ui.spinner", V.ui.spinner, { _enhance: function() {
    this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
  }, _uiSpinnerHtml: function() {
    return "<span>";
  }, _buttonHtml: function() {
    return "<a></a><a></a>";
  } });
  var A;
  V.ui.spinner, V.widget("ui.tabs", { version: "1.14.0", delay: 300, options: { active: null, classes: { "ui-tabs": "ui-corner-all", "ui-tabs-nav": "ui-corner-all", "ui-tabs-panel": "ui-corner-bottom", "ui-tabs-tab": "ui-corner-top" }, collapsible: false, event: "click", heightStyle: "content", hide: null, show: null, activate: null, beforeActivate: null, beforeLoad: null, load: null }, _isLocal: (A = /#.*$/, function(t3) {
    var e3 = t3.href.replace(A, ""), i3 = location.href.replace(A, "");
    try {
      e3 = decodeURIComponent(e3);
    } catch (t4) {
    }
    try {
      i3 = decodeURIComponent(i3);
    } catch (t4) {
    }
    return 1 < t3.hash.length && e3 === i3;
  }), _create: function() {
    var e3 = this, t3 = this.options;
    this.running = false, this._addClass("ui-tabs", "ui-widget ui-widget-content"), this._toggleClass("ui-tabs-collapsible", null, t3.collapsible), this._processTabs(), t3.active = this._initialActive(), Array.isArray(t3.disabled) && (t3.disabled = V.uniqueSort(t3.disabled.concat(V.map(this.tabs.filter(".ui-state-disabled"), function(t4) {
      return e3.tabs.index(t4);
    }))).sort()), false !== this.options.active && this.anchors.length ? this.active = this._findActive(t3.active) : this.active = V(), this._refresh(), this.active.length && this.load(t3.active);
  }, _initialActive: function() {
    var i3 = this.options.active, t3 = this.options.collapsible, s3 = location.hash.substring(1);
    return null === i3 && (s3 && this.tabs.each(function(t4, e3) {
      if (V(e3).attr("aria-controls") === s3) return i3 = t4, false;
    }), null !== (i3 = null === i3 ? this.tabs.index(this.tabs.filter(".ui-tabs-active")) : i3) && -1 !== i3 || (i3 = !!this.tabs.length && 0)), false !== i3 && -1 === (i3 = this.tabs.index(this.tabs.eq(i3))) && (i3 = !t3 && 0), i3 = !t3 && false === i3 && this.anchors.length ? 0 : i3;
  }, _getCreateEventData: function() {
    return { tab: this.active, panel: this.active.length ? this._getPanelForTab(this.active) : V() };
  }, _tabKeydown: function(t3) {
    var e3 = V(this.document[0].activeElement).closest("li"), i3 = this.tabs.index(e3), s3 = true;
    if (!this._handlePageNav(t3)) {
      switch (t3.keyCode) {
        case V.ui.keyCode.RIGHT:
        case V.ui.keyCode.DOWN:
          i3++;
          break;
        case V.ui.keyCode.UP:
        case V.ui.keyCode.LEFT:
          s3 = false, i3--;
          break;
        case V.ui.keyCode.END:
          i3 = this.anchors.length - 1;
          break;
        case V.ui.keyCode.HOME:
          i3 = 0;
          break;
        case V.ui.keyCode.SPACE:
          return t3.preventDefault(), clearTimeout(this.activating), void this._activate(i3);
        case V.ui.keyCode.ENTER:
          return t3.preventDefault(), clearTimeout(this.activating), void this._activate(i3 !== this.options.active && i3);
        default:
          return;
      }
      t3.preventDefault(), clearTimeout(this.activating), i3 = this._focusNextTab(i3, s3), t3.ctrlKey || t3.metaKey || (e3.attr("aria-selected", "false"), this.tabs.eq(i3).attr("aria-selected", "true"), this.activating = this._delay(function() {
        this.option("active", i3);
      }, this.delay));
    }
  }, _panelKeydown: function(t3) {
    this._handlePageNav(t3) || t3.ctrlKey && t3.keyCode === V.ui.keyCode.UP && (t3.preventDefault(), this.active.trigger("focus"));
  }, _handlePageNav: function(t3) {
    return t3.altKey && t3.keyCode === V.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, false)), true) : t3.altKey && t3.keyCode === V.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, true)), true) : void 0;
  }, _findNextTab: function(t3, e3) {
    var i3 = this.tabs.length - 1;
    for (; -1 !== V.inArray(t3 = (t3 = i3 < t3 ? 0 : t3) < 0 ? i3 : t3, this.options.disabled); ) t3 = e3 ? t3 + 1 : t3 - 1;
    return t3;
  }, _focusNextTab: function(t3, e3) {
    return t3 = this._findNextTab(t3, e3), this.tabs.eq(t3).trigger("focus"), t3;
  }, _setOption: function(t3, e3) {
    "active" === t3 ? this._activate(e3) : (this._super(t3, e3), "collapsible" === t3 && (this._toggleClass("ui-tabs-collapsible", null, e3), e3 || false !== this.options.active || this._activate(0)), "event" === t3 && this._setupEvents(e3), "heightStyle" === t3 && this._setupHeightStyle(e3));
  }, _sanitizeSelector: function(t3) {
    return t3 ? t3.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
  }, refresh: function() {
    var t3 = this.options, e3 = this.tablist.children(":has(a[href])");
    t3.disabled = V.map(e3.filter(".ui-state-disabled"), function(t4) {
      return e3.index(t4);
    }), this._processTabs(), false !== t3.active && this.anchors.length ? this.active.length && !V.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t3.disabled.length ? (t3.active = false, this.active = V()) : this._activate(this._findNextTab(Math.max(0, t3.active - 1), false)) : t3.active = this.tabs.index(this.active) : (t3.active = false, this.active = V()), this._refresh();
  }, _refresh: function() {
    this._setOptionDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({ "aria-selected": "false", "aria-expanded": "false", tabIndex: -1 }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({ "aria-hidden": "true" }), this.active.length ? (this.active.attr({ "aria-selected": "true", "aria-expanded": "true", tabIndex: 0 }), this._addClass(this.active, "ui-tabs-active", "ui-state-active"), this._getPanelForTab(this.active).show().attr({ "aria-hidden": "false" })) : this.tabs.eq(0).attr("tabIndex", 0);
  }, _processTabs: function() {
    var l3 = this, t3 = this.tabs, e3 = this.anchors, i3 = this.panels;
    this.tablist = this._getList().attr("role", "tablist"), this._addClass(this.tablist, "ui-tabs-nav", "ui-helper-reset ui-helper-clearfix ui-widget-header"), this.tablist.on("mousedown" + this.eventNamespace, "> li", function(t4) {
      V(this).is(".ui-state-disabled") && t4.preventDefault();
    }), this.tabs = this.tablist.find("> li:has(a[href])").attr({ role: "tab", tabIndex: -1 }), this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default"), this.anchors = this.tabs.map(function() {
      return V("a", this)[0];
    }).attr({ tabIndex: -1 }), this._addClass(this.anchors, "ui-tabs-anchor"), this.panels = V(), this.anchors.each(function(t4, e4) {
      var i4, s3, n3, o3 = V(e4).uniqueId().attr("id"), a3 = V(e4).closest("li"), r3 = a3.attr("aria-controls");
      l3._isLocal(e4) ? (n3 = (i4 = e4.hash).substring(1), s3 = l3.element.find(l3._sanitizeSelector(i4))) : (n3 = a3.attr("aria-controls") || V({}).uniqueId()[0].id, (s3 = l3.element.find(i4 = "#" + n3)).length || (s3 = l3._createPanel(n3)).insertAfter(l3.panels[t4 - 1] || l3.tablist), s3.attr("aria-live", "polite")), s3.length && (l3.panels = l3.panels.add(s3)), r3 && a3.data("ui-tabs-aria-controls", r3), a3.attr({ "aria-controls": n3, "aria-labelledby": o3 }), s3.attr("aria-labelledby", o3);
    }), this.panels.attr("role", "tabpanel"), this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content"), t3 && (this._off(t3.not(this.tabs)), this._off(e3.not(this.anchors)), this._off(i3.not(this.panels)));
  }, _getList: function() {
    return this.tablist || this.element.find("ol, ul").eq(0);
  }, _createPanel: function(t3) {
    return V("<div>").attr("id", t3).data("ui-tabs-destroy", true);
  }, _setOptionDisabled: function(t3) {
    var e3, i3;
    for (Array.isArray(t3) && (t3.length ? t3.length === this.anchors.length && (t3 = true) : t3 = false), i3 = 0; e3 = this.tabs[i3]; i3++) e3 = V(e3), true === t3 || -1 !== V.inArray(i3, t3) ? (e3.attr("aria-disabled", "true"), this._addClass(e3, null, "ui-state-disabled")) : (e3.removeAttr("aria-disabled"), this._removeClass(e3, null, "ui-state-disabled"));
    this.options.disabled = t3, this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, true === t3);
  }, _setupEvents: function(t3) {
    var i3 = {};
    t3 && V.each(t3.split(" "), function(t4, e3) {
      i3[e3] = "_eventHandler";
    }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(true, this.anchors, { click: function(t4) {
      t4.preventDefault();
    } }), this._on(this.anchors, i3), this._on(this.tabs, { keydown: "_tabKeydown" }), this._on(this.panels, { keydown: "_panelKeydown" }), this._focusable(this.tabs), this._hoverable(this.tabs);
  }, _setupHeightStyle: function(t3) {
    var i3, e3 = this.element.parent();
    "fill" === t3 ? (i3 = e3.height(), i3 -= this.element.outerHeight() - this.element.height(), this.element.siblings(":visible").each(function() {
      var t4 = V(this), e4 = t4.css("position");
      "absolute" !== e4 && "fixed" !== e4 && (i3 -= t4.outerHeight(true));
    }), this.element.children().not(this.panels).each(function() {
      i3 -= V(this).outerHeight(true);
    }), this.panels.each(function() {
      V(this).height(Math.max(0, i3 - V(this).innerHeight() + V(this).height()));
    }).css("overflow", "auto")) : "auto" === t3 && (i3 = 0, this.panels.each(function() {
      i3 = Math.max(i3, V(this).height("").height());
    }).height(i3));
  }, _eventHandler: function(t3) {
    var e3 = this.options, i3 = this.active, s3 = V(t3.currentTarget).closest("li"), n3 = s3[0] === i3[0], o3 = n3 && e3.collapsible, a3 = o3 ? V() : this._getPanelForTab(s3), r3 = i3.length ? this._getPanelForTab(i3) : V(), i3 = { oldTab: i3, oldPanel: r3, newTab: o3 ? V() : s3, newPanel: a3 };
    t3.preventDefault(), s3.hasClass("ui-state-disabled") || s3.hasClass("ui-tabs-loading") || this.running || n3 && !e3.collapsible || false === this._trigger("beforeActivate", t3, i3) || (e3.active = !o3 && this.tabs.index(s3), this.active = n3 ? V() : s3, this.xhr && this.xhr.abort(), r3.length || a3.length || V.error("jQuery UI Tabs: Mismatching fragment identifier."), a3.length && this.load(this.tabs.index(s3), t3), this._toggle(t3, i3));
  }, _toggle: function(t3, e3) {
    var i3 = this, s3 = e3.newPanel, n3 = e3.oldPanel;
    function o3() {
      i3.running = false, i3._trigger("activate", t3, e3);
    }
    function a3() {
      i3._addClass(e3.newTab.closest("li"), "ui-tabs-active", "ui-state-active"), s3.length && i3.options.show ? i3._show(s3, i3.options.show, o3) : (s3.show(), o3());
    }
    this.running = true, n3.length && this.options.hide ? this._hide(n3, this.options.hide, function() {
      i3._removeClass(e3.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), a3();
    }) : (this._removeClass(e3.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), n3.hide(), a3()), n3.attr("aria-hidden", "true"), e3.oldTab.attr({ "aria-selected": "false", "aria-expanded": "false" }), s3.length && n3.length ? e3.oldTab.attr("tabIndex", -1) : s3.length && this.tabs.filter(function() {
      return 0 === V(this).attr("tabIndex");
    }).attr("tabIndex", -1), s3.attr("aria-hidden", "false"), e3.newTab.attr({ "aria-selected": "true", "aria-expanded": "true", tabIndex: 0 });
  }, _activate: function(t3) {
    var t3 = this._findActive(t3);
    t3[0] !== this.active[0] && (t3 = (t3 = t3.length ? t3 : this.active).find(".ui-tabs-anchor")[0], this._eventHandler({ target: t3, currentTarget: t3, preventDefault: V.noop }));
  }, _findActive: function(t3) {
    return false === t3 ? V() : this.tabs.eq(t3);
  }, _getIndex: function(t3) {
    return t3 = "string" == typeof t3 ? this.anchors.index(this.anchors.filter("[href$='" + CSS.escape(t3) + "']")) : t3;
  }, _destroy: function() {
    this.xhr && this.xhr.abort(), this.tablist.removeAttr("role").off(this.eventNamespace), this.anchors.removeAttr("role tabIndex").removeUniqueId(), this.tabs.add(this.panels).each(function() {
      V.data(this, "ui-tabs-destroy") ? V(this).remove() : V(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded");
    }), this.tabs.each(function() {
      var t3 = V(this), e3 = t3.data("ui-tabs-aria-controls");
      e3 ? t3.attr("aria-controls", e3).removeData("ui-tabs-aria-controls") : t3.removeAttr("aria-controls");
    }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "");
  }, enable: function(i3) {
    var t3 = this.options.disabled;
    false !== t3 && (t3 = void 0 !== i3 && (i3 = this._getIndex(i3), Array.isArray(t3) ? V.map(t3, function(t4) {
      return t4 !== i3 ? t4 : null;
    }) : V.map(this.tabs, function(t4, e3) {
      return e3 !== i3 ? e3 : null;
    })), this._setOptionDisabled(t3));
  }, disable: function(t3) {
    var e3 = this.options.disabled;
    if (true !== e3) {
      if (void 0 === t3) e3 = true;
      else {
        if (t3 = this._getIndex(t3), -1 !== V.inArray(t3, e3)) return;
        e3 = Array.isArray(e3) ? V.merge([t3], e3).sort() : [t3];
      }
      this._setOptionDisabled(e3);
    }
  }, load: function(t3, s3) {
    t3 = this._getIndex(t3);
    function n3(t4, e3) {
      "abort" === e3 && o3.panels.stop(false, true), o3._removeClass(i3, "ui-tabs-loading"), a3.removeAttr("aria-busy"), t4 === o3.xhr && delete o3.xhr;
    }
    var o3 = this, i3 = this.tabs.eq(t3), t3 = i3.find(".ui-tabs-anchor"), a3 = this._getPanelForTab(i3), r3 = { tab: i3, panel: a3 };
    this._isLocal(t3[0]) || (this.xhr = V.ajax(this._ajaxSettings(t3, s3, r3)), "canceled" !== this.xhr.statusText && (this._addClass(i3, "ui-tabs-loading"), a3.attr("aria-busy", "true"), this.xhr.done(function(t4, e3, i4) {
      a3.html(t4), o3._trigger("load", s3, r3), n3(i4, e3);
    }).fail(function(t4, e3) {
      n3(t4, e3);
    })));
  }, _ajaxSettings: function(t3, i3, s3) {
    var n3 = this;
    return { url: t3.attr("href"), beforeSend: function(t4, e3) {
      return n3._trigger("beforeLoad", i3, V.extend({ jqXHR: t4, ajaxSettings: e3 }, s3));
    } };
  }, _getPanelForTab: function(t3) {
    t3 = V(t3).attr("aria-controls");
    return this.element.find(this._sanitizeSelector("#" + t3));
  } }), true === V.uiBackCompat && V.widget("ui.tabs", V.ui.tabs, { _processTabs: function() {
    this._superApply(arguments), this._addClass(this.tabs, "ui-tab");
  } }), V.ui.tabs, V.widget("ui.tooltip", { version: "1.14.0", options: { classes: { "ui-tooltip": "ui-corner-all ui-widget-shadow" }, content: function() {
    var t3 = V(this).attr("title");
    return V("<a>").text(t3).html();
  }, hide: true, items: "[title]:not([disabled])", position: { my: "left top+15", at: "left bottom", collision: "flipfit flip" }, show: true, track: false, close: null, open: null }, _addDescribedBy: function(t3, e3) {
    var i3 = (t3.attr("aria-describedby") || "").split(/\s+/);
    i3.push(e3), t3.data("ui-tooltip-id", e3).attr("aria-describedby", String.prototype.trim.call(i3.join(" ")));
  }, _removeDescribedBy: function(t3) {
    var e3 = t3.data("ui-tooltip-id"), i3 = (t3.attr("aria-describedby") || "").split(/\s+/), e3 = V.inArray(e3, i3);
    -1 !== e3 && i3.splice(e3, 1), t3.removeData("ui-tooltip-id"), (i3 = String.prototype.trim.call(i3.join(" "))) ? t3.attr("aria-describedby", i3) : t3.removeAttr("aria-describedby");
  }, _create: function() {
    this._on({ mouseover: "open", focusin: "open" }), this.tooltips = {}, this.parents = {}, this.liveRegion = V("<div>").attr({ role: "log", "aria-live": "assertive", "aria-relevant": "additions" }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this.disabledTitles = V([]);
  }, _setOption: function(t3, e3) {
    var i3 = this;
    this._super(t3, e3), "content" === t3 && V.each(this.tooltips, function(t4, e4) {
      i3._updateContent(e4.element);
    });
  }, _setOptionDisabled: function(t3) {
    this[t3 ? "_disable" : "_enable"]();
  }, _disable: function() {
    var s3 = this;
    V.each(this.tooltips, function(t3, e3) {
      var i3 = V.Event("blur");
      i3.target = i3.currentTarget = e3.element[0], s3.close(i3, true);
    }), this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function() {
      var t3 = V(this);
      if (t3.is("[title]")) return t3.data("ui-tooltip-title", t3.attr("title")).removeAttr("title");
    }));
  }, _enable: function() {
    this.disabledTitles.each(function() {
      var t3 = V(this);
      t3.data("ui-tooltip-title") && t3.attr("title", t3.data("ui-tooltip-title"));
    }), this.disabledTitles = V([]);
  }, open: function(t3) {
    var i3 = this, e3 = V(t3 ? t3.target : this.element).closest(this.options.items);
    e3.length && !e3.data("ui-tooltip-id") && (e3.attr("title") && e3.data("ui-tooltip-title", e3.attr("title")), e3.data("ui-tooltip-open", true), t3 && "mouseover" === t3.type && e3.parents().each(function() {
      var t4, e4 = V(this);
      e4.data("ui-tooltip-open") && ((t4 = V.Event("blur")).target = t4.currentTarget = this, i3.close(t4, true)), e4.attr("title") && (e4.uniqueId(), i3.parents[this.id] = { element: this, title: e4.attr("title") }, e4.attr("title", ""));
    }), this._registerCloseHandlers(t3, e3), this._updateContent(e3, t3));
  }, _updateContent: function(e3, i3) {
    var t3 = this.options.content, s3 = this, n3 = i3 ? i3.type : null;
    if ("string" == typeof t3 || t3.nodeType || t3.jquery) return this._open(i3, e3, t3);
    (t3 = t3.call(e3[0], function(t4) {
      e3.data("ui-tooltip-open") && (i3 && (i3.type = n3), s3._open(i3, e3, t4));
    })) && this._open(i3, e3, t3);
  }, _open: function(t3, e3, i3) {
    var s3, n3, o3, a3 = V.extend({}, this.options.position);
    function r3(t4) {
      a3.of = t4, s3.is(":hidden") || s3.position(a3);
    }
    i3 && ((o3 = this._find(e3)) ? o3.tooltip.find(".ui-tooltip-content").html(i3) : (e3.is("[title]") && (t3 && "mouseover" === t3.type ? e3.attr("title", "") : e3.removeAttr("title")), o3 = this._tooltip(e3), s3 = o3.tooltip, this._addDescribedBy(e3, s3.attr("id")), s3.find(".ui-tooltip-content").html(i3), this.liveRegion.children().hide(), (o3 = V("<div>").html(s3.find(".ui-tooltip-content").html())).removeAttr("name").find("[name]").removeAttr("name"), o3.removeAttr("id").find("[id]").removeAttr("id"), o3.appendTo(this.liveRegion), this.options.track && t3 && /^mouse/.test(t3.type) ? (this._on(this.document, { mousemove: r3 }), r3(t3)) : s3.position(V.extend({ of: e3 }, this.options.position)), s3.hide(), this._show(s3, this.options.show), this.options.track && this.options.show && this.options.show.delay && (n3 = this.delayedShow = setInterval(function() {
      s3.is(":visible") && (r3(a3.of), clearInterval(n3));
    }, 13)), this._trigger("open", t3, { tooltip: s3 })));
  }, _registerCloseHandlers: function(t3, e3) {
    var i3 = { keyup: function(t4) {
      t4.keyCode === V.ui.keyCode.ESCAPE && ((t4 = V.Event(t4)).currentTarget = e3[0], this.close(t4, true));
    } };
    e3[0] !== this.element[0] && (i3.remove = function() {
      var t4 = this._find(e3);
      t4 && this._removeTooltip(t4.tooltip);
    }), t3 && "mouseover" !== t3.type || (i3.mouseleave = "close"), t3 && "focusin" !== t3.type || (i3.focusout = "close"), this._on(true, e3, i3);
  }, close: function(t3) {
    var e3, i3 = this, s3 = V(t3 ? t3.currentTarget : this.element), n3 = this._find(s3);
    n3 ? (e3 = n3.tooltip, n3.closing || (clearInterval(this.delayedShow), s3.data("ui-tooltip-title") && !s3.attr("title") && s3.attr("title", s3.data("ui-tooltip-title")), this._removeDescribedBy(s3), n3.hiding = true, e3.stop(true), this._hide(e3, this.options.hide, function() {
      i3._removeTooltip(V(this));
    }), s3.removeData("ui-tooltip-open"), this._off(s3, "mouseleave focusout keyup"), s3[0] !== this.element[0] && this._off(s3, "remove"), this._off(this.document, "mousemove"), t3 && "mouseleave" === t3.type && V.each(this.parents, function(t4, e4) {
      V(e4.element).attr("title", e4.title), delete i3.parents[t4];
    }), n3.closing = true, this._trigger("close", t3, { tooltip: e3 }), n3.hiding) || (n3.closing = false)) : s3.removeData("ui-tooltip-open");
  }, _tooltip: function(t3) {
    var e3 = V("<div>").attr("role", "tooltip"), i3 = V("<div>").appendTo(e3), s3 = e3.uniqueId().attr("id");
    return this._addClass(i3, "ui-tooltip-content"), this._addClass(e3, "ui-tooltip", "ui-widget ui-widget-content"), e3.appendTo(this._appendTo(t3)), this.tooltips[s3] = { element: t3, tooltip: e3 };
  }, _find: function(t3) {
    t3 = t3.data("ui-tooltip-id");
    return t3 ? this.tooltips[t3] : null;
  }, _removeTooltip: function(t3) {
    clearInterval(this.delayedShow), t3.remove(), delete this.tooltips[t3.attr("id")];
  }, _appendTo: function(t3) {
    t3 = t3.closest(".ui-front, dialog");
    return t3 = t3.length ? t3 : this.document[0].body;
  }, _destroy: function() {
    var s3 = this;
    V.each(this.tooltips, function(t3, e3) {
      var i3 = V.Event("blur"), e3 = e3.element;
      i3.target = i3.currentTarget = e3[0], s3.close(i3, true), V("#" + t3).remove(), e3.data("ui-tooltip-title") && (e3.attr("title") || e3.attr("title", e3.data("ui-tooltip-title")), e3.removeData("ui-tooltip-title"));
    }), this.liveRegion.remove();
  } }), true === V.uiBackCompat && V.widget("ui.tooltip", V.ui.tooltip, { options: { tooltipClass: null }, _tooltip: function() {
    var t3 = this._superApply(arguments);
    return this.options.tooltipClass && t3.tooltip.addClass(this.options.tooltipClass), t3;
  } }), V.ui.tooltip;
});

// node_modules/wcdatavis/datavis.js
var import_jquery_contextmenu = __toESM(require_jquery_contextMenu());
var import_sumoselect = __toESM(require_jquery_sumoselect());

// node_modules/wcdatavis/src/util/misc.js
var misc_exports = {};
__export(misc_exports, {
  EagerPipeline: () => EagerPipeline,
  I: () => I,
  NOP: () => NOP,
  Timing: () => Timing,
  Y: () => Y,
  addSrcInfo: () => addSrcInfo,
  addTimeComponent: () => addTimeComponent,
  arrayCompare: () => arrayCompare,
  arrayCopy: () => arrayCopy,
  arrayEqual: () => arrayEqual,
  asyncChain: () => asyncChain,
  asyncEach: () => asyncEach,
  blockGrid: () => blockGrid,
  car: () => car,
  cdr: () => cdr,
  chain: () => chain2,
  cmpObjField: () => cmpObjField,
  concatLog: () => concatLog,
  copyProps: () => copyProps,
  curry: () => curry,
  curryCtor: () => curryCtor,
  dataURItoBlob: () => dataURItoBlob,
  debug: () => debug,
  deepCopy: () => deepCopy,
  deepDefaults: () => deepDefaults,
  delegate: () => delegate,
  deprecated: () => deprecated,
  determineColumns: () => determineColumns,
  eachUntil: () => eachUntil,
  eachUntilObj: () => eachUntilObj,
  either: () => either,
  fontAwesome: () => fontAwesome,
  format: () => format2,
  formatDate: () => formatDate,
  formatDateString: () => formatDateString,
  formatDateTime: () => formatDateTime,
  formatDateTimeString: () => formatDateTimeString,
  formatTime: () => formatTime,
  formatTimeString: () => formatTimeString,
  gensym: () => gensym,
  getComparisonFn: () => getComparisonFn,
  getElement: () => getElement,
  getNatRep: () => getNatRep,
  getParamsFromUrl: () => getParamsFromUrl,
  getProp: () => getProp,
  getPropDef: () => getPropDef,
  getText: () => getText,
  gridIsBlocked: () => gridIsBlocked,
  init: () => init,
  interleaveWith: () => interleaveWith,
  iota: () => iota,
  isElement: () => isElement2,
  isElementInViewport: () => isElementInViewport,
  isEmpty: () => isEmpty2,
  isFloat: () => isFloat,
  isInt: () => isInt,
  isLocked: () => isLocked,
  isNothing: () => isNothing,
  isVisible: () => isVisible,
  loadScript: () => loadScript,
  lock: () => lock,
  log: () => log,
  logAsync: () => logAsync,
  makeArray: () => makeArray,
  makeChain: () => makeChain,
  makeCheckbox: () => makeCheckbox,
  makeOperationButton: () => makeOperationButton,
  makeRadioButtons: () => makeRadioButtons,
  makeSetters: () => makeSetters,
  makeSubclass: () => makeSubclass,
  makeSuper: () => makeSuper,
  makeToggleCheckbox: () => makeToggleCheckbox,
  mapLimit: () => mapLimit,
  mergeSort: () => mergeSort,
  mergeSort2: () => mergeSort2,
  mergeSort3: () => mergeSort3,
  mergeSort4: () => mergeSort4,
  mixinDebugging: () => mixinDebugging,
  mixinEventHandling: () => mixinEventHandling,
  mixinLogging: () => mixinLogging,
  mixinNameSetting: () => mixinNameSetting,
  moveArrayElement: () => moveArrayElement,
  needArg: () => needArg,
  needArgInst: () => needArgInst,
  needProp: () => needProp,
  needPropArr: () => needPropArr,
  needPropIn: () => needPropIn,
  needPropInst: () => needPropInst,
  needPropObj: () => needPropObj,
  objFromArray: () => objFromArray,
  objGetPath: () => objGetPath,
  onVisibilityChange: () => onVisibilityChange,
  outerHtml: () => outerHtml,
  parseNumber: () => parseNumber,
  pigeonHoleSort: () => pigeonHoleSort,
  presentDownload: () => presentDownload,
  pruneTree: () => pruneTree,
  removeZeroDateTimes: () => removeZeroDateTimes,
  removeZeroDates: () => removeZeroDates,
  setElement: () => setElement,
  setProp: () => setProp,
  setPropDef: () => setPropDef,
  setTableCell: () => setTableCell,
  shallowCopy: () => shallowCopy,
  sleep: () => sleep,
  stringValueType: () => stringValueType,
  toFloat: () => toFloat,
  toInt: () => toInt2,
  trulyYours: () => trulyYours,
  tryFloatConvert: () => tryFloatConvert,
  tryIntConvert: () => tryIntConvert,
  unblockGrid: () => unblockGrid,
  universalCmp: () => universalCmp,
  unlock: () => unlock,
  uuid: () => uuid,
  validateColConfig: () => validateColConfig,
  valueInfo: () => valueInfo,
  walkObj: () => walkObj,
  withGridBlock: () => withGridBlock
});
var import_bignumber2 = __toESM(require_bignumber());
var import_numeral2 = __toESM(require_numeral());

// node_modules/moment/dist/moment.js
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback2) {
  hookCallback = callback2;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a2, b) {
  return Object.prototype.hasOwnProperty.call(a2, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i2, arrLen = arr.length;
  for (i2 = 0; i2 < arrLen; ++i2) {
    res.push(fn(arr[i2], i2));
  }
  return res;
}
function extend(a2, b) {
  for (var i2 in b) {
    if (hasOwnProp(b, i2)) {
      a2[i2] = b[i2];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a2.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a2.valueOf = b.valueOf;
  }
  return a2;
}
function createUTC(input, format3, locale2, strict) {
  return createLocalOrUTC(input, format3, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i2;
    for (i2 = 0; i2 < len; i2++) {
      if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m2) {
  var flags = null, parsedParts = false, isNowValid = m2._d && !isNaN(m2._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags(m2);
    parsedParts = some.call(flags.parsedDateParts, function(i2) {
      return i2 != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m2)) {
    m2._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m2._isValid;
}
function createInvalid(flags) {
  var m2 = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m2), flags);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [];
var updateInProgress = false;
function copyConfig(to3, from3) {
  var i2, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from3._isAMomentObject)) {
    to3._isAMomentObject = from3._isAMomentObject;
  }
  if (!isUndefined(from3._i)) {
    to3._i = from3._i;
  }
  if (!isUndefined(from3._f)) {
    to3._f = from3._f;
  }
  if (!isUndefined(from3._l)) {
    to3._l = from3._l;
  }
  if (!isUndefined(from3._strict)) {
    to3._strict = from3._strict;
  }
  if (!isUndefined(from3._tzm)) {
    to3._tzm = from3._tzm;
  }
  if (!isUndefined(from3._isUTC)) {
    to3._isUTC = from3._isUTC;
  }
  if (!isUndefined(from3._offset)) {
    to3._offset = from3._offset;
  }
  if (!isUndefined(from3._pf)) {
    to3._pf = getParsingFlags(from3);
  }
  if (!isUndefined(from3._locale)) {
    to3._locale = from3._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i2 = 0; i2 < momentPropertiesLen; i2++) {
      prop = momentProperties[i2];
      val = from3[prop];
      if (!isUndefined(val)) {
        to3[prop] = val;
      }
    }
  }
  return to3;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i2, key, argLen = arguments.length;
      for (i2 = 0; i2 < argLen; i2++) {
        arg = "";
        if (typeof arguments[i2] === "object") {
          arg += "\n[" + i2 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i2];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i2;
  for (i2 in config) {
    if (hasOwnProp(config, i2)) {
      prop = config[i2];
      if (isFunction(prop)) {
        this[i2] = prop;
      } else {
        this["_" + i2] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i2, res = [];
    for (i2 in obj) {
      if (hasOwnProp(obj, i2)) {
        res.push(i2);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign3 = number >= 0;
  return (sign3 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
var formatFunctions = {};
var formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback2) {
  var func = callback2;
  if (typeof callback2 === "string") {
    func = function() {
      return this[callback2]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format3) {
  var array = format3.match(formattingTokens), i2, length;
  for (i2 = 0, length = array.length; i2 < length; i2++) {
    if (formatTokenFunctions[array[i2]]) {
      array[i2] = formatTokenFunctions[array[i2]];
    } else {
      array[i2] = removeFormattingTokens(array[i2]);
    }
  }
  return function(mom) {
    var output = "", i3;
    for (i3 = 0; i3 < length; i3++) {
      output += isFunction(array[i3]) ? array[i3].call(mom, format3) : array[i3];
    }
    return output;
  };
}
function formatMoment(m2, format3) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format3 = expandFormat(format3, m2.localeData());
  formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
  return formatFunctions[format3](m2);
}
function expandFormat(format3, locale2) {
  var i2 = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i2 >= 0 && localFormattingTokens.test(format3)) {
    format3 = format3.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i2 -= 1;
  }
  return format3;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format3 || !formatUpper) {
    return format3;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d";
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format3) ? format3(output) : format3.replace(/%s/i, output);
}
var aliases = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a2, b) {
    return a2.priority - b.priority;
  });
  return units;
}
var match1 = /\d/;
var match2 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match6 = /[+-]?\d{6}/;
var match1to2 = /\d\d?/;
var match3to4 = /\d\d\d\d?/;
var match5to6 = /\d\d\d\d\d\d?/;
var match1to3 = /\d{1,3}/;
var match1to4 = /\d{1,4}/;
var match1to6 = /[+-]?\d{1,6}/;
var matchUnsigned = /\d+/;
var matchSigned = /[+-]?\d+/;
var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
var match1to2NoLeadingZero = /^[1-9]\d?/;
var match1to2HasZero = /^([1-9]\d|\d)/;
var regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s2) {
  return regexEscape(
    s2.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
var tokens = {};
function addParseToken(token2, callback2) {
  var i2, func = callback2, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback2)) {
    func = function(input, array) {
      array[callback2] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    tokens[token2[i2]] = func;
  }
}
function addWeekParseToken(token2, callback2) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback2(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var d2 = mom._d, isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d2.getUTCMilliseconds() : d2.getMilliseconds();
    case "Seconds":
      return isUTC ? d2.getUTCSeconds() : d2.getSeconds();
    case "Minutes":
      return isUTC ? d2.getUTCMinutes() : d2.getMinutes();
    case "Hours":
      return isUTC ? d2.getUTCHours() : d2.getHours();
    case "Date":
      return isUTC ? d2.getUTCDate() : d2.getDate();
    case "Day":
      return isUTC ? d2.getUTCDay() : d2.getDay();
    case "Month":
      return isUTC ? d2.getUTCMonth() : d2.getMonth();
    case "FullYear":
      return isUTC ? d2.getUTCFullYear() : d2.getFullYear();
    default:
      return NaN;
  }
}
function set$1(mom, unit, value) {
  var d2, isUTC, year, month, date;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d2 = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d2.setUTCMilliseconds(value) : d2.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d2.setUTCSeconds(value) : d2.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d2.setUTCMinutes(value) : d2.setMinutes(value));
    case "Hours":
      return void (isUTC ? d2.setUTCHours(value) : d2.setHours(value));
    case "Date":
      return void (isUTC ? d2.setUTCDate(value) : d2.setDate(value));
    // case 'Day': // Not real
    //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
    // case 'Month': // Not used because we need to pass two variables
    //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
    case "FullYear":
      break;
    // See below ...
    default:
      return;
  }
  year = value;
  month = mom.month();
  date = mom.date();
  date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
  void (isUTC ? d2.setUTCFullYear(year, month, date) : d2.setFullYear(year, month, date));
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
    for (i2 = 0; i2 < prioritizedLen; i2++) {
      this[prioritized[i2].unit](units[prioritized[i2].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod(n2, x) {
  return (n2 % x + x) % x;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o2) {
    var i2;
    for (i2 = 0; i2 < this.length; ++i2) {
      if (this[i2] === o2) {
        return i2;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format3) {
  return this.localeData().monthsShort(this, format3);
});
addFormatToken("MMMM", 0, 0, function(format3) {
  return this.localeData().months(this, format3);
});
addRegexToken("M", match1to2, match1to2NoLeadingZero);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
);
var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultMonthsShortRegex = matchWord;
var defaultMonthsRegex = matchWord;
function localeMonths(m2, format3) {
  if (!m2) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format3) {
  if (!m2) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format3, strict) {
  var i2, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i2 = 0; i2 < 12; ++i2) {
      mom = createUTC([2e3, i2]);
      this._shortMonthsParse[i2] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format3 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format3 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format3, strict) {
  var i2, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format3, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    if (strict && !this._longMonthsParse[i2]) {
      this._longMonthsParse[i2] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i2] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i2]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format3 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (strict && format3 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (!strict && this._monthsParse[i2].test(monthName)) {
      return i2;
    }
  }
}
function setMonth(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  var month = value, date = mom.date();
  date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
  void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a2, b) {
    return b.length - a2.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, shortP, longP;
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    shortP = regexEscape(this.monthsShort(mom, ""));
    longP = regexEscape(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function createDate(y, m2, d2, h, M, s2, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m2, d2, h, M, s2, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m2, d2, h, M, s2, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addRegexToken("w", match1to2, match1to2NoLeadingZero);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2, match1to2NoLeadingZero);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format3) {
  return this.localeData().weekdaysMin(this, format3);
});
addFormatToken("ddd", 0, 0, function(format3) {
  return this.localeData().weekdaysShort(this, format3);
});
addFormatToken("dddd", 0, 0, function(format3) {
  return this.localeData().weekdays(this, format3);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
var defaultWeekdaysRegex = matchWord;
var defaultWeekdaysShortRegex = matchWord;
var defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format3) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format3, strict) {
  var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i2 = 0; i2 < 7; ++i2) {
      mom = createUTC([2e3, 1]).day(i2);
      this._minWeekdaysParse[i2] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i2] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format3 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format3 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format3 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format3 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format3, strict) {
  var i2, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format3, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    if (strict && !this._fullWeekdaysParse[i2]) {
      this._fullWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i2]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format3 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format3 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
      return i2;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get(this, "Day");
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a2, b) {
    return b.length - a2.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2, match1to2HasZero);
addRegexToken("h", match1to2, match1to2NoLeadingZero);
addRegexToken("k", match1to2, match1to2NoLeadingZero);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
var getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {};
var localeFamilies = {};
var globalLocale;
function commonPrefix(arr1, arr2) {
  var i2, minl = Math.min(arr1.length, arr2.length);
  for (i2 = 0; i2 < minl; i2 += 1) {
    if (arr1[i2] !== arr2[i2]) {
      return i2;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names2) {
  var i2 = 0, j, next, locale2, split;
  while (i2 < names2.length) {
    split = normalizeLocale(names2[i2]).split("-");
    j = split.length;
    next = normalizeLocale(names2[i2 + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i2++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return !!(name && name.match("^[^/\\\\]*$"));
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e2) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values2) {
  var data;
  if (key) {
    if (isUndefined(values2)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values2);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m2) {
  var overflow, a2 = m2._a;
  if (a2 && getParsingFlags(m2).overflow === -2) {
    overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
var isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
];
var isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
];
var aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
var obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i2, l2, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
      if (isoDates[i2][1].exec(match[1])) {
        dateFormat = isoDates[i2][0];
        allowTime = isoDates[i2][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
        if (isoTimes[i2][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i2][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result2 = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result2.push(parseInt(secondStr, 10));
  }
  return result2;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m2 = hm % 100, h = (hm - m2) / 100;
    return h * 60 + m2;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config) {
    config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
  }
);
function defaults2(a2, b, c2) {
  if (a2 != null) {
    return a2;
  }
  if (b != null) {
    return b;
  }
  return c2;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
    config._a[i2] = input[i2] = currentDate[i2];
  }
  for (; i2 < 7; i2++) {
    config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults2(
      w.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults2(w.W, 1);
    weekday = defaults2(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults2(w.gg, config._a[YEAR], curWeek.year);
    week = defaults2(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    token2 = tokens2[i2];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i2 = 0; i2 < configfLen; i2++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i2];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
  config._a = map(
    [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format3 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format3 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format3)) {
    configFromStringAndArray(config);
  } else if (format3) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
  var c2 = {};
  if (format3 === true || format3 === false) {
    strict = format3;
    format3 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale2;
  c2._i = input;
  c2._f = format3;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input, format3, locale2, strict) {
  return createLocalOrUTC(input, format3, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
var prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn, moments) {
  var res, i2;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i2 = 1; i2 < moments.length; ++i2) {
    if (!moments[i2].isValid() || moments[i2][fn](res)) {
      res = moments[i2];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i2, orderLen = ordering.length;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i2 = 0; i2 < orderLen; ++i2) {
    if (m2[ordering[i2]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration2) {
  var normalizedInput = normalizeObjectUnits(duration2), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
  for (i2 = 0; i2 < len; i2++) {
    if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign3 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign3 = "-";
    }
    return sign3 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher2, string) {
  var matches = (string || "").match(matcher2), chunk2, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk2 = matches[matches.length - 1] || [];
  parts = (chunk2 + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration2 = input, match = null, sign3, ret, diffRes;
  if (isDuration(input)) {
    duration2 = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration2 = {};
    if (key) {
      duration2[key] = +input;
    } else {
      duration2.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign3 = match[1] === "-" ? -1 : 1;
    duration2 = {
      y: 0,
      d: toInt(match[DATE]) * sign3,
      h: toInt(match[HOUR]) * sign3,
      m: toInt(match[MINUTE]) * sign3,
      s: toInt(match[SECOND]) * sign3,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign3
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign3 = match[1] === "-" ? -1 : 1;
    duration2 = {
      y: parseIso(match[2], sign3),
      M: parseIso(match[3], sign3),
      w: parseIso(match[4], sign3),
      d: parseIso(match[5], sign3),
      h: parseIso(match[6], sign3),
      m: parseIso(match[7], sign3),
      s: parseIso(match[8], sign3)
    };
  } else if (duration2 == null) {
    duration2 = {};
  } else if (typeof duration2 === "object" && ("from" in duration2 || "to" in duration2)) {
    diffRes = momentsDifference(
      createLocal(duration2.from),
      createLocal(duration2.to)
    );
    duration2 = {};
    duration2.ms = diffRes.milliseconds;
    duration2.M = diffRes.months;
  }
  ret = new Duration(duration2);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign3) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign3;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration2, isAdding, updateOffset) {
  var milliseconds2 = duration2._milliseconds, days2 = absRound(duration2._days), months2 = absRound(duration2._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add");
var subtract = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i2, property2, propertyLen = properties.length;
  for (i2 = 0; i2 < propertyLen; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i2, property2;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats2) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats2 = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats2 = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats2 = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output = formats2 && (isFunction(formats2[format3]) ? formats2[format3].call(this, now2) : formats2[format3]);
  return this.format(
    output || this.localeData().calendar(format3, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween2(from3, to3, units, inclusivity) {
  var localFrom = isMoment(from3) ? from3 : createLocal(from3), localTo = isMoment(to3) ? to3 : createLocal(to3);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    // 1000
    case "minute":
      output = (this - that) / 6e4;
      break;
    // 1000 * 60
    case "hour":
      output = (this - that) / 36e5;
      break;
    // 1000 * 60 * 60
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    // 1000 * 60 * 60 * 24, negate dst
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    // 1000 * 60 * 60 * 24 * 7, negate dst
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a2, b) {
  if (a2.date() < b.date()) {
    return -monthDiff(b, a2);
  }
  var wholeMonthDiff = (b.year() - a2.year()) * 12 + (b.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(
      m2,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(
    m2,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE = 60 * MS_PER_SECOND;
var MS_PER_HOUR = 60 * MS_PER_MINUTE;
var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m2, d2) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m2, d2).valueOf();
  }
}
function utcStartOfDate(y, m2, d2) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m2, d2);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array, config, token2) {
    var era = config._locale.erasParse(input, token2, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config, token2) {
  var match;
  if (config._locale._eraYearOrdinalRegex) {
    match = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m2, format3) {
  var i2, l2, date, eras = this._eras || getLocale("en")._eras;
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    switch (typeof eras[i2].since) {
      case "string":
        date = hooks(eras[i2].since).startOf("day");
        eras[i2].since = date.valueOf();
        break;
    }
    switch (typeof eras[i2].until) {
      case "undefined":
        eras[i2].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i2].until).startOf("day").valueOf();
        eras[i2].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format3, strict) {
  var i2, l2, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    name = eras[i2].name.toUpperCase();
    abbr = eras[i2].abbr.toUpperCase();
    narrow = eras[i2].narrow.toUpperCase();
    if (strict) {
      switch (format3) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i2];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i2];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i2];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i2];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].name;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].narrow;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].abbr;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i2, l2, dir, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
      return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    erasName = regexEscape(eras[i2].name);
    erasAbbr = regexEscape(eras[i2].abbr);
    erasNarrow = regexEscape(eras[i2].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addRegexToken("D", match1to2, match1to2NoLeadingZero);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addRegexToken("m", match1to2, match1to2HasZero);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addRegexToken("s", match1to2, match1to2HasZero);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token;
var getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween2;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format3, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format3);
}
function listMonthsImpl(format3, index2, field) {
  if (isNumber(format3)) {
    index2 = format3;
    format3 = void 0;
  }
  format3 = format3 || "";
  if (index2 != null) {
    return get$1(format3, index2, field, "month");
  }
  var i2, out = [];
  for (i2 = 0; i2 < 12; i2++) {
    out[i2] = get$1(format3, i2, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format3, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format3)) {
      index2 = format3;
      format3 = void 0;
    }
    format3 = format3 || "";
  } else {
    format3 = localeSorted;
    index2 = format3;
    localeSorted = false;
    if (isNumber(format3)) {
      index2 = format3;
      format3 = void 0;
    }
    format3 = format3 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
  if (index2 != null) {
    return get$1(format3, (index2 + shift) % 7, field, "day");
  }
  for (i2 = 0; i2 < 7; i2++) {
    out[i2] = get$1(format3, (i2 + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format3, index2) {
  return listMonthsImpl(format3, index2, "months");
}
function listMonthsShort(format3, index2) {
  return listMonthsImpl(format3, index2, "monthsShort");
}
function listWeekdays(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration2, input, value, direction) {
  var other = createDuration(input, value);
  duration2._milliseconds += direction * other._milliseconds;
  duration2._days += direction * other._days;
  duration2._months += direction * other._months;
  return duration2._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      // Math.floor prevents floating point math errors here
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms");
var asSeconds = makeAs("s");
var asMinutes = makeAs("m");
var asHours = makeAs("h");
var asDays = makeAs("d");
var asWeeks = makeAs("w");
var asMonths = makeAs("M");
var asQuarters = makeAs("Q");
var asYears = makeAs("y");
var valueOf$1 = asMilliseconds;
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds");
var seconds = makeGetter("seconds");
var minutes = makeGetter("minutes");
var hours = makeGetter("hours");
var days = makeGetter("days");
var months = makeGetter("months");
var years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round;
var thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration2 = createDuration(posNegDuration).abs(), seconds2 = round(duration2.as("s")), minutes2 = round(duration2.as("m")), hours2 = round(duration2.as("h")), days2 = round(duration2.as("d")), months2 = round(duration2.as("M")), weeks2 = round(duration2.as("w")), years2 = round(duration2.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a2[2] = withoutSuffix;
  a2[3] = +posNegDuration > 0;
  a2[4] = locale2;
  return substituteTimeAgo.apply(null, a2);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});
hooks.version = "2.30.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var moment_default = hooks;

// node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some2,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone2,
  collect: () => map2,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce2,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get2,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys2,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map2,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max2,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min2,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some2,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray2,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});

// node_modules/underscore/modules/_setup.js
var VERSION = "1.13.6";
var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
var push = ArrayProto.push;
var slice = ArrayProto.slice;
var toString2 = ObjProto.toString;
var hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
var supportsDataView = typeof DataView !== "undefined";
var nativeIsArray = Array.isArray;
var nativeKeys = Object.keys;
var nativeCreate = Object.create;
var nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN;
var _isFinite = isFinite;
var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
var nonEnumerableProps = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

// node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index2 = 0;
    for (; index2 < length; index2++) {
      rest2[index2] = arguments[index2 + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index2 = 0; index2 < startIndex; index2++) {
      args[index2] = arguments[index2];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}

// node_modules/underscore/modules/isObject.js
function isObject2(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}

// node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}

// node_modules/underscore/modules/isUndefined.js
function isUndefined2(obj) {
  return obj === void 0;
}

// node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString2.call(obj) === "[object Boolean]";
}

// node_modules/underscore/modules/isElement.js
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

// node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString2.call(obj) === tag;
  };
}

// node_modules/underscore/modules/isString.js
var isString_default = tagTester("String");

// node_modules/underscore/modules/isNumber.js
var isNumber_default = tagTester("Number");

// node_modules/underscore/modules/isDate.js
var isDate_default = tagTester("Date");

// node_modules/underscore/modules/isRegExp.js
var isRegExp_default = tagTester("RegExp");

// node_modules/underscore/modules/isError.js
var isError_default = tagTester("Error");

// node_modules/underscore/modules/isSymbol.js
var isSymbol_default = tagTester("Symbol");

// node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default = tagTester("ArrayBuffer");

// node_modules/underscore/modules/isFunction.js
var isFunction2 = tagTester("Function");
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
  isFunction2 = function(obj) {
    return typeof obj == "function" || false;
  };
}
var isFunction_default = isFunction2;

// node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default = tagTester("Object");

// node_modules/underscore/modules/_stringTagBug.js
var hasStringTagBug = supportsDataView && hasObjectTag_default(new DataView(new ArrayBuffer(8)));
var isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());

// node_modules/underscore/modules/isDataView.js
var isDataView = tagTester("DataView");
function ie10IsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView_default = hasStringTagBug ? ie10IsDataView : isDataView;

// node_modules/underscore/modules/isArray.js
var isArray_default = nativeIsArray || tagTester("Array");

// node_modules/underscore/modules/_has.js
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}

// node_modules/underscore/modules/isArguments.js
var isArguments = tagTester("Arguments");
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has(obj, "callee");
    };
  }
})();
var isArguments_default = isArguments;

// node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}

// node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}

// node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}

// node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}

// node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}

// node_modules/underscore/modules/_getByteLength.js
var getByteLength_default = shallowProperty("byteLength");

// node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default = createSizePropertyCheck(getByteLength_default);

// node_modules/underscore/modules/isTypedArray.js
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString2.call(obj));
}
var isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);

// node_modules/underscore/modules/_getLength.js
var getLength_default = shallowProperty("length");

// node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys3) {
  var hash = {};
  for (var l2 = keys3.length, i2 = 0; i2 < l2; ++i2) hash[keys3[i2]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys3.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys3) {
  keys3 = emulatedSet(keys3);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto2 = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj, prop) && !keys3.contains(prop)) keys3.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto2[prop] && !keys3.contains(prop)) {
      keys3.push(prop);
    }
  }
}

// node_modules/underscore/modules/keys.js
function keys2(obj) {
  if (!isObject2(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys3 = [];
  for (var key in obj) if (has(obj, key)) keys3.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys3);
  return keys3;
}

// node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null) return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj))) return length === 0;
  return getLength_default(keys2(obj)) === 0;
}

// node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys2(attrs), length = _keys.length;
  if (object2 == null) return !length;
  var obj = Object(object2);
  for (var i2 = 0; i2 < length; i2++) {
    var key = _keys[i2];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}

// node_modules/underscore/modules/underscore.js
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}
_.VERSION = VERSION;
_.prototype.value = function() {
  return this._wrapped;
};
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
_.prototype.toString = function() {
  return String(this._wrapped);
};

// node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}

// node_modules/underscore/modules/isEqual.js
var tagDataView = "[object DataView]";
function eq(a2, b, aStack, bStack) {
  if (a2 === b) return a2 !== 0 || 1 / a2 === 1 / b;
  if (a2 == null || b == null) return false;
  if (a2 !== a2) return b !== b;
  var type = typeof a2;
  if (type !== "function" && type !== "object" && typeof b != "object") return false;
  return deepEq(a2, b, aStack, bStack);
}
function deepEq(a2, b, aStack, bStack) {
  if (a2 instanceof _) a2 = a2._wrapped;
  if (b instanceof _) b = b._wrapped;
  var className = toString2.call(a2);
  if (className !== toString2.call(b)) return false;
  if (hasStringTagBug && className == "[object Object]" && isDataView_default(a2)) {
    if (!isDataView_default(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + a2 === "" + b;
    case "[object Number]":
      if (+a2 !== +a2) return +b !== +b;
      return +a2 === 0 ? 1 / +a2 === 1 / b : +a2 === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a2 === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a2) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a2), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a2)) {
    var byteLength = getByteLength_default(a2);
    if (byteLength !== getByteLength_default(b)) return false;
    if (a2.buffer === b.buffer && a2.byteOffset === b.byteOffset) return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a2 != "object" || typeof b != "object") return false;
    var aCtor = a2.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a2 && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a2) return bStack[length] === b;
  }
  aStack.push(a2);
  bStack.push(b);
  if (areArrays) {
    length = a2.length;
    if (length !== b.length) return false;
    while (length--) {
      if (!eq(a2[length], b[length], aStack, bStack)) return false;
    }
  } else {
    var _keys = keys2(a2), key;
    length = _keys.length;
    if (keys2(b).length !== length) return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b, key) && eq(a2[key], b[key], aStack, bStack))) return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a2, b) {
  return eq(a2, b);
}

// node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject2(obj)) return [];
  var keys3 = [];
  for (var key in obj) keys3.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys3);
  return keys3;
}

// node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null) return false;
    var keys3 = allKeys(obj);
    if (getLength_default(keys3)) return false;
    for (var i2 = 0; i2 < length; i2++) {
      if (!isFunction_default(obj[methods[i2]])) return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName = "forEach";
var hasName = "has";
var commonInit = ["clear", "delete"];
var mapTail = ["get", hasName, "set"];
var mapMethods = commonInit.concat(forEachName, mapTail);
var weakMapMethods = commonInit.concat(mapTail);
var setMethods = ["add"].concat(commonInit, forEachName, hasName);

// node_modules/underscore/modules/isMap.js
var isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");

// node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");

// node_modules/underscore/modules/isSet.js
var isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");

// node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default = tagTester("WeakSet");

// node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys2(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i2 = 0; i2 < length; i2++) {
    values2[i2] = obj[_keys[i2]];
  }
  return values2;
}

// node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys2(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i2 = 0; i2 < length; i2++) {
    pairs2[i2] = [_keys[i2], obj[_keys[i2]]];
  }
  return pairs2;
}

// node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys2(obj);
  for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
    result2[obj[_keys[i2]]] = _keys[i2];
  }
  return result2;
}

// node_modules/underscore/modules/functions.js
function functions(obj) {
  var names2 = [];
  for (var key in obj) {
    if (isFunction_default(obj[key])) names2.push(key);
  }
  return names2.sort();
}

// node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults4) {
  return function(obj) {
    var length = arguments.length;
    if (defaults4) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index2 = 1; index2 < length; index2++) {
      var source = arguments[index2], keys3 = keysFunc(source), l2 = keys3.length;
      for (var i2 = 0; i2 < l2; i2++) {
        var key = keys3[i2];
        if (!defaults4 || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}

// node_modules/underscore/modules/extend.js
var extend_default = createAssigner(allKeys);

// node_modules/underscore/modules/extendOwn.js
var extendOwn_default = createAssigner(keys2);

// node_modules/underscore/modules/defaults.js
var defaults_default = createAssigner(allKeys, true);

// node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject2(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}

// node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props) extendOwn_default(result2, props);
  return result2;
}

// node_modules/underscore/modules/clone.js
function clone2(obj) {
  if (!isObject2(obj)) return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}

// node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}

// node_modules/underscore/modules/toPath.js
function toPath(path) {
  return isArray_default(path) ? path : [path];
}
_.toPath = toPath;

// node_modules/underscore/modules/_toPath.js
function toPath2(path) {
  return _.toPath(path);
}

// node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path) {
  var length = path.length;
  for (var i2 = 0; i2 < length; i2++) {
    if (obj == null) return void 0;
    obj = obj[path[i2]];
  }
  return length ? obj : void 0;
}

// node_modules/underscore/modules/get.js
function get2(object2, path, defaultValue) {
  var value = deepGet(object2, toPath2(path));
  return isUndefined2(value) ? defaultValue : value;
}

// node_modules/underscore/modules/has.js
function has2(obj, path) {
  path = toPath2(path);
  var length = path.length;
  for (var i2 = 0; i2 < length; i2++) {
    var key = path[i2];
    if (!has(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}

// node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}

// node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}

// node_modules/underscore/modules/property.js
function property(path) {
  path = toPath2(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}

// node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    // The 2-argument case is omitted because were not using it.
    case 3:
      return function(value, index2, collection) {
        return func.call(context, value, index2, collection);
      };
    case 4:
      return function(accumulator, value, index2, collection) {
        return func.call(context, accumulator, value, index2, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}

// node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (isFunction_default(value)) return optimizeCb(value, context, argCount);
  if (isObject2(value) && !isArray_default(value)) return matcher(value);
  return property(value);
}

// node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_.iteratee = iteratee;

// node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee) return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}

// node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys2(obj), length = _keys.length, results = {};
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys[index2];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}

// node_modules/underscore/modules/noop.js
function noop() {
}

// node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path) {
    return get2(obj, path);
  };
}

// node_modules/underscore/modules/times.js
function times(n2, iteratee2, context) {
  var accum = Array(Math.max(0, n2));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i2 = 0; i2 < n2; i2++) accum[i2] = iteratee2(i2);
  return accum;
}

// node_modules/underscore/modules/random.js
function random(min3, max3) {
  if (max3 == null) {
    max3 = min3;
    min3 = 0;
  }
  return min3 + Math.floor(Math.random() * (max3 - min3 + 1));
}

// node_modules/underscore/modules/now.js
var now_default = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};

// node_modules/underscore/modules/_createEscaper.js
function createEscaper(map5) {
  var escaper = function(match) {
    return map5[match];
  };
  var source = "(?:" + keys2(map5).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}

// node_modules/underscore/modules/_escapeMap.js
var escapeMap_default = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

// node_modules/underscore/modules/escape.js
var escape_default = createEscaper(escapeMap_default);

// node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default = invert(escapeMap_default);

// node_modules/underscore/modules/unescape.js
var unescape_default = createEscaper(unescapeMap_default);

// node_modules/underscore/modules/templateSettings.js
var templateSettings_default = _.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};

// node_modules/underscore/modules/template.js
var noMatch = /(.)^/;
var escapes = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
  return "\\" + escapes[match];
}
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index2 = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape, interpolate3, evaluate, offset2) {
    source += text.slice(index2, offset2).replace(escapeRegExp, escapeChar);
    index2 = offset2 + match.length;
    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate3) {
      source += "'+\n((__t=(" + interpolate3 + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument)) throw new Error(
      "variable is not a bare identifier: " + argument
    );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e2) {
    e2.source = source;
    throw e2;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}

// node_modules/underscore/modules/result.js
function result(obj, path, fallback) {
  path = toPath2(path);
  var length = path.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i2 = 0; i2 < length; i2++) {
    var prop = obj == null ? void 0 : obj[path[i2]];
    if (prop === void 0) {
      prop = fallback;
      i2 = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}

// node_modules/underscore/modules/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}

// node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}

// node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject2(result2)) return result2;
  return self2;
}

// node_modules/underscore/modules/partial.js
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i2 = 0; i2 < length; i2++) {
      args[i2] = boundArgs[i2] === placeholder ? arguments[position++] : boundArgs[i2];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});
partial.placeholder = _;
var partial_default = partial;

// node_modules/underscore/modules/bind.js
var bind_default = restArguments(function(func, context, args) {
  if (!isFunction_default(func)) throw new TypeError("Bind must be called on a function");
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
});

// node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default = createSizePropertyCheck(getLength_default);

// node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i2 = 0, length = getLength_default(input); i2 < length; i2++) {
    var value = input[i2];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

// node_modules/underscore/modules/bindAll.js
var bindAll_default = restArguments(function(obj, keys3) {
  keys3 = flatten(keys3, false, false);
  var index2 = keys3.length;
  if (index2 < 1) throw new Error("bindAll must be passed function names");
  while (index2--) {
    var key = keys3[index2];
    obj[key] = bind_default(obj[key], obj);
  }
  return obj;
});

// node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}

// node_modules/underscore/modules/delay.js
var delay_default = restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
});

// node_modules/underscore/modules/defer.js
var defer_default = partial_default(delay_default, _, 1);

// node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options) options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  var throttled2 = function() {
    var _now = now_default();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled2.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled2;
}

// node_modules/underscore/modules/debounce.js
function debounce2(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result2 = func.apply(context, args);
      if (!timeout) args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}

// node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}

// node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

// node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i2 = start;
    var result2 = args[start].apply(this, arguments);
    while (i2--) result2 = args[i2].call(this, result2);
    return result2;
  };
}

// node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}

// node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1) func = null;
    return memo;
  };
}

// node_modules/underscore/modules/once.js
var once_default = partial_default(before, 2);

// node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys2(obj), key;
  for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
    key = _keys[i2];
    if (predicate(obj[key], key, obj)) return key;
  }
}

// node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index2 = dir > 0 ? 0 : length - 1;
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      if (predicate(array[index2], index2, array)) return index2;
    }
    return -1;
  };
}

// node_modules/underscore/modules/findIndex.js
var findIndex_default = createPredicateIndexFinder(1);

// node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default = createPredicateIndexFinder(-1);

// node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value) low = mid + 1;
    else high = mid;
  }
  return low;
}

// node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i2 = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i2 = idx >= 0 ? idx : Math.max(idx + length, i2);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i2, length), isNaN2);
      return idx >= 0 ? idx + i2 : -1;
    }
    for (idx = dir > 0 ? i2 : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}

// node_modules/underscore/modules/indexOf.js
var indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);

// node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);

// node_modules/underscore/modules/find.js
function find(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}

// node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}

// node_modules/underscore/modules/each.js
function each(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i2, length;
  if (isArrayLike_default(obj)) {
    for (i2 = 0, length = obj.length; i2 < length; i2++) {
      iteratee2(obj[i2], i2, obj);
    }
  } else {
    var _keys = keys2(obj);
    for (i2 = 0, length = _keys.length; i2 < length; i2++) {
      iteratee2(obj[_keys[i2]], _keys[i2], obj);
    }
  }
  return obj;
}

// node_modules/underscore/modules/map.js
function map2(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys2(obj), length = (_keys || obj).length, results = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    results[index2] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}

// node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys2(obj), length = (_keys || obj).length, index2 = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index2] : index2];
      index2 += dir;
    }
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      var currentKey = _keys ? _keys[index2] : index2;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}

// node_modules/underscore/modules/reduce.js
var reduce_default = createReduce(1);

// node_modules/underscore/modules/reduceRight.js
var reduceRight_default = createReduce(-1);

// node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index2, list) {
    if (predicate(value, index2, list)) results.push(value);
  });
  return results;
}

// node_modules/underscore/modules/reject.js
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}

// node_modules/underscore/modules/every.js
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys2(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}

// node_modules/underscore/modules/some.js
function some2(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys2(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}

// node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj)) obj = values(obj);
  if (typeof fromIndex != "number" || guard) fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}

// node_modules/underscore/modules/invoke.js
var invoke_default = restArguments(function(obj, path, args) {
  var contextPath, func;
  if (isFunction_default(path)) {
    func = path;
  } else {
    path = toPath2(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map2(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
});

// node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map2(obj, property(key));
}

// node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}

// node_modules/underscore/modules/max.js
function max2(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i2 = 0, length = obj.length; i2 < length; i2++) {
      value = obj[i2];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index2, list) {
      computed = iteratee2(v, index2, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}

// node_modules/underscore/modules/min.js
function min2(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i2 = 0, length = obj.length; i2 < length; i2++) {
      value = obj[i2];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index2, list) {
      computed = iteratee2(v, index2, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}

// node_modules/underscore/modules/toArray.js
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray2(obj) {
  if (!obj) return [];
  if (isArray_default(obj)) return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj)) return map2(obj, identity);
  return values(obj);
}

// node_modules/underscore/modules/sample.js
function sample(obj, n2, guard) {
  if (n2 == null || guard) {
    if (!isArrayLike_default(obj)) obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample3 = toArray2(obj);
  var length = getLength_default(sample3);
  n2 = Math.max(Math.min(n2, length), 0);
  var last2 = length - 1;
  for (var index2 = 0; index2 < n2; index2++) {
    var rand = random(index2, last2);
    var temp = sample3[index2];
    sample3[index2] = sample3[rand];
    sample3[rand] = temp;
  }
  return sample3.slice(0, n2);
}

// node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}

// node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index2 = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map2(obj, function(value, key, list) {
    return {
      value,
      index: index2++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a2 = left.criteria;
    var b = right.criteria;
    if (a2 !== b) {
      if (a2 > b || a2 === void 0) return 1;
      if (a2 < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), "value");
}

// node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj, function(value, index2) {
      var key = iteratee2(value, index2, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}

// node_modules/underscore/modules/groupBy.js
var groupBy_default = group(function(result2, value, key) {
  if (has(result2, key)) result2[key].push(value);
  else result2[key] = [value];
});

// node_modules/underscore/modules/indexBy.js
var indexBy_default = group(function(result2, value, key) {
  result2[key] = value;
});

// node_modules/underscore/modules/countBy.js
var countBy_default = group(function(result2, value, key) {
  if (has(result2, key)) result2[key]++;
  else result2[key] = 1;
});

// node_modules/underscore/modules/partition.js
var partition_default = group(function(result2, value, pass) {
  result2[pass ? 0 : 1].push(value);
}, true);

// node_modules/underscore/modules/size.js
function size(obj) {
  if (obj == null) return 0;
  return isArrayLike_default(obj) ? obj.length : keys2(obj).length;
}

// node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}

// node_modules/underscore/modules/pick.js
var pick_default = restArguments(function(obj, keys3) {
  var result2 = {}, iteratee2 = keys3[0];
  if (obj == null) return result2;
  if (isFunction_default(iteratee2)) {
    if (keys3.length > 1) iteratee2 = optimizeCb(iteratee2, keys3[1]);
    keys3 = allKeys(obj);
  } else {
    iteratee2 = keyInObj;
    keys3 = flatten(keys3, false, false);
    obj = Object(obj);
  }
  for (var i2 = 0, length = keys3.length; i2 < length; i2++) {
    var key = keys3[i2];
    var value = obj[key];
    if (iteratee2(value, key, obj)) result2[key] = value;
  }
  return result2;
});

// node_modules/underscore/modules/omit.js
var omit_default = restArguments(function(obj, keys3) {
  var iteratee2 = keys3[0], context;
  if (isFunction_default(iteratee2)) {
    iteratee2 = negate(iteratee2);
    if (keys3.length > 1) context = keys3[1];
  } else {
    keys3 = map2(flatten(keys3, false, false), String);
    iteratee2 = function(value, key) {
      return !contains(keys3, key);
    };
  }
  return pick_default(obj, iteratee2, context);
});

// node_modules/underscore/modules/initial.js
function initial(array, n2, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n2 == null || guard ? 1 : n2)));
}

// node_modules/underscore/modules/first.js
function first(array, n2, guard) {
  if (array == null || array.length < 1) return n2 == null || guard ? void 0 : [];
  if (n2 == null || guard) return array[0];
  return initial(array, array.length - n2);
}

// node_modules/underscore/modules/rest.js
function rest(array, n2, guard) {
  return slice.call(array, n2 == null || guard ? 1 : n2);
}

// node_modules/underscore/modules/last.js
function last(array, n2, guard) {
  if (array == null || array.length < 1) return n2 == null || guard ? void 0 : [];
  if (n2 == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n2));
}

// node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}

// node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}

// node_modules/underscore/modules/difference.js
var difference_default = restArguments(function(array, rest2) {
  rest2 = flatten(rest2, true, true);
  return filter(array, function(value) {
    return !contains(rest2, value);
  });
});

// node_modules/underscore/modules/without.js
var without_default = restArguments(function(array, otherArrays) {
  return difference_default(array, otherArrays);
});

// node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null) iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i2 = 0, length = getLength_default(array); i2 < length; i2++) {
    var value = array[i2], computed = iteratee2 ? iteratee2(value, i2, array) : value;
    if (isSorted && !iteratee2) {
      if (!i2 || seen !== computed) result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}

// node_modules/underscore/modules/union.js
var union_default = restArguments(function(arrays) {
  return uniq(flatten(arrays, true, true));
});

// node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i2 = 0, length = getLength_default(array); i2 < length; i2++) {
    var item = array[i2];
    if (contains(result2, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result2.push(item);
  }
  return result2;
}

// node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max2(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    result2[index2] = pluck(array, index2);
  }
  return result2;
}

// node_modules/underscore/modules/zip.js
var zip_default = restArguments(unzip);

// node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i2 = 0, length = getLength_default(list); i2 < length; i2++) {
    if (values2) {
      result2[list[i2]] = values2[i2];
    } else {
      result2[list[i2][0]] = list[i2][1];
    }
  }
  return result2;
}

// node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}

// node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result2 = [];
  var i2 = 0, length = array.length;
  while (i2 < length) {
    result2.push(slice.call(array, i2, i2 += count));
  }
  return result2;
}

// node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}

// node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}

// node_modules/underscore/modules/underscore-array-methods.js
each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === "shift" || name === "splice") && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});
each(["concat", "join", "slice"], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});
var underscore_array_methods_default = _;

// node_modules/underscore/modules/index-default.js
var _2 = mixin(modules_exports);
_2._ = _2;
var index_default_default = _2;

// node_modules/wcdatavis/src/util/misc.js
var import_sprintf_js2 = __toESM(require_sprintf());

// node_modules/json-formatter-js/dist/json-formatter.esm.js
function t(t2) {
  return null === t2 ? "null" : typeof t2;
}
function e(t2) {
  return !!t2 && "object" == typeof t2;
}
function r(t2) {
  if (void 0 === t2) return "";
  if (null === t2) return "Object";
  if ("object" == typeof t2 && !t2.constructor) return "Object";
  var e2 = /function ([^(]*)/.exec(t2.constructor.toString());
  return e2 && e2.length > 1 ? e2[1] : "";
}
function n(t2, e2, r2) {
  return "null" === t2 || "undefined" === t2 ? t2 : ("string" !== t2 && "stringifiable" !== t2 || (r2 = '"' + r2.replace(/"/g, '\\"') + '"'), "function" === t2 ? e2.toString().replace(/[\r\n]/g, "").replace(/\{.*\}/, "") + "{}" : r2);
}
function o(o2) {
  var i2 = "";
  return e(o2) ? (i2 = r(o2), Array.isArray(o2) && (i2 += "[" + o2.length + "]")) : i2 = n(t(o2), o2, o2), i2;
}
function i(t2) {
  return "json-formatter-" + t2;
}
function s(t2, e2, r2) {
  var n2 = document.createElement(t2);
  return e2 && n2.classList.add(i(e2)), void 0 !== r2 && (r2 instanceof Node ? n2.appendChild(r2) : n2.appendChild(document.createTextNode(String(r2)))), n2;
}
!function(t2) {
  if (t2 && "undefined" != typeof window) {
    var e2 = document.createElement("style");
    e2.setAttribute("media", "screen"), e2.innerHTML = t2, document.head.appendChild(e2);
  }
}('.json-formatter-row,\n.json-formatter-row a,\n.json-formatter-row a:hover {\n  color: black;\n  text-decoration: none;\n}\n.json-formatter-row .json-formatter-row {\n  margin-left: 1rem;\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty {\n  opacity: 0.5;\n  margin-left: 1rem;\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty:after {\n  display: none;\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-object:after {\n  content: "No properties";\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-array:after {\n  content: "[]";\n}\n.json-formatter-row .json-formatter-string,\n.json-formatter-row .json-formatter-stringifiable {\n  color: green;\n  white-space: pre;\n  word-wrap: break-word;\n}\n.json-formatter-row .json-formatter-number {\n  color: blue;\n}\n.json-formatter-row .json-formatter-boolean {\n  color: red;\n}\n.json-formatter-row .json-formatter-null {\n  color: #855A00;\n}\n.json-formatter-row .json-formatter-undefined {\n  color: #ca0b69;\n}\n.json-formatter-row .json-formatter-function {\n  color: #FF20ED;\n}\n.json-formatter-row .json-formatter-date {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n.json-formatter-row .json-formatter-url {\n  text-decoration: underline;\n  color: blue;\n  cursor: pointer;\n}\n.json-formatter-row .json-formatter-bracket {\n  color: blue;\n}\n.json-formatter-row .json-formatter-key {\n  color: #00008B;\n  padding-right: 0.2rem;\n}\n.json-formatter-row .json-formatter-toggler-link {\n  cursor: pointer;\n}\n.json-formatter-row .json-formatter-toggler {\n  line-height: 1.2rem;\n  font-size: 0.7rem;\n  vertical-align: middle;\n  opacity: 0.6;\n  cursor: pointer;\n  padding-right: 0.2rem;\n}\n.json-formatter-row .json-formatter-toggler:after {\n  display: inline-block;\n  transition: transform 100ms ease-in;\n  content: "";\n}\n.json-formatter-row > a > .json-formatter-preview-text {\n  opacity: 0;\n  transition: opacity 0.15s ease-in;\n  font-style: italic;\n}\n.json-formatter-row:hover > a > .json-formatter-preview-text {\n  opacity: 0.6;\n}\n.json-formatter-row.json-formatter-open > .json-formatter-toggler-link .json-formatter-toggler:after {\n  transform: rotate(90deg);\n}\n.json-formatter-row.json-formatter-open > .json-formatter-children:after {\n  display: inline-block;\n}\n.json-formatter-row.json-formatter-open > a > .json-formatter-preview-text {\n  display: none;\n}\n.json-formatter-row.json-formatter-open.json-formatter-empty:after {\n  display: block;\n}\n.json-formatter-dark.json-formatter-row,\n.json-formatter-dark.json-formatter-row a,\n.json-formatter-dark.json-formatter-row a:hover {\n  color: white;\n  text-decoration: none;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-row {\n  margin-left: 1rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty {\n  opacity: 0.5;\n  margin-left: 1rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty:after {\n  display: none;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-object:after {\n  content: "No properties";\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-array:after {\n  content: "[]";\n}\n.json-formatter-dark.json-formatter-row .json-formatter-string,\n.json-formatter-dark.json-formatter-row .json-formatter-stringifiable {\n  color: #31F031;\n  white-space: pre;\n  word-wrap: break-word;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-number {\n  color: #66C2FF;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-boolean {\n  color: #EC4242;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-null {\n  color: #EEC97D;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-undefined {\n  color: #ef8fbe;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-function {\n  color: #FD48CB;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-date {\n  background-color: rgba(255, 255, 255, 0.05);\n}\n.json-formatter-dark.json-formatter-row .json-formatter-url {\n  text-decoration: underline;\n  color: #027BFF;\n  cursor: pointer;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-bracket {\n  color: #9494FF;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-key {\n  color: #23A0DB;\n  padding-right: 0.2rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-toggler-link {\n  cursor: pointer;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-toggler {\n  line-height: 1.2rem;\n  font-size: 0.7rem;\n  vertical-align: middle;\n  opacity: 0.6;\n  cursor: pointer;\n  padding-right: 0.2rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-toggler:after {\n  display: inline-block;\n  transition: transform 100ms ease-in;\n  content: "";\n}\n.json-formatter-dark.json-formatter-row > a > .json-formatter-preview-text {\n  opacity: 0;\n  transition: opacity 0.15s ease-in;\n  font-style: italic;\n}\n.json-formatter-dark.json-formatter-row:hover > a > .json-formatter-preview-text {\n  opacity: 0.6;\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open > .json-formatter-toggler-link .json-formatter-toggler:after {\n  transform: rotate(90deg);\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open > .json-formatter-children:after {\n  display: inline-block;\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open > a > .json-formatter-preview-text {\n  display: none;\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open.json-formatter-empty:after {\n  display: block;\n}\n');
var a = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/;
var f = /\d{2}:\d{2}:\d{2} GMT-\d{4}/;
var m = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;
var l = window.requestAnimationFrame || function(t2) {
  return t2(), 0;
};
var d = { hoverPreviewEnabled: false, hoverPreviewArrayCount: 100, hoverPreviewFieldCount: 5, animateOpen: true, animateClose: true, theme: null, useToJSON: true, sortPropertiesBy: null, onToggle: null };
var c = function() {
  function c2(t2, e2, r2, n2) {
    void 0 === e2 && (e2 = 1), void 0 === r2 && (r2 = d), this.json = t2, this.open = e2, this.config = r2, this.key = n2, this._isOpen = null, void 0 === this.config.hoverPreviewEnabled && (this.config.hoverPreviewEnabled = d.hoverPreviewEnabled), void 0 === this.config.hoverPreviewArrayCount && (this.config.hoverPreviewArrayCount = d.hoverPreviewArrayCount), void 0 === this.config.hoverPreviewFieldCount && (this.config.hoverPreviewFieldCount = d.hoverPreviewFieldCount), void 0 === this.config.useToJSON && (this.config.useToJSON = d.useToJSON), "" === this.key && (this.key = '""');
  }
  return Object.defineProperty(c2.prototype, "isOpen", { get: function() {
    return null !== this._isOpen ? this._isOpen : this.open > 0;
  }, set: function(t2) {
    this._isOpen = t2;
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "isDate", { get: function() {
    return this.json instanceof Date || "string" === this.type && (a.test(this.json) || m.test(this.json) || f.test(this.json));
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "isUrl", { get: function() {
    return "string" === this.type && 0 === this.json.indexOf("http");
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "isArray", { get: function() {
    return Array.isArray(this.json);
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "isObject", { get: function() {
    return e(this.json);
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "isEmptyObject", { get: function() {
    return !this.keys.length && !this.isArray;
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "isEmpty", { get: function() {
    return this.isEmptyObject || this.keys && !this.keys.length && this.isArray;
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "useToJSON", { get: function() {
    return this.config.useToJSON && "stringifiable" === this.type;
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "hasKey", { get: function() {
    return void 0 !== this.key;
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "constructorName", { get: function() {
    return r(this.json);
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "type", { get: function() {
    return this.config.useToJSON && this.json && this.json.toJSON ? "stringifiable" : t(this.json);
  }, enumerable: true, configurable: true }), Object.defineProperty(c2.prototype, "keys", { get: function() {
    if (this.isObject) {
      var t2 = Object.keys(this.json);
      return !this.isArray && this.config.sortPropertiesBy ? t2.sort(this.config.sortPropertiesBy) : t2;
    }
    return [];
  }, enumerable: true, configurable: true }), c2.prototype.toggleOpen = function() {
    this.isOpen = !this.isOpen, this.config.onToggle && this.config.onToggle(this.isOpen), this.element && (this.isOpen ? this.appendChildren(this.config.animateOpen) : this.removeChildren(this.config.animateClose), this.element.classList.toggle(i("open")));
  }, c2.prototype.openAtDepth = function(t2) {
    void 0 === t2 && (t2 = 1), t2 < 0 || (this.open = t2, this.isOpen = 0 !== t2, this.element && (this.removeChildren(false), 0 === t2 ? this.element.classList.remove(i("open")) : (this.appendChildren(this.config.animateOpen), this.element.classList.add(i("open")))));
  }, c2.prototype.getInlinepreview = function() {
    var t2 = this;
    if (this.isArray) return this.json.length > this.config.hoverPreviewArrayCount ? "Array[" + this.json.length + "]" : "[" + this.json.map(o).join(", ") + "]";
    var e2 = this.keys, r2 = e2.slice(0, this.config.hoverPreviewFieldCount).map(function(e3) {
      return e3 + ":" + o(t2.json[e3]);
    }), n2 = e2.length >= this.config.hoverPreviewFieldCount ? "" : "";
    return "{" + r2.join(", ") + n2 + "}";
  }, c2.prototype.render = function() {
    this.element = s("div", "row");
    var t2 = this.isObject ? s("a", "toggler-link") : s("span");
    if (this.isObject && !this.useToJSON && t2.appendChild(s("span", "toggler")), this.hasKey && t2.appendChild(s("span", "key", this.key + ":")), this.isObject && !this.useToJSON) {
      var e2 = s("span", "value"), r2 = s("span"), o2 = s("span", "constructor-name", this.constructorName);
      if (r2.appendChild(o2), this.isArray) {
        var a2 = s("span");
        a2.appendChild(s("span", "bracket", "[")), a2.appendChild(s("span", "number", this.json.length)), a2.appendChild(s("span", "bracket", "]")), r2.appendChild(a2);
      }
      e2.appendChild(r2), t2.appendChild(e2);
    } else {
      (e2 = this.isUrl ? s("a") : s("span")).classList.add(i(this.type)), this.isDate && e2.classList.add(i("date")), this.isUrl && (e2.classList.add(i("url")), e2.setAttribute("href", this.json));
      var f2 = n(this.type, this.json, this.useToJSON ? this.json.toJSON() : this.json);
      e2.appendChild(document.createTextNode(f2)), t2.appendChild(e2);
    }
    if (this.isObject && this.config.hoverPreviewEnabled) {
      var m2 = s("span", "preview-text");
      m2.appendChild(document.createTextNode(this.getInlinepreview())), t2.appendChild(m2);
    }
    var l2 = s("div", "children");
    return this.isObject && l2.classList.add(i("object")), this.isArray && l2.classList.add(i("array")), this.isEmpty && l2.classList.add(i("empty")), this.config && this.config.theme && this.element.classList.add(i(this.config.theme)), this.isOpen && this.element.classList.add(i("open")), this.element.appendChild(t2), this.element.appendChild(l2), this.isObject && this.isOpen && this.appendChildren(), this.isObject && !this.useToJSON && t2.addEventListener("click", this.toggleOpen.bind(this)), this.element;
  }, c2.prototype.appendChildren = function(t2) {
    var e2 = this;
    void 0 === t2 && (t2 = false);
    var r2 = this.element.querySelector("div." + i("children"));
    if (r2 && !this.isEmpty) if (t2) {
      var n2 = 0, o2 = function() {
        var t3 = e2.keys[n2], i2 = new c2(e2.json[t3], e2.open - 1, e2.config, t3);
        r2.appendChild(i2.render()), (n2 += 1) < e2.keys.length && (n2 > 10 ? o2() : l(o2));
      };
      l(o2);
    } else this.keys.forEach(function(t3) {
      var n3 = new c2(e2.json[t3], e2.open - 1, e2.config, t3);
      r2.appendChild(n3.render());
    });
  }, c2.prototype.removeChildren = function(t2) {
    void 0 === t2 && (t2 = false);
    var e2 = this.element.querySelector("div." + i("children"));
    if (t2) {
      var r2 = 0, n2 = function() {
        e2 && e2.children.length && (e2.removeChild(e2.children[0]), (r2 += 1) > 10 ? n2() : l(n2));
      };
      l(n2);
    } else e2 && (e2.innerHTML = "");
  }, c2;
}();
var json_formatter_esm_default = c;

// node_modules/wcdatavis/src/util/ordmap.js
function OrdMap() {
  this._keys = [];
  this._keyIndex = {};
  this._map = {};
  this._size = 0;
  this._setHandlers = {};
  this._prepend = false;
}
Object.defineProperty(OrdMap, "name", { value: "OrdMap" });
OrdMap.prototype = Object.create(Object.prototype);
OrdMap.prototype.constructor = OrdMap;
OrdMap.fromArray = function(values2, keyField) {
  var o2 = new OrdMap();
  for (var i2 = 0; i2 < values2.length; i2 += 1) {
    o2.set(values2[i2][keyField], values2[i2]);
  }
  return o2;
};
OrdMap.fromMerge = function(maps) {
  var o2 = new OrdMap();
  for (var i2 = 0; i2 < maps.length; i2 += 1) {
    if (!(maps[i2] instanceof OrdMap)) {
      throw new Error("Call Error: `maps[" + i2 + "]` must be an OrdMap");
    }
    maps[i2].each(function(v, k) {
      if (!o2.isSet(k)) {
        o2.set(k, v);
      }
    });
  }
  return o2;
};
OrdMap.deserialize = function(x) {
  var result2 = new OrdMap();
  if (typeof x === "string") {
    x = JSON.parse(x);
  }
  for (var i2 = 0; i2 < x._keys.length; i2 += 1) {
    if (x._map[x._keys[i2]] !== void 0) {
      result2.set(x._keys[i2], x._map[x._keys[i2]]);
    }
  }
  return result2;
};
OrdMap.fromJSON = OrdMap.deserialize;
OrdMap.prototype.setInsertOrder = function(dir) {
  switch (dir) {
    case "append":
      this._prepend = false;
      break;
    case "prepend":
      this._prepend = true;
      break;
    default:
      throw new Error('Call Error: `dir` must be either "append" or "prepend"');
  }
};
OrdMap.prototype.get = function(k, d2) {
  return this.isSet(k) ? this._map[k] : d2;
};
OrdMap.prototype.set = function(k, v) {
  if (!this.isSet(k)) {
    if (this._prepend) {
      this._keys.unshift(k);
    } else {
      this._keys.push(k);
    }
    this._keyIndex[k] = this._keys.length - 1;
    this._size += 1;
  }
  this._map[k] = v;
  if (this._setHandlers[k] != null) {
    for (var i2 = 0; i2 < this._setHandlers[k].length; i2 += 1) {
      this._setHandlers[k][i2](v);
    }
    this._setHandlers[k] = null;
  }
};
OrdMap.prototype.append = function(k, v) {
  if (this.isSet(k)) {
    if (!Array.isArray(this._map[k])) {
      this._map[k] = [this._map[k]];
    }
    this._map[k].push(v);
  } else {
    this.set(k, [v]);
  }
};
OrdMap.prototype.unset = function(k) {
  delete this._keyIndex[k];
  delete this._map[k];
  this._size -= 1;
};
OrdMap.prototype.isSet = function(k) {
  return this._keyIndex[k] !== void 0;
};
OrdMap.prototype.each = function(f2) {
  var i2, j = 0, k, v, keyLen = this._keys.length;
  for (i2 = 0; i2 < keyLen; i2 += 1) {
    k = this._keys[i2];
    if (this._keyIndex[k] === i2) {
      v = this._map[k];
      f2(v, k, j);
      j += 1;
    }
  }
};
OrdMap.prototype.keys = function() {
  var i2, k, result2 = [], keyLen = this._keys.length;
  for (i2 = 0; i2 < keyLen; i2 += 1) {
    k = this._keys[i2];
    if (this._keyIndex[k] === i2) {
      result2.push(k);
    }
  }
  return result2;
};
OrdMap.prototype.toString = function() {
  var s2 = "";
  this.each(function(v, k) {
    v = JSON.stringify(v);
    if (v == null) {
      v = "null";
    }
    if (s2 !== "") {
      s2 += ", ";
    }
    s2 += '"' + k + '": ' + v;
  });
  return "{" + s2 + "}";
};
OrdMap.prototype.asMap = function() {
  return this._map;
};
OrdMap.prototype.asHtmlDefnList = function() {
  var dl = jQuery("<dl>");
  this.each(function(v, k) {
    var dt = jQuery("<dt>").text(k);
    var dd = jQuery("<dd>");
    if (v instanceof jQuery || v instanceof Element) {
      dd.append(v);
    } else if (index_default_default.isObject(v)) {
      dd.append(new json_formatter_esm_default(v, 0).render());
    } else {
      dd.text(v);
    }
    jQuery("<div>").append(dt).append(dd).appendTo(dl);
  });
  return dl;
};
OrdMap.prototype.serialize = function() {
  return {
    _keys: this.keys(),
    _map: this.asMap()
  };
};
OrdMap.prototype.toJSON = OrdMap.prototype.serialize;
OrdMap.prototype.size = function() {
  return this._size;
};
OrdMap.prototype.whenSet = function(k, h, opts) {
  opts = opts || {};
  if (opts.prepend == null) {
    opts.prepend = false;
  }
  if (this.isSet(k)) {
    return h(this.get(k));
  }
  if (this._setHandlers[k] == null) {
    this._setHandlers[k] = [];
  }
  if (opts.prepend) {
    this._setHandlers[k].unshift(h);
  } else {
    this._setHandlers[k].push(h);
  }
};
OrdMap.prototype.filter = function(test) {
  var result2 = new OrdMap();
  this.each(function(v, k) {
    if (test(v, k)) {
      result2.set(k, v);
    }
  });
  return result2;
};
OrdMap.prototype.clone = function() {
  var result2 = new OrdMap();
  this.each(function(v, k) {
    result2.set(k, deepCopy(v));
  });
  return result2;
};
OrdMap.prototype.clear = function() {
  this._keys = [];
  this._keyIndex = {};
  this._map = {};
  this._size = 0;
};
OrdMap.prototype.replaceWith = function(o2) {
  var self2 = this;
  if (!(o2 instanceof OrdMap)) {
    throw new Error("Call Error: `o` must be an instance of OrdMap");
  }
  self2.clear();
  o2.each(function(v, k) {
    self2.set(k, v);
  });
};
OrdMap.prototype.mergeWith = function(o2) {
  var self2 = this;
  var numSet = 0;
  if (!(o2 instanceof OrdMap)) {
    throw new Error("Call Error: `o` must be an instance of OrdMap");
  }
  o2.each(function(v, k) {
    if (!self2.isSet(k)) {
      self2.set(k, v);
      numSet += 1;
    }
  });
  return numSet;
};
OrdMap.prototype._changeKeyIndex = function(oldIndex, newIndex) {
  var self2 = this;
  var key = self2._keys[oldIndex];
  self2._keys.splice(oldIndex, 1);
  self2._keys.splice(newIndex, 0, key);
};
var ordmap_default = OrdMap;

// node_modules/wcdatavis/src/util/lock.js
var Lock = function(name, opts) {
  var self2 = this;
  self2._name = name || "#" + Lock._id++;
  self2._lockCount = 0;
  self2._onUnlock = [];
};
Lock._id = 1;
Lock.prototype.lock = function(why) {
  var self2 = this;
  this._lockCount += 1;
  var msg = "Locking to level: " + self2._lockCount;
  if (why != null) {
    msg += " - " + why;
  }
  console.debug("[DataVis // Lock(%s)] %s", self2._name, msg);
};
Lock.prototype.unlock = function(msg) {
  var self2 = this;
  self2._lockCount -= 1;
  if (msg != null) {
    console.debug("[DataVis // Lock(%s)] Unlocking to level %s: %s", self2._name, self2._lockCount, msg);
  } else {
    console.debug("[DataVis // Lock(%s)] Unlocking to level %s", self2._name, self2._lockCount);
  }
  var onUnlockLen = self2._onUnlock.length;
  var i2 = 0;
  while (self2._onUnlock.length > 0 && !self2.isLocked()) {
    i2 += 1;
    var onUnlock = self2._onUnlock.shift();
    console.debug(
      "[DataVis // Lock(%s)] Running onUnlock function (%d of %d) - %s",
      self2._name,
      i2,
      onUnlockLen,
      onUnlock.info || "[NO INFO]"
    );
    onUnlock.f();
  }
};
Lock.prototype.completelyUnlock = function() {
  var self2 = this;
  while (self2.isLocked()) {
    self2.unlock();
  }
};
Lock.prototype.isLocked = function() {
  var self2 = this;
  return self2._lockCount !== 0;
};
Lock.prototype.onUnlock = function(f2, info) {
  var self2 = this;
  if (!self2.isLocked()) {
    return f2();
  }
  self2._onUnlock.push({
    f: f2,
    info
  });
  console.debug(
    "[DataVis // Lock(%s)] Saved onUnlock function (#%d) - %s",
    self2._name,
    self2._onUnlock.length,
    info || "[NO INFO]"
  );
};
Lock.prototype.flushUnlockQueue = function() {
  var self2 = this;
  var count = self2._onUnlock.length;
  if (count > 0) {
    var info = index_default_default.map(index_default_default.pluck(self2._onUnlock, "info"), function(i2) {
      return i2 || "[NO INFO]";
    });
    console.debug(
      "[DataVis // Lock(%s)] Flushing %d onUnlock functions: %O",
      self2._name,
      count,
      info
    );
    self2._onUnlock = [];
  }
};
Lock.prototype.clear = function() {
  var self2 = this;
  self2.flushUnlockQueue();
  self2.completelyUnlock();
};
var lock_default = Lock;

// node_modules/wcdatavis/src/flags.js
var flags_default = {
  "Safe Float Equality": true
};

// node_modules/wcdatavis/src/types.js
var import_sprintf_js = __toESM(require_sprintf());
var import_jquery = __toESM(require_jquery());
var import_bignumber = __toESM(require_bignumber());
var import_numeral = __toESM(require_numeral());
var types = {};
types.registry = new ordmap_default();
types.registry.setInsertOrder("prepend");
types.guess = function(val) {
  var typeNames = types.registry.keys();
  for (var i2 = 0; i2 < typeNames.length; i2 += 1) {
    if (types.registry.get(typeNames[i2]).matches(val)) {
      return typeNames[i2];
    }
  }
};
types.universalCmp = function(a2, b) {
  return a2 === b ? 0 : a2 < b ? -1 : 1;
};
(function() {
  function matches(str) {
    return true;
  }
  function parse2(str) {
    return str;
  }
  function decode2(val, ir) {
    if (typeof val === "string") {
      return parse2(val, ir);
    } else {
      console.error("[DataVis // Type(String) // Decode] Call Error: unsupported conversion: %s", ir);
      return null;
    }
  }
  function format3(val) {
    return val;
  }
  function natRep(val) {
    return val;
  }
  function compare(a2, b) {
    return types.universalCmp(a2, b);
  }
  types.registry.set("string", {
    matches,
    parse: parse2,
    decode: decode2,
    format: format3,
    natRep,
    compare
  });
})();
(function() {
  var re_number = new RegExp(/(^-?[1-9]{1}[0-9]{0,2}(,?\d{3})*(\.\d+)?(e[+-]?\d+)?$)|(^0(e[+-]?\d+)?$)|(^-?0?\.\d+(e[+-]?\d+)?$)/);
  var re_comma = new RegExp(/,/g);
  var formatOpts = {
    integerPart: {
      grouping: false,
      groupSize: 3,
      groupSeparator: ","
    },
    fractionalPart: {
      grouping: false,
      groupSize: 3,
      groupSeparator: " "
    },
    radixPoint: ".",
    decimalPlaces: null,
    negativeFormat: "minus",
    roundingMethod: "half_up",
    currencySymbol: ""
  };
  if (window.Intl != null && window.Intl.NumberFormat != null && window.Intl.NumberFormat.prototype.formatToParts != null) {
    index_default_default.each(Intl.NumberFormat(window.DATAVIS_LANG).formatToParts("1234.5"), function(o2) {
      switch (o2.type) {
        case "group":
          formatOpts.integerPart.groupSeparator = o2.value;
          break;
        case "decimal":
          formatOpts.radixPoint = o2.value;
      }
    });
  }
  function matches(val) {
    return typeof val === "number" || typeof val === "string" && re_number.test(val);
  }
  function _parse(str, resultType) {
    if (str.charAt(0) === "(" && str.charAt(-1) === ")") {
      return _parse(str.substring(1, str.length - 1)) * -1;
    } else {
      var noCommas = str.replace(re_comma, "");
      return resultType === "string" ? noCommas : str.indexOf(".") >= 0 || str.indexOf("e") >= 0 ? parseFloat(noCommas) : parseInt(noCommas);
    }
  }
  function parse2(str, ir) {
    var parsed;
    if (typeof str !== "string") {
      console.error("[DataVis // Type(Number) // Parse] Call Error: `str` must be a string");
      return null;
    }
    switch (ir) {
      case "primitive":
        return _parse(str, "number");
      case "numeral":
        parsed = _parse(str, "number");
        if (parsed == null) {
          return null;
        }
        return (0, import_numeral.default)(parsed);
      case "bignumber":
        parsed = _parse(str, "string");
        if (parsed == null) {
          return null;
        }
        return new import_bignumber.default(parsed);
      default:
        console.error("[DataVis // Type(Number) // Parse] Call Error: invalid internal representation: %s", ir);
        return null;
    }
  }
  function decode2(val, ir) {
    if (typeof val === "string") {
      return parse2(val, ir);
    } else if (typeof val === "number") {
      switch (ir) {
        case "primitive":
          return val;
        case "bignumber":
          return new import_bignumber.default(val);
        case "numeral":
          return (0, import_numeral.default)(val);
        default:
          console.error("[DataVis // Type(Number) // Decode] Call Error: invalid internal representation: %s", ir);
          return null;
      }
    } else {
      console.error("[DataVis // Type(Number) // Decode] Call Error: unsupported conversion: %s to %s", typeof val, ir);
      return null;
    }
  }
  function numeralFormat(fmt) {
    var result2 = "";
    result2 += fmt.integerPart.grouping ? "0,0" : "0";
    if (fmt.decimalPlaces == null) {
      result2 += "[.][0000000000000000]";
    } else if (fmt.decimalPlaces > 0) {
      result2 += ".";
      result2 += "0".repeat(fmt.decimalPlaces);
    }
    return result2;
  }
  function bigNumberFormat(fmt) {
    var obj = {
      prefix: "",
      decimalSeparator: fmt.radixPoint,
      secondaryGroupSize: 0,
      suffix: ""
    };
    if (fmt.integerPart.grouping) {
      obj.groupSeparator = fmt.integerPart.groupSeparator;
      obj.groupSize = fmt.integerPart.groupSize;
    } else {
      obj.groupSize = 0;
    }
    if (fmt.fractionalPart.grouping) {
      obj.fractionGroupSeparator = fmt.fractionalPart.groupSeparator;
      obj.fractionGroupSize = fmt.fractionalPart.groupSize;
    } else {
      obj.fractionGroupSize = 0;
    }
    return obj;
  }
  function bigNumberRoundingMode(fmt) {
    switch (fmt.roundingMethod) {
      case "up":
        return import_bignumber.default.ROUND_UP;
      case "down":
        return import_bignumber.default.ROUND_DOWN;
      case "ceil":
        return import_bignumber.default.ROUND_CEIL;
      case "floor":
        return import_bignumber.default.ROUND_FLOOR;
      case "half_up":
        return import_bignumber.default.ROUND_HALF_UP;
      case "half_down":
        return import_bignumber.default.ROUND_HALF_DOWN;
      case "half_even":
        return import_bignumber.default.ROUND_HALF_EVEN;
      case "half_ceil":
        return import_bignumber.default.ROUND_HALF_CEIL;
      case "half_floor":
        return import_bignumber.default.ROUND_HALF_FLOOR;
    }
  }
  function _format_primitive(val, fmt) {
    var method = window.Intl != null && window.Intl.NumberFormat != null ? "intl" : "bignumber";
    switch (method) {
      case "intl":
        var config = {
          useGrouping: fmt.integerPart.grouping
        };
        if (fmt.decimalPlaces != null) {
          config.minimumFractionDigits = fmt.decimalPlaces;
          config.maximumFractionDigits = fmt.decimalPlaces;
        } else {
          config.minimumFractionDigits = 0;
          config.maximumFractionDigits = 17;
        }
        return Intl.NumberFormat(window.DATAVIS_LANG, config).format(val);
      case "bignumber":
        return new import_bignumber.default(val).toFormat(
          fmt.decimalPlaces,
          bigNumberRoundingMode(fmt),
          bigNumberFormat(fmt)
        );
      case "numeral":
        return (0, import_numeral.default)(val).format(numeralFormat(fmt));
      default:
        console.error("[DataVis // Type(Number) // Format] Unsupported primitive value formatting method: %s", method);
    }
  }
  function format3(val, fmt, isCurrency) {
    var isNegative = false, str;
    if (val == null) {
      return "";
    } else if (typeof val === "number") {
      if (Number.isNaN(val)) {
        return "";
      }
      if (val < 0) {
        isNegative = true;
        val = val * -1;
      }
      str = _format_primitive(val, fmt);
    } else if (import_numeral.default.isNumeral(val)) {
      if (val.value() < 0) {
        isNegative = true;
        val = val.multiply(-1);
      }
      str = val.format(numeralFormat(fmt));
    } else if (import_bignumber.default.isBigNumber(val)) {
      if (val.isNaN()) {
        return "";
      }
      if (val.isNegative()) {
        isNegative = true;
        val = val.abs();
      }
      str = val.toFormat(fmt.decimalPlaces, bigNumberRoundingMode(fmt), bigNumberFormat(fmt));
    } else {
      console.error("[DataVis // Type(Number) // Format] Unsupported value type: %s", val);
      return "";
    }
    if (isNegative) {
      switch (fmt.negativeFormat) {
        case "minus":
          str = (isCurrency ? fmt.currencySymbol : "") + "-" + str;
          break;
        case "parens":
          str = "(" + (isCurrency ? fmt.currencySymbol : "") + str + ")";
          break;
      }
    } else {
      str = (isCurrency ? fmt.currencySymbol : "") + str;
    }
    return str;
  }
  function natRep(val) {
    if (import_numeral.default.isNumeral(val)) {
      return val.value();
    } else if (moment_default.isMoment(val)) {
      return val.unix();
    } else {
      return val;
    }
  }
  var floatSafe_equalp = function(n2, m2) {
    var epsilon = Number.EPSILON;
    return Math.abs(n2 - m2) < epsilon;
  };
  function compare(a2, b) {
    if (a2 == null || b == null) {
      return a2 == b ? 0 : a2 == null ? -1 : 1;
    }
    if (typeof a2 === "number" && typeof b === "number") {
      if (flags_default["Safe Float Equality"]) {
        return floatSafe_equalp(a2, b) ? 0 : a2 < b ? -1 : 1;
      } else {
        return a2 < b ? -1 : a2 > b ? 1 : 0;
      }
    } else if (import_numeral.default.isNumeral(a2) && import_numeral.default.isNumeral(b)) {
      if (flags_default["Safe Float Equality"]) {
        return floatSafe_equalp(a2.value(), b.value()) ? 0 : a2.value() < b.value() ? -1 : 1;
      } else {
        return a2.value() < b.value() ? -1 : a2.value() > b.value() ? 1 : 0;
      }
    } else if (import_bignumber.default.isBigNumber(a2) && import_bignumber.default.isBigNumber(b)) {
      return a2.lt(b) ? -1 : a2.gt(b) ? 1 : 0;
    }
    if (import_numeral.default.isNumeral(a2)) {
      if (import_bignumber.default.isBigNumber(b)) {
        return b.gt(a2.value()) ? -1 : b.lt(a2.value()) ? 1 : 0;
      } else if (typeof b === "number") {
        return a2.value() < b ? -1 : a2.value() > b ? 1 : 0;
      } else {
        return types.universalCmp(a2, b);
      }
    } else if (import_bignumber.default.isBigNumber(a2)) {
      if (import_numeral.default.isNumeral(b)) {
        return a2.lt(b.value()) ? -1 : a2.gt(b.value()) ? 1 : 0;
      } else if (typeof b === "number") {
        return a2.lt(b) ? -1 : a2.gt(b) ? 1 : 0;
      } else {
        return types.universalCmp(a2, b);
      }
    } else if (typeof a2 === "number") {
      if (import_bignumber.default.isBigNumber(b)) {
        return b.gt(a2) ? -1 : b.lt(a2) ? 1 : 0;
      } else if (import_numeral.default.isNumeral(b)) {
        return a2 < b.value() ? -1 : a2 > b.value() ? 1 : 0;
      } else {
        return types.universalCmp(a2, b);
      }
    } else {
      return types.universalCmp(a2, b);
    }
  }
  types.registry.set("number", {
    matches,
    parse: parse2,
    decode: decode2,
    format: format3,
    natRep,
    compare
  });
})();
(function() {
  function matches(val) {
    if (typeof val !== "string") {
      console.error("[DataVis // Types // Currency // Parse] Call Error: `val` must be a string");
      return false;
    }
    if (val.charAt(0) === "$") {
      return types.registry.get("number").matches(val.substring(1));
    } else if (val.startsWith("(") && val.endsWith(")")) {
      return types.registry.get("number").matches(val.substring(1, val.length - 1));
    }
    return false;
  }
  var re_comma = new RegExp(/,/g);
  function _parse(str, resultType) {
    if (str.charAt(0) === "$") {
      return _parse(str.substring(1));
    } else if (str.charAt(0) === "(" && str.charAt(-1) === ")") {
      return _parse(str.substring(1, str.length - 1)) * -1;
    } else if (!types.registry.get("number").matches(str)) {
      return null;
    } else {
      var noCommas = str.replace(re_comma, "");
      return resultType === "string" ? noCommas : str.indexOf(".") >= 0 || str.indexOf("e") >= 0 ? parseFloat(noCommas) : parseInt(noCommas);
    }
  }
  function parse2(str, ir) {
    var parsed;
    if (typeof str !== "string") {
      console.error("[DataVis // Type(Currency) // Parse] Call Error: `val` must be a string");
      return null;
    }
    switch (ir) {
      case "primitive":
        return _parse(str, "number");
      case "numeral":
        parsed = _parse(str, "number");
        if (parsed == null) {
          return null;
        }
        return (0, import_numeral.default)(parsed);
      case "bignumber":
        parsed = _parse(str, "string");
        if (parsed == null) {
          return null;
        }
        return new import_bignumber.default(parsed);
      default:
        console.error("[DataVis // Type(Currency) // Parse] Call Error: invalid internal representation: %s", ir);
        return null;
    }
  }
  function decode2(val, ir) {
    if (typeof val === "string") {
      return parse2(val, ir);
    } else if (typeof val === "number") {
      switch (ir) {
        case "primitive":
          return val;
        case "bignumber":
          return new import_bignumber.default(val);
        case "numeral":
          return (0, import_numeral.default)(val);
        default:
          console.error("[DataVis // Type(Currency) // Decode] Call Error: invalid internal representation: %s", ir);
          return null;
      }
    } else {
      console.error("[DataVis // Type(Currency) // Decode] Call Error: unsupported conversion: %s to %s", typeof val, ir);
      return null;
    }
  }
  function format3(val, fmt) {
    return types.registry.get("number").format(val, fmt, true);
  }
  types.registry.set("currency", {
    matches,
    parse: parse2,
    decode: decode2,
    format: format3,
    natRep: types.registry.get("number").natRep,
    compare: types.registry.get("number").compare
  });
})();
(function() {
  var re_date = new RegExp(/^\d{4}-\d{2}-\d{2}$/);
  function matches(val) {
    return re_date.test(val);
  }
  function parse2(val, ir, fmt) {
    var parsed;
    ir = ir || "string";
    fmt = fmt || {};
    if (typeof val !== "string") {
      console.error("[DataVis // Type(Date) // Parse] Call Error: `val` must be a string");
      return null;
    }
    switch (ir) {
      case "string":
        return val;
      case "native":
        return Date.parse(val);
      case "moment":
        return moment_default(val, fmt);
      default:
        return null;
    }
  }
  function decode2(val, ir, fmt) {
    if (typeof val === "string") {
      return parse2(val, ir, fmt);
    }
  }
  function format3(val, fmt) {
    if (val == null) {
      return "";
    }
    if (typeof val === "string") {
      if (["", "0000-00-00", "0000-00-00 00:00:00"].indexOf(val) >= 0) {
        return "";
      }
      val = moment_default(val, "YYYY-MM-DD");
    } else if (val instanceof Date) {
      val = moment_default(val);
    }
    if (!moment_default.isMoment(val)) {
      console.error("[DataVis // Type(Date) // Format] Unsupported value: %s", val);
      return "";
    }
    if (!val.isValid()) {
      return "";
    }
    return val.format(fmt.full);
  }
  function natRep(val) {
    if (typeof val === "string") {
      return val;
    } else if (val instanceof Date) {
      return import_sprintf_js.default.sprintf("%04d-%02d-%02d", val.getFullYear(), val.getMonth() + 1, val.getDate());
    } else if (moment_default.isMoment(val)) {
      return val.format("YYYY-MM-DD");
    } else {
      return "";
    }
  }
  function compare(a2, b) {
    return types.registry.get("string").compare(natRep(a2), natRep(b));
  }
  types.registry.set("date", {
    matches,
    parse: parse2,
    decode: decode2,
    format: format3,
    natRep,
    compare
  });
})();
(function() {
  var re_datetime = new RegExp(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/);
  function matches(str) {
    return re_datetime.test(str);
  }
  function parse2(str, ir, fmt) {
    var parsed;
    ir = ir || "string";
    fmt = fmt || {};
    if (typeof str !== "string") {
      console.error("[DataVis // Type(Date) // Parse] Call Error: `str` must be a string");
      return null;
    }
    switch (ir) {
      case "string":
        return str;
      case "native":
        return Date.parse(str);
      case "moment":
        return moment_default(str, fmt);
      default:
        return null;
    }
  }
  function decode2(val, ir) {
    if (typeof val === "string") {
      return parse2(val, ir);
    } else {
      console.error("[DataVis // Type(Datetime) // Decode] Call Error: unsupported conversion: %s to %s", typeof val, ir);
      return null;
    }
  }
  function format3(val, fmt) {
    if (val == null) {
      return "";
    }
    if (typeof val === "string") {
      if (["", "0000-00-00", "0000-00-00 00:00:00"].indexOf(val) >= 0) {
        return "";
      }
      val = moment_default(val, "YYYY-MM-DD HH:mm:ss");
    } else if (val instanceof Date) {
      val = moment_default(val);
    }
    if (!moment_default.isMoment(val)) {
      console.error("[DataVis // Type(Date) // Format] Unsupported value: %s", val);
      return "";
    }
    if (!val.isValid()) {
      return "";
    }
    if (fmt.abbrev && val.hour() === 0 && val.minute() === 0 && val.second() === 0) {
      return val.format(fmt.abbrev);
    } else {
      return val.format(fmt.full);
    }
  }
  function natRep(val) {
    if (typeof val === "string") {
      return val;
    } else if (val instanceof Date) {
      return import_sprintf_js.default.sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        val.getFullYear(),
        val.getMonth() + 1,
        val.getDate(),
        val.getHours(),
        val.getMinutes(),
        val.getSeconds()
      );
    } else if (moment_default.isMoment(val)) {
      return val.format("YYYY-MM-DD HH:mm:ss");
    } else {
      return "";
    }
  }
  function compare(a2, b) {
    return types.registry.get("string").compare(natRep(a2), natRep(b));
  }
  types.registry.set("datetime", {
    matches,
    parse: parse2,
    decode: decode2,
    format: format3,
    natRep,
    compare
  });
})();
(function() {
  var re_time = new RegExp(/^\d{2}:\d{2}:\d{2}$/);
  function matches(str) {
    return re_time.test(str);
  }
  function parse2(str, ir, fmt) {
    var parsed;
    ir = ir || "string";
    if (typeof str !== "string") {
      console.error("[DataVis // Type(Time) // Parse] Call Error: `str` must be a string");
      return null;
    }
    switch (ir) {
      case "string":
        return str;
      case "native":
        return Date.parse("2000-01-01T" + str + ".000Z");
      case "moment":
        return moment_default("2000-01-01 " + str, "YYYY-MM-DD " + (fmt || "HH:mm:ss"));
      default:
        return null;
    }
  }
  function decode2(val, ir) {
    if (typeof val === "string") {
      return parse2(val, ir);
    } else {
      console.error("[DataVis // Type(Time) // Decode] Call Error: unsupported conversion: %s to %s", typeof val, ir);
      return null;
    }
  }
  function format3(val, fmt) {
    if (val == null) {
      return "";
    }
    if (typeof val === "string") {
      if (["", "0000-00-00", "0000-00-00 00:00:00"].indexOf(val) >= 0) {
        return "";
      }
      val = moment_default("2000-01-01 " + val, "YYYY-MM-DD HH:mm:ss");
    } else if (val instanceof Date) {
      val = moment_default(val);
    }
    if (!moment_default.isMoment(val)) {
      console.error("[DataVis // Type(Date) // Format] Unsupported value: %s", val);
      return "";
    }
    if (!val.isValid()) {
      return "";
    }
    return val.format(fmt.full);
  }
  function natRep(val) {
    if (typeof val === "string") {
      return val;
    } else if (val instanceof Date) {
      return import_sprintf_js.default.sprintf(
        "%02d:%02d:%02d",
        val.getHours(),
        val.getMinutes(),
        val.getSeconds()
      );
    } else if (moment_default.isMoment(val)) {
      return val.format("HH:mm:ss");
    } else {
      return "";
    }
  }
  function compare(a2, b) {
    return types.registry.get("string").compare(natRep(a2), natRep(b));
  }
  types.registry.set("time", {
    matches,
    parse: parse2,
    decode: decode2,
    format: format3,
    natRep,
    compare
  });
})();
(function() {
  function matches(val) {
    return typeof val === "string" && (val.startsWith("{") && val.endsWith("}") || val.startsWith("[") && val.endsWith("]"));
  }
  function parse2(str, ir, fmt) {
    var parsed;
    ir = ir || "obj";
    fmt = fmt || {};
    if (typeof str !== "string") {
      console.error("[DataVis // Type(JSON) // Parse] Call Error: `str` must be a string");
      return null;
    }
    switch (ir) {
      case "obj":
        return JSON.parse(str);
      default:
        return null;
    }
  }
  function decode2(val, ir, fmt) {
    if (typeof val === "string") {
      return parse2(val, ir, fmt);
    } else if (typeof val === "object") {
      return val;
    }
  }
  function format3(val, opts) {
    if (typeof val === "string") {
      return val;
    } else {
      return new json_formatter_esm_default(val, 0, {
        onToggle: function(isOpen) {
          if (window.TableTool) {
            window.TableTool.update();
          }
        }
      }).render();
    }
  }
  types.registry.set("json", {
    matches,
    parse: parse2,
    decode: decode2,
    format: format3,
    natRep: null,
    compare: null
  });
})();
var types_default = types;

// node_modules/wcdatavis/src/util/misc.js
var gensym = /* @__PURE__ */ function() {
  var gensymSeed = 0;
  return function() {
    gensymSeed += 1;
    return "gensym-" + gensymSeed;
  };
}();
function Y(f2) {
  return function(g) {
    return g(g);
  }(function(g) {
    return f2(function() {
      return g(g).apply(this, arguments);
    });
  });
}
function I(x) {
  return x;
}
function NOP() {
  return;
}
function universalCmp(a2, b) {
  return a2 === b ? 0 : a2 < b ? -1 : 1;
}
if (Number.EPSILON == null) {
  Number.EPSILON = Math.pow(2, -52);
}
var getComparisonFn = function() {
  var cmpFn = {};
  var floatSafe_equalp = function(n2, m2) {
    var epsilon = Number.EPSILON;
    return Math.abs(n2 - m2) < epsilon;
  };
  cmpFn.date = function(a2, b) {
    if (a2 == null || b == null) {
      return a2 == b ? 0 : a2 == null ? -1 : 1;
    }
    if (!moment_default.isMoment(a2) && !moment_default.isMoment(b)) {
      return a2 < b ? -1 : a2 > b ? 1 : 0;
    } else if (moment_default.isMoment(a2) && moment_default.isMoment(b)) {
      return a2.isBefore(b) ? -1 : a2.isAfter(b) ? 1 : 0;
    } else {
      log.warn("Cannot compare Moment w/ non-Moment");
      return 0;
    }
  };
  cmpFn.time = cmpFn.date;
  cmpFn.datetime = cmpFn.date;
  cmpFn.month = function(a2, b) {
    var trans2 = {
      "Jan": 1,
      "Feb": 2,
      "Mar": 3,
      "Apr": 4,
      "May": 5,
      "Jun": 6,
      "Jul": 7,
      "Aug": 8,
      "Sep": 9,
      "Oct": 10,
      "Nov": 11,
      "Dec": 12
    };
    var a_month = trans2[a2];
    var b_month = trans2[b];
    return a_month == null ? -1 : b_month == null ? 1 : a_month < b_month ? -1 : a_month > b_month ? 1 : 0;
  };
  cmpFn.day_of_week = function(a2, b) {
    var trans2 = { "Mon": 0, "Tue": 1, "Wed": 2, "Thu": 3, "Fri": 4, "Sat": 5, "Sun": 6 };
    var a_num = trans2[a2];
    var b_num = trans2[b];
    return a_num == null ? -1 : b_num == null ? 1 : a_num < b_num ? -1 : a_num > b_num ? 1 : 0;
  };
  cmpFn.year_and_month = function(a2, b) {
    var trans2 = {
      "Jan": 1,
      "Feb": 2,
      "Mar": 3,
      "Apr": 4,
      "May": 5,
      "Jun": 6,
      "Jul": 7,
      "Aug": 8,
      "Sep": 9,
      "Oct": 10,
      "Nov": 11,
      "Dec": 12
    };
    var regexp = /^(\d{4}) (\w{3})$/;
    var m2;
    var a_year, a_month, b_year, b_month;
    if ((m2 = regexp.exec(a2)) != null) {
      a_year = toInt2(m2[1]);
      a_month = trans2[m2[2]];
    }
    if (m2 == null || a_month == null) {
      return -1;
    }
    if ((m2 = regexp.exec(b)) != null) {
      b_year = toInt2(m2[1]);
      b_month = trans2[m2[2]];
    }
    if (m2 == null || b_month == null) {
      return 1;
    }
    return a_year < b_year ? -1 : a_year > b_year ? 1 : a_month < b_month ? -1 : a_month > b_month ? 1 : 0;
  };
  if (Intl && Intl.Collator) {
    var collator = Intl.Collator(void 0, { usage: "sort", sensitivity: "base" });
    cmpFn.string = function(a2, b) {
      if (a2 == null || b == null) {
        return a2 == b ? 0 : a2 == null ? -1 : 1;
      }
      return collator.compare(a2, b);
    };
  } else {
    cmpFn.string = function(a2, b) {
      if (a2 == null || b == null) {
        return a2 == b ? 0 : a2 == null ? -1 : 1;
      }
      return a2 < b ? -1 : a2 > b ? 1 : 0;
    };
  }
  cmpFn.number = function(a2, b) {
    if (a2 == null || b == null) {
      return a2 == b ? 0 : a2 == null ? -1 : 1;
    }
    if (typeof a2 === "number" && typeof b === "number") {
      if (flags_default["Safe Float Equality"]) {
        return floatSafe_equalp(a2, b) ? 0 : a2 < b ? -1 : 1;
      } else {
        return a2 < b ? -1 : a2 > b ? 1 : 0;
      }
    } else if (import_numeral2.default.isNumeral(a2) && import_numeral2.default.isNumeral(b)) {
      if (flags_default["Safe Float Equality"]) {
        return floatSafe_equalp(a2.value(), b.value()) ? 0 : a2.value() < b.value() ? -1 : 1;
      } else {
        return a2.value() < b.value() ? -1 : a2.value() > b.value() ? 1 : 0;
      }
    } else if (import_bignumber2.default.isBigNumber(a2) && import_bignumber2.default.isBigNumber(b)) {
      return a2.lt(b) ? -1 : a2.gt(b) ? 1 : 0;
    }
    if (import_numeral2.default.isNumeral(a2)) {
      if (import_bignumber2.default.isBigNumber(b)) {
        return b.gt(a2.value()) ? -1 : b.lt(a2.value()) ? 1 : 0;
      } else if (typeof b === "number") {
        return a2.value() < b ? -1 : a2.value() > b ? 1 : 0;
      } else {
        return universalCmp(a2, b);
      }
    } else if (import_bignumber2.default.isBigNumber(a2)) {
      if (import_numeral2.default.isNumeral(b)) {
        return a2.lt(b.value()) ? -1 : a2.gt(b.value()) ? 1 : 0;
      } else if (typeof b === "number") {
        return a2.lt(b) ? -1 : a2.gt(b) ? 1 : 0;
      } else {
        return universalCmp(a2, b);
      }
    } else if (typeof a2 === "number") {
      if (import_bignumber2.default.isBigNumber(b)) {
        return b.gt(a2) ? -1 : b.lt(a2) ? 1 : 0;
      } else if (import_numeral2.default.isNumeral(b)) {
        return a2 < b.value() ? -1 : a2 > b.value() ? 1 : 0;
      } else {
        return universalCmp(a2, b);
      }
    } else {
      return universalCmp(a2, b);
    }
  };
  cmpFn.currency = cmpFn.number;
  cmpFn.array = function(a2, b) {
    return arrayCompare(a2, b);
  };
  return {
    byType: function(type) {
      return cmpFn[type];
    },
    byValue: function(val) {
      if (typeof val === "number" || import_numeral2.default.isNumeral(val) || import_bignumber2.default.isBigNumber(val)) {
        return cmpFn.number;
      } else if (moment_default.isMoment(val)) {
        return cmpFn.date;
      } else if (index_default_default.isArray(val)) {
        return cmpFn.array;
      } else {
        return cmpFn.string;
      }
    }
  };
}();
function getNatRep(x) {
  if (import_numeral2.default.isNumeral(x)) {
    return x.value();
  } else if (moment_default.isMoment(x)) {
    return x.unix();
  } else {
    return x;
  }
}
function chain2() {
  var args = Array.prototype.slice.call(arguments);
  var fnArgs = args.shift();
  var fn;
  while (args.length > 0) {
    fn = args.shift();
    if (!(fnArgs instanceof Array)) {
      fnArgs = [fnArgs];
    }
    if (typeof fn !== "function") {
      return fnArgs;
    }
    fnArgs = fn.apply(null, fnArgs);
  }
  return fnArgs;
}
function makeChain() {
  var fns = Array.prototype.slice.call(arguments);
  return function() {
    var args = Array.prototype.slice.call(arguments);
    return chain2.apply(null, Array.prototype.concat.call([args], fns));
  };
}
function makeArray() {
  return Array.prototype.slice.call(arguments);
}
function trulyYours(cont, spec, thisArg, acc) {
  acc = acc || {};
  return spec.length === 0 ? cont(acc) : function() {
    console.debug("[DataVis // Truly Yours] Calling #%s() to set property .%s", spec[0].fn, spec[0].prop);
    return thisArg[spec[0].fn].bind(thisArg)(function(y) {
      acc[spec[0].prop] = (spec[0].conv || I)(y);
      return trulyYours(cont, spec.slice(1), thisArg, acc);
    });
  }();
}
function asyncChain(fns, args, done) {
  var self2 = this;
  if (!index_default_default.isArray(fns)) {
    throw new Error("Call Error: `fns` must be an array");
  }
  if (!index_default_default.isArray(args)) {
    throw new Error("Call Error: `args` must be an array");
  }
  fns = shallowCopy(fns);
  var g = function() {
    if (fns.length === 0) {
      return done();
    }
    fns.shift().apply(self2, args.concat(g));
  };
  return g();
}
function curry() {
  var curryArgs = Array.prototype.slice.call(arguments);
  var fn = curryArgs.shift();
  var placeholderIndex = curryArgs.indexOf("#");
  return function() {
    var args = Array.prototype.slice.call(arguments);
    var fnArgs = curryArgs.slice();
    var spliceArgs = placeholderIndex === -1 ? [fnArgs.length, 0] : [placeholderIndex, 1];
    Array.prototype.splice.apply(fnArgs, spliceArgs.concat(args));
    return fn.apply(this, fnArgs);
  };
}
function curryCtor() {
  var args = Array.prototype.slice.call(arguments), result2 = curry.apply(null, args);
  result2.prototype = args[0].prototype;
  return result2;
}
function either() {
  var args = Array.prototype.slice.call(arguments);
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    if (args[i2] !== void 0) {
      return args[i2];
    }
  }
  return void 0;
}
function car(a2) {
  return a2[0];
}
function cdr(a2) {
  return a2.slice(1);
}
function isInt(x) {
  return typeof x === "string" ? String(parseInt(x, 10)) === x : +x === Math.floor(+x);
}
function isFloat(x) {
  if (x === null || typeof x === "string" && x === "") {
    return false;
  }
  return !isNaN(+x);
}
function toInt2(x) {
  return typeof x === "string" ? parseInt(x, 10) : Math.floor(+x);
}
function toFloat(x) {
  return +x;
}
var stringValueType = function() {
  var re_date = new RegExp(/^\d{4}-\d{2}-\d{2}$/);
  var re_time = new RegExp(/^\d{2}:\d{2}:\d{2}$/);
  var re_datetime = new RegExp(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/);
  var re_number = new RegExp(/(^-?[1-9]{1}[0-9]{0,2}(,?\d{3})*(\.\d+)?(e[+-]?\d+)?$)|(^0(e[+-]?\d+)?$)|(^-?0?\.\d+(e[+-]?\d+)?$)/);
  var re_comma = new RegExp(/,/g);
  return function p(s2) {
    var guess;
    if (re_date.test(s2)) {
      return "date";
    } else if (re_time.test(s2)) {
      return "time";
    } else if (re_datetime.test(s2)) {
      return "datetime";
    } else if (typeof s2 === "string" && s2.startsWith("{") && s2.endsWith("}")) {
      return "json";
    } else if (typeof s2 === "string" && s2.startsWith("[") && s2.endsWith("]")) {
      return "json";
    } else if (typeof s2 === "string" && s2.charAt(0) === "$") {
      guess = p(s2.substring(1));
      return guess === "number" ? "currency" : "string";
    } else if (typeof s2 === "string" && s2.charAt(0) === "(" && s2.charAt(s2.length - 1) === ")") {
      guess = p(s2.substring(1, s2.length - 1));
      return ["number", "currency"].indexOf(guess) >= 0 ? guess : "string";
    } else {
      return re_number.test(s2) ? "number" : "string";
    }
  };
}();
var parseNumber = function() {
  var re_number = new RegExp(/(^-?[1-9]{1}[0-9]{0,2}(,?\d{3})*(\.\d+)?(e[+-]?\d+)?$)|(^0(e[+-]?\d+)?$)|(^-?0?\.\d+(e[+-]?\d+)?$)/);
  var re_comma = new RegExp(/,/g);
  return function p(s2, resultType) {
    if (typeof s2 !== "string") {
      throw new Error("Call Error: `s` must be a string");
    }
    if (resultType != null && typeof resultType !== "string") {
      throw new Error("Call Error: `resultType` must be null or a string");
    }
    if (resultType == null) {
      resultType = "number";
    }
    if (["number", "string"].indexOf(resultType) < 0) {
      throw new Error('Call Error: `resultType` must be one of: ["number", "string"]');
    }
    if (s2.charAt(0) === "$") {
      return p(s2.substring(1));
    } else if (s2.charAt(0) === "(" && s2.charAt(-1) === ")") {
      return p(s2.substring(1, s2.length - 1)) * -1;
    } else {
      return !re_number.test(s2) ? null : s2.indexOf(".") >= 0 || s2.indexOf("e") >= 0 ? (resultType === "number" ? parseFloat : I)(s2.replace(re_comma, "")) : (resultType === "number" ? parseInt : I)(s2.replace(re_comma, ""));
    }
  };
}();
function tryIntConvert(x) {
  return isInt(x) ? toInt2(x) : 0;
}
function tryFloatConvert(x) {
  return isFloat(x) ? toFloat(x) : 0;
}
function arrayCompare(a2, b) {
  if (!index_default_default.isArray(a2) || !index_default_default.isArray(b)) {
    throw new Error("Call Error: arguments must be arrays");
  }
  if (a2.length !== b.length) {
    throw new Error("Call Error: arguments must have the same length");
  }
  for (var i2 = 0; i2 < a2.length; i2 += 1) {
    if (a2[i2] < b[i2]) {
      return -1;
    } else if (a2[i2] > b[i2]) {
      return 1;
    }
  }
  return 0;
}
function arrayEqual(a2, b) {
  if (!index_default_default.isArray(a2) || !index_default_default.isArray(b)) {
    throw new Error("Call Error: arguments must be arrays");
  }
  if (a2.length !== b.length) {
    return false;
  }
  return arrayCompare(a2, b) === 0;
}
function moveArrayElement(a2, fromIdx, toIdx) {
  var elt2 = a2[fromIdx];
  a2.splice(fromIdx, 1);
  a2.splice(toIdx, 0, elt2);
}
function eachUntil(l2, f2, r2) {
  var i2;
  for (i2 = 0; i2 < l2.length; i2 += 1) {
    if (f2(l2[i2], i2) === r2) {
      return;
    }
  }
}
function eachUntilObj(o2, f2, r2, extra) {
  for (var k in o2) {
    if (Object.prototype.hasOwnProperty.call(o2, k) && f2(o2[k], k, extra) === r2) {
      return false;
    }
  }
  return true;
}
function asyncEach(args, fun, done) {
  if (!index_default_default.isArray(args)) {
    throw new Error("Call Error: `args` must be an array");
  }
  if (typeof fun !== "function") {
    throw new Error("Call Error: `fun` must be a function");
  }
  if (typeof done !== "function") {
    throw new Error("Call Error: `done` must be a function");
  }
  args = shallowCopy(args);
  var i2 = 0;
  function g() {
    if (args.length === 0) {
      return done();
    }
    return fun(args.shift(), i2++, g);
  }
  return g();
}
function mapLimit(a2, f2, l2) {
  var result2 = [];
  for (var i2 = 0; i2 < Math.min(a2.length, l2); i2 += 1) {
    result2.push(f2(a2[i2], i2));
  }
  return result2;
}
var shallowCopy = function(x) {
  if (x == null) {
    return {};
  }
  var result2;
  if (jQuery.isArray(x)) {
    result2 = [];
    for (var i2 = 0; i2 < x.length; i2 += 1) {
      result2[i2] = x[i2];
    }
    return result2;
  } else if (jQuery.isPlainObject(x)) {
    result2 = {};
    for (var k in x) {
      if (Object.prototype.hasOwnProperty.call(x, k)) {
        result2[k] = x[k];
      }
    }
    return result2;
  } else {
    return x;
  }
};
var deepCopy = function(x0) {
  var depth = 0;
  var depthLimit = 99;
  var path = [];
  if (x0 == null) {
    return {};
  }
  function recursive(x, depth2) {
    if (depth2 > depthLimit) {
      throw new Error("deepCopy: Maximum recursion depth exceeded");
    }
    var result2;
    if (jQuery.isArray(x)) {
      result2 = [];
      for (var i2 = 0; i2 < x.length; i2 += 1) {
        path.push(i2);
        result2[i2] = recursive(x[i2], depth2 + 1);
        path.pop();
      }
      return result2;
    } else if (jQuery.isPlainObject(x)) {
      result2 = {};
      for (var k in x) {
        if (Object.prototype.hasOwnProperty.call(x, k)) {
          path.push(k);
          result2[k] = recursive(x[k], depth2 + 1);
          path.pop();
        }
      }
      return result2;
    } else {
      return x;
    }
  }
  return recursive(x0, 0);
};
var arrayCopy = deepCopy;
function isNothing(x) {
  return x === void 0 || x === null;
}
function isEmpty2(o2) {
  var numProps = 0;
  index_default_default.each(o2, function() {
    numProps += 1;
  });
  return numProps === 0;
}
function deepDefaults() {
  var args = Array.prototype.slice.call(arguments), base;
  if (args[0] === true) {
    args.shift();
    base = args.shift();
  } else {
    base = deepCopy(args.shift());
  }
  var f2 = function(dst, src) {
    index_default_default.each(src, function(v, k) {
      if (dst[k] === void 0) {
        dst[k] = typeof v === "object" && v != null ? deepCopy(v) : v;
      } else if (index_default_default.isObject(dst[k]) && index_default_default.isObject(v)) {
        f2(dst[k], v);
      }
    });
  };
  index_default_default.each(args, function(arg) {
    f2(base, arg);
  });
  return base;
}
function getProp() {
  var args = Array.prototype.slice.call(arguments), o2 = args.shift(), i2;
  args = index_default_default.flatten(args);
  for (i2 = 0; o2 !== void 0 && o2 !== null && i2 < args.length; i2 += 1) {
    o2 = o2[args[i2]];
  }
  return i2 < args.length ? void 0 : o2;
}
function getPropDef() {
  var args = Array.prototype.slice.call(arguments);
  var d2 = args.shift();
  var p = getProp.apply(void 0, args);
  return p !== void 0 ? p : d2;
}
function setProp() {
  var args = Array.prototype.slice.call(arguments);
  var x = args.shift();
  var o2 = args.shift();
  args = index_default_default.flatten(args);
  for (var i2 = 0; i2 < args.length - 1; i2 += 1) {
    if (o2[args[i2]] == null) {
      o2[args[i2]] = index_default_default.isNumber(args[i2]) ? [] : {};
    }
    o2 = o2[args[i2]];
  }
  o2[args[args.length - 1]] = x;
}
function setPropDef() {
  var args = Array.prototype.slice.call(arguments);
  var x = args.shift();
  var o2 = args.shift();
  args = index_default_default.flatten(args);
  for (var i2 = 0; i2 < args.length - 1; i2 += 1) {
    if (o2[args[i2]] === void 0) {
      o2[args[i2]] = index_default_default.isNumber(args[i2]) ? [] : {};
    }
    o2 = o2[args[i2]];
  }
  if (o2[args[args.length - 1]] === void 0) {
    o2[args[args.length - 1]] = x;
  }
}
function copyProps(src, dest, props, opts) {
  opts = opts || {};
  index_default_default.each(props, function(p) {
    if (Object.prototype.hasOwnProperty.call(src, p) || opts.followPrototype && p in src) {
      dest[p] = src[p];
    }
  });
}
function needProp() {
  var args = Array.prototype.slice.call(arguments), exn = args.shift(), prop = getProp.apply(this, args);
  if (prop === void 0) {
    throw new exn("Missing property: [" + args.slice(1).join(".") + "]");
  }
  return prop;
}
function needPropIn() {
  var args = Array.prototype.slice.call(arguments), set3 = args.pop(), prop = needProp.apply(this, args);
  if (set3.indexOf(prop) === -1) {
    throw new Error("Property [" + args.slice(1).join(".") + '] must be one of: {"' + set3.join('", "') + '"}');
  }
  return prop;
}
function needPropArr() {
  var args = Array.prototype.slice.call(arguments), exn = args[0], prop = needProp.apply(this, args);
  if (!index_default_default.isArray(prop)) {
    throw new exn("Property [" + args.slice(1).join(".") + "] must be an array");
  }
  return prop;
}
function needPropObj() {
  var args = Array.prototype.slice.call(arguments), exn = args[0], prop = needProp.apply(this, args);
  if (!index_default_default.isObject(prop)) {
    throw new exn("Property [" + args.slice(1).join(".") + "] must be an object");
  }
  return prop;
}
function needPropInst() {
  var args = Array.prototype.slice.call(arguments), exn = args[0], cls = args.pop(), prop = needProp.apply(this, args);
  if (!(prop instanceof cls)) {
    throw new exn("Property [" + args.slice(1).join(".") + "] must be an instance of " + cls.name);
  }
  return prop;
}
function needArgInst(val, varName, cls) {
  needArg(val, varName);
  var msg = arguments.callee.name + '(): Argument "' + varName + '" must be an instance of ' + cls.name;
  if (!(val instanceof cls)) {
    console.error(msg + ", received: %O", val);
    throw new Error(msg);
  }
  return val;
}
function needArg(val, varName) {
  var msg = arguments.callee.name + '(): Missing required argument "' + varName + '"';
  if (isNothing(val)) {
    throw new Error(msg);
  }
  return val;
}
function iota(a2, b, step) {
  var r2 = [], start, end;
  if (b == null) {
    start = 0;
    end = a2;
  } else {
    start = a2;
    end = b;
  }
  if (step == null) {
    step = 1;
  }
  for (var i2 = start; i2 <= end; i2 += step) {
    r2.push(i2);
  }
  return r2;
}
function pruneTree() {
  var args = Array.prototype.slice.call(arguments);
  var o2 = args.shift();
  var deleteFrom = [];
  var i2;
  for (i2 = 0; i2 < args.length; i2 += 1) {
    if (o2[args[i2]] !== void 0) {
      deleteFrom.push(o2);
      if (index_default_default.isObject(o2[args[i2]])) {
        o2 = o2[args[i2]];
        continue;
      }
    }
    break;
  }
  for (i2 = deleteFrom.length - 1; i2 >= 0; i2 -= 1) {
    delete deleteFrom[i2][args[i2]];
    if (!isEmpty2(deleteFrom[i2])) {
      break;
    }
  }
}
function interleaveWith(a2, x) {
  var result2 = [];
  if (a2.length > 0) {
    result2.push(a2[0]);
  }
  for (var i2 = 1; i2 < a2.length; i2 += 1) {
    result2.push(x);
    result2.push(a2[i2]);
  }
  return result2;
}
function mergeSort(data, cmp2, cont) {
  cmp2 = cmp2 || universalCmp;
  return Y(function(recur) {
    return function(data2, cont2) {
      function merge2(left, right, cont3) {
        var result2 = [];
        while (left.length !== 0 && right.length !== 0) {
          var cmpResult = cmp2(left[0], right[0]);
          if (!index_default_default.isNumber(cmpResult)) {
            throw "comparison result returned non-number";
          }
          result2.push(cmpResult <= 0 ? left.shift() : right.shift());
        }
        window.setTimeout(function() {
          cont3(result2.concat(left.length > 0 ? left : right));
        }, 0);
      }
      if (data2.length <= 1) {
        window.setTimeout(function() {
          cont2(data2);
        }, 0);
      } else {
        var pivot = Math.floor(data2.length / 2);
        window.setTimeout(function() {
          recur(data2.slice(0, pivot), function(left) {
            window.setTimeout(function() {
              recur(data2.slice(pivot), function(right) {
                window.setTimeout(function() {
                  merge2(left, right, cont2);
                }, 0);
              });
            }, 0);
          });
        }, 0);
      }
    };
  })(data, cont);
}
function mergeSort2(data, cmp2) {
  cmp2 = cmp2 || function(a2, b) {
    return a2 < b;
  };
  var merge2 = function(left2, right2) {
    var result2 = [], leftLen = left2.length, leftIdx = 0, rightLen = right2.length, rightIdx = 0;
    while (leftIdx < leftLen && rightIdx < rightLen) {
      var cmpResult = cmp2(left2[leftIdx], right2[rightIdx]);
      result2.push(cmpResult ? left2[leftIdx++] : right2[rightIdx++]);
    }
    return result2.concat(leftIdx < leftLen ? left2.slice(leftIdx) : right2.slice(rightIdx));
  };
  if (data.length <= 1) {
    return data;
  } else {
    var pivot = Math.floor(data.length / 2), left = mergeSort2(data.slice(0, pivot), cmp2), right = mergeSort2(data.slice(pivot), cmp2);
    return merge2(left, right);
  }
}
function mergeSort3(data, cmp2, cont, update) {
  cmp2 = cmp2 || function(a2, b) {
    return a2 < b;
  };
  var size2 = data.length;
  var step = 0;
  var stepsBeforeUpdate = Math.min(data.length / 50, 500);
  function merge2(left, right) {
    var result2 = [], leftLen = left.length, leftIdx = 0, rightLen = right.length, rightIdx = 0;
    while (leftIdx < leftLen && rightIdx < rightLen) {
      var cmpResult = cmp2(left[leftIdx], right[rightIdx]);
      result2.push(cmpResult ? left[leftIdx++] : right[rightIdx++]);
    }
    return result2.concat(leftIdx < leftLen ? left.slice(leftIdx) : right.slice(rightIdx));
  }
  function sort(data2, cont2) {
    if (data2.length <= 1) {
      return cont2(data2);
    } else {
      var pivot = Math.floor(data2.length / 2);
      return sort(data2.slice(0, pivot), function(left) {
        return sort(data2.slice(pivot), function(right) {
          var fn = function() {
            return cont2(merge2(left, right, cont2));
          };
          step += 1;
          if (step % stepsBeforeUpdate === 0) {
            if (typeof update === "function") {
              update(step, size2);
            }
            return window.setTimeout(fn);
          } else {
            return fn();
          }
        });
      });
    }
  }
  return sort(data, cont);
}
var mergeSort4 = function(data, cmp2, cont, update) {
  cmp2 = cmp2 || function(x, y) {
    return x < y;
  };
  var a2 = data;
  var num = data.length;
  var b = new Array(num);
  var rght, wid, rend;
  var i2, j, m2, t2;
  var sortWindow = function(k) {
    for (var left = 0; left + k < num; left += k * 2) {
      rght = left + k;
      rend = rght + k;
      if (rend > num) rend = num;
      m2 = left;
      i2 = left;
      j = rght;
      while (i2 < rght && j < rend) {
        if (cmp2(a2[i2], a2[j])) {
          b[m2] = a2[i2];
          i2++;
        } else {
          b[m2] = a2[j];
          j++;
        }
        m2++;
      }
      while (i2 < rght) {
        b[m2] = a2[i2];
        i2++;
        m2++;
      }
      while (j < rend) {
        b[m2] = a2[j];
        j++;
        m2++;
      }
      for (m2 = left; m2 < rend; m2++) {
        a2[m2] = b[m2];
      }
    }
    if (k < num) {
      if (typeof update === "function") {
        update(k, num);
      }
      return window.setTimeout(function() {
        sortWindow(k * 2);
      });
    } else {
      return cont(a2);
    }
  };
  sortWindow(1);
};
function pigeonHoleSort(data, values2, cont) {
  var o2 = {}, r2 = [], i2, j;
  for (i2 = 0; i2 < values2.length; i2 += 1) {
    o2[values2[i2]] = [];
  }
  for (i2 = 0; i2 < data.length; i2 += 1) {
    if (o2[data[i2].sortSource] != null) {
      o2[data[i2].sortSource].push(data[i2]);
    }
  }
  for (i2 = 0; i2 < values2.length; i2 += 1) {
    for (j = 0; j < o2[values2[i2]].length; j += 1) {
      r2.push(o2[values2[i2]][j]);
    }
  }
  return cont(r2);
}
function objGetPath(obj, fieldPath) {
  var i2, len = fieldPath.length;
  for (i2 = 0; i2 < len && obj !== void 0; i2 += 1) {
    obj = obj[fieldPath[i2]];
  }
  return obj;
}
function cmpObjField(fieldPath, cmp2) {
  cmp2 = cmp2 || universalCmp;
  return function(a2, b) {
    a2 = objGetPath(a2, fieldPath);
    b = objGetPath(b, fieldPath);
    if (!index_default_default.isString(a2) && !index_default_default.isNumber(a2) && !index_default_default.isDate(a2)) {
      throw `object "a" doesn't contain field path: ` + fieldPath.toString();
    }
    if (!index_default_default.isString(b) && !index_default_default.isNumber(b) && !index_default_default.isDate(b)) {
      throw `object "b" doesn't contain field path: ` + fieldPath.toString();
    }
    return cmp2(a2, b);
  };
}
function objFromArray(a2, v) {
  return index_default_default.reduce(a2, function(o2, x, i2) {
    o2[x] = v ? v[i2 % v.length] : x;
    return o2;
  }, {});
}
function walkObj(o2, f2, opts) {
  opts = deepDefaults(opts, {
    replace: false,
    callOnNodes: false
  });
  var walk = function(o3, acc) {
    index_default_default.each(o3, function(v, k) {
      var x;
      var newAcc = acc.slice();
      newAcc.push(k);
      if (opts.callOnNodes || !index_default_default.isObject(v) || index_default_default.isArray(v)) {
        x = f2(v, newAcc);
      }
      if (opts.replace) {
        o3[k] = v = x;
      }
      if (index_default_default.isObject(v)) {
        walk(v, newAcc);
      }
    });
    return o3;
  };
  return walk(o2, []);
}
var makeSubclass = function(name, parent, ctor2, ptype) {
  if (typeof name !== "string") {
    throw new Error("Call Error: `name` must be a string");
  }
  if (typeof parent !== "function") {
    throw new Error("Call Error: `parent` must be a function");
  }
  if (ctor2 != null && typeof ctor2 !== "function") {
    throw new Error("Call Error: `ctor` must be null or a function");
  }
  if (ptype != null && typeof ptype !== "object") {
    throw new Error("Call Error: `ptype` must be null or an object");
  }
  if (ctor2 == null && parent !== Object) {
    ctor2 = function() {
      this.super.ctor.apply(this, arguments);
    };
  }
  var subclass = function() {
    if (parent !== Object) {
      this.super = makeSuper(this, parent);
    }
    if (ctor2 != null) {
      ctor2.apply(this, arguments);
    }
  };
  Object.defineProperty(subclass, "name", { value: name });
  subclass.prototype = Object.create(parent.prototype);
  subclass.prototype.constructor = subclass;
  index_default_default.each(ptype, function(v, k) {
    subclass.prototype[k] = v;
  });
  return subclass;
};
var makeSuper = function(me, parent) {
  var sup = index_default_default.mapObject(parent.prototype, function(v, k) {
    if (typeof v === "function") {
      return index_default_default.bind(v, me);
    }
  });
  sup.ctor = index_default_default.bind(parent, me);
  return sup;
};
var mixinEventHandling = /* @__PURE__ */ function() {
  var HANDLER_ID = 0;
  return function(obj, events) {
    if (events != null) {
      obj.events = objFromArray(events);
    }
    obj._seenEvents = {};
    obj._eventHandlers = {
      byEvent: {},
      byId: {}
    };
    var getName = function(self2) {
      if (typeof self2.toString === "function" && self2.toString !== Object.prototype.toString) {
        return self2.toString();
      } else {
        return obj.prototype.constructor.name.toUpperCase();
      }
    };
    var getTag = function(self2) {
      if (typeof self2.getDebugTag === "function") {
        return self2.getDebugTag();
      } else if (typeof self2.toString === "function" && self2.toString !== Object.prototype.toString) {
        return self2.toString();
      } else {
        return obj.prototype.constructor.name.toUpperCase();
      }
    };
    obj.prototype._initEventHandlers = function() {
      var self2 = this;
      if (self2.eventHandlers == null) {
        self2.eventHandlers = {};
        if (obj.events != null) {
          index_default_default.each(obj.events, function(evt) {
            self2.eventHandlers[evt] = [];
          });
        }
      }
      if (self2.eventHandlersById == null) {
        self2.eventHandlersById = [];
      }
    };
    obj.prototype.echo = function(src, evt, opts) {
      var self2 = this;
      opts = opts || {};
      if (!index_default_default.isArray(evt)) {
        evt = [evt];
      }
      index_default_default.each(evt, function(e2, i2) {
        if (typeof e2 !== "string") {
          throw new Error("Call Error: `evt[" + i2 + "]` must be a string");
        }
        if (obj.events != null && obj.events[e2] === void 0) {
          throw new Error("Unable to register handler on " + getName(self2) + ' for "' + e2 + '" event: no such event available');
        }
        src.on(e2, function() {
          self2.fire(e2);
        }, opts);
      });
    };
    obj.prototype.on = function(evt, cb2, opts) {
      var self2 = this;
      opts = opts || {};
      self2._initEventHandlers();
      if (!index_default_default.isArray(evt)) {
        evt = [evt];
      }
      index_default_default.each(evt, function(e2) {
        if (obj.events != null && obj.events[e2] === void 0) {
          throw new Error("Unable to register handler on " + getName(self2) + ' for "' + e2 + '" event: no such event available');
        }
        var handler = {
          id: HANDLER_ID++,
          who: opts.who,
          info: opts.info,
          cb: cb2,
          limit: opts.limit
        };
        self2.eventHandlers = self2.eventHandlers || {};
        self2.eventHandlers[e2] = self2.eventHandlers[e2] || [];
        self2.eventHandlers[e2].push(handler);
        self2.eventHandlersById = self2.eventHandlersById || [];
        self2.eventHandlersById[handler.id] = handler;
        var msg = 'Adding "' + evt + '" event handler on ' + getName(self2);
        if (opts.who != null) {
          msg += " from " + opts.who;
        }
        console.debug(
          "[DataVis // %s // On] %s",
          getTag(self2),
          msg
        );
      });
      return self2;
    };
    obj.prototype.off = function(evt, who, opts) {
      var self2 = this;
      opts = opts || {};
      self2._initEventHandlers();
      if (evt === "*") {
        index_default_default.each(obj.events, function(e2) {
          self2.off(e2, who, opts);
        });
        return;
      }
      if (obj.events[evt] === void 0) {
        throw new Error("Unable to register handler on " + getName(self2) + ' for "' + evt + '" event: no such event available');
      }
      var newHandlers = [];
      index_default_default.each(self2.eventHandlers[evt], function(handler, i2) {
        if (handler == null) {
          return;
        }
        if (who == null || handler.who === who) {
          self2.eventHandlersById[handler.id] = null;
        } else {
          newHandlers.push(handler);
        }
      });
      if (!opts.silent) {
        console.debug(
          '[DataVis // %s // Off] Removed %s handlers from %s on "%s" event',
          getTag(self2),
          self2.eventHandlers[evt].length - newHandlers.length,
          who,
          evt
        );
      }
      self2.eventHandlers[evt] = newHandlers;
    };
    obj.prototype.fire = function() {
      var self2 = this, args = Array.prototype.slice.call(arguments), evt = args.shift(), opts = args.shift() || {};
      self2._initEventHandlers();
      if (obj.events[evt] === void 0) {
        throw new Error("Illegal event: " + evt);
      }
      var handlers = [];
      index_default_default.each(self2.eventHandlers[evt], function(handler, i2) {
        var handler = self2.eventHandlers[evt][i2];
        if (handler == null) {
          return;
        }
        if (handler.who && opts.notTo && (index_default_default.isArray(opts.notTo) && opts.notTo.indexOf(handler.who) >= 0 || typeof opts.notTo === "function" && opts.notTo(handler.who) || typeof opts.notTo === "object" && opts.notTo === handler.who)) {
          return;
        }
        handlers.push({
          handler,
          index: i2
        });
      });
      if (!opts.silent) {
        console.debug(
          '[DataVis // %s // Fire] Triggering %d handlers for "%s" event on %s: %O',
          getTag(self2),
          handlers.length,
          evt,
          getName(self2),
          args
        );
      }
      asyncEach(handlers, function(h, i2, next) {
        if (self2.eventHandlersById[h.handler.id] == null) {
          return;
        }
        if (h.handler.info != null) {
          console.debug(
            '[DataVis // %s // Fire] Executing "%s" handler %O (%d of %d) on %s: %s',
            getTag(self2),
            evt,
            h.handler.cb,
            i2 + 1,
            handlers.length,
            getName(self2),
            h.handler.info
          );
        } else {
          console.debug(
            '[DataVis // %s // Fire] Executing "%s" handler %O (%d of %d) on %s',
            getTag(self2),
            evt,
            h.handler.cb,
            i2 + 1,
            handlers.length,
            getName(self2)
          );
        }
        h.handler.cb.apply(null, args);
        if (h.handler.limit) {
          h.handler.limit -= 1;
          if (h.handler.limit <= 0) {
            console.debug(
              '[DataVis // %s // Fire] Removing "%s" handler #%d from %s after reaching invocation limit',
              getTag(self2),
              evt,
              i2 + 1,
              getName(self2)
            );
            self2.eventHandlers[evt][h.index] = null;
          }
        }
        return opts.async ? window.setTimeout(next) : next();
      }, function() {
        if (!opts.silent) {
          console.debug(
            '[DataVis // %s // Fire] Done triggering handlers for "%s" event on %s',
            getTag(self2),
            evt,
            getName(self2)
          );
        }
        self2.eventHandlers[evt] = index_default_default.without(self2.eventHandlers[evt], null);
      });
    };
  };
}();
function mixinDebugging(obj, tagStart) {
  if (tagStart != null && typeof tagStart !== "string" && typeof tagStart !== "function") {
    throw new Error("Call Error: `tagStart` must be null, a string, or a function");
  }
  var getTag = function(self2) {
    if (typeof tagStart === "function") {
      return tagStart.call(self2);
    } else if (typeof tagStart === "string") {
      return tagStart;
    } else if (typeof self2.getDebugTag === "function") {
      return self2.getDebugTag();
    } else if (typeof self2.toString === "function" && self2.toString !== Object.prototype.toString) {
      return self2.toString();
    } else {
      return obj.prototype.constructor.name.toUpperCase();
    }
  };
  obj.prototype.debug = function() {
    var args = Array.prototype.slice.call(arguments);
    var tag = args.shift();
    var fullTag = getTag(this);
    if (tag != null) {
      fullTag += " // " + tag;
    }
    debug.info.apply(null, Array.prototype.concat.call([fullTag], args));
  };
}
function mixinLogging(obj, tagPrefix) {
  if (tagPrefix != null && typeof tagPrefix !== "string" && typeof tagPrefix !== "function") {
    throw new Error("Call Error: `tagPrefix` must be null, a string, or a function");
  }
  var getTag = function(self2) {
    if (typeof tagPrefix === "function") {
      return tagPrefix.call(self2);
    } else if (typeof tagPrefix === "string") {
      return tagPrefix;
    } else if (typeof self2.getDebugTag === "function") {
      return self2.getDebugTag();
    } else if (typeof self2.toString === "function" && self2.toString !== Object.prototype.toString) {
      return self2.toString();
    } else {
      return obj.prototype.constructor.name.toUpperCase();
    }
  };
  var makeLogger = function(loggerType) {
    return function() {
      var args = Array.prototype.slice.call(arguments);
      var tag = args.shift();
      var msg = args.shift();
      var prefix = ["[" + getTag(this) + (tag != null ? " // " + tag : "") + "] " + msg];
      var call = Function.prototype.call;
      call.apply(call, [console[loggerType], console].concat(prefix, args));
    };
  };
  obj.prototype.logDebug = makeLogger("debug");
  obj.prototype.logInfo = makeLogger("log");
  obj.prototype.logWarning = makeLogger("warn");
  obj.prototype.logError = makeLogger("error");
}
function makeSetters(cls, setterList) {
  index_default_default.each(setterList, function(s2) {
    cls.prototype[s2.name] = function(x, opts) {
      opts = deepDefaults(opts, {
        sendEvent: true,
        dontSendEventTo: []
      });
      this[s2.prop] = x;
      if (s2.event != null && opts.sendEvent) {
        this.fire(s2.event, {
          notTo: opts.dontSendEventTo
        }, x);
      }
    };
  });
}
function delegate(from3, to3, methods) {
  if (!index_default_default.isArray(methods)) {
    methods = [methods];
  }
  index_default_default.each(methods, function(m2, i2) {
    if (typeof m2 !== "string") {
      throw new Error("Call Error: `methods[" + i2 + "]` must be a string");
    }
    from3.prototype[m2] = function() {
      var args = Array.prototype.slice.call(arguments);
      return this[to3][m2].apply(this[to3], args);
    };
  });
}
function mixinNameSetting(cls) {
  cls.prototype.__namesGenerated = 0;
  cls.prototype.setName = function(name) {
    var self2 = this;
    if (name != null && !index_default_default.isString(name)) {
      self2.name = self2.constructor.name + " #" + ++cls.prototype.__namesGenerated;
      self2.logWarning(null, "Name provided for this " + self2.constructor.name + " instance is not a string.");
    } else if (name == null || name === "") {
      self2.name = self2.constructor.name + " #" + ++cls.prototype.__namesGenerated;
      self2.logWarning(null, "Providing a name for this " + self2.constructor.name + " instance is strongly recommended to improve logging.");
    } else {
      self2.name = name;
    }
  };
  cls.prototype.getName = function() {
    var self2 = this;
    return self2.name;
  };
}
function lock(defn, name) {
  if (defn.locks === void 0) {
    defn.locks = {};
  }
  if (defn.locks[name] === void 0) {
    defn.locks[name] = 0;
  }
  defn.locks[name] += 1;
  debug.info("LOCK", "Locking " + name + " - " + defn.locks[name]);
}
function unlock(defn, name) {
  if (defn.locks === void 0) {
    defn.locks = {};
  }
  if (defn.locks[name] === void 0) {
    defn.locks[name] = 1;
  }
  defn.locks[name] -= 1;
  debug.info("LOCK", "Unlocking " + name + " - " + defn.locks[name]);
}
function isLocked(defn, name) {
  return defn.locks && !!defn.locks[name];
}
function outerHtml(elt2) {
  return jQuery("<div>").append(elt2).html();
}
function getText(selector) {
  return jQuery(selector).map(function(i2, x) {
    return jQuery(x).text();
  });
}
function isVisible(elt2) {
  return elt2.css("display") !== "none" && elt2.css("visibility") === "visible";
}
function isElement2(x) {
  return x instanceof Element || x instanceof jQuery;
}
function getElement(x) {
  return x instanceof Element ? x : x instanceof jQuery ? x.get(0) : null;
}
function isElementInViewport(parent, elt2) {
  if (elt2 instanceof jQuery) {
    elt2 = elt2.get(0);
  }
  var eltRect = elt2.getBoundingClientRect();
  if (eltRect.top < 0 || eltRect.left < 0) {
    return false;
  }
  if (parent !== window) {
    if (parent instanceof Element) {
      parent = jQuery(parent);
    }
    var parentRect = parent.get(0).getBoundingClientRect();
    return eltRect.bottom <= parent.innerHeight() + parentRect.top;
  } else {
    return eltRect.bottom <= window.innerHeight;
  }
}
function onVisibilityChange(parent, elt2, callback2) {
  var old_visible;
  return function() {
    var visible = isElementInViewport(parent, elt2);
    if (visible !== old_visible) {
      if (old_visible !== void 0 && typeof callback2 == "function") {
        callback2(visible);
      }
      old_visible = visible;
    }
  };
}
function fontAwesome(icon, cls, title) {
  var span = jQuery("<span>").addClass("fa");
  if (icon.substr(0, 3) === "fa-") {
    span.addClass(icon);
  } else {
    span.text(String.fromCharCode(parseInt(icon, 16)));
  }
  if (cls != void 0) {
    span.addClass(cls);
  }
  if (title != void 0) {
    span.attr("title", title);
  }
  return span;
}
var loadScript = function() {
  var alreadyLoaded = {};
  var lock2 = new lock_default("LOAD SCRIPT");
  return function(url, callback2, opts) {
    index_default_default.defaults(opts, {
      needAsyncSetup: false
    });
    var load = function(url2, callback3) {
      var head = document.getElementsByTagName("head")[0];
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = url2;
      script.onreadystatechange = callback3;
      script.onload = callback3;
      head.appendChild(script);
    };
    var makeCb = function(isAlreadyLoaded) {
      var showLoadMsg = function() {
        if (isAlreadyLoaded) {
          console.debug("[DataVis // Load Script] [url = %s] Already loaded", url);
        } else {
          console.debug("[DataVis // Load Script] [url = %s] Finished executing loaded script", url);
        }
      };
      if (opts.needAsyncSetup) {
        return function() {
          showLoadMsg();
          callback2(isAlreadyLoaded, function() {
            console.debug("[DataVis // Load Script] [url = %s] Exiting control of the script loader", url);
            if (!isAlreadyLoaded) {
              alreadyLoaded[url] = true;
              lock2.unlock();
            }
          });
        };
      } else {
        return function() {
          showLoadMsg();
          console.debug("[DataVis // Load Script] [url = %s] Exiting control of the script loader", url);
          if (!isAlreadyLoaded) {
            alreadyLoaded[url] = true;
            lock2.unlock();
          }
          callback2(isAlreadyLoaded);
        };
      }
    };
    lock2.onUnlock(function() {
      if (alreadyLoaded[url]) {
        makeCb(true)();
      } else {
        lock2.lock();
        load(url, makeCb(false));
      }
    }, import_sprintf_js2.default.sprintf("Waiting to load [url = %s]", url));
  };
}();
function setTableCell(cell, value, opts) {
  opts = opts || {};
  var fcc = opts.colConfig instanceof ordmap_default && opts.colConfig.get(opts.field) || opts.colConfig || {};
  var fti = opts.typeInfo instanceof ordmap_default && opts.typeInfo.get(opts.field) || opts.typeInfo || {};
  var ops = opts.operations || [];
  if (cell instanceof jQuery) {
    cell = cell.get(0);
  }
  if (!(cell instanceof HTMLTableCellElement)) {
    throw new Error("Call Error: `cell` must be a HTMLTableCellElement instance");
  }
  var container = cell;
  if (fcc.maxHeight != null && value !== "") {
    var wrapper = document.createElement("div");
    wrapper.classList.add("wcdv_maxheight_wrapper");
    wrapper.style.maxHeight = fcc.maxHeight;
    if (fcc.width) {
      wrapper.classList.add("wcdv_maxheight_wrapper_withwidth");
      wrapper.style.width = fcc.width;
    }
    var showValueBtn = document.createElement("button");
    showValueBtn.setAttribute("title", "Full value has been truncated; click to show it.");
    showValueBtn.classList.add("wcdv_icon_button");
    showValueBtn.classList.add("wcdv_icon_button_incell");
    showValueBtn.classList.add("wcdv_icon_button_nolabel");
    showValueBtn.classList.add("wcdv_show_full_value");
    var showValueSpan = document.createElement("span");
    showValueSpan.classList.add("fa");
    showValueSpan.classList.add("fa-asterisk");
    var operationDiv = document.createElement("div");
    operationDiv.style.display = "inline-block";
    operationDiv.style.float = "right";
    index_default_default.each(ops, function(op, index2) {
      operationDiv.appendChild(makeOperationButton("cell", op, index2, { inCell: true }));
    });
    container = document.createElement("div");
    cell.appendChild(wrapper);
    wrapper.appendChild(showValueBtn);
    showValueBtn.appendChild(showValueSpan);
    wrapper.appendChild(operationDiv);
    wrapper.appendChild(container);
  } else if (ops.length > 0) {
    var wrapper = document.createElement("div");
    var operationDiv = document.createElement("div");
    operationDiv.style.display = "inline-block";
    operationDiv.style.float = "right";
    index_default_default.each(ops, function(op, index2) {
      operationDiv.appendChild(makeOperationButton("cell", op, index2, { inCell: true }));
    });
    container = document.createElement("div");
    cell.appendChild(wrapper);
    wrapper.appendChild(operationDiv);
    wrapper.appendChild(container);
  }
  setElement(container, value, opts);
}
function setElement(container, value, opts) {
  opts = opts || {};
  var fcc = opts.colConfig instanceof ordmap_default && opts.colConfig.get(opts.field) || opts.colConfig || {};
  var fti = opts.typeInfo instanceof ordmap_default && opts.typeInfo.get(opts.field) || opts.typeInfo || {};
  if (container instanceof jQuery) {
    container = container.get(0);
  }
  if (!(container instanceof Element)) {
    throw new Error("Call Error: `container` must be an Element instance");
  }
  if (value instanceof Element) {
    container.appendChild(value);
  } else if (value instanceof jQuery) {
    container.appendChild(value.get(0));
  } else if (fcc.allowHtml && fti.type === "string") {
    container.innerHTML = value;
  } else if (value === "") {
    container.innerText = "";
  } else {
    container.innerText = value;
  }
}
function makeOperationButton(type, op, index2, opts) {
  opts = opts || {};
  index_default_default.defaults(opts, {
    inCell: false
  });
  var btn = document.createElement("button");
  btn.setAttribute("type", "button");
  btn.setAttribute("data-operation-type", type);
  btn.setAttribute("data-operation-index", index2);
  btn.classList.add("wcdv_operation");
  if (type === "cell") {
    btn.classList.add("wcdv_icon_button");
    btn.classList.add("wcdv_icon_button_incell");
    btn.classList.add("wcdv_icon_button_nolabel");
    btn.style.float = "initial";
    btn.appendChild(fontAwesome(op.icon).get(0));
  } else {
    if (op.icon) {
      btn.appendChild(fontAwesome(op.icon).get(0));
    }
    if (op.label) {
      btn.classList.add("wcdv_nowrap");
      btn.append(op.label);
    } else {
      btn.classList.add("no_label");
    }
  }
  if (op.tooltip) {
    btn.setAttribute("title", op.tooltip);
  }
  return btn;
}
function makeCheckbox(startChecked, onChange, text, parent) {
  var label = jQuery("<label>");
  var input = jQuery("<input>", { "type": "checkbox", "checked": startChecked }).on("change", onChange);
  label.append(input).append(text).appendTo(parent);
  return input;
}
function makeToggleCheckbox(rootObj, path, startChecked, text, parent, after2) {
  if (rootObj != null) {
    setPropDef(startChecked, rootObj, path);
  }
  return makeCheckbox(rootObj != null ? getProp(rootObj, path) : startChecked, function() {
    var isChecked = jQuery(this).prop("checked");
    if (rootObj != null) {
      console.debug("[DataVis // Grid // Toolbar] Setting `" + path.join(".") + "` to " + isChecked);
      setProp(isChecked, rootObj, path);
    }
    if (typeof after2 === "function") {
      after2(isChecked);
    }
  }, text, parent);
}
function makeRadioButtons(rootObj, path, def, label, name, values2, conv, onChange, parent) {
  setPropDef(def, rootObj, path);
  var initial2 = getProp(rootObj, path);
  var root2 = jQuery("<div>").css("display", "inline-block").appendTo(parent);
  var handler = function() {
    var selected = root2.find("input[type=radio]:checked").val();
    if (typeof conv === "function") {
      selected = conv(selected);
    }
    console.debug("[DataVis // Grid // Toolbar] Setting `" + path.join(".") + "` to " + selected);
    setProp(selected, rootObj, path);
    if (typeof onChange === "function") {
      onChange(selected);
    }
  };
  if (label) {
    jQuery("<label>").text(label).appendTo(root2);
  }
  index_default_default.each(values2, function(v) {
    var label2 = index_default_default.isString(v) ? v : v.label;
    var value = index_default_default.isString(v) ? v : v.value;
    jQuery("<label>").append(jQuery("<input>", { "type": "radio", "name": name, "value": value }).on("change", handler)).append(label2).appendTo(root2);
  });
  root2.find("input[type=radio]").val([initial2]);
  return root2;
}
function valueInfo(value) {
  if (index_default_default.isNumber(value)) {
    return [value, ": Number"];
  } else if (index_default_default.isString(value)) {
    return ['"' + value + '"', ": String"];
  } else if (index_default_default.isArray(value)) {
    return [value, ": Array"];
  } else if (index_default_default.isObject(value)) {
    return [value, ": Object"];
  } else {
    return [value, ": Unknown"];
  }
}
function addSrcInfo(srcIndex, field) {
  return ":" + srcIndex + ":" + field;
}
var log = {
  info: Function.prototype.bind.call(window.console.log, window.console),
  warn: Function.prototype.bind.call(window.console.warn, window.console),
  error: Function.prototype.bind.call(window.console.error, window.console)
};
var concatLog = {
  info: function() {
    log.info.apply(window.console, index_default_default.flatten(arguments, true));
  },
  warn: function() {
    log.warn.apply(window.console, index_default_default.flatten(arguments, true));
  },
  error: function() {
    log.error.apply(window.console, index_default_default.flatten(arguments, true));
  }
};
var debug = {
  info: function(tag) {
    if (!(window.MIE && window.MIE.DEBUGGING)) {
      return;
    }
    var rest2 = Array.prototype.slice.call(arguments, 1);
    var args = Array.prototype.concat.call(["[DEBUG // " + tag + "] " + rest2[0]], rest2.slice(1));
    return log.info.apply(window.console, args);
  },
  warn: function(tag) {
    if (!(window.MIE && window.MIE.DEBUGGING)) {
      return;
    }
    var rest2 = Array.prototype.slice.call(arguments, 1);
    var args = Array.prototype.concat.call(["[DEBUG // " + tag + "] " + rest2[0]], rest2.slice(1));
    return log.warn.apply(window.console, args);
  },
  error: function(tag) {
    if (!(window.MIE && window.MIE.DEBUGGING)) {
      return;
    }
    var rest2 = Array.prototype.slice.call(arguments, 1);
    var args = Array.prototype.concat.call(["[DEBUG // " + tag + "] " + rest2[0]], rest2.slice(1));
    return log.error.apply(window.console, args);
  }
};
var logAsync = /* @__PURE__ */ function() {
  var ids = {};
  return function(id) {
    ids[id] = ids[id] == null ? 0 : ids[id] + 1;
    id += "[" + ids[id] + "]";
    console.log("~~~ ASYNC: " + id + " - START");
    return {
      finish: function() {
        console.log("~~~ ASYNC: " + id + " - FINISH");
      }
    };
  };
}();
function deprecated(defn, msg, ref) {
  var output = msg + " See https://miewiki.med-web.com/wiki/index.php/Advanced_Reports:_Filtering,_Graphing,_Comparing#" + ref + " for more information.";
  emailWarning(defn, output);
}
var decode = function(cell, fti) {
  if (cell.decoded) {
    return;
  }
  if (cell.orig === void 0) {
    cell.orig = cell.value;
  }
  if (typeof cell.orig === "string") {
    cell.value = types_default.registry.get(fti.type).parse(cell.orig, fti.internalType, fti.format);
  } else {
    cell.value = types_default.registry.get(fti.type).decode(cell.orig, fti.internalType);
  }
  cell.decoded = true;
};
function format2(fcc, fti, cell, opts) {
  var newVal, isNegative = false, isSafeToCache = true;
  fcc = fcc || {};
  fti = fti || {};
  opts = opts || {
    decode: true
  };
  index_default_default.defaults(opts, {
    debug: false,
    overrideType: null,
    saferCaching: true
  });
  if (opts.debug) {
    console.debug("[DataVis // Format] typeInfo = %O ; colConfig = %O ; cell = %O ; opts = %O", fti, fcc, cell, opts);
  }
  var formatStrToObj = function(formatStr, base) {
    var formatObj2 = deepCopy(base), m2;
    if (formatStr[0] === "$") {
      formatObj2.currencySymbol = "$";
      formatStr = formatStr.slice(1);
    }
    m2 = formatStr.match(/^0,0/);
    setProp(!!m2, formatObj2, "integerPart", "grouping");
    m2 = formatStr.match(/\.(0+)$/);
    setProp(m2 != null ? m2[1].length : 0, formatObj2, "decimalPlaces");
    return formatObj2;
  };
  if (moment_default.isMoment(cell) || import_numeral2.default.isNumeral(cell) || import_bignumber2.default.isBigNumber(cell) || cell == null || typeof cell !== "object") {
    cell = {
      value: cell
    };
  }
  if (cell.cachedRender != null) {
    return cell.cachedRender;
  }
  var result2 = cell.orig || cell.value;
  var t2 = opts.overrideType || fti.type;
  var format3 = fcc.format;
  var formatObj;
  var format_dateOnly = fcc.format_dateOnly;
  var defaultNumberFormat = {
    integerPart: {
      grouping: false,
      groupSize: 3,
      groupSeparator: ","
    },
    fractionalPart: {
      grouping: false,
      groupSize: 3,
      groupSeparator: " "
    },
    radixPoint: ".",
    decimalPlaces: null,
    negativeFormat: "minus",
    roundingMethod: "half_up"
  };
  if (window.Intl != null && window.Intl.NumberFormat != null && window.Intl.NumberFormat.prototype.formatToParts != null) {
    index_default_default.each(Intl.NumberFormat(window.DATAVIS_LANG).formatToParts("1234.5"), function(o2) {
      switch (o2.type) {
        case "group":
          defaultNumberFormat.integerPart.groupSeparator = o2.value;
          break;
        case "decimal":
          defaultNumberFormat.radixPoint = o2.value;
      }
    });
  }
  var defaultCurrencyFormat = deepDefaults({
    integerPart: {
      grouping: true
    },
    decimalPlaces: 2,
    negativeFormat: "parens",
    currencySymbol: "$"
  }, defaultNumberFormat);
  if (format3 == null) {
    switch (t2) {
      case "number":
        format3 = deepCopy(defaultNumberFormat);
        break;
      case "currency":
        format3 = deepCopy(defaultCurrencyFormat);
        break;
      case "date":
        format3 = "LL";
        break;
      case "datetime":
        format3 = "LLL";
        break;
      case "time":
        format3 = "LTS";
        break;
    }
  } else {
    switch (t2) {
      case "number":
        format3 = typeof format3 === "string" ? formatStrToObj(format3, defaultNumberFormat) : deepDefaults(format3, defaultNumberFormat);
        break;
      case "currency":
        format3 = typeof format3 === "string" ? formatStrToObj(format3, defaultCurrencyFormat) : deepDefaults(format3, defaultCurrencyFormat);
        break;
    }
  }
  if (format_dateOnly == null && t2 === "datetime") {
    format_dateOnly = "LL";
  }
  if (result2 == null || result2 === "") {
    result2 = "";
  } else if (["date", "datetime"].indexOf(t2) >= 0 && (moment_default.isMoment(cell.value) && !cell.value.isValid() || ["", "0000-00-00", "0000-00-00 00:00:00"].indexOf(cell.value) >= 0)) {
    result2 = "";
  } else {
    switch (t2) {
      case "date":
      case "time":
      case "datetime":
        if (opts.decode) {
          decode(cell, fti);
        }
        result2 = types_default.registry.get(t2).format(cell.value, {
          full: format3,
          abbrev: t2 === "datetime" && fcc.hideMidnight ? format_dateOnly : null
        });
        break;
      case "number":
      case "currency":
        if (opts.decode) {
          decode(cell, fti);
        }
        result2 = types_default.registry.get(t2).format(cell.value, format3);
        break;
      case "json":
        if (typeof cell.value === "string") {
          result2 = cell.value;
        } else {
          result2 = new json_formatter_esm_default(cell.value, 0, {
            onToggle: function(isOpen) {
              if (window.TableTool) {
                TableTool.update();
              }
            }
          }).render();
        }
        break;
      case "string":
        result2 = cell.value;
        break;
      default:
        log.error(
          'Unable to format - unknown type: { field = "%s", type = "%s", value = "%s" }',
          fti.field,
          t2,
          cell.value
        );
    }
  }
  if (typeof cell.render === "function") {
    result2 = cell.render(result2);
    if (opts.saferCaching && (result2 instanceof jQuery || result2 instanceof Element)) {
      isSafeToCache = false;
    }
  }
  if (isSafeToCache) {
    cell.cachedRender = result2;
  }
  return result2;
}
var dateFormatString = "yyyy-MM-dd";
var timeFormatString = "HH:mm:ss";
function init(cont) {
  switch (miecgictrl.dateformat) {
    case 1:
      dateFormatString = "MM-dd-yyyy";
      break;
    case 2:
      dateFormatString = "dd-MM-yyyy";
      break;
    case 3:
      dateFormatString = "yyyy-MM-dd";
      break;
    default:
      dateFormatString = "yyyy-MM-dd";
  }
  timeFormatString = miecgictrl.militaryTime ? "HH:mm:ss" : "hh:mm:ss tt";
  cont();
}
function formatDate(d2) {
  var convert = {
    "MM": function(x) {
      var m2 = x.getMonth() + 1;
      return m2 > 9 ? m2 : "0" + m2;
    },
    "dd": function(x) {
      var d3 = x.getDate();
      return d3 > 9 ? d3 : "0" + d3;
    },
    "yyyy": function(x) {
      return x.getFullYear();
    }
  };
  return index_default_default.map(dateFormatString.split("-"), function(fmt) {
    if (convert[fmt]) {
      return convert[fmt](d2);
    } else {
      return "[UNKNOWN]";
    }
  }).join("-");
}
function formatTime(t2) {
  var convert = {
    "HH": function(x) {
      var h = x.getHours();
      return h > 9 ? h : "0" + h;
    },
    "hh": function(x) {
      var h = x.getHours();
      if (h === 0) {
        h = 12;
      } else if (h > 12) {
        h = h - 12;
      }
      return h > 9 ? h : "0" + h;
    },
    "mm": function(x) {
      var m2 = x.getMinutes();
      return m2 > 9 ? m2 : "0" + m2;
    },
    "ss": function(x) {
      var s2 = x.getSeconds();
      return s2 > 9 ? s2 : "0" + s2;
    },
    "tt": function(x) {
      var h = x.getHours();
      return h < 12 ? "AM" : "PM";
    }
  };
  return timeFormatString.replace(/[A-Za-z]+/g, function(fmt) {
    if (convert[fmt]) {
      return convert[fmt](t2);
    }
  });
}
function formatDateTime(d2) {
  return formatDate(d2) + " " + formatTime(d2);
}
function formatDateString(s2) {
  if (s2 === "" || s2 === "0000-00-00" || s2 === "0000-00-00 00:00:00") {
    return "[UNKNOWN]";
  }
  return formatDate(new Date(s2));
}
function formatTimeString(s2) {
  if (s2 === "" || s2 === "0000-00-00" || s2 === "0000-00-00 00:00:00") {
    return "[UNKNOWN]";
  }
  return formatTime(new Date(s2));
}
function formatDateTimeString(s2) {
  if (s2 === "" || s2 === "0000-00-00" || s2 === "0000-00-00 00:00:00") {
    return "[UNKNOWN]";
  }
  formatDateTime(new Date(s2));
}
function removeZeroDates(x) {
  return x === "0000-00-00" ? "" : x;
}
function removeZeroDateTimes(x) {
  return x === "0000-00-00 00:00:00" ? "" : x;
}
var DATE_ONLY_REGEXP = /^\d\d\d\d-\d\d-\d\d$/;
function addTimeComponent(x) {
  return typeof x === "string" && DATE_ONLY_REGEXP.test(x) ? x + " 00:00:00" : x;
}
function blockGrid(defn, fn, info) {
  var grid;
  var blockConfig;
  var output;
  if (defn.table.blockCount === void 0) {
    defn.table.blockCount = 0;
  }
  defn.table.blockCount += 1;
  console.debug("[DataVis // Blocking // Push] COUNT =", defn.table.blockCount, "> INFO =", info);
  if (defn.table.blockCount === 1) {
    output = getProp(defn, "table", "output", "method");
    switch (output) {
      case "jqwidgets":
        grid = jQuery(document.getElementById(defn.table.id)).children('div [role="grid"]');
        break;
      case "pivot":
        grid = jQuery(document.getElementById(defn.table.id));
        break;
      default:
        grid = null;
    }
    if (grid !== null) {
      blockConfig = {
        message: null,
        overlayCSS: {
          opacity: 0.9,
          backgroundColor: "#FFF"
        }
      };
      if (typeof fn === "function") {
        blockConfig.onBlock = fn;
      }
      grid.block(blockConfig);
    } else {
      fn();
    }
  } else if (typeof fn === "function") {
    fn();
  }
}
function unblockGrid(defn, info) {
  var grid;
  var output;
  if (defn.table.blockCount === void 0) {
    defn.table.blockCount = 0;
  }
  if (defn.table.blockCount > 0) {
    defn.table.blockCount -= 1;
    console.debug("[DataVis // Blocking // Pop] COUNT =", defn.table.blockCount, "> INFO =", info);
    if (defn.table.blockCount === 0) {
      output = getProp(defn, "table", "output", "method");
      switch (output) {
        case "jqwidgets":
          grid = jQuery(document.getElementById(defn.table.id)).children('div [role="grid"]');
          break;
        case "pivot":
          grid = jQuery(document.getElementById(defn.table.id));
          break;
        default:
          grid = null;
      }
      if (grid !== null) {
        grid.unblock();
      }
    }
  }
}
function gridIsBlocked(defn) {
  return defn.table.blockCount > 0;
}
function withGridBlock(defn, fn, info) {
  if (typeof fn !== "function") {
    throw Error("Call Error: `fn` must be a function");
  }
  blockGrid(defn, function() {
    window.setTimeout(function() {
      fn();
      unblockGrid(defn, info);
    }, jQuery.blockUI.defaults.fadeIn);
  }, info);
}
function Timing() {
  var self2 = this;
  self2.data = {};
  self2.events = {};
  self2.eventCount = {};
}
Timing.prototype.start = function(what) {
  var self2 = this, subject = what[0], event = what[1];
  setPropDef([], self2.events, subject);
  setPropDef(0, self2.eventCount, subject, event);
  setPropDef({}, self2.data, subject);
  self2.eventCount[subject][event] += 1;
  if (self2.eventCount[subject][event] > 1) {
    event += " (#" + self2.eventCount[subject][event] + ")";
  }
  self2.events[subject].push(event);
  console.debug("[DataVis // Timing] Received <START> event for [" + subject + " ] " + event);
  setProp(Date.now(), self2.data, subject, event, "start");
};
Timing.prototype.stop = function(what) {
  var self2 = this, subject = what[0], event = what[1];
  setPropDef(0, self2.eventCount, subject, event);
  if (self2.eventCount[subject][event] > 1) {
    event += " (#" + self2.eventCount[subject][event] + ")";
  }
  console.debug("[DataVis // Timing] Received <STOP> event for [" + subject + " ] " + event);
  if (getProp(self2.data, subject, event, "start") === void 0) {
    log.warn("Received <STOP> event for [" + subject + " : " + event + "] with no <START> event");
    return;
  }
  setProp(Date.now(), self2.data, subject, event, "end");
};
Timing.prototype.getSubjects = function() {
  return index_default_default.keys(this.events);
};
Timing.prototype.dump = function(subject) {
  var self2 = this;
  var f2 = function(sub) {
    if (isNothing(self2.events[sub])) {
      throw new Error("Unknown subject: " + sub);
    }
    index_default_default.each(self2.events[sub], function(evt) {
      var start = getProp(self2.data, sub, evt, "start"), end = getProp(self2.data, sub, evt, "end");
      log.info("[TIMING] " + sub + " : " + evt + " >> " + (end - start) + "ms");
    });
  };
  if (subject != null) {
    f2(subject);
  } else {
    index_default_default.each(self2.getSubjects(), f2);
  }
};
function getParamsFromUrl() {
  var match, key, val, pl = /\+/g, search = /([^&=]+)=?([^&]*)/g, decode2 = function(s2) {
    return decodeURIComponent(s2.replace(pl, " "));
  }, query = window.location.search.substring(1), params = {};
  while (match = search.exec(query)) {
    key = decode2(match[1]);
    val = decode2(match[2]);
    if (params[key]) {
      if (!index_default_default.isArray(params[key])) {
        params[key] = [params[key]];
      }
      params[key].push(val);
    } else {
      params[key] = val;
    }
  }
  return params;
}
function validateColConfig(colConfig, data) {
  if (!(colConfig instanceof ordmap_default)) {
    throw new Error("Call Error: `colConfig` must be an OrdMap instance");
  }
  if (data == null) {
    log.warn("Unable to validate column configuration without data");
    return false;
  }
  if (!data.isPlain) {
    log.info("Can only validate column config for plain output");
    return false;
  }
  if (data.data.length === 0) {
    log.info("Unable to validate column configuration using data with no rows");
    return false;
  }
  colConfig.each(function(fcc, field) {
    if (data.data[0].rowData[field] === void 0) {
      log.warn('Column configuration refers to field "' + field + '" which does not exist in the data');
      return false;
    }
  });
  return true;
}
function determineColumns(colConfig, data, typeInfo) {
  var columns = [];
  if (!(colConfig instanceof ordmap_default)) {
    throw new Error("Call Error: `colConfig` must be an OrdMap instance");
  }
  if (!(typeInfo instanceof ordmap_default)) {
    throw new Error("Call Error: `typeInfo` must be an OrdMap instance");
  }
  validateColConfig(colConfig, data);
  if (colConfig._keys.length > 0) {
    var notHidden = colConfig.filter(function(cc) {
      return !cc.isHidden;
    });
    var pinned = notHidden.filter(function(cc) {
      return cc.isPinned;
    }).keys();
    var notPinned = notHidden.filter(function(cc) {
      return !cc.isPinned;
    }).keys();
    columns = pinned.concat(notPinned);
  } else if (typeInfo.size() > 0) {
    columns = index_default_default.reject(typeInfo.keys(), function(field) {
      return field.charAt(0) === "_";
    });
  } else if (data != null) {
    if (data.isPlain && data.data.length > 0) {
      columns = index_default_default.keys(data.data[0].rowData);
    } else if (data.isGroup && data.data[0].length > 0) {
      columns = index_default_default.keys(data.data[0][0].rowData);
    } else if (data.isPivot && data.data[0][0].length > 0) {
      columns = index_default_default.keys(data.data[0][0][0].rowData);
    }
  }
  console.debug("[DataVis // Determine Columns] Columns = %O", columns);
  return columns;
}
function presentDownload(blob, fileName) {
  if (!(blob instanceof Blob)) {
    throw new Error("Call Error: `blob` must be a Blob");
  }
  if (window.navigator.msSaveBlob != null) {
    window.navigator.msSaveBlob(blob, fileName);
  } else {
    var a2 = document.createElement("a");
    a2.download = fileName;
    a2.href = URL.createObjectURL(blob);
    jQuery(document.body).append(a2);
    a2.click();
    a2.remove();
  }
}
function dataURItoBlob(dataURI) {
  var byteString = atob(dataURI.split(",")[1]);
  var mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
  var ab = new ArrayBuffer(byteString.length);
  var ia = new Uint8Array(ab);
  for (var i2 = 0; i2 < byteString.length; i2++) {
    ia[i2] = byteString.charCodeAt(i2);
  }
  var blob = new Blob([ab], { type: mimeString });
  return blob;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    var r2 = Math.random() * 16 | 0, v = c2 == "x" ? r2 : r2 & 3 | 8;
    return v.toString(16);
  });
}
function sleep(ms) {
  var start = /* @__PURE__ */ new Date();
  var end;
  do {
    end = /* @__PURE__ */ new Date();
  } while (end - start < ms);
}
var EagerPipeline = makeSubclass("EagerPipeline", Object, function(x) {
  this.x = x;
});
EagerPipeline.prototype.andThen = function(f2) {
  var x = this.x;
  return new EagerPipeline(f2(x));
};
EagerPipeline.prototype.andThenCurry = function() {
  var f2 = curry.apply(null, arguments);
  return this.andThen(f2);
};
EagerPipeline.prototype.done = function() {
  return this.x;
};
if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    "use strict";
    if (this == null) {
      throw new TypeError("can't convert " + this + " to object");
    }
    var str = "" + this;
    count = +count;
    if (count < 0) {
      throw new RangeError("repeat count must be non-negative");
    }
    if (count == Infinity) {
      throw new RangeError("repeat count must be less than infinity");
    }
    count |= 0;
    if (str.length == 0 || count == 0) {
      return "";
    }
    if (str.length * count >= 1 << 28) {
      throw new RangeError("repeat count must not overflow maximum string size");
    }
    while (count >>= 1) {
      str += str;
    }
    str += str.substring(0, str.length * count - str.length);
    return str;
  };
}
if (!String.prototype.startsWith) {
  Object.defineProperty(String.prototype, "startsWith", {
    value: function(search, rawPos) {
      var pos = rawPos > 0 ? rawPos | 0 : 0;
      return this.substring(pos, pos + search.length) === search;
    }
  });
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === void 0 || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}
Number.isNaN = Number.isNaN || function(value) {
  return value !== value;
};
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
  Element.prototype.closest = function(s2) {
    var el = this;
    do {
      if (el.matches(s2)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
  };
}

// node_modules/wcdatavis/src/aggregates.js
var import_sprintf_js4 = __toESM(require_sprintf());
var import_numeral3 = __toESM(require_numeral());
var import_bignumber3 = __toESM(require_bignumber());

// node_modules/wcdatavis/src/trans.js
var import_sprintf_js3 = __toESM(require_sprintf());

// node_modules/wcdatavis/src/lang/en-US.js
var en_US_default = {
  "AGGREGATE.FIELD.DENOMINATOR": "Denom",
  "AGGREGATE.FIELD.NUMERATOR": "Num",
  "AGGREGATE.HEADER_DISPLAY": "%s of %s",
  "AGGREGATE.NAME.AVERAGE": "Average",
  "AGGREGATE.NAME.COUNT": "Count",
  "AGGREGATE.NAME.COUNT_DISTINCT": "Count Distinct",
  "AGGREGATE.NAME.COUNT_OVER_COUNT": "Count/Count",
  "AGGREGATE.NAME.DISTINCT_VALUES": "Distinct Values",
  "AGGREGATE.NAME.FIRST": "First",
  "AGGREGATE.NAME.LAST": "Last",
  "AGGREGATE.NAME.MAX": "Max",
  "AGGREGATE.NAME.MIN": "Min",
  "AGGREGATE.NAME.NTH": "Nth",
  "AGGREGATE.NAME.SUM": "Sum",
  "AGGREGATE.NAME.SUM_OVER_SUM": "Sum/Sum",
  "AGGREGATE.NAME.VALUES": "Values",
  "AGGREGATE.NAME.VALUES_WITH_COUNTS": "Values w/ Counts",
  "CALENDAR.DATE": "date",
  "CALENDAR.DAY": "day",
  "CALENDAR.DAY.FRIDAY": "Friday",
  "CALENDAR.DAY.MONDAY": "Monday",
  "CALENDAR.DAY.SATURDAY": "Saturday",
  "CALENDAR.DAY.SUNDAY": "Sunday",
  "CALENDAR.DAY.THURSDAY": "Thursday",
  "CALENDAR.DAY.TUESDAY": "Tuesday",
  "CALENDAR.DAY.WEDNESDAY": "Wednesday",
  "CALENDAR.MONTH": "month",
  "CALENDAR.MONTH.APRIL": "April",
  "CALENDAR.MONTH.AUGUST": "August",
  "CALENDAR.MONTH.DECEMBER": "December",
  "CALENDAR.MONTH.FEBRUARY": "February",
  "CALENDAR.MONTH.JANUARY": "January",
  "CALENDAR.MONTH.JULY": "July",
  "CALENDAR.MONTH.JUNE": "June",
  "CALENDAR.MONTH.MARCH": "March",
  "CALENDAR.MONTH.MAY": "May",
  "CALENDAR.MONTH.NOVEMBER": "November",
  "CALENDAR.MONTH.OCTOBER": "October",
  "CALENDAR.MONTH.SEPTEMBER": "September",
  "CALENDAR.QUARTER": "quarter",
  "CALENDAR.WEEK": "week",
  "CALENDAR.YEAR": "year",
  "DIALOG.CANCEL": "Cancel",
  "DIALOG.OK": "OK",
  "FILTER.DATE.OPERATOR.AFTER": "after",
  "FILTER.DATE.OPERATOR.AND": "and",
  "FILTER.DATE.OPERATOR.BEFORE": "before",
  "FILTER.DATE.OPERATOR.BETWEEN": "between",
  "FILTER.DATE.OPERATOR.CURRENT": "current",
  "FILTER.DATE.OPERATOR.EVERY": "every",
  "FILTER.DATE.OPERATOR.LAST": "last",
  "FILTER.DATE.OPERATOR.ON": "on",
  "GRAPH.TITLEBAR.SHOW_HIDE": "Show/Hide Graph",
  "GRAPH.TITLEBAR.SHOW_HIDE_CONTROLS": "Show/Hide Graph Controls",
  "GRID.COLCONFIG_WIN.ALLOW_HTML": "Allow HTML to be rendered?",
  "GRID.COLCONFIG_WIN.HIDE_COL": "Hide column?",
  "GRID.COLCONFIG_WIN.MOVE_COL_TO_BOTTOM": "Move to bottom of column list",
  "GRID.COLCONFIG_WIN.MOVE_COL_TO_TOP": "Move to top of column list",
  "GRID.COLCONFIG_WIN.PINNED_COL_WARNING": "Pinned columns always appear before any others in plain (non-grouped) output, in the relative order shown above.",
  "GRID.COLCONFIG_WIN.PIN_COL": "Pin column to left side of table?",
  "GRID.COLCONFIG_WIN.RENAME_COL": "Rename column in table.",
  "GRID.COLCONFIG_WIN.RENAME_COL.PROMPT": 'Rename field "%s" to what?',
  "GRID.COLCONFIG_WIN.REORDER_COLS": "Click and drag to reorder columns",
  "GRID.COLCONFIG_WIN.RESET_COL_ORDER": "Reset Column Order",
  "GRID.COLCONFIG_WIN.TBL.DISPLAY": "Display",
  "GRID.COLCONFIG_WIN.TBL.FIELD": "Field",
  "GRID.COLCONFIG_WIN.TBL.OPTIONS": "Options",
  "GRID.COLCONFIG_WIN.TITLE": "Columns",
  "GRID.GROUP_FUN.DATE.FULL_DATE": "Full Date (No Time)",
  "GRID.GROUP_FUN.DATE.YEAR": "Year",
  "GRID.GROUP_FUN.DATE.YEAR_AND_MONTH": "Year & Month",
  "GRID.GROUP_FUN.DATE.YEAR_AND_QUARTER": "Year & Quarter",
  "GRID.GROUP_FUN.DATE.YEAR_AND_WEEK": "Year & Week (ISO)",
  "GRID.GROUP_FUN.DATE_TIME.SLICE.15MIN": "Date & Time: 15 min slices",
  "GRID.GROUP_FUN.DATE_TIME.SLICE.1HR": "Date & Time: 1 hr slices",
  "GRID.GROUP_FUN.DIALOG.DATE": "Date",
  "GRID.GROUP_FUN.DIALOG.DATE_TIME": "Date & Time",
  "GRID.GROUP_FUN.DIALOG.OTHER": "Other",
  "GRID.GROUP_FUN.DIALOG.REPEATING": "Repeating",
  "GRID.GROUP_FUN.DIALOG.TIME": "Time",
  "GRID.GROUP_FUN.DIALOG.TITLE": "Apply Function to %s",
  "GRID.GROUP_FUN.NONE": "None",
  "GRID.GROUP_FUN.REPEATING.DAY_OF_WEEK": "Day of Week",
  "GRID.GROUP_FUN.REPEATING.MONTH": "Month",
  "GRID.GROUP_FUN.REPEATING.QUARTER": "Quarter",
  "GRID.GROUP_FUN.REPEATING.WEEK": "Week (ISO)",
  "GRID.GROUP_FUN.TIME.SLICE.15MIN": "Time: 15 min slices",
  "GRID.GROUP_FUN.TIME.SLICE.1HR": "Time: 1 hr slices",
  "GRID.PERSPECTIVE_WIN.TEMP_PERSPECTIVE_WARNING": "This perspective is temporary; the configuration below does not reflect the current state of any bound prefs modules.",
  "GRID.PERSPECTIVE_WIN.TITLE": "Perspective",
  "GRID.TABLE.ADD_FILTER_HELP": 'Click to add a filter for "%s"',
  "GRID.TABLE.DRAGGABLE_FIELD_HELP": "You can drag & drop this field into the grid controls above to filter, group or pivot.",
  "GRID.TABLE.SORT_MENU.ASCENDING": "%s, Ascending",
  "GRID.TABLE.SORT_MENU.DESCENDING": "%s, Descending",
  "GRID.TABLE.SORT_MENU.RESET_SORT": "Reset Sort",
  "GRID.TEMPLATE_EDITOR.CONFIG.AFTER": "After",
  "GRID.TEMPLATE_EDITOR.CONFIG.AFTER_GROUP": "After Group",
  "GRID.TEMPLATE_EDITOR.CONFIG.BEFORE": "Before",
  "GRID.TEMPLATE_EDITOR.CONFIG.BEFORE_GROUP": "Before Group",
  "GRID.TEMPLATE_EDITOR.CONFIG.EMPTY": "Empty",
  "GRID.TEMPLATE_EDITOR.CONFIG.ITEM": "Item",
  "GRID.TEMPLATE_EDITOR.GROUPED": "Grouped",
  "GRID.TEMPLATE_EDITOR.PIVOTTED": "Pivotted",
  "GRID.TEMPLATE_EDITOR.PLAIN": "Plain",
  "GRID.TEMPLATE_EDITOR.TITLE": "Template Editor",
  "GRID.TITLEBAR.CANCEL": "Cancel",
  "GRID.TITLEBAR.CLEAR_FILTER": "clear filter",
  "GRID.TITLEBAR.DATA_LIMITED_WARNING": "You are not looking at all of the records. Click to fetch the rest (this may take a while).",
  "GRID.TITLEBAR.DOWNLOAD_CSV": "Download CSV",
  "GRID.TITLEBAR.GENERATE_CSV": "Generate CSV",
  "GRID.TITLEBAR.GROUP_COUNT_PLURAL": "%d groups",
  "GRID.TITLEBAR.GROUP_COUNT_SINGULAR": "%d group",
  "GRID.TITLEBAR.LOADED": "Loaded",
  "GRID.TITLEBAR.LOADING": "Loading...",
  "GRID.TITLEBAR.NOT_LOADED": "Not Loaded",
  "GRID.TITLEBAR.RECORD_COUNT_PLURAL": "%d records",
  "GRID.TITLEBAR.RECORD_COUNT_SINGULAR": "%d record",
  "GRID.TITLEBAR.REFRESH": "Refresh",
  "GRID.TITLEBAR.SELECTED_COUNT_PLURAL": "%d records selected",
  "GRID.TITLEBAR.SELECTED_COUNT_SINGULAR": "%d record selected",
  "GRID.TITLEBAR.SHOW_DEBUG_INFO": "Show Grid Debug Info",
  "GRID.TITLEBAR.SHOW_HIDE": "Show/Hide Grid",
  "GRID.TITLEBAR.SHOW_HIDE_CONTROLS": "Show/Hide Grid Controls",
  "GRID.TITLEBAR.WORKING": "Working...",
  "GRID_CONTROL.AGGREGATE.EDIT_OPTIONS": "Edit options",
  "GRID_CONTROL.AGGREGATE.OPTIONS_DIALOG.TITLE": "Options for %s",
  "GRID_CONTROL.AGGREGATE.TITLE": "Aggregate",
  "GRID_CONTROL.FIELD": "Field",
  "GRID_CONTROL.FIELD.REMOVE": "Remove",
  "GRID_CONTROL.FIELD.SHOW_FUNCTIONS": "Show functions available for this field",
  "GRID_CONTROL.FILTER.TITLE": "Filters",
  "GRID_CONTROL.GROUP.TITLE": "Group Fields",
  "GRID_CONTROL.OPERATIONS.TITLE": "Operations",
  "GRID_CONTROL.PIVOT.TITLE": "Pivot Fields",
  "GRID_CONTROL.SELECT_AGGREGATE": "Select Aggregate",
  "GRID_CONTROL.SELECT_FIELD": "Select Field",
  "GRID_TOOLBAR.GROUP.MODE.DETAIL": "Detail",
  "GRID_TOOLBAR.GROUP.MODE.SUMMARY": "Summary",
  "GRID_TOOLBAR.GROUP.PIN_GROUPS": "Pin Groups",
  "GRID_TOOLBAR.GROUP.TOTAL_ROW": "Total Row",
  "GRID_TOOLBAR.MIRAGE.STORE_DISPLAYED_DATA": "Store Displayed Data",
  "GRID_TOOLBAR.PIVOT.HIDE_ZERO_VALUES": "Hide Zero Values",
  "GRID_TOOLBAR.PIVOT.TOTAL_ROW_COLUMN": "Total Row/Column",
  "GRID_TOOLBAR.PLAIN.COLUMNS": "Columns",
  "GRID_TOOLBAR.PLAIN.SHOW_ALL_ROWS": "Show All Rows",
  "GRID_TOOLBAR.PLAIN.SHOW_MORE_ON_SCROLL": "Show More on Scroll",
  "GRID_TOOLBAR.PLAIN.TEMPLATES_EDITOR": "Templates Editor",
  "GRID_TOOLBAR.PREFS.BACK.TOOLTIP": "Back",
  "GRID_TOOLBAR.PREFS.BACKEND_DOES_NOT_SAVE": "The preferences system is not configured to permanently save perspectives.",
  "GRID_TOOLBAR.PREFS.DELETE.TOOLTIP": "Delete",
  "GRID_TOOLBAR.PREFS.DELETE_PERSPECTIVE.CONFIRM": "Are you sure you want to delete this perspective?",
  "GRID_TOOLBAR.PREFS.FORWARD.TOOLTIP": "Forward",
  "GRID_TOOLBAR.PREFS.INFO.TOOLTIP": "Info",
  "GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE": "New Perspective...",
  "GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE.PROMPT": "Enter new perspective name",
  "GRID_TOOLBAR.PREFS.RENAME.TOOLTIP": "Rename",
  "GRID_TOOLBAR.PREFS.RENAME_PERSPECTIVE.PROMPT": 'Rename perspective "%s" to what?',
  "GRID_TOOLBAR.PREFS.RESET.CONFIRM": "Are you sure you want to reset all configuration, delete all perspectives, and start over?",
  "GRID_TOOLBAR.PREFS.RESET.TOOLTIP": "Reset",
  "GRID_TOOLBAR.PREFS.SAVE.HELP": "Click to save the current configuration.  The next time this grid is visited, the previously saved configuration will automatically be used.",
  "GRID_TOOLBAR.PREFS.SAVE.TOOLTIP": "Save",
  "GRID_TOOLBAR.PREFS.SAVE_AS.HELP": "This pre-defined perspective cannot be saved with this name.  Click to save with a new name.  After that, any changes will be saved under the new name.",
  "GRID_TOOLBAR.PREFS.SAVE_AS.TOOLTIP": "Save As...",
  "GRID_TOOLBAR.RENDERER.DISPLAY_OPTIONS": "Display Options"
};

// node_modules/wcdatavis/src/lang/es-MX.js
var es_MX_default = {
  "AGGREGATE.FIELD.DENOMINATOR": "Denominacin",
  "AGGREGATE.FIELD.NUMERATOR": "Nmero",
  "AGGREGATE.NAME.AVERAGE": "Promedio",
  "AGGREGATE.NAME.COUNT": "Contar",
  "AGGREGATE.NAME.COUNT_DISTINCT": "Cuenta distinta",
  "AGGREGATE.NAME.COUNT_OVER_COUNT": "Recuento/recuento",
  "AGGREGATE.NAME.DISTINCT_VALUES": "Valores distintos",
  "AGGREGATE.NAME.FIRST": "Primero",
  "AGGREGATE.NAME.LAST": "ltimo",
  "AGGREGATE.NAME.MAX": "Mximo",
  "AGGREGATE.NAME.MIN": "Mnimo",
  "AGGREGATE.NAME.NTH": "Ensimo",
  "AGGREGATE.NAME.SUM": "Suma",
  "AGGREGATE.NAME.SUM_OVER_SUM": "Suma/suma",
  "AGGREGATE.NAME.VALUES": "Valores",
  "AGGREGATE.NAME.VALUES_WITH_COUNTS": "Valores con recuentos",
  "DIALOG.CANCEL": "Cancelar",
  "DIALOG.OK": "OK",
  "GRAPH.TITLEBAR.SHOW_HIDE": "Mostrar/ocultar grfico",
  "GRAPH.TITLEBAR.SHOW_HIDE_CONTROLS": "Mostrar/ocultar controles de grfico",
  "GRID.COLCONFIG_WIN.ALLOW_HTML": "Permitir que se represente HTML?",
  "GRID.COLCONFIG_WIN.HIDE_COL": "Ocultar columna?",
  "GRID.COLCONFIG_WIN.MOVE_COL_TO_BOTTOM": "Mover al final de la lista de columnas",
  "GRID.COLCONFIG_WIN.MOVE_COL_TO_TOP": "Mover al principio de la lista de columnas",
  "GRID.COLCONFIG_WIN.PINNED_COL_WARNING": "Las columnas ancladas siempre aparecen antes que cualesquier otras en la salida simple (no agrupada), en el orden relativo que se muestra arriba.",
  "GRID.COLCONFIG_WIN.PIN_COL": "Anclar la columna al lado izquierdo de la tabla?",
  "GRID.COLCONFIG_WIN.RENAME_COL": "Cambiar el nombre de la columna en la tabla.",
  "GRID.COLCONFIG_WIN.RENAME_COL.PROMPT": 'Cambiar el nombre del campo "%s" a qu?',
  "GRID.COLCONFIG_WIN.REORDER_COLS": "Haga clic y arrastre para reordenar las columnas",
  "GRID.COLCONFIG_WIN.RESET_COL_ORDER": "Restablecer el orden de las columnas",
  "GRID.COLCONFIG_WIN.TBL.DISPLAY": "Mostrar",
  "GRID.COLCONFIG_WIN.TBL.FIELD": "Campo",
  "GRID.COLCONFIG_WIN.TBL.OPTIONS": "Opciones",
  "GRID.COLCONFIG_WIN.TITLE": "Columnas",
  "GRID.GROUP_FUN.DATE.FULL_DATE": "Fecha completa (sin hora)",
  "GRID.GROUP_FUN.DATE.YEAR": "Ao",
  "GRID.GROUP_FUN.DATE.YEAR_AND_MONTH": "Ao y mes",
  "GRID.GROUP_FUN.DATE.YEAR_AND_QUARTER": "Ao y trimestre",
  "GRID.GROUP_FUN.DATE.YEAR_AND_WEEK": "Ao y semana (ISO)",
  "GRID.GROUP_FUN.DATE_TIME.SLICE.15MIN": "Fecha y hora:perodos de 15 minutos",
  "GRID.GROUP_FUN.DATE_TIME.SLICE.1HR": "Fecha y hora: perodos de 1 hora",
  "GRID.GROUP_FUN.DIALOG.DATE": "Fecha",
  "GRID.GROUP_FUN.DIALOG.DATE_TIME": "Fecha y hora",
  "GRID.GROUP_FUN.DIALOG.OTHER": "Otro",
  "GRID.GROUP_FUN.DIALOG.REPEATING": "Repitiendo",
  "GRID.GROUP_FUN.DIALOG.TIME": "Tiempo",
  "GRID.GROUP_FUN.DIALOG.TITLE": "Aplicar funcin a %s",
  "GRID.GROUP_FUN.NONE": "Ninguno",
  "GRID.GROUP_FUN.REPEATING.DAY_OF_WEEK": "Da de la semana",
  "GRID.GROUP_FUN.REPEATING.MONTH": "Mes",
  "GRID.GROUP_FUN.REPEATING.QUARTER": "Trimestre",
  "GRID.GROUP_FUN.REPEATING.WEEK": "Semana (ISO)",
  "GRID.GROUP_FUN.TIME.SLICE.15MIN": "Tiempo: perodos de 15 minutos",
  "GRID.GROUP_FUN.TIME.SLICE.1HR": "Tiempo: perodos de 1 hora",
  "GRID.PERSPECTIVE_WIN.TEMP_PERSPECTIVE_WARNING": "Esta perspectiva es temporal; la configuracin que aparece a continuacin no refleja el estado actual de cualquier mdulo de preferencias vinculado.",
  "GRID.PERSPECTIVE_WIN.TITLE": "Perspectiva",
  "GRID.TABLE.ADD_FILTER_HELP": 'Haga clic para agregar un filtro para "%s"',
  "GRID.TABLE.DRAGGABLE_FIELD_HELP": "Puede arrastrar y soltar este campo en los controles de cuadrcula de arriba para filtrar, agrupar o girar.",
  "GRID.TABLE.SORT_MENU.ASCENDING": "%s, ascendente",
  "GRID.TABLE.SORT_MENU.DESCENDING": "%s, descendente",
  "GRID.TABLE.SORT_MENU.RESET_SORT": "Restablecer clasificacin",
  "GRID.TITLEBAR.CANCEL": "Cancelar",
  "GRID.TITLEBAR.DATA_LIMITED_WARNING": "Usted no tiene visibilidad de todos los registros. Haga clic para obtener el resto (esto puede tomar un tiempo).",
  "GRID.TITLEBAR.DOWNLOAD_CSV": "Descargar CSV",
  "GRID.TITLEBAR.GENERATE_CSV": "Generar CSV",
  "GRID.TITLEBAR.GROUP_COUNT_PLURAL": "Grupos %d",
  "GRID.TITLEBAR.GROUP_COUNT_SINGULAR": "Grupo %d",
  "GRID.TITLEBAR.LOADED": "Cargado",
  "GRID.TITLEBAR.LOADING": "Cargando...",
  "GRID.TITLEBAR.NOT_LOADED": "No cargado",
  "GRID.TITLEBAR.RECORD_COUNT_PLURAL": "Registros %d",
  "GRID.TITLEBAR.RECORD_COUNT_SINGULAR": "Registro %d",
  "GRID.TITLEBAR.REFRESH": "Actualizar",
  "GRID.TITLEBAR.SELECTED_COUNT_PLURAL": "Registros seleccionados %d",
  "GRID.TITLEBAR.SELECTED_COUNT_SINGULAR": "Registro seleccionado %d",
  "GRID.TITLEBAR.SHOW_DEBUG_INFO": "Mostrar informacin de depuracin de cuadrcula",
  "GRID.TITLEBAR.SHOW_HIDE": "Mostrar/ocultar cuadrcula",
  "GRID.TITLEBAR.SHOW_HIDE_CONTROLS": "Mostrar/ocultar controles de cuadrcula",
  "GRID.TITLEBAR.WORKING": "En proceso...",
  "GRID_CONTROL.AGGREGATE.EDIT_OPTIONS": "Editar opciones",
  "GRID_CONTROL.AGGREGATE.OPTIONS_DIALOG.TITLE": "Opciones para %s",
  "GRID_CONTROL.AGGREGATE.TITLE": "Agregar",
  "GRID_CONTROL.FIELD": "Campo",
  "GRID_CONTROL.FIELD.REMOVE": "Eliminar",
  "GRID_CONTROL.FIELD.SHOW_FUNCTIONS": "Mostrar las funciones disponibles para este campo",
  "GRID_CONTROL.FILTER.TITLE": "Filtros",
  "GRID_CONTROL.GROUP.TITLE": "Campos de grupo",
  "GRID_CONTROL.PIVOT.TITLE": "Campos dinmicos",
  "GRID_CONTROL.SELECT_AGGREGATE": "Seleccionar agregado",
  "GRID_CONTROL.SELECT_FIELD": "Seleccionar campo",
  "GRID_TOOLBAR.GROUP.MODE.DETAIL": "Detalle",
  "GRID_TOOLBAR.GROUP.MODE.SUMMARY": "Resumen",
  "GRID_TOOLBAR.GROUP.PIN_GROUPS": "Grupos de pin",
  "GRID_TOOLBAR.GROUP.TOTAL_ROW": "Fila total",
  "GRID_TOOLBAR.MIRAGE.STORE_DISPLAYED_DATA": "Almacenar los datos mostrados",
  "GRID_TOOLBAR.PIVOT.HIDE_ZERO_VALUES": "Ocultar valores cero",
  "GRID_TOOLBAR.PIVOT.TOTAL_ROW_COLUMN": "Fila/columna total",
  "GRID_TOOLBAR.PLAIN.COLUMNS": "Columnas",
  "GRID_TOOLBAR.PLAIN.SHOW_ALL_ROWS": "Mostrar todas las filas",
  "GRID_TOOLBAR.PLAIN.SHOW_MORE_ON_SCROLL": "Mostrar ms en desplazamiento",
  "GRID_TOOLBAR.PREFS.BACK.TOOLTIP": "Atrs",
  "GRID_TOOLBAR.PREFS.BACKEND_DOES_NOT_SAVE": "El sistema de preferencias no est configurado para guardar perspectivas permanentemente.",
  "GRID_TOOLBAR.PREFS.DELETE.TOOLTIP": "Eliminar",
  "GRID_TOOLBAR.PREFS.DELETE_PERSPECTIVE.CONFIRM": "Est seguro de que desea eliminar esta perspectiva?",
  "GRID_TOOLBAR.PREFS.FORWARD.TOOLTIP": "Adelante",
  "GRID_TOOLBAR.PREFS.INFO.TOOLTIP": "Informacin",
  "GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE": "Nueva perspectiva...",
  "GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE.PROMPT": "Ingrese el nombre de la nueva perspectiva",
  "GRID_TOOLBAR.PREFS.RENAME.TOOLTIP": "Renombrar",
  "GRID_TOOLBAR.PREFS.RENAME_PERSPECTIVE.PROMPT": 'Cambiar el nombre de la perspectiva "%s" a qu?',
  "GRID_TOOLBAR.PREFS.RESET.CONFIRM": "Est seguro de que desea restablecer toda la configuracin, eliminar todas las perspectivas y volver a empezar?",
  "GRID_TOOLBAR.PREFS.RESET.TOOLTIP": "Restablecer",
  "GRID_TOOLBAR.PREFS.SAVE.HELP": "Haga clic para guardar la configuracin actual.  La prxima vez que se visite esta cuadrcula, se utilizar de manera automtica la configuracin guardada previamente.",
  "GRID_TOOLBAR.PREFS.SAVE.TOOLTIP": "Guardar",
  "GRID_TOOLBAR.PREFS.SAVE_AS.HELP": "Esta perspectiva predefinida no se puede guardar con este nombre.  Haga clic para guardar con un nuevo nombre.  Despus de eso, cualquier cambio se guardar con el nuevo nombre.",
  "GRID_TOOLBAR.PREFS.SAVE_AS.TOOLTIP": "Guardar como...",
  "GRID_TOOLBAR.RENDERER.DISPLAY_OPTIONS": "Opciones de visualizacin"
};

// node_modules/wcdatavis/src/lang/pt-BR.js
var pt_BR_default = {
  "AGGREGATE.FIELD.DENOMINATOR": "Denom.",
  "AGGREGATE.FIELD.NUMERATOR": "Num.",
  "AGGREGATE.NAME.AVERAGE": "Mdia",
  "AGGREGATE.NAME.COUNT": "Contar",
  "AGGREGATE.NAME.COUNT_DISTINCT": "Contar distintos",
  "AGGREGATE.NAME.COUNT_OVER_COUNT": "Contagem/Contagem",
  "AGGREGATE.NAME.DISTINCT_VALUES": "Valores distintos",
  "AGGREGATE.NAME.FIRST": "Primeiro",
  "AGGREGATE.NAME.LAST": "ltimo",
  "AGGREGATE.NAME.MAX": "Mx.",
  "AGGREGATE.NAME.MIN": "Min.",
  "AGGREGATE.NAME.NTH": "Ensimo",
  "AGGREGATE.NAME.SUM": "Soma",
  "AGGREGATE.NAME.SUM_OVER_SUM": "Soma/Soma",
  "AGGREGATE.NAME.VALUES": "Valores",
  "AGGREGATE.NAME.VALUES_WITH_COUNTS": "Valores com contagem",
  "DIALOG.CANCEL": "Cancelar",
  "GRAPH.TITLEBAR.SHOW_HIDE": "Exibir/Ocultar grfico",
  "GRAPH.TITLEBAR.SHOW_HIDE_CONTROLS": "Exibir/Ocultar controles grficos",
  "GRID.COLCONFIG_WIN.ALLOW_HTML": "Permitir que o HTML seja renderizado?",
  "GRID.COLCONFIG_WIN.HIDE_COL": "Ocultar coluna?",
  "GRID.COLCONFIG_WIN.MOVE_COL_TO_BOTTOM": "Mover para a parte inferior da lista de colunas",
  "GRID.COLCONFIG_WIN.MOVE_COL_TO_TOP": "Mover para o topo da lista de colunas",
  "GRID.COLCONFIG_WIN.PINNED_COL_WARNING": "As colunas fixadas sempre aparecem antes de qualquer outra na sada simples (no agrupada), na ordem relativa exibida acima.",
  "GRID.COLCONFIG_WIN.PIN_COL": "Fixar a coluna no lado esquerdo da tabela?",
  "GRID.COLCONFIG_WIN.RENAME_COL": "Renomear a coluna na tabela.",
  "GRID.COLCONFIG_WIN.RENAME_COL.PROMPT": 'Renomear o campo "%s" como?',
  "GRID.COLCONFIG_WIN.REORDER_COLS": "Clique e arraste para reordenar as colunas",
  "GRID.COLCONFIG_WIN.RESET_COL_ORDER": "Redefinir ordem das colunas",
  "GRID.COLCONFIG_WIN.TBL.DISPLAY": "Exibio",
  "GRID.COLCONFIG_WIN.TBL.FIELD": "Campo",
  "GRID.COLCONFIG_WIN.TBL.OPTIONS": "Opes",
  "GRID.COLCONFIG_WIN.TITLE": "Colunas",
  "GRID.GROUP_FUN.DATE.FULL_DATE": "Data completa (sem hora)",
  "GRID.GROUP_FUN.DATE.YEAR": "Ano",
  "GRID.GROUP_FUN.DATE.YEAR_AND_MONTH": "Ano e ms",
  "GRID.GROUP_FUN.DATE.YEAR_AND_QUARTER": "Ano e trimestre",
  "GRID.GROUP_FUN.DATE.YEAR_AND_WEEK": "Ano e semana (ISO)",
  "GRID.GROUP_FUN.DATE_TIME.SLICE.15MIN": "Data e hora: intervalos de 15 min",
  "GRID.GROUP_FUN.DATE_TIME.SLICE.1HR": "Data e hora: intervalos de 1 hora",
  "GRID.GROUP_FUN.DIALOG.DATE": "Data",
  "GRID.GROUP_FUN.DIALOG.DATE_TIME": "Data e hora",
  "GRID.GROUP_FUN.DIALOG.OTHER": "Outros",
  "GRID.GROUP_FUN.DIALOG.REPEATING": "Repetindo",
  "GRID.GROUP_FUN.DIALOG.TIME": "Hora",
  "GRID.GROUP_FUN.DIALOG.TITLE": "Aplicar funo a %s",
  "GRID.GROUP_FUN.NONE": "Nenhum",
  "GRID.GROUP_FUN.REPEATING.DAY_OF_WEEK": "Dia da semana",
  "GRID.GROUP_FUN.REPEATING.MONTH": "Ms",
  "GRID.GROUP_FUN.REPEATING.QUARTER": "Trimestre",
  "GRID.GROUP_FUN.REPEATING.WEEK": "Semana (ISO)",
  "GRID.GROUP_FUN.TIME.SLICE.15MIN": "Hora: intervalos de 15 min",
  "GRID.GROUP_FUN.TIME.SLICE.1HR": "Hora: intervalos de 1 hora",
  "GRID.PERSPECTIVE_WIN.TEMP_PERSPECTIVE_WARNING": "Essa perspectiva  temporria; a configurao abaixo no reflete o estado atual de nenhum mdulo preferencial vinculado.",
  "GRID.PERSPECTIVE_WIN.TITLE": "Perspectiva",
  "GRID.TABLE.ADD_FILTER_HELP": 'Clicar para adicionar um filtro para "%s"',
  "GRID.TABLE.DRAGGABLE_FIELD_HELP": "Voc pode arrastar e soltar este campo nos controles de grade acima para filtrar, agrupar ou pivotar.",
  "GRID.TABLE.SORT_MENU.ASCENDING": "%s, Ascendente",
  "GRID.TABLE.SORT_MENU.DESCENDING": "%s, Descendente",
  "GRID.TABLE.SORT_MENU.RESET_SORT": "Redefinir classificao",
  "GRID.TITLEBAR.CANCEL": "Cancelar",
  "GRID.TITLEBAR.DATA_LIMITED_WARNING": "Voc no est visualizando todos os registros. Clique para recuperar os restantes (isso pode demorar um pouco).",
  "GRID.TITLEBAR.DOWNLOAD_CSV": "Baixar .csv",
  "GRID.TITLEBAR.GENERATE_CSV": "Gerar .csv",
  "GRID.TITLEBAR.GROUP_COUNT_PLURAL": "%d grupos",
  "GRID.TITLEBAR.GROUP_COUNT_SINGULAR": "%d grupo",
  "GRID.TITLEBAR.LOADED": "Carregado",
  "GRID.TITLEBAR.LOADING": "Carregando...",
  "GRID.TITLEBAR.NOT_LOADED": "No carregado",
  "GRID.TITLEBAR.RECORD_COUNT_PLURAL": "%d registros",
  "GRID.TITLEBAR.RECORD_COUNT_SINGULAR": "%d registro",
  "GRID.TITLEBAR.REFRESH": "Atualizar",
  "GRID.TITLEBAR.SELECTED_COUNT_PLURAL": "%d registros selecionados",
  "GRID.TITLEBAR.SELECTED_COUNT_SINGULAR": "%d registro selecionado",
  "GRID.TITLEBAR.SHOW_DEBUG_INFO": "Exibir informaes de depurao da grade",
  "GRID.TITLEBAR.SHOW_HIDE": "Exibir/Ocultar grade",
  "GRID.TITLEBAR.SHOW_HIDE_CONTROLS": "Exibir/Ocultar controles da grade",
  "GRID.TITLEBAR.WORKING": "Trabalhando...",
  "GRID_CONTROL.AGGREGATE.EDIT_OPTIONS": "Editar opes",
  "GRID_CONTROL.AGGREGATE.OPTIONS_DIALOG.TITLE": "Opes para %s",
  "GRID_CONTROL.AGGREGATE.TITLE": "Agregar",
  "GRID_CONTROL.FIELD": "Campo",
  "GRID_CONTROL.FIELD.REMOVE": "Remover",
  "GRID_CONTROL.FIELD.SHOW_FUNCTIONS": "Exibir as funes disponveis para este campo",
  "GRID_CONTROL.FILTER.TITLE": "Filtros",
  "GRID_CONTROL.GROUP.TITLE": "Campos de grupo",
  "GRID_CONTROL.PIVOT.TITLE": "Pivotar campos",
  "GRID_CONTROL.SELECT_AGGREGATE": "Selecionar agregar",
  "GRID_CONTROL.SELECT_FIELD": "Selecionar campo",
  "GRID_TOOLBAR.GROUP.MODE.DETAIL": "Detalhe",
  "GRID_TOOLBAR.GROUP.MODE.SUMMARY": "Resumo",
  "GRID_TOOLBAR.GROUP.PIN_GROUPS": "Fixar grupos",
  "GRID_TOOLBAR.GROUP.TOTAL_ROW": "Total de linhas",
  "GRID_TOOLBAR.MIRAGE.STORE_DISPLAYED_DATA": "Armazenar dados exibidos",
  "GRID_TOOLBAR.PIVOT.HIDE_ZERO_VALUES": "Ocultar valores zero",
  "GRID_TOOLBAR.PIVOT.TOTAL_ROW_COLUMN": "Total de linhas/colunas",
  "GRID_TOOLBAR.PLAIN.COLUMNS": "Colunas",
  "GRID_TOOLBAR.PLAIN.SHOW_ALL_ROWS": "Exibir todas as linhas",
  "GRID_TOOLBAR.PLAIN.SHOW_MORE_ON_SCROLL": "Exibir mais na rolagem",
  "GRID_TOOLBAR.PREFS.BACK.TOOLTIP": "Voltar",
  "GRID_TOOLBAR.PREFS.BACKEND_DOES_NOT_SAVE": "O sistema de preferncias no est configurado para salvar perspectivas permanentemente.",
  "GRID_TOOLBAR.PREFS.DELETE.TOOLTIP": "Excluir",
  "GRID_TOOLBAR.PREFS.DELETE_PERSPECTIVE.CONFIRM": "Tem certeza de que deseja excluir esta perspectiva?",
  "GRID_TOOLBAR.PREFS.FORWARD.TOOLTIP": "Avanar",
  "GRID_TOOLBAR.PREFS.INFO.TOOLTIP": "Informaes",
  "GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE": "Nova perspectiva...",
  "GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE.PROMPT": "Inserir o novo nome da perspectiva",
  "GRID_TOOLBAR.PREFS.RENAME.TOOLTIP": "Renomear",
  "GRID_TOOLBAR.PREFS.RENAME_PERSPECTIVE.PROMPT": 'Como renomear a perspectiva "%s"?',
  "GRID_TOOLBAR.PREFS.RESET.CONFIRM": "Tem certeza de que deseja redefinir todas as configuraes, excluir todas as perspectivas e comear novamente?",
  "GRID_TOOLBAR.PREFS.RESET.TOOLTIP": "Reiniciar",
  "GRID_TOOLBAR.PREFS.SAVE.HELP": "Clique para salvar a configurao atual. Na prxima vez que essa grade for acessada, a ltima configurao salva ser usada automaticamente.",
  "GRID_TOOLBAR.PREFS.SAVE.TOOLTIP": "Salvar",
  "GRID_TOOLBAR.PREFS.SAVE_AS.HELP": "Esta perspectiva predefinida no pode ser salva com este nome. Clique para salvar com um novo nome. Depois disso, todas as alteraes sero salvas com o novo nome.",
  "GRID_TOOLBAR.PREFS.SAVE_AS.TOOLTIP": "Salvar como...",
  "GRID_TOOLBAR.RENDERER.DISPLAY_OPTIONS": "Exibir opes"
};

// node_modules/wcdatavis/src/trans.js
var TRANSLATION_REGISTRY = new ordmap_default();
TRANSLATION_REGISTRY.set("EN", en_US_default);
TRANSLATION_REGISTRY.set("EN-US", en_US_default);
TRANSLATION_REGISTRY.set("ES", es_MX_default);
TRANSLATION_REGISTRY.set("ES-MX", es_MX_default);
TRANSLATION_REGISTRY.set("PT", pt_BR_default);
TRANSLATION_REGISTRY.set("PT-BR", pt_BR_default);
var trans = /* @__PURE__ */ function() {
  var alreadyWarnedAboutLang = {};
  return function() {
    var args = Array.prototype.slice.call(arguments);
    var k = args.shift(), lang2 = window.DATAVIS_LANG;
    if (lang2 == null) {
      if (TRANSLATION_REGISTRY.isSet(navigator.language.toUpperCase())) {
        lang2 = navigator.language;
      } else {
        lang2 = navigator.language.split("-")[0];
      }
    }
    if (!TRANSLATION_REGISTRY.isSet(lang2.toUpperCase())) {
      if (!alreadyWarnedAboutLang[lang2]) {
        console.error('Missing DataVis translation info for language "' + lang2 + '"');
        alreadyWarnedAboutLang[lang2] = true;
      }
    } else if (TRANSLATION_REGISTRY.get(lang2.toUpperCase())[k] == null) {
      console.error('Missing DataVis translation for key "' + k + '" in locale "' + lang2 + '"');
    }
    var s2 = (TRANSLATION_REGISTRY.get(lang2.toUpperCase()) || {})[k] || (TRANSLATION_REGISTRY.get("EN") || {})[k] || k;
    if (args.length > 0) {
      args.unshift(s2);
      s2 = import_sprintf_js3.sprintf.apply(null, args);
    }
    if (lang2 === "xx") {
      s2 = s2.replace(/[A-Za-z]/g, "x");
    }
    return s2;
  };
}();

// node_modules/wcdatavis/src/aggregates.js
var Aggregate = makeSubclass("Aggregate", Object, function(opts) {
  var self2 = this;
  self2.opts = deepDefaults(opts, {
    isHidden: false
  });
}, {
  enabled: true,
  fieldCount: 0,
  fieldInfo: [],
  inheritFormatting: false,
  numItems: 0
});
Aggregate.prototype.calculate = function(data) {
  var self2 = this;
  var i2, i0, len, acc;
  if (!self2.checkOpts() || !self2.checkData(data)) {
    return self2.bottomValue;
  }
  self2.numItems = 0;
  len = data.length;
  acc = typeof self2.init === "function" ? self2.init() : self2.init != null ? self2.init : self2.bottomValue;
  i0 = 0;
  if (len === 0) {
    if (typeof self2.calculateDone === "function") {
      return self2.calculateDone(acc);
    }
    return acc;
  }
  if (acc == null) {
    acc = data[0].rowData;
    if (self2.opts.fields && self2.opts.fields.length > 0) {
      acc = self2.getRealValue(acc[self2.opts.fields[0]]);
    }
    i0 = 1;
  }
  for (i2 = i0; i2 < len; i2 += 1) {
    try {
      acc = self2.calculateStep(acc, data[i2].rowData, data, i2);
    } catch (e2) {
      log.error("Aggregate " + self2.name + ": Error occurred at data index [" + i2 + "]: " + e2.toString());
      return self2.bottomValue;
    }
  }
  return self2.calculateDone != null ? self2.calculateDone(acc) : acc;
};
Aggregate.prototype.checkOpts = function() {
  var self2 = this;
  if (self2.fieldCount > 0) {
    if (self2.opts.fields == null) {
      log.error("Aggregate " + self2.name + ": Missing `opts.fields`");
      return false;
    } else if (!index_default_default.isArray(self2.opts.fields)) {
      log.error("Aggregate " + self2.name + ": `opts.fields` must be an array");
      return false;
    } else if (self2.opts.fields.length !== self2.fieldCount) {
      log.error("Aggregate " + self2.name + ": `opts.fields` must include " + self2.fieldCount + " elements");
      return false;
    }
    if (self2.opts.typeInfo == null) {
      log.error("Aggregate " + self2.name + ": Missing `opts.typeInfo`");
      return false;
    } else if (!index_default_default.isArray(self2.opts.typeInfo)) {
      log.error("Aggregate " + self2.name + ": `opts.typeInfo` must be an array");
      return false;
    } else if (self2.opts.typeInfo.length !== self2.fieldCount) {
      log.error("Aggregate " + self2.name + ": `opts.typeInfo` must include " + self2.fieldCount + " elements");
      return false;
    }
  }
  return true;
};
Aggregate.prototype.checkData = function(data) {
  var self2 = this;
  if (!index_default_default.isArray(data)) {
    log.error("Aggregate " + self2.name + ": `data` must be an array");
    return false;
  }
  return true;
};
Aggregate.prototype.getRealValue = function(cell) {
  if (index_default_default.isString(cell)) {
    return cell;
  } else if (index_default_default.isNumber(cell)) {
    return cell;
  } else if (index_default_default.isObject(cell)) {
    if (cell.value !== void 0) {
      return cell.value;
    } else if (cell.orig !== void 0) {
      return cell.orig;
    } else {
      throw new Error("Unable to get real value of cell");
    }
  }
};
Aggregate.prototype.getFormattedValue = function(cell) {
  var self2 = this;
  var val = self2.getRealValue(cell);
  var colConfig = self2.opts.colConfig ? self2.opts.colConfig[0] : null;
  var typeInfo = self2.opts.typeInfo ? self2.opts.typeInfo[0] : null;
  return format2(colConfig, typeInfo, cell);
};
Aggregate.prototype.getNumber = function(x) {
  if (window.numeral && window.numeral.isNumeral(x)) {
    return x.value();
  } else if (index_default_default.isString(x)) {
    if (isInt(x)) {
      return toInt2(x);
    } else if (isFloat(x)) {
      return toFloat(x);
    } else {
      return 0;
    }
  } else if (index_default_default.isNumber(x)) {
    return x;
  } else {
    return 0;
  }
};
Aggregate.prototype.getFullName = function() {
  var self2 = this;
  if (self2.opts.name != null) {
    return self2.opts.name;
  } else if (self2.fieldCount > 0 && index_default_default.isArray(self2.opts.fields) && self2.opts.fields.length > 0) {
    return trans("AGGREGATE.HEADER_DISPLAY", self2.name, index_default_default.map(self2.opts.fields, function(field, fieldIdx) {
      var fcc = getPropDef({}, self2.opts, "colConfig", fieldIdx);
      return fcc.displayText || field;
    }).join(", "));
  } else {
    return self2.name;
  }
};
Aggregate.prototype.getType = function() {
  var self2 = this;
  var t2 = self2.type;
  if (getProp(self2.opts, "fields", "length")) {
    var uniqueTypes = index_default_default.uniq(index_default_default.pluck(self2.opts.typeInfo, "type"));
    if (uniqueTypes.length === 1) {
      if (self2.allowedTypes && self2.allowedTypes.indexOf(uniqueTypes[0]) >= 0) {
        t2 = uniqueTypes[0];
      } else if (t2 == null) {
        t2 = uniqueTypes[0];
      }
    }
  }
  if (t2 == null) {
    t2 = "string";
  }
  return t2;
};
var CountAggregate = makeSubclass("CountAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.COUNT"),
  fieldCount: 0,
  type: "number",
  inheritFormatting: false,
  bottomValue: 0
});
CountAggregate.prototype.calculate = function(data) {
  var self2 = this;
  if (!self2.checkOpts() || !self2.checkData(data)) {
    return self2.bottomValue;
  }
  return data && data.length || self2.bottomValue;
};
var CountDistinctAggregate = makeSubclass("CountDistinctAggregate", Aggregate, function() {
  var self2 = this;
  self2.set = {};
  self2.super.ctor.apply(self2, arguments);
}, {
  name: trans("AGGREGATE.NAME.COUNT_DISTINCT"),
  fieldCount: 1,
  type: "number",
  inheritFormatting: false,
  bottomValue: 0,
  init: function() {
    return {
      set: {},
      count: 0
    };
  }
});
CountDistinctAggregate.prototype.calculateStep = function(acc, next) {
  var self2 = this;
  var cell = next[self2.opts.fields[0]];
  var key = getNatRep(cell.value);
  if (key != null && key != "" && acc.set[key] == null) {
    acc.set[key] = true;
    acc.count += 1;
  }
  return acc;
};
CountDistinctAggregate.prototype.calculateDone = function(acc) {
  return acc.count;
};
var ValuesAggregate = makeSubclass("ValuesAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.VALUES"),
  fieldCount: 1,
  inheritFormatting: false,
  type: "string",
  init: function() {
    return {
      resultIsElement: false,
      values: []
    };
  },
  options: {
    "separator": {
      "displayText": "Separator"
    }
  }
});
ValuesAggregate.prototype.calculateStep = function(acc, next) {
  var self2 = this;
  var formatted = self2.getFormattedValue(next[self2.opts.fields[0]]);
  if (isElement2(formatted)) {
    acc.resultIsElement = true;
  }
  acc.values.push(formatted);
  return acc;
};
ValuesAggregate.prototype.calculateDone = function(acc) {
  var self2 = this;
  if (!acc.resultIsElement) {
    return acc.values.join(self2.opts.separator || ", ");
  } else {
    var wrapper = jQuery("<div>");
    index_default_default.each(acc.values, function(elt2, i2) {
      if (i2 > 0) {
        wrapper.append(self2.opts.separator || ", ");
      }
      wrapper.append(isElement2(elt2) ? jQuery(elt2).clone() : elt2);
    });
    return wrapper;
  }
};
var ValuesWithCountsAggregate = makeSubclass("ValuesWithCountsAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.VALUES_WITH_COUNTS"),
  fieldCount: 1,
  inheritFormatting: false,
  type: "string",
  init: function() {
    return {
      map: new ordmap_default(),
      resultIsElement: false
    };
  },
  options: {
    "separator": {
      "displayText": "Separator"
    }
  }
});
ValuesWithCountsAggregate.prototype.calculateStep = function(acc, next) {
  var self2 = this;
  var cell = next[self2.opts.fields[0]];
  var key = getNatRep(cell.value);
  var formatted = self2.getFormattedValue(cell);
  if (acc.map.isSet(key)) {
    var info = acc.map.get(key);
    info.count += 1;
  } else {
    acc.map.set(key, {
      formatted,
      count: 1
    });
    if (isElement2(formatted)) {
      acc.resultIsElement = true;
    }
  }
  return acc;
};
ValuesWithCountsAggregate.prototype.calculateDone = function(acc) {
  var self2 = this;
  if (acc.resultIsElement) {
    var div = jQuery("<div>");
    acc.map.each(function(v, k, i2) {
      if (i2 > 0) {
        div.append(self2.opts.separator || ", ");
      }
      div.append(isElement2(v.formatted) ? v.formatted.clone() : v.formatted);
      div.append(" (" + v.count + ")");
    });
    return div;
  } else {
    var a2 = [];
    acc.map.each(function(v, k) {
      a2.push(k + " (" + v.count + ")");
    });
    return a2.join(self2.opts.separator || ", ");
  }
};
var DistinctValuesAggregate = makeSubclass("DistinctValuesAggregate", ValuesWithCountsAggregate, null, {
  name: trans("AGGREGATE.NAME.DISTINCT_VALUES")
});
DistinctValuesAggregate.prototype.calculateDone = function(acc) {
  var self2 = this;
  if (acc.resultIsElement) {
    var div = jQuery("<div>");
    acc.map.each(function(v, k, i2) {
      if (i2 > 0) {
        div.append(self2.opts.separator || ", ");
      }
      div.append(isElement2(v.formatted) ? v.formatted.clone() : v.formatted);
    });
    return div;
  } else {
    var a2 = [];
    acc.map.each(function(v, k) {
      a2.push(k);
    });
    return a2.join(self2.opts.separator || ", ");
  }
};
var SumAggregate = makeSubclass("SumAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.SUM"),
  fieldCount: 1,
  type: "number",
  allowedTypes: ["number", "currency"],
  inheritFormatting: true,
  bottomValue: 0,
  init: function() {
    switch (this.opts.typeInfo[0].internalType) {
      case "primitive":
        return 0;
      case "numeral":
        return (0, import_numeral3.default)(0);
      case "bignumber":
        return (0, import_bignumber3.default)(0);
    }
  }
});
SumAggregate.prototype.calculateStep = function(acc, next) {
  var self2 = this;
  var val = self2.getRealValue(next[self2.opts.fields[0]]);
  if (val == null) {
    return acc;
  }
  switch (self2.opts.typeInfo[0].internalType) {
    case "primitive":
      if (Number.isNaN(val)) {
        return acc;
      } else {
        self2.numItems += 1;
        return acc + val;
      }
    case "numeral":
      if (Number.isNaN(val) || val.value() === null) {
        return acc;
      } else {
        self2.numItems += 1;
        return acc.add(val.value());
      }
    case "bignumber":
      if (val.isNaN()) {
        return acc;
      } else {
        self2.numItems += 1;
        return acc.plus(val);
      }
  }
};
var AverageAggregate = makeSubclass("AverageAggregate", Aggregate, function(opts) {
  var self2 = this;
  self2.sumAgg = new SumAggregate(opts);
  self2.super.ctor.apply(self2, arguments);
}, {
  name: trans("AGGREGATE.NAME.AVERAGE"),
  fieldCount: 1,
  type: "number",
  allowedTypes: ["number", "currency"],
  inheritFormatting: true,
  bottomValue: 0
});
AverageAggregate.prototype.calculate = function(data) {
  var self2 = this;
  if (!self2.checkOpts() || !self2.checkData(data)) {
    return self2.bottomValue;
  }
  var num = self2.sumAgg.calculate(data);
  var denom = self2.sumAgg.numItems;
  if (num == null || denom === 0) {
    return self2.bottomVal;
  }
  switch (self2.opts.typeInfo[0].internalType) {
    case "primitive":
      if (Number.isNaN(num)) {
        return self2.bottomVal;
      } else {
        return num / denom;
      }
    case "numeral":
      if (Number.isNaN(num) || num.value() === null) {
        return self2.bottomVal;
      } else {
        return num.divide(denom);
      }
    case "bignumber":
      if (num.isNaN()) {
        return self2.bottomVal;
      } else {
        return num.div(denom);
      }
  }
};
var MinAggregate = makeSubclass("MinAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.MIN"),
  fieldCount: 1,
  inheritFormatting: true
});
MinAggregate.prototype.checkOpts = function() {
  var self2 = this;
  if (self2.opts.typeInfo == null) {
    log.error("Aggregate " + self2.name + ": Missing `opts.typeInfo`");
    return false;
  }
  if (self2.opts.compare == null) {
    self2.opts.compare = getComparisonFn.byType(self2.opts.typeInfo[0].type);
  }
  if (typeof self2.opts.compare !== "function") {
    log.error("Aggregate " + self2.name + ": Missing `opts.compare`");
    return false;
  }
  return self2.super.checkOpts();
};
MinAggregate.prototype.calculateStep = function(acc, next) {
  var self2 = this;
  var val = self2.getRealValue(next[self2.opts.fields[0]]);
  return self2.opts.compare(acc, val) < 0 ? acc : val;
};
var MaxAggregate = makeSubclass("MaxAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.MAX"),
  fieldCount: 1,
  inheritFormatting: true
});
MaxAggregate.prototype.checkOpts = function() {
  var self2 = this;
  if (self2.opts.typeInfo == null) {
    log.error("Aggregate " + self2.name + ": Missing `opts.typeInfo`");
    return false;
  }
  if (self2.opts.compare == null) {
    self2.opts.compare = getComparisonFn.byType(self2.opts.typeInfo[0].type);
  }
  if (typeof self2.opts.compare !== "function") {
    log.error("Aggregate " + self2.name + ": Missing `opts.compare`");
    return false;
  }
  return self2.super.checkOpts();
};
MaxAggregate.prototype.calculateStep = function(acc, next) {
  var self2 = this;
  var val = self2.getRealValue(next[self2.opts.fields[0]]);
  return self2.opts.compare(acc, val) < 0 ? val : acc;
};
var FirstAggregate = makeSubclass("FirstAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.FIRST"),
  fieldCount: 1,
  inheritFormatting: true
});
FirstAggregate.prototype.checkData = function(data) {
  var self2 = this;
  if (data.length === 0) {
    return false;
  }
  return self2.super.checkData(data);
};
FirstAggregate.prototype.calculate = function(data) {
  var self2 = this;
  if (!self2.checkOpts() || !self2.checkData(data)) {
    return self2.bottomValue;
  }
  return self2.getRealValue(data[0].rowData[self2.opts.fields[0]]);
};
var LastAggregate = makeSubclass("LastAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.LAST"),
  fieldCount: 1,
  inheritFormatting: true
});
LastAggregate.prototype.checkData = function(data) {
  var self2 = this;
  if (data.length === 0) {
    return false;
  }
  return self2.super.checkData(data);
};
LastAggregate.prototype.calculate = function(data) {
  var self2 = this;
  if (!self2.checkOpts() || !self2.checkData(data)) {
    return self2.bottomValue;
  }
  return self2.getRealValue(data[data.length - 1].rowData[self2.opts.fields[0]]);
};
var NthAggregate = makeSubclass("NthAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.NTH"),
  enabled: false,
  fieldCount: 1,
  inheritFormatting: true
});
NthAggregate.prototype.checkOpts = function() {
  var self2 = this;
  if (self2.opts.index == null) {
    log.error("Aggregate " + self2.name + ": Missing `opts.index`");
    return false;
  }
  if (!index_default_default.isNumber(self2.opts.index)) {
    log.error("Aggregate " + self2.name + ": `opts.index` must be a number");
    return false;
  }
  return self2.super.checkOpts();
};
NthAggregate.prototype.checkData = function(data) {
  var self2 = this;
  if (data.length === 0) {
    return false;
  }
  if (data.length <= self2.opts.index) {
    log.error("Aggregate " + self2.name + ": `data` has insufficient number of elements");
    return self2.bottomValue;
  }
  return self2.super.checkData(data);
};
NthAggregate.prototype.calculate = function(data) {
  var self2 = this;
  if (!self2.checkOpts() || !self2.checkData(data)) {
    return self2.bottomValue;
  }
  return data[data.length - 1];
};
var SumOverSumAggregate = makeSubclass("SumOverSumAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.SUM_OVER_SUM"),
  fieldCount: 2,
  fieldInfo: [{
    name: trans("AGGREGATE.FIELD.NUMERATOR")
  }, {
    name: trans("AGGREGATE.FIELD.DENOMINATOR")
  }],
  type: "string",
  inheritFormatting: false,
  bottomValue: 0,
  init: function() {
    return { a: 0, b: 0 };
  },
  options: {
    "format": {}
  }
});
SumOverSumAggregate.prototype.calculateStep = function(acc, next) {
  var self2 = this;
  acc.a += self2.getNumber(next[self2.opts.fields[0]].value);
  acc.b += self2.getNumber(next[self2.opts.fields[1]].value);
  return acc;
};
SumOverSumAggregate.prototype.calculateDone = function(obj) {
  var self2 = this;
  var result2 = (obj.a + 0) / (obj.b + 0);
  if (window.sprintf) {
    if (self2.opts.format) {
      return import_sprintf_js4.default.sprintf(self2.opts.format, result2);
    }
    if (result2 >= 100) {
      return import_sprintf_js4.default.sprintf("%d", result2);
    } else if (result2 >= 10) {
      return import_sprintf_js4.default.sprintf("%3.1f", result2);
    } else if (result2 >= 1) {
      return import_sprintf_js4.default.sprintf("%3.2f", result2);
    } else {
      return import_sprintf_js4.default.sprintf("%3.3f", result2);
    }
  }
  return result2;
};
SumOverSumAggregate.prototype.getFullName = function() {
  var self2 = this;
  return "Sum(" + getPropDef(self2.opts.fields[0], self2.opts, "colConfig", 0, "displayText") + ") / Sum(" + getPropDef(self2.opts.fields[1], self2.opts, "colConfig", 1, "displayText") + ")";
};
var CountOverCountAggregate = makeSubclass("CountOverCountAggregate", Aggregate, null, {
  name: trans("AGGREGATE.NAME.COUNT_OVER_COUNT"),
  fieldCount: 2,
  fieldInfo: [{
    name: trans("AGGREGATE.FIELD.NUMERATOR")
  }, {
    name: trans("AGGREGATE.FIELD.DENOMINATOR")
  }],
  type: "number",
  inheritFormatting: false,
  bottomValue: 0
});
var AGGREGATE_REGISTRY = new ordmap_default();
AGGREGATE_REGISTRY.set("count", CountAggregate);
AGGREGATE_REGISTRY.set("countDistinct", CountDistinctAggregate);
AGGREGATE_REGISTRY.set("values", ValuesAggregate);
AGGREGATE_REGISTRY.set("valuesWithCounts", ValuesWithCountsAggregate);
AGGREGATE_REGISTRY.set("distinctValues", DistinctValuesAggregate);
AGGREGATE_REGISTRY.set("sum", SumAggregate);
AGGREGATE_REGISTRY.set("average", AverageAggregate);
AGGREGATE_REGISTRY.set("min", MinAggregate);
AGGREGATE_REGISTRY.set("max", MaxAggregate);
AGGREGATE_REGISTRY.set("first", FirstAggregate);
AGGREGATE_REGISTRY.set("last", LastAggregate);
AGGREGATE_REGISTRY.set("nth", NthAggregate);
AGGREGATE_REGISTRY.set("sumOverSum", SumOverSumAggregate);
var AggregateInfo = makeSubclass("AggregateInfo", Object, function(aggType, spec, aggNum, colConfig, typeInfo, decode2) {
  var self2 = this;
  self2.aggNum = aggNum;
  self2.aggType = aggType;
  self2.fun = spec.fun;
  self2.name = spec.name;
  self2.isHidden = spec.isHidden;
  self2.fields = [];
  self2.colConfig = [];
  self2.typeInfo = [];
  self2.debug = spec.debug;
  if (typeof aggType !== "string") {
    throw new Error("Call Error: `aggType` must be a string");
  }
  if (!index_default_default.isObject(spec)) {
    throw new Error("Call Error: `spec` must be an object");
  }
  if (typeof spec.fun !== "string") {
    throw new Error("Call Error: `spec.fun` must be a string");
  }
  if (spec.fields != null && !index_default_default.isArray(spec.fields)) {
    throw new Error("Call Error: `spec.fields` must be null or an array");
  }
  if (aggNum != null && typeof aggNum !== "number") {
    throw new Error("Call Error: `aggNum` must be null or a number");
  }
  if (colConfig != null && !(colConfig instanceof ordmap_default)) {
    throw new Error("Call Error: `colConfig` must be null or an OrdMap instance");
  }
  if (typeInfo != null && !(typeInfo instanceof ordmap_default)) {
    throw new Error("Call Error: `typeInfo` must be null or an OrdMap instance");
  }
  if (decode2 != null && typeof decode2 !== "function") {
    throw new Error("Call Error: `decode` must be null or a function");
  }
  var aggClass = AGGREGATE_REGISTRY.get(spec.fun);
  if (aggClass == null) {
    throw new Error('No such aggregate function: "' + spec.fun + '"' + (spec.name ? ' (output name = "' + spec.name + '")' : ""));
  }
  var ctorOpts = {
    name: spec.name
  };
  if (spec.fields) {
    self2.fields = spec.fields;
  }
  if (self2.fields.length !== aggClass.prototype.fieldCount) {
    log.warn("Creating " + aggType + "[" + aggNum + '] aggregate function "' + spec.fun + '" to be applied over fields ' + JSON.stringify(self2.fields) + ", which doesn't match the number of fields supported by the aggregate function (" + aggClass.prototype.fieldCount + ")... expect trouble.");
  }
  if (self2.fields.length > 0) {
    if (colConfig != null) {
      self2.colConfig = index_default_default.map(self2.fields, function(f2) {
        return colConfig.get(f2);
      });
    } else {
      log.warn("Creating " + aggType + "[" + aggNum + '] aggregate function "' + spec.fun + '" to be applied over fields ' + JSON.stringify(self2.fields) + ", but no column config was provided.");
    }
    if (typeInfo != null) {
      self2.typeInfo = index_default_default.map(self2.fields, function(f2) {
        return typeInfo.get(f2);
      });
    } else {
      log.warn("Creating " + aggType + "[" + aggNum + '] aggregate function "' + spec.fun + '" to be applied over fields ' + JSON.stringify(self2.fields) + ", but no type info was provided.");
    }
    index_default_default.each(self2.typeInfo, function(fti, i2) {
      if (fti == null) {
        throw new Error('Aggregate function applied to unknown field: "' + self2.fields[i2] + '"');
      }
      if (fti.needsDecoding) {
        if (decode2 != null) {
          decode2(fti.field);
        } else {
          log.warn('Unable to decode field "' + fti.field + '" on demand for aggregate function, no decoding function provided.');
        }
      }
    });
    ctorOpts.fields = self2.fields;
    ctorOpts.isHidden = self2.isHidden;
    ctorOpts.colConfig = self2.colConfig;
    ctorOpts.typeInfo = self2.typeInfo;
  }
  index_default_default.extend(ctorOpts, spec.opts);
  self2.instance = new aggClass(ctorOpts);
});

// node_modules/wcdatavis/src/source_param.js
var FilterError = makeSubclass("FilterError", Error, function(msg) {
  this.message = msg;
});
var Filter = function(config) {
  var self2 = this, method, operator;
  if (config.inputName && !config.paramName) {
    config.paramName = config.inputName;
  } else if (config.paramName && !config.inputName) {
    config.inputName = config.paramName;
  }
  index_default_default.defaults(config, {
    required: false,
    defaultValue: null,
    sendEmpty: false,
    emptyValue: ""
  });
  index_default_default.extend(self2, config);
  if (self2.type === "multi-autocomplete" && (self2.method === "json_where" || self2.method === "json_having") && (self2.json.operator !== "$in" && self2.json.operator !== "$nin")) {
    throw new FilterError('Filter "' + self2.paramName + `" is a multi-autocomplete, so the operator must be either "$in" or "$nin" (right now it's "` + self2.json.operator + '").');
  }
};
Filter.prototype.store = function(id) {
  var form = id ? document.getElementById(id) : null;
  var findInput = form ? function(s2) {
    return jQuery(form).find(s2);
  } : jQuery;
  var self2 = this;
  if (self2.type === void 0) {
    self2.value = typeof self2.defaultValue === "function" ? self2.defaultValue() : self2.defaultValue;
  } else {
    switch (self2.type) {
      case "hidden":
      case "text":
        self2.value = findInput('input[name="' + self2.inputName + '"]').val();
        break;
      case "textarea":
        self2.value = findInput('textarea[name="' + self2.inputName + '"]').val();
        break;
      case "date":
        self2.internalValue = {};
        var x = index_default_default.map(["YEAR", "MONTH", "DAY"], function(elt2) {
          var value = findInput('[name="' + self2.inputName + elt2 + '"]')[0].value;
          self2.internalValue[elt2] = value;
          return value;
        }).join("-");
        self2.value = x === "--" ? "" : x;
        break;
      case "checkbox":
        self2.value = index_default_default.map(findInput('input[name="' + self2.inputName + '"]:checkbox:checked'), function(x2) {
          return findInput(x2).val();
        });
        break;
      case "toggle-checkbox":
        self2.value = findInput('input[name="' + self2.inputName + '"]').prop("checked") ? "on" : "off";
        break;
      case "radio":
        self2.value = findInput('input[name="' + self2.inputName + '"]:radio:checked').val();
        break;
      case "select":
        self2.value = findInput('select[name="' + self2.inputName + '"]').val();
        break;
      case "autocomplete":
        throw new Error();
      case "multi-autocomplete":
        self2.value = [];
        self2.internalValue = [];
        index_default_default.each(findInput('input[name="' + self2.inputName + '"]'), function(elt2, i2) {
          self2.value[i2] = jQuery(elt2).val();
          self2.internalValue[i2] = jQuery(elt2).parent().text();
        });
        break;
      case "form":
        var obj = {};
        findInput("input").each(function(i2, elt2) {
          var j = jQuery(elt2), name = j.attr("name"), type = j.attr("type");
          if (name == null) {
            return;
          }
          switch (type) {
            case "hidden":
            case "text":
              obj[name] = j.val();
              break;
            case "checkbox":
            case "radio":
              if (j.prop("checked")) {
                if (obj[j.attr("name")] == null) {
                  obj[name] = [];
                }
                obj[name].push(j.val());
              }
              break;
          }
        });
        findInput("select,textarea").each(function(i2, elt2) {
          var j = jQuery(elt2), name = j.attr("name");
          if (name == null) {
            return;
          }
          obj[name] = j.val();
        });
        self2.value = obj;
        break;
      default:
        throw 'Invalid parameter specification: unknown input type "' + self2.type + '"';
    }
  }
  console.debug("[DataVis // Filter // Store] Input Type = %s, Input Name = %s, Param Name = %s, Value = %s", self2.type, self2.inputName, self2.paramName, self2.value);
};
Filter.prototype.load = function(id, opts) {
  var self2 = this;
  if (self2.type === void 0) {
    return;
  }
  opts = opts || {};
  var form = id ? document.getElementById(id) : null;
  var findInput = form ? function(s2) {
    return jQuery(form).find(s2);
  } : jQuery;
  index_default_default.defaults(opts, {
    fade: false
  });
  if (opts.fade && !(index_default_default.isString(opts.bgAccentIn) && index_default_default.isString(opts.bgAccentOut))) {
    throw "Cannot load filter with fading without specifying bgAccent[In|Out] properties";
  }
  var fade = {
    backgroundColor: jQuery.Color(opts.bgAccentIn)
  };
  function unfade() {
    jQuery(this).animate({
      backgroundColor: jQuery.Color(opts.bgAccentOut)
    }, 500);
  }
  function unfadeBdr() {
    jQuery(this).animate({
      borderColor: jQuery.Color(opts.bgAccentOut)
    }, 500, function() {
      jQuery(this).css("border", "none");
    });
  }
  switch (self2.type) {
    case "hidden":
      (function() {
        var nodes = findInput('input[name="' + self2.inputName + '"]');
        nodes.val(self2.value ? self2.value : self2.defaultValue ? self2.defaultValue : "");
      })();
      break;
    case "text":
      (function() {
        var nodes = findInput('input[name="' + self2.inputName + '"]');
        if (opts.fade && nodes.val() !== self2.value) {
          nodes.animate(fade, 500, unfade);
        }
        nodes.val(self2.value ? self2.value : self2.defaultValue ? self2.defaultValue : "");
      })();
      break;
    case "date":
      index_default_default.each(["YEAR", "MONTH", "DAY"], function(elt2) {
        var nodes = findInput('input[name="' + self2.inputName + elt2 + '"]');
        nodes.val(index_default_default.isObject(self2.internalValue) && index_default_default.isString(self2.internalValue[elt2]) && self2.internalValue[elt2] !== "" ? self2.internalValue[elt2] : self2.defaultValue ? self2.defaultValue : "");
        if (opts.fade) {
          nodes.animate(fade, 500, unfade);
        }
      });
      break;
    case "checkbox":
      (function() {
        var curNodes = findInput('input[name="' + self2.inputName + '"]:checkbox:checked');
        var curValues = {};
        index_default_default.each(curNodes, function(node) {
          curValues[jQuery(node).val()] = node;
        });
        curNodes.prop("checked", false);
        index_default_default.each(self2.value, function(x) {
          var nodes = findInput('input[name="' + self2.inputName + '"]:checkbox[value="' + x + '"]');
          nodes.prop("checked", true);
          delete curValues[x];
          if (opts.fade) {
            nodes.parent("label").animate(fade, 500, unfade);
          }
        });
        if (opts.fade) {
          index_default_default.each(curValues, function(node) {
            var label = jQuery(node).parent("label");
            label.animate(fade, 500, unfade);
          });
        }
      })();
      break;
    case "toggle-checkbox":
      (function() {
        var node = findInput('input[name="' + self2.inputName + '"]');
        var curValue = node.prop("checked") ? "on" : "off";
        node.prop("checked", self2.value === "on");
        if (opts.fade && curValue !== self2.value) {
          node.parent("label").animate(fade, 500, unfade);
        }
      })();
      break;
    case "radio":
      (function() {
        var nodes = findInput('input[name="' + self2.inputName + '"]:radio[value="' + self2.value + '"]');
        nodes.prop("checked", true);
        if (opts.fade) {
          nodes.parent("label").animate(fade, 500, unfade);
        }
      })();
      break;
    case "select":
      (function() {
        var nodes = findInput('select[name="' + self2.inputName + '"]');
        var oldVal = nodes.val();
        nodes.val(self2.value);
        if (opts.fade && oldVal !== self2.value) {
          nodes.parent().animate(fade, 500, unfade);
        }
      })();
      break;
    case "autocomplete":
      return new Error();
    case "multi-autocomplete":
      (function() {
        if (!index_default_default.isObject(window[self2.inputName + "_ac"])) {
          throw 'Autocomplete object "' + self2.inputName + '" does not exist';
        }
        window[self2.inputName + "_ac"].storedvalues = [];
        jQuery(document.getElementById(self2.inputName + "_ac_div")).children().remove();
        index_default_default.each(self2.value, function(v, i2) {
          window[self2.inputName + "_ac"].multiAddValue(v, self2.internalValue[i2]);
        });
        if (opts.fade) {
          jQuery(document.getElementById(self2.inputName + "_ac_div")).animate(fade, 500, unfade);
        }
      })();
      break;
    default:
      throw 'Invalid parameter specification: unknown input type "' + self2.type + '"';
  }
};
Filter.prototype.buildInput = function(form) {
  var self2 = this;
  var val = index_default_default.isArray(this.value) ? this.value : [this.value];
  index_default_default.each(val, function(v) {
    jQuery("<input>").attr({
      type: "hidden",
      name: self2.paramName,
      value: v
    }).appendTo(form);
  });
};
Filter.prototype.addJsonParam = function(obj) {
  var self2 = this, operand;
  if (self2.json == null) {
    throw new FilterError("Missing configuration object for JSON grid parameter.");
  }
  if (self2.json.name == null || self2.json.name === "") {
    throw new FilterError("Missing constraint set name for JSON grid parameter.");
  }
  if (self2.json.column == null || self2.json.column === "") {
    throw new FilterError("Missing column name for JSON grid parameter.");
  }
  if (self2.json.operator == null || self2.json.operator === "") {
    self2.json.operator = "$eq";
  }
  var name = self2.json.name;
  var column = self2.json.column;
  var operator = self2.json.operator;
  if (self2.value === null || self2.type === "date" && self2.value === "" || self2.type === "multi-autocomplete" && self2.value.length === 0) {
    if (getProp(obj, name, column, operator)) {
      delete obj[name][column][operator];
      if (isEmpty2(obj[name][column])) {
        delete obj[name][column];
      }
      if (isEmpty2(obj[name])) {
        delete obj[name];
      }
    }
    return;
  }
  if (index_default_default.isArray(self2.json.operand)) {
    operand = arrayCopy(self2.json.operand);
    index_default_default.each(operand, function(elt2, i2) {
      if (index_default_default.isArray(elt2) && elt2.length === 0) {
        operand[i2] = self2.value;
      }
    });
  } else {
    operand = self2.json.operand == null ? self2.value : self2.json.operand;
  }
  setProp(operand, obj, name, column, operator);
};
Filter.prototype.toParams = function(params) {
  var self2 = this;
  self2.store();
  switch (self2.method) {
    case "json_where":
      params.report_json_where = params.report_json_where || {};
      self2.addJsonParam(params.report_json_where);
      break;
    case "json_having":
      params.report_json_having = params.report_json_having || {};
      self2.addJsonParam(params.report_json_having);
      break;
    case "cgi":
      if (self2.type === "form") {
        index_default_default.each(self2.value, function(v, k) {
          if (v != self2.emptyValue || self2.sendEmpty) {
            params[k] = v;
          }
        });
      } else {
        if (self2.value != self2.emptyValue || self2.sendEmpty) {
          params[self2.paramName] = self2.value;
        }
      }
      break;
    default:
      throw "INVALID METHOD";
  }
};
var FilterSet = function(name, template2) {
  this.name = name;
  this.filters = [];
  this.filterMap = {};
  var self2 = this;
  index_default_default.each(template2, function(t2) {
    self2.add(new Filter(t2));
  });
};
FilterSet.prototype.copyTo = function(target) {
  index_default_default.each(this.filterMap, function(src, paramName) {
    var dst = target.get(paramName);
    if (dst.value === void 0) {
      dst.value = src.value;
      dst.internalValue = src.internalValue;
      if (index_default_default.isObject(dst.value)) {
        dst.value = JSON.parse(JSON.stringify(dst.value));
      }
      if (index_default_default.isObject(dst.internalValue)) {
        dst.internalValue = JSON.parse(JSON.stringify(dst.internalValue));
      }
    }
  });
};
FilterSet.prototype.add = function(config) {
  var fltr = new Filter(config);
  this.filters.push(fltr);
  this.filterMap[fltr.paramName] = fltr;
};
FilterSet.prototype.remove = function(paramName) {
  this.filters = index_default_default.reject(this.filters, function(fltr) {
    return fltr.paramName === paramName;
  });
};
FilterSet.prototype.get = function(name) {
  return this.filterMap[name];
};
FilterSet.prototype.load = function(id, opts) {
  index_default_default.each(this.filters, function(fltr) {
    fltr.load(id, opts);
  });
};
FilterSet.prototype.store = function(id) {
  index_default_default.each(this.filters, function(fltr) {
    fltr.store(id);
  });
};
FilterSet.prototype.buildForm = function() {
  var form = jQuery("<form>").attr({
    action: "webchart.cgi",
    method: "POST"
  });
  index_default_default.each(this.filters, function(e2) {
    e2.buildInput(form);
  });
  return form;
};
FilterSet.prototype.toParams = function() {
  var params = {};
  index_default_default.each(this.filters, function(fltr) {
    fltr.toParams(params);
  });
  if (params.report_json_where !== void 0) {
    params.report_json_where = JSON.stringify(params.report_json_where);
  }
  if (params.report_json_having !== void 0) {
    params.report_json_having = JSON.stringify(params.report_json_having);
  }
  return params;
};
var FilterInput = function(formId) {
  this.formId = formId;
  this.activeFilterSet = null;
  this.availableFilterSets = {};
};
FilterInput.prototype.store = function() {
  this.activeFilterSet.store(this.formId);
  return this;
};
FilterInput.prototype.load = function(opts) {
  this.activeFilterSet.load(this.formId, opts);
  return this;
};
FilterInput.prototype.change = function(name, opts) {
  opts = index_default_default.isObject(opts) ? opts : {};
  index_default_default.defaults(opts, {
    copy: false
  });
  if (this.availableFilterSets[name] === void 0) {
    throw "No such filter set: " + name;
  }
  if (opts.copy) {
    this.activeFilterSet.copyTo(this.availableFilterSets[name]);
  }
  this.activeFilterSet = this.availableFilterSets[name];
  return this;
};
FilterInput.prototype.activeName = function() {
  return this.activeFilterSet.name;
};
FilterInput.prototype.add = function(name, template2) {
  this.availableFilterSets[name] = new FilterSet(name, template2);
  this.change(name);
  return this;
};
FilterInput.prototype.remove = function(name) {
  delete this.availableFilterSets[name];
  return this;
};
FilterInput.prototype.get = function(name) {
  return this.availableFilterSets[name];
};
var ParamInputError = makeSubclass("ParamInputError", Error, function(msg) {
  this.message = msg;
});
var ParamInput = function(sourceType, opts) {
  var self2 = this, filterOpts = {};
  self2.inputName = opts.inputName;
  self2.inputType = opts.inputType;
  switch (sourceType) {
    case "report":
      self2.reportMethod = opts.reportMethod;
      filterOpts = {
        type: self2.inputType,
        method: self2.reportMethod,
        inputName: self2.inputName
      };
      switch (self2.reportMethod) {
        case "cgi":
          self2.cgiName = opts.cgi.name;
          self2.cgiValue = opts.cgi.value;
          filterOpts.paramName = self2.cgiName;
          filterOpts.defaultValue = self2.cgiValue;
          break;
        case "json_where":
        case "json_having":
          self2.jsonName = opts.json.name;
          self2.jsonColumn = opts.json.column;
          self2.jsonOperator = opts.json.operator;
          self2.jsonOperand = opts.json.operand;
          filterOpts.json = {
            // TODO: Remove after self.filter is gone.
            name: self2.jsonName,
            column: self2.jsonColumn,
            operator: self2.jsonOperator,
            operand: self2.jsonOperand
          };
          break;
        default:
          throw new ParamInputError('Unrecognized report method "' + opts.reportMethod + '". Must be "cgi", "json_where", or "json_having".');
      }
      break;
    case "json":
    case "json_api":
      self2.reportMethod = "cgi";
      filterOpts = {
        type: self2.inputType,
        method: self2.reportMethod,
        inputName: self2.inputName
      };
      self2.cgiName = getPropDef(self2.inputName, opts, "cgi", "name");
      self2.cgiValue = getProp(opts, "cgi", "value");
      filterOpts.paramName = self2.cgiName;
      filterOpts.defaultValue = self2.cgiValue;
      break;
    case "local":
      throw new ParamInputError("Parameter inputs not allowed for local data.");
    default:
      throw new ParamInputError('Unrecognized source type "' + sourceType + '". Must be "report", "json", or "local".');
  }
  self2.filter = new Filter(filterOpts);
};
delegate(ParamInput, "filter", ["toParams"]);

// node_modules/wcdatavis/src/source.js
var import_papaparse = __toESM(require_papaparse_min());
var SourceError = makeSubclass("SourceError", Error, function(msg) {
  this.message = msg;
});
var LocalSource = makeSubclass("LocalSource", Object, function(spec) {
  var self2 = this;
  self2.varName = spec.varName;
  self2.cache = {
    data: deepCopy(window[self2.varName].data),
    typeInfo: new ordmap_default()
  };
  if (index_default_default.isArray(window[self2.varName].typeInfo)) {
    index_default_default.each(window[self2.varName].typeInfo, function(fti) {
      self2.cache.typeInfo.set(fti.field, fti);
    });
  } else {
    index_default_default.each(window[self2.varName].typeInfo, function(fti, field) {
      fti.field = field;
      self2.cache.typeInfo.set(field, fti);
    });
  }
});
LocalSource.prototype.getData = function(params, cont) {
  var self2 = this;
  return cont(true, self2.cache.data);
};
LocalSource.prototype.getTypeInfo = function(cont) {
  var self2 = this;
  return cont(true, self2.cache.typeInfo);
};
LocalSource.prototype.clearCachedData = function() {
  var self2 = this;
  self2.cache = null;
};
LocalSource.prototype.getName = function() {
  var self2 = this;
  return self2.varName;
};
var HttpSource = makeSubclass("HttpSource", Object, function(spec, userTypeInfo) {
  var self2 = this;
  self2.url = spec.url;
  self2.method = spec.method || "GET";
  self2.dataType = spec.dataType;
  self2.cache = null;
  self2.userTypeInfo = userTypeInfo;
});
HttpSource.prototype.parseData = function(data) {
  var self2 = this, result2 = {
    data: [],
    typeInfo: new ordmap_default()
  };
  if (data instanceof Document) {
    var root2 = jQuery(data).children("root");
    if (!root2.is("root")) {
      throw new SourceError("HTTP Data Source / XML Parser / Missing (root) element");
    }
    data = root2.children("data");
    if (data.length === 0) {
      throw new SourceError("HTTP Data Source / XML Parser / Missing (root > data) element");
    } else if (data.length > 1) {
      throw new SourceError("HTTP Data Source / XML Parser / Too many (root > data) elements");
    }
    data.children("item").each(function(_itemIndex, item) {
      item = jQuery(item);
      var row = {};
      item.children().each(function(_fieldIndex, field) {
        field = jQuery(field);
        row[field.prop("tagName")] = field.text();
      });
      result2.data.push(row);
    });
    var typeInfo = root2.children("typeInfo");
    if (typeInfo.length === 0) {
      throw new SourceError("HTTP Data Source / XML Parser / Missing (root > typeInfo) element");
    } else if (typeInfo.length > 1) {
      throw new SourceError("HTTP Data Source / XML Parser / Too many (root > typeInfo) elements");
    }
    typeInfo.children().each(function(_fieldIndex, field) {
      field = jQuery(field);
      var fieldName = field.prop("tagName");
      result2.typeInfo.set(fieldName, {});
      if (field.children().length === 0) {
        result2.typeInfo.get(fieldName).type = field.text();
      } else {
        var type = field.children("type");
        if (type.length === 0) {
          throw new SourceError("HTTP Data Source / XML Parser / Missing (root > typeInfo > " + fieldName + " > type) element");
        } else if (type.length > 1) {
          throw new SourceError("HTTP Data Source / XML Parser / Too many (root > typeInfo > " + fieldName + " > type) elements");
        } else if (type.children().length > 0) {
          throw new SourceError("HTTP Data Source / XML Parser / (root > typeInfo > " + fieldName + " > type) element cannot have children");
        }
        result2.typeInfo.get(fieldName).type = type.text();
        var format3 = field.children("format");
        if (format3.length > 1) {
          throw new SourceError("HTTP Data Source / XML Parser / Too many (root > typeInfo > " + fieldName + " > format) elements");
        } else if (format3.length === 1) {
          if (format3.children().length > 0) {
            throw new SourceError("HTTP Data Source / XML Parser / (root > typeInfo > " + fieldName + " > format) element cannot have children");
          }
          result2.typeInfo.get(fieldName).format = format3.text();
        }
      }
    });
  } else if (typeof data === "string") {
    var decoded = import_papaparse.default.parse(data, { skipEmptyLines: true }), fields = decoded.data[0];
    index_default_default.each(decoded.data.slice(1), function(row) {
      var newRow2 = {};
      index_default_default.each(row, function(colVal, colIdx) {
        newRow2[fields[colIdx]] = colVal;
      });
      result2.data.push(newRow2);
    });
    index_default_default.each(fields, function(f2) {
      result2.typeInfo.set(f2, {
        type: "string"
      });
    });
  } else {
    if (data.data === void 0) {
      throw new SourceError("HTTP Data Source / JSON Parser / Missing (data) property");
    } else if (!index_default_default.isArray(data.data)) {
      throw new SourceError("HTTP Data Source / JSON Parser / (data) property must be an array");
    }
    if (data.typeInfo === void 0) {
      throw new SourceError("HTTP Data Source / JSON Parser / Missing (typeInfo) property");
    }
    index_default_default.each(data.typeInfo, function(fti) {
      var field = fti.field;
      delete fti.field;
      result2.typeInfo.set(field, fti);
    });
    for (var rowNum = 0; rowNum < data.data.length; rowNum += 1) {
      if (index_default_default.isArray(data.data[rowNum])) {
        var newRow = {};
        result2.typeInfo.each(function(fti, field, i2) {
          newRow[field] = data.data[rowNum][i2];
        });
        data.data[rowNum] = newRow;
      }
    }
    result2.data = data.data;
  }
  return result2;
};
HttpSource.prototype.getData = function(params, cont) {
  var self2 = this;
  if (self2.cache != null) {
    return cont(true, self2.cache.data);
  }
  var al = logAsync("HttpSource#getData");
  self2.xhr = jQuery.ajax(self2.url, {
    method: self2.method,
    data: params,
    traditional: true,
    dataType: self2.dataType,
    error: function(jqXHR, textStatus, errorThrown) {
      al.finish();
      log.error("HTTP Data Source / AJAX Error / " + errorThrown);
      return cont(false);
    },
    success: function(data, textStatus, jqXHR) {
      al.finish();
      self2.cache = self2.parseData(data);
      return cont(true, self2.cache.data);
    }
  });
  return self2.xhr;
};
HttpSource.prototype.getTypeInfo = function(cont) {
  var self2 = this;
  if (self2.cache != null) {
    return cont(true, self2.cache.typeInfo);
  }
  return self2.getData(void 0, function(ok) {
    if (!ok) {
      return cont(false);
    }
    return cont(true, self2.cache.typeInfo);
  });
};
HttpSource.prototype.clearCachedData = function() {
  var self2 = this;
  self2.cache = null;
};
HttpSource.prototype.cancel = function() {
  var self2 = this;
  self2.xhr.abort();
};
var FileSource = makeSubclass("FileSource", Object, function(spec, userTypeInfo, source) {
  var self2 = this;
  self2.spec = spec;
  self2.userTypeInfo = userTypeInfo;
  self2.source = source;
  self2.cache = {
    data: [],
    typeInfo: new ordmap_default()
  };
});
FileSource.prototype.setToolbar = function(toolbar) {
  var self2 = this;
  var input = jQuery("<input>", { "type": "file", "name": "file", "accept": ".csv" }).on("change", function() {
    import_papaparse.default.parse(this.files.item(0), {
      header: true,
      skipEmptyLines: true,
      complete: function(results, file) {
        console.log(results);
        self2.cache.data = results.data;
        self2.cache.typeInfo = new ordmap_default();
        index_default_default.each(results.meta.fields, function(field) {
          self2.cache.typeInfo.set(field, {
            "type": "string"
          });
        });
        self2.source.clearCachedData();
      }
    });
  }).appendTo(toolbar);
};
FileSource.prototype.setFiles = function(files) {
  var self2 = this;
  if (!(files instanceof FileList)) {
    return;
  }
  import_papaparse.default.parse(files.item(0), {
    header: true,
    skipEmptyLines: true,
    complete: function(results, file) {
      console.log(results);
      self2.cache.data = results.data;
      self2.cache.typeInfo = new ordmap_default();
      index_default_default.each(results.meta.fields, function(field) {
        self2.cache.typeInfo.set(field, {
          "type": "string"
        });
      });
      self2.source.clearCachedData();
    }
  });
};
FileSource.prototype.getData = function(params, cont) {
  var self2 = this;
  return cont(true, self2.cache.data);
};
FileSource.prototype.getTypeInfo = function(cont) {
  var self2 = this;
  return cont(true, self2.cache.typeInfo);
};
var TableSource = makeSubclass("TableSource", Object, function(spec, userTypeInfo, source) {
  var self2 = this;
  self2.spec = spec;
  self2.userTypeInfo = userTypeInfo;
  self2.source = source;
  self2.cache = {};
});
TableSource.prototype.getData = function(params, cont) {
  var self2 = this;
  if (self2.cache.data != null) {
    return self2.cache.data;
  }
  var getText2 = function(selector) {
    return jQuery(selector).map(function(i2, x) {
      return jQuery(x).text();
    });
  };
  var tableSelector = self2.spec.tableSelector || "", columnSelector = self2.spec.columnSelector || 'div[id="lv_' + self2.source.table.id + '_span"] table tbody:eq(0) tr th a font', dataSelector = self2.spec.dataSelector || 'div[id="lv_' + self2.source.table.id + '_span"] table tbody:eq(1) tr td font', columns = getText2(columnSelector), data = getText2(dataSelector), row, col, newData = [], newObj;
  for (row = 0; row < data.length / columns.length; row += 1) {
    newObj = {};
    for (col = 0; col < columns.length; col += 1) {
      newObj[columns[col]] = data[row * columns.length + col];
    }
    newData.push(newObj);
  }
  self2.cache.data = newData;
  return cont(true, self2.cache.data);
};
TableSource.prototype.getTypeInfo = function(cont) {
  var self2 = this;
  if (self2.cache.typeInfo != null) {
    return self2.cache.typeInfo;
  }
  var getText2 = function(selector) {
    return jQuery(selector).map(function(i2, x) {
      return jQuery(x).text();
    });
  };
  var columnSelector = self2.spec.columnSelector || 'div[id="lv_' + self2.source.table.id + '_span"] table tbody:eq(0) tr th a font', columns = getText2(columnSelector), newTypeInfo = new ordmap_default();
  index_default_default.each(columns, function(field) {
    newTypeInfo.set(field, {
      "type": "string"
    });
  });
  self2.cache.typeInfo = newTypeInfo;
  return cont(true, self2.cache.typeInfo);
};
var Source2 = makeSubclass("Source", Object, function(spec, params, userTypeInfo, opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    deferDecoding: true,
    passThroughParams: false
  });
  self2.setName(opts.name);
  self2.error = spec.error;
  self2.type = spec.type;
  self2.cache = {};
  self2.params = params;
  self2.locks = {};
  self2.opts = opts;
  self2.eventHandlers = {};
  index_default_default.each(index_default_default.keys(Source2.events), function(evt) {
    self2.eventHandlers[evt] = [];
  });
  self2.guessColumnTypes = true;
  if (index_default_default.isArray(userTypeInfo)) {
    self2.userTypeInfo = index_default_default.indexBy(userTypeInfo, "field");
  } else {
    self2.userTypeInfo = userTypeInfo;
  }
  if (Source2.sources[self2.type] === void 0) {
    throw new SourceError("Unsupported data source type: " + self2.type);
  }
  self2.origin = new Source2.sources[self2.type](spec, userTypeInfo, self2);
  var checkConversionArray = function(convs, field) {
    index_default_default.each(convs, function(c2, i2) {
      if (typeof c2 === "string") {
        if (Source2.converters[c2] === void 0) {
          throw new SourceError("Conversion" + (field ? ' for field "' + field + '", ' : "") + " #" + i2 + ': Named converter "' + c2 + '" not registered');
        }
        if (typeof Source2.converters[c2] !== "function") {
          throw new SourceError("Conversion" + (field ? ' for field "' + field + '", ' : "") + " #" + i2 + ': Named converter "' + c2 + '" is not a function');
        }
      } else if (typeof c2 !== "function") {
        throw new SourceError("Invalid Source config: `.conversion" + (field ? "[" + field + "]" : "") + "[" + i2 + "]` must be a function or string");
      }
    });
  };
  if (index_default_default.isArray(spec.conversion)) {
    checkConversionArray(spec.conversion);
  } else {
    index_default_default.each(spec.conversion, function(convs, field) {
      checkConversionArray(convs, field);
    });
  }
  self2.conversion = spec.conversion;
  self2.locks.getData = new lock_default(self2.toString() + " // GET DATA");
  self2.locks.refresh = new lock_default(self2.toString() + " // REFRESH");
});
mixinEventHandling(Source2, [
  "fetchDataBegin",
  "fetchDataEnd",
  "fetchDataCancel",
  "dataUpdated",
  "getTypeInfo"
]);
mixinDebugging(Source2);
mixinLogging(Source2);
mixinNameSetting(Source2);
Source2.sources = {
  local: LocalSource,
  http: HttpSource,
  file: FileSource,
  table: TableSource
};
Source2.converters = {};
Source2.decode = function(cell, fti) {
  if (cell.decoded) {
    return;
  }
  if (cell.orig === void 0) {
    cell.orig = cell.value;
  }
  if (typeof cell.orig === "string") {
    cell.value = types_default.registry.get(fti.type).parse(cell.orig, fti.internalType, fti.format);
  } else {
    cell.value = types_default.registry.get(fti.type).decode(cell.orig, fti.internalType);
  }
  cell.decoded = true;
};
Source2.decodeAll = function(data, field, typeInfo) {
  var fti = typeInfo.get(field);
  if (!fti.needsDecoding) {
    return;
  }
  console.debug('[DataVis // Source // Decoding] Decoding all values: field = "%s" ; type = %s ; internalType = %s ; valueTypeOf = %s', field, fti.type, fti.internalType, typeof getProp(data, 0, field, "value"));
  index_default_default.each(data, function(row) {
    Source2.decode(row[field], typeInfo.get(field));
  });
  fti.deferDecoding = false;
  fti.needsDecoding = false;
};
Source2.prototype.unlimit = function() {
  var self2 = this;
  if (typeof self2.origin.unlimit === "function") {
    return self2.origin.unlimit();
  }
};
Source2.prototype.getName = function() {
  var self2 = this;
  if (typeof self2.origin.getName === "function") {
    return self2.origin.getName();
  }
};
Source2.prototype.getData = function(cont) {
  var self2 = this;
  if (self2.locks.getData.isLocked()) {
    return self2.locks.getData.onUnlock(function() {
      return self2.getData(cont);
    });
  }
  if (self2.cache.data != null) {
    return cont(true, self2.cache.data);
  }
  self2.locks.getData.lock();
  self2.fire("fetchDataBegin", { async: true });
  return self2.origin.getData(self2.createParams(), function(ok, data) {
    if (!ok) {
      self2.locks.getData.unlock();
      self2.fire("fetchDataEnd", { async: true });
      return cont(false);
    }
    if (
      /* TODO: Add option to disable post-processing */
      false
    ) {
      self2.cache.data = data;
      self2.locks.getData.unlock();
      self2.fire("fetchDataEnd", { async: true });
      return cont(true, data);
    } else {
      self2.postProcess(data, function(finalData) {
        self2.cache.data = finalData;
        self2.locks.getData.unlock();
        self2.fire("fetchDataEnd", { async: true });
        return cont(true, finalData);
      });
    }
  });
};
Source2.prototype.getUniqueVals = function(cont) {
  var self2 = this;
  if (self2.cache.uniqElts != null) {
    return cont(self2.cache.uniqElts);
  }
  self2.getData(function(ok, data) {
    var uniqElts = {};
    var tmp = {};
    if (!ok) {
      return cont({});
    }
    index_default_default.each(data, function(row) {
      index_default_default.each(row, function(cell, field) {
        if (uniqElts[field] === void 0) {
          uniqElts[field] = {
            count: 0,
            values: []
          };
          tmp[field] = {};
        }
        if (tmp[field][cell.value] === void 0) {
          tmp[field][cell.value] = true;
          uniqElts[field].count += 1;
          uniqElts[field].values.push(cell.value);
        }
      });
    });
    index_default_default.each(uniqElts, function(obj) {
      obj.values.sort();
    });
    self2.cache.uniqElts = uniqElts;
    return cont(self2.cache.uniqElts);
  });
};
Source2.prototype.getTypeInfo = function(cont) {
  var self2 = this;
  if (self2.cache.typeInfo != null) {
    return cont(true, self2.cache.typeInfo);
  }
  return self2.origin.getTypeInfo(function(ok, typeInfo) {
    if (!ok) {
      return cont(false);
    }
    typeInfo.each(function(v, k) {
      if (typeof v === "string") {
        v = {
          "type": v
        };
        typeInfo.set(k, v);
      }
      v.field = k;
      v.overridden = false;
    });
    if (self2.userTypeInfo != null) {
      index_default_default.each(self2.userTypeInfo, function(userFti, field) {
        if (!typeInfo.isSet(field)) {
          log.warn('Overriding type information on field "' + field + '" which is not present in the source.');
          typeInfo.set(field, {});
        }
        if (typeof userFti === "string") {
          userFti = { type: userFti };
        }
        var fti = typeInfo.get(field);
        if (userFti.type != null) {
          fti.overridden = true;
        }
        index_default_default.extend(fti, userFti);
        self2.debug("GET TYPE INFO", 'Overriding origin type information { field = "' + field + '", typeInfo = %O }', userFti);
      });
    }
    self2.cache.typeInfo = typeInfo;
    self2.debug("GET TYPE INFO", "Type Info = %O", deepCopy(self2.cache.typeInfo.asMap()));
    self2.fire(Source2.events.getTypeInfo, null, self2.cache.typeInfo, self2);
    return cont(true, self2.cache.typeInfo);
  });
};
Source2.prototype.getDisplayName = function(cont) {
  var self2 = this;
  if (self2.cache.displayName != null) {
    return cont(self2.cache.displayName);
  }
  if (self2.origin.getDisplayName != null) {
    return self2.origin.getDisplayName(function(displayName) {
      self2.cache.displayName = displayName;
      return cont(self2.cache.displayName);
    });
  } else {
    self2.cache.displayName = {};
    return cont(self2.cache.displayName);
  }
};
Source2.prototype.postProcess = function(data, cont) {
  var self2 = this;
  if (data == null) {
    throw new SourceError("Data Source / Post Process / Received nothing");
  } else if (!index_default_default.isArray(data)) {
    throw new SourceError("Data Source / Post Process / Data is not an array");
  }
  self2.debug("POST-PROCESSING", "Beginning post-processing");
  self2.getTypeInfo(function(ok, typeInfo) {
    if (!ok) {
      return cont(data);
    }
    self2.debug("POST-PROCESSING", "Received type info from source origin: %O", typeInfo.asMap());
    typeInfo.each(function(fti) {
      if (fti.type == null) {
        fti.type = "string";
      }
    });
    var conversionFuncs = {};
    typeInfo.each(function(fti, fieldName) {
      conversionFuncs[fieldName] = self2.getConversionFuncs(fieldName);
    });
    index_default_default.each(data, function(row, rowNum) {
      index_default_default.each(row, function(val, field) {
        var fti = typeInfo.get(field);
        var cell = {
          value: val
        };
        if (conversionFuncs[field] != null) {
          var conversionFuncOpts = {
            row,
            source: self2,
            rowNum,
            totalRows: data.length
          };
          for (var i2 = 0; i2 < conversionFuncs[field].length; i2 += 1) {
            if (conversionFuncs[field][i2](cell, field, fti, conversionFuncOpts)) {
              break;
            }
          }
        }
        row[field] = cell;
      });
    });
    self2.guessTypes(data, typeInfo);
    self2.setConversionTypeInfo(data, typeInfo);
    index_default_default.each(data, function(row, rowNum) {
      index_default_default.each(row, function(val, field) {
        var fti = typeInfo.get(field);
        if (fti != null && (!fti.deferDecoding || field === self2.discriminatorField)) {
          Source2.decode(row[field], fti);
        }
      });
    });
    if (self2.discriminatorField != null) {
      var dfti = typeInfo.get(self2.discriminatorField);
      var cmp2 = getComparisonFn.byType(dfti);
      var newMin = null;
      var newMax = null;
      self2.debug("POST-PROCESSING", 'Checking discriminator ranges for "%s" field (type = %s)', self2.discriminatorField, dfti.type);
      index_default_default.each(data, function(row, rowNum) {
        var val = row[self2.discriminatorField].value;
        var inRange2 = false;
        for (var i2 = 0; i2 < self2.discriminatorRanges.length && !inRange2; i2 += 1) {
          var range2 = self2.discriminatorRanges[i2];
          if (cmp2(range2[0], val) <= 0 && cmp2(val, range2[1]) <= 0) {
            inRange2 = true;
          }
        }
        if (inRange2) {
          data[rowNum] = null;
        } else {
          if (newMin == null || cmp2(val, newMin) < 0) {
            newMin = val;
          }
          if (newMax == null || cmp2(newMax, val) > 0) {
            newMax = val;
          }
        }
      });
      self2.addDiscriminatorRange([newMin, newMax]);
      data = index_default_default.without(data, null);
    }
    self2.debug("POST-PROCESSING", "Post-processing finished");
    return cont(data);
  });
};
Source2.prototype.getConversionFuncs = function(fieldName) {
  var self2 = this, conversionFuncs = [];
  var addConversionFuncs = function(convs) {
    index_default_default.each(convs, function(c2, i2) {
      if (typeof c2 === "function") {
        conversionFuncs.push(c2);
      } else if (typeof c2 === "string") {
        conversionFuncs.push(Source2.converters[c2]);
      }
    });
  };
  if (self2.conversion !== void 0) {
    if (index_default_default.isArray(self2.conversion)) {
      addConversionFuncs(self2.conversion);
    } else if (self2.conversion[fieldName] !== void 0) {
      addConversionFuncs(self2.conversion[fieldName]);
    }
  }
  return conversionFuncs;
};
Source2.prototype.guessTypes = function(data, typeInfo) {
  var self2 = this;
  typeInfo.each(function(fti, f2) {
    if (fti.overridden || fti.type !== "string") {
      return;
    }
    self2.debug("CONVERSION // TYPE GUESSING", 'Guessing type for field "%s"', fti.field);
    var guess = null;
    for (var i2 = 0; guess !== "string" && i2 < data.length; i2 += 1) {
      var val = data[i2][f2].value;
      var newGuess = stringValueType(val);
      if (guess == null) {
        guess = newGuess;
      } else if (newGuess !== guess) {
        self2.debug("CONVERSION // TYPE GUESSING", 'For field "%s", previous guess "%s" disagrees with current guess "%s" (rowNum = %d, value = %O)', f2, guess, newGuess, i2, val);
        guess = "string";
      }
    }
    if (guess != null && guess !== "string") {
      self2.debug("CONVERSION // TYPE GUESSING", 'For field "%s", successfully guessed new type "%s"', f2, guess);
      fti.type = guess;
    }
  });
};
Source2.prototype.setConversionTypeInfo = function(data, typeInfo) {
  var self2 = this;
  typeInfo.each(function(fti, f2) {
    if (fti.type === "string") {
      fti.internalType = "string";
    } else if (["number", "currency"].indexOf(fti.type) >= 0) {
      fti.deferDecoding = self2.opts.deferDecoding;
      fti.needsDecoding = true;
      if (fti.internalType == null) {
        if (fti.type === "currency") {
          fti.internalType = "bignumber";
        } else {
          fti.internalType = "primitive";
        }
      } else if (["primitive", "numeral", "bignumber"].indexOf(fti.internalType) < 0) {
        log.error('Invalid internalType "' + fti.internalType + '" requested for field "' + fti.field + '" - falling back to "primitive" instead');
        fti.internalType = "primitive";
      }
    } else if (["date", "datetime", "time"].indexOf(fti.type) >= 0) {
      fti.deferDecoding = self2.opts.deferDecoding;
      if (fti.type === "date" && (fti.format === void 0 || fti.format === "YYYY-MM-DD") || fti.type === "datetime" && (fti.format === void 0 || fti.format === "YYYY-MM-DD HH:mm:ss") || fti.type === "time" && (fti.format === void 0 || fti.format === "HH:mm:ss" || fti.format === "HH:mm")) {
        fti.internalType = "string";
      } else {
        fti.needsDecoding = true;
        fti.internalType = "moment";
      }
    }
    if (fti.deferDecoding) {
      self2.debug(
        "CONVERSION",
        'Deferring conversion until <%s> { field = "%s", type = "%s", format = "%s" }',
        fti.needsDecoding ? "SORT" : "DISPLAY",
        f2,
        fti.type,
        fti.format
      );
    }
  });
};
Source2.prototype.clearCachedData = function() {
  var self2 = this;
  if (typeof self2.origin.clearCachedData === "function") {
    self2.origin.clearCachedData();
  }
  self2.cache = {};
  self2.fire("dataUpdated");
};
Source2.prototype.refresh = function() {
  var self2 = this;
  if (self2.locks.refresh.isLocked()) {
    return;
  }
  self2.debug(null, "Refreshing...");
  self2.locks.refresh.lock();
  if (typeof self2.origin.clearCachedData === "function") {
    self2.origin.clearCachedData();
  }
  var tmp = self2.cache;
  self2.cache = {};
  self2.getData(function(ok) {
    self2.locks.refresh.unlock();
    if (ok) {
      self2.fire("dataUpdated");
    } else {
      self2.cache = tmp;
    }
  });
};
Source2.prototype.createParams = function() {
  var self2 = this, obj = {};
  if (self2.opts.passThroughParams) {
    obj = getParamsFromUrl();
  }
  index_default_default.each(self2.params, function(p) {
    self2.debug("CREATE PARAMS", "Parameter =", p);
    p.toParams(obj);
  });
  self2.debug("CREATE PARAMS", "Final Parameters =", obj);
  if (obj.report_json_where != null) {
    obj.report_json_where = JSON.stringify(obj.report_json_where);
  }
  if (obj.report_json_having != null) {
    obj.report_json_having = JSON.stringify(obj.report_json_having);
  }
  return obj;
};
Source2.prototype.swapRows = function(oldIndex, newIndex) {
  var self2 = this;
  if (self2.cache.data === void 0) {
    throw new SourceError("Attempted to swap rows before retrieving data");
  }
  var temp = self2.cache.data.splice(oldIndex, 1);
  self2.cache.data.splice(newIndex, 0, temp[0]);
};
Source2.prototype.isCancellable = function() {
  var self2 = this;
  return typeof self2.origin.cancel === "function";
};
Source2.prototype.cancel = function() {
  var self2 = this;
  if (typeof self2.origin.cancel === "function") {
    self2.origin.cancel();
    self2.locks.getData.clear();
    self2.locks.refresh.clear();
    self2.fire("fetchDataCancel");
  }
};
Source2.prototype.toString = function() {
  var self2 = this;
  return "Source(" + self2.name + ", " + self2.type + ")";
};
Source2.prototype.setToolbar = function(toolbar) {
  var self2 = this;
  self2.toolbar = toolbar;
  if (typeof self2.origin.setToolbar === "function") {
    self2.origin.setToolbar(toolbar);
  }
};
Source2.prototype.setDiscriminatorField = function(field) {
  this.discriminatorField = field;
};
Source2.prototype.setDiscriminatorRanges = function(ranges) {
  this.discriminatorRanges = ranges;
};
Source2.prototype.addDiscriminatorRange = function(range2) {
  this.discriminatorRanges.push(range2);
};
Source2.prototype.clearDiscriminatorRanges = function() {
  this.discriminatorRanges = [];
};
Source2.prototype.condenseDiscriminatorRanges = function() {
  var self2 = this;
  if (self2.discriminatorRanges.length === 0) {
    return;
  }
  var newMin = null;
  var newMax = null;
  index_default_default.each(self2.discriminatorRanges, function(range2) {
    if (newMin == null || cmp(range2[0], newMin) < 0) {
      newMin = range2[0];
    }
    if (newMax == null || cmp(newMax, range2[1]) > 0) {
      newMax = range2[1];
    }
  });
  if (newMin == null || newMax == null) {
    self2.clearDiscriminatorRanges();
  } else {
    self2.setDiscriminatorRanges([[newMin, newMax]]);
  }
};

// node_modules/wcdatavis/src/computed_view.js
var import_bignumber8 = __toESM(require_bignumber());
var import_numeral16 = __toESM(require_numeral());

// node_modules/wcdatavis/src/prefs.js
var import_sprintf_js17 = __toESM(require_sprintf());
var import_numeral15 = __toESM(require_numeral());

// node_modules/wcdatavis/src/grid.js
var import_sprintf_js16 = __toESM(require_sprintf());

// node_modules/wcdatavis/src/util/jquery.js
var import_jquery2 = __toESM(require_jquery());
import_jquery2.default.fn.extend({
  /**
   * Tells whether the element is checked.
   *
   * @function external:"jQuery.fn"#_isChecked
   *
   * @returns {boolean}
   * True if the element is checked, false if it's not.
   */
  _isChecked: function() {
    return this.prop("checked");
  },
  /**
   * Checks a checkbox.
   *
   * @function external:"jQuery.fn"#_check
   *
   * @returns {boolean}
   * True if the element is now checked, false if it's not.
   */
  _check: function() {
    this.prop("checked", true);
  },
  /**
   * Unchecks a checkbox.
   *
   * @function external:"jQuery.fn"#_uncheck
   */
  _uncheck: function() {
    this.prop("checked", false);
  },
  /**
   * Toggles the checkbox.
   *
   * @function external:"jQuery.fn"#_toggleCheck
   *
   * @returns {boolean}
   * True if the element is now checked, false if it's not.
   */
  _toggleCheck: function() {
    var newValue = !this.prop("checked");
    this.prop("checked", newValue);
    return newValue;
  },
  /**
   * Tells whether the element is disabled.
   *
   * @function external:"jQuery.fn"#_isDisabled
   *
   * @returns {boolean}
   * True if the element is disabled, false if it's not.
   */
  _isDisabled: function() {
    return this.attr("disabled");
  },
  /**
   * Tells whether the element is hidden.
   *
   * @function external:"jQuery.fn"#_isHidden
   *
   * @returns {boolean}
   * True if the element is hidden, false if it's visible.
   */
  _isHidden: function() {
    return this.css("display") === "none" || this.css("visibility") !== "visible";
  },
  _addTrailing: function(chars) {
    var t2 = this.text();
    if (t2.slice(chars.length * -1) !== chars) {
      this.text(t2 + chars);
    }
  },
  _stripTrailing: function(chars) {
    var t2 = this.text();
    if (t2.slice(chars.length * -1) === chars) {
      this.text(t2.slice(0, chars.length * -1));
    }
  },
  // _makeIconCheckbox('foo') -->
  //   off = fontawesome('foo'), class = 'wcdv_icon_checkbox_off'
  //   on = fontawesome('foo'), class = 'wcdv_icon_checkbox_on'
  // _makeIconCheckbox('foo', 'bar') -->
  //   off = fontawesome('foo')
  //   on = fontawesome('bar')
  // _makeIconCheckbox(obj) -->
  //   off = fontawesome(obj.off.icon), class = obj.off.classes
  //   on = fontawesome(obj.on.icon), class = obj.on.classes
  _makeIconCheckbox: function() {
    var self2 = this, args = Array.prototype.slice.call(arguments), opts = {};
    if (args.length === 1) {
      if (typeof args[0] === "string") {
        opts = {
          on: {
            icon: args[0],
            classes: "wcdv_icon_checkbox_on"
          },
          off: {
            icon: args[0],
            classes: "wcdv_icon_checkbox_off"
          }
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        on: {
          icon: args[0]
        },
        off: {
          icon: args[1]
        }
      };
    }
    var button = (0, import_jquery2.default)("<button>", {
      "type": "button",
      "disabled": (0, import_jquery2.default)(self2).prop("disabled"),
      "title": self2.attr("title")
    }).addClass("wcdv_icon_button wcdv_button_left").on("click", function() {
      self2._toggleCheck();
      self2.trigger("change");
    });
    var onIcon = fontAwesome(opts.on.icon, opts.on.classes).css("display", "inline-block").hide().appendTo(button);
    var offIcon = fontAwesome(opts.off.icon, opts.off.classes).css("display", "inline-block").hide().appendTo(button);
    var updateIcon = function() {
      if (self2._isChecked()) {
        onIcon.show();
        offIcon.hide();
        if (opts.on.tooltip != null) {
          button.attr("title", opts.on.tooltip);
        }
      } else {
        onIcon.hide();
        offIcon.show();
        if (opts.off.tooltip != null) {
          button.attr("title", opts.off.tooltip);
        }
      }
    };
    updateIcon();
    self2.hide();
    self2.before(button);
    self2.on("change", updateIcon);
    self2._updateIcon = updateIcon;
    return self2;
  },
  /**
   * Adds debugging output for jQuery UI behavior events.
   *
   * @function external:"jQuery.fn"#_addEventDebugging
   *
   * @param {string} what
   * The behavior to output debugging info for.  Must be: drag, drop, or sort.
   *
   * @param {string} tag
   * Prefix to output at the beginning of the debug message.
   */
  _addEventDebugging: function(what, tag) {
    switch (what) {
      case "drag":
        this.on("dragstart", function(evt, ui) {
          console.log("### " + tag + " > DRAG.START: evt = %O, ui = %O", evt, ui);
        });
        this.on("dragstop", function(evt, ui) {
          console.log("### " + tag + " > DRAG.STOP: evt = %O, ui = %O", evt, ui);
        });
        break;
      case "drop":
        this.on("dropactivate", function(evt, ui) {
          console.log("### " + tag + " > DROP.ACTIVATE: evt = %O, ui = %O", evt, ui);
        });
        this.on("dropdeactivate", function(evt, ui) {
          console.log("### " + tag + " > DROP.DEACTIVATE: evt = %O, ui = %O", evt, ui);
        });
        this.on("drop", function(evt, ui) {
          console.log("### " + tag + " > DROP.DROP: evt = %O, ui = %O", evt, ui);
        });
        break;
      case "sort":
        this.on("sortreceive", function(evt, ui) {
          console.log("### " + tag + " > SORT.RECEIVE: evt = %O, ui = %O", evt, ui);
        });
        this.on("sortremove", function(evt, ui) {
          console.log("### " + tag + " > SORT.REMOVE: evt = %O, ui = %O", evt, ui);
        });
        this.on("sortstart", function(evt, ui) {
          console.log("### " + tag + " > SORT.START: evt = %O, ui = %O", evt, ui);
        });
        this.on("sortstop", function(evt, ui) {
          console.log("### " + tag + " > SORT.STOP: evt = %O, ui = %O", evt, ui);
        });
        this.on("sortactivate", function(evt, ui) {
          console.log("### " + tag + " > SORT.ACTIVATE: evt = %O, ui = %O", evt, ui);
        });
        this.on("sortdeactivate", function(evt, ui) {
          console.log("### " + tag + " > SORT.DEACTIVATE: evt = %O, ui = %O", evt, ui);
        });
        this.on("sortupdate", function(evt, ui) {
          console.log("### " + tag + " > SORT.UPDATE: evt = %O, ui = %O", evt, ui);
        });
        break;
      default:
        throw new Error('Call Error: Event type must be one of: ["drag", "drop", "sort"]');
    }
    return this;
  },
  /**
   * Make this element draggable.
   *
   * @function external:"jQuery.fn"#_makeDraggableField
   *
   * @param {object} [opts]
   * Change options passed to `draggable()`.
   */
  _makeDraggableField: function(opts) {
    opts = deepDefaults(true, {
      classes: {
        "ui-draggable-handle": "wcdv_drag_handle"
      },
      distance: 8,
      // FIXME Deprecated [1.12]: replacement will be in 1.13
      helper: "clone",
      appendTo: document.body,
      revert: true,
      revertDuration: 0
    });
    this.attr("title", "XXX");
    var tooltipContent = (0, import_jquery2.default)("<div>").append(fontAwesome("fa-info-circle").css("padding-right", "0.25em").addClass("wcdv_text-primary")).append(trans("GRID.TABLE.DRAGGABLE_FIELD_HELP"));
    this.tooltip({
      classes: {
        "ui-tooltip": "ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary"
      },
      show: { delay: 2e3 },
      content: tooltipContent
    });
    return this.draggable(opts);
  },
  _makeSortableTable: function(cb2) {
    var self2 = this;
    var helperClone = function(e2, tr) {
      var originals = tr.children(), clonedRow = tr.clone(), start_idx = tr.index(), all_rows = tr.parent().children(), all_select = tr.find("select");
      clonedRow.children().each(function(index2, val) {
        (0, import_jquery2.default)(val).width(originals.eq(index2).width());
      });
      clonedRow.find("select").val(function(index2) {
        return all_select.eq(index2).val();
      });
      for (var i2 = start_idx + 1; i2 < all_rows.length; i2++) {
        if (i2 % 2 == 0) {
          (0, import_jquery2.default)(all_rows[i2]).addClass("odd");
        } else {
          (0, import_jquery2.default)(all_rows[i2]).addClass("even");
        }
      }
      if (start_idx % 2 == 0) {
        clonedRow.addClass("odd");
      } else {
        clonedRow.addClass("even");
      }
      return clonedRow;
    };
    self2.on("keydown", "button.drag-handle", function(event) {
      var tr = (0, import_jquery2.default)(event.currentTarget).closest("tr"), oldIndex = tr.index(), newIndex = oldIndex;
      switch (event.keyCode) {
        case 38:
          event.preventDefault();
          if (tr.prev().length) {
            tr.insertBefore(tr.prev());
          } else {
            return true;
          }
          break;
        case 40:
          event.preventDefault();
          if (tr.next().length) {
            tr.insertAfter(tr.next());
          } else {
            return true;
          }
          break;
        default:
          return true;
      }
      newIndex = tr.index();
      if (oldIndex !== newIndex) {
        cb2(oldIndex, newIndex);
      }
      (0, import_jquery2.default)(event.currentTarget).focus();
    });
    var opts = {
      forcePlaceholderSize: true,
      axis: "y",
      cancel: "input,textarea,select,option",
      helper: helperClone,
      handle: ".drag-handle",
      containment: self2,
      // This event is triggered when sorting starts.
      start: function(event, ui) {
        ui.placeholder.height(ui.helper.height());
        ui.item.data("originIndex", ui.item.index());
      },
      // This event is triggered when sorting has stopped.
      stop: function(event, ui) {
        var oldIndex = ui.item.data("originIndex"), newIndex = ui.item.index();
        ui.item.parent().children().removeClass("even odd");
        if (typeof oldIndex !== "undefined" && typeof newIndex !== "undefined" && oldIndex !== newIndex) {
          cb2(oldIndex, newIndex);
        } else {
          (0, import_jquery2.default)(this).sortable("cancel");
        }
      }
    };
    self2.sortable(opts);
    return this;
  },
  /**
   * Specify what to do when a file is dropped onto this element.
   *
   * ```
   * $('#fileDropTarget')._onFileDrop(function (files) {
   *   something.addFiles(files);
   * });
   * ```
   *
   * @function external:"jQuery.fn"#_onFileDrop
   *
   * @param {function} cb
   * Function to call when the file is dropped; it is passed a `File` array.
   */
  _onFileDrop: function(cb2) {
    function handleFileSelect(evt) {
      evt.stopPropagation();
      evt.preventDefault();
      cb2(evt.dataTransfer.files);
    }
    function handleDragOver(evt) {
      evt.stopPropagation();
      evt.preventDefault();
      switch (getProp(evt.dataTransfer, "items", 0, "type")) {
        case "text/csv":
        case "application/csv":
        case "application/vnd.ms-excel":
          evt.dataTransfer.dropEffect = "copy";
          break;
        default:
          evt.dataTransfer.dropEffect = "none";
      }
    }
    this.get(0).addEventListener("dragover", handleDragOver, false);
    this.get(0).addEventListener("drop", handleFileSelect, false);
  },
  findFieldCell: function(field) {
    return this.children().filter(function(i2, elt2) {
      return (0, import_jquery2.default)(elt2).attr("data-wcdv-field") === field;
    });
  },
  /**
   * A shortcut for accessing DataVis-specific attributes on elements.
   *
   * @param {string|object} name
   * When a string, the partial name of the attribute.  When an object, sets the values of a bunch
   * of attributes at once.  In both cases, the attribute names are prefixed with `data-wcdv-`.
   *
   * @param {string} [val]
   * Assigns this value to the attribute, if provided.
   *
   * @returns {string|jQuery}
   * When getting, returns the attribute value, which is always a string because HTML.  When
   * setting, returns `this` for chaining purposes.
   */
  dvAttr: function() {
    var args = Array.prototype.slice.call(arguments);
    if (args.length === 1) {
      if (typeof args[0] === "string") {
        return this.attr("data-wcdv-" + args[0]);
      } else if (typeof args[0] === "object") {
        for (var p in args[0]) {
          if (Object.prototype.hasOwnProperty.call(args[0], p)) {
            args[0]["data-wcdv-" + p] = args[0][p];
            delete args[0][p];
          }
        }
        return this.attr(args[0]);
      } else {
        throw new Error("Call Error: Sole argument must be a string (getter) or object (setter)");
      }
    } else if (args.length === 2) {
      if (typeof args[0] !== "string") {
        throw new Error("Call Error: With two arguments, first argument must be a string");
      }
      if (args[1] != null && typeof args[1] !== "string" && typeof args[1] !== "number") {
        if (typeof args[1] === "boolean") {
          args[1] = args[1] ? "1" : "0";
        } else {
          throw new Error("Call Error: With two arguments, second must be a string, number, boolean, or null");
        }
      }
      return this.attr("data-wcdv-" + args[0], args[1]);
    } else {
      throw new Error("Call Error: dvAttr(string|object), dvAttr(string, string|number|boolean)");
    }
  }
});

// node_modules/wcdatavis/src/group_fun.js
var import_bignumber4 = __toESM(require_bignumber());
var import_numeral4 = __toESM(require_numeral());
var GroupFunction = makeSubclass("GroupFunction", Object, function(spec) {
  var self2 = this;
  spec = deepDefaults(spec, {});
  if (spec.displayName == null || typeof spec.displayName !== "string") {
    throw new Error("Call Error: `displayName` must be a string");
  }
  if (spec.allowedTypes != null && !index_default_default.isArray(spec.allowedTypes)) {
    throw new Error("Call Error: `allowedTypes` must be null or an array");
  }
  if (spec.valueFun != null && typeof spec.valueFun !== "function") {
    throw new Error("Call Error: `valueFun` must be null or a function");
  }
  if (spec.resultType != null && typeof spec.resultType !== "string") {
    throw new Error("Call Error: `resultType` must be null or a string");
  }
  if (spec.sortType != null && typeof spec.sortType !== "string") {
    throw new Error("Call Error: `sortType` must be null or a string");
  }
  if (spec.valueToFilter != null && typeof spec.valueToFilter !== "function") {
    throw new Error("Call Error: `valueToFilter` must be null or a function");
  }
  spec = deepDefaults(spec, {
    category: "other",
    resultType: "string",
    canFilter: true,
    valueToFilter: function(s2) {
      return { "$eq": s2 };
    }
  });
  if (spec.sortType == null) {
    spec.sortType = spec.resultType;
  }
  copyProps(spec, self2, ["category", "displayName", "allowedTypes", "valueFun", "resultType", "sortType", "canFilter", "valueToFilter"]);
});
GroupFunction.prototype.applyValueFun = function(x, fti) {
  return this.valueFun ? this.valueFun(x, fti) : x;
};
var GROUP_FUNCTION_REGISTRY = new ordmap_default();
GROUP_FUNCTION_REGISTRY.set("year", new GroupFunction({
  category: "date",
  displayName: trans("GRID.GROUP_FUN.DATE.YEAR"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("YYYY");
  },
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2, "YYYY").format("YYYY-MM-DD HH:mm:ss"),
      "$lte": moment_default(s2, "YYYY").add(1, "years").subtract(1, "seconds").format("YYYY-MM-DD HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("quarter", new GroupFunction({
  category: "repeating",
  displayName: trans("GRID.GROUP_FUN.REPEATING.QUARTER"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("[Q]Q");
  },
  // The View does not currently offer a filter that matches a date within a specific quarter
  // regardless of year (e.g. all dates in Q1 in any year).
  canFilter: false
}));
GROUP_FUNCTION_REGISTRY.set("month", new GroupFunction({
  category: "repeating",
  displayName: trans("GRID.GROUP_FUN.REPEATING.MONTH"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("MMM");
  },
  sortType: "month",
  // The View does not currently offer a filter that matches a date within a specific month
  // regardless of year (e.g. all dates in October in any year).
  canFilter: false
}));
GROUP_FUNCTION_REGISTRY.set("week_iso", new GroupFunction({
  category: "repeating",
  displayName: trans("GRID.GROUP_FUN.REPEATING.WEEK"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("[W]WW");
  },
  // The View does not currently offer a filter that matches a date within a specific week
  // regardless of year.
  canFilter: false
}));
GROUP_FUNCTION_REGISTRY.set("day_of_week", new GroupFunction({
  category: "repeating",
  displayName: trans("GRID.GROUP_FUN.REPEATING.DAY_OF_WEEK"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("ddd");
  },
  sortType: "day_of_week",
  // The View does not currently offer a filter that matches a date for a specific day of the week
  // (e.g. find all dates that fall on Tuesday).
  canFilter: false
}));
GROUP_FUNCTION_REGISTRY.set("year_and_quarter", new GroupFunction({
  category: "date",
  displayName: trans("GRID.GROUP_FUN.DATE.YEAR_AND_QUARTER"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("YYYY [Q]Q");
  },
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2, "YYYY [Q]Q").format("YYYY-MM-DD HH:mm:ss"),
      "$lte": moment_default(s2, "YYYY [Q]Q").add(1, "quarters").subtract(1, "seconds").format("YYYY-MM-DD HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("year_and_month", new GroupFunction({
  category: "date",
  displayName: trans("GRID.GROUP_FUN.DATE.YEAR_AND_MONTH"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("YYYY MMM");
  },
  sortType: "year_and_month",
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2, "YYYY MMM").format("YYYY-MM-DD HH:mm:ss"),
      "$lte": moment_default(s2, "YYYY MMM").add(1, "months").subtract(1, "seconds").format("YYYY-MM-DD HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("year_and_week_iso", new GroupFunction({
  category: "date",
  displayName: trans("GRID.GROUP_FUN.DATE.YEAR_AND_WEEK"),
  allowedTypes: ["date", "datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("YYYY [W]WW");
  },
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2, "YYYY [W]WW").format("YYYY-MM-DD HH:mm:ss"),
      "$lte": moment_default(s2, "YYYY [W]WW").add(1, "weeks").subtract(1, "seconds").format("YYYY-MM-DD HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("day", new GroupFunction({
  category: "date",
  displayName: trans("GRID.GROUP_FUN.DATE.FULL_DATE"),
  allowedTypes: ["datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("YYYY-MM-DD");
  },
  resultType: "date",
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2).format("YYYY-MM-DD HH:mm:ss"),
      "$lte": moment_default(s2).add(1, "days").subtract(1, "seconds").format("YYYY-MM-DD HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("day_and_time_1hr", new GroupFunction({
  category: "datetime",
  displayName: trans("GRID.GROUP_FUN.DATE_TIME.SLICE.1HR"),
  allowedTypes: ["datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("YYYY-MM-DD HH:00:00");
  },
  resultType: "datetime",
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2).format("YYYY-MM-DD HH:mm:ss"),
      "$lte": moment_default(s2).add(1, "hours").subtract(1, "seconds").format("YYYY-MM-DD HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("day_and_time_15min", new GroupFunction({
  category: "datetime",
  displayName: trans("GRID.GROUP_FUN.DATE_TIME.SLICE.15MIN"),
  allowedTypes: ["datetime"],
  valueFun: function(d2) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2);
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    var min3 = d2.minutes();
    var minStr = min3 >= 0 && min3 <= 14 ? "00" : min3 >= 15 && min3 <= 29 ? "15" : min3 >= 30 && min3 <= 44 ? "30" : min3 >= 45 && min3 <= 59 ? "45" : "00";
    return d2.format("YYYY-MM-DD HH:" + minStr + ":00");
  },
  resultType: "datetime",
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2).format("YYYY-MM-DD HH:mm:ss"),
      "$lte": moment_default(s2).add(15, "minutes").subtract(1, "seconds").format("YYYY-MM-DD HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("time_1hr", new GroupFunction({
  category: "time",
  displayName: trans("GRID.GROUP_FUN.TIME.SLICE.1HR"),
  allowedTypes: ["time"],
  valueFun: function(d2, fti) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2, getProp(fti, "format"));
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    return d2.format("HH:00:00");
  },
  resultType: "time",
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2).format("HH:mm:ss"),
      "$lte": moment_default(s2).add(1, "hours").subtract(1, "seconds").format("HH:mm:ss")
    };
  }
}));
GROUP_FUNCTION_REGISTRY.set("time_15min", new GroupFunction({
  category: "time",
  displayName: trans("GRID.GROUP_FUN.TIME.SLICE.15MIN"),
  allowedTypes: ["time"],
  valueFun: function(d2, fti) {
    if (typeof d2 === "string") {
      d2 = moment_default(d2, getProp(fti, "format"));
    }
    if (!moment_default.isMoment(d2) || !d2.isValid()) {
      return "Invalid Date";
    }
    var min3 = d2.minutes();
    var minStr = min3 >= 0 && min3 <= 14 ? "00" : min3 >= 15 && min3 <= 29 ? "15" : min3 >= 30 && min3 <= 44 ? "30" : min3 >= 45 && min3 <= 59 ? "45" : "00";
    return d2.format("HH:" + minStr + ":00");
  },
  resultType: "time",
  valueToFilter: function(s2) {
    return {
      "$gte": moment_default(s2).format("HH:mm:ss"),
      "$lte": moment_default(s2).add(15, "minutes").subtract(1, "seconds").format("HH:mm:ss")
    };
  }
}));

// node_modules/wcdatavis/src/grid_filter.js
var import_numeral6 = __toESM(require_numeral());
var import_bignumber6 = __toESM(require_bignumber());

// node_modules/wcdatavis/src/ui/grid_filter.js
var import_numeral5 = __toESM(require_numeral());
var import_jquery3 = __toESM(require_jquery());
var import_bignumber5 = __toESM(require_bignumber());
var GridFilter = function() {
  var id = 0;
  var genId = function() {
    return "GridFilter_" + id++;
  };
  return makeSubclass("GridFilter", Object, function(field, gridFilterSet, typeInfo, opts) {
    var self2 = this;
    var localRemoveButton;
    self2.id = genId();
    self2.field = field;
    self2.gridFilterSet = gridFilterSet;
    self2.typeInfo = typeInfo;
    self2.opts = opts;
    self2.limit = 0;
    self2.applyImmediately = false;
    self2.div = (0, import_jquery3.default)("<div>").addClass("wcdv_filter_control_filter");
    if (self2.opts.makeRemoveButton) {
      self2.removeBtn = self2.makeRemoveBtn();
      localRemoveButton = self2.removeBtn;
    } else if (self2.opts.removeButton) {
      localRemoveButton = self2.opts.removeButton;
    }
    if (localRemoveButton) {
      localRemoveButton.on("click", function() {
        self2.gridFilterSet.remove(self2.getId(), self2.opts.filterButton);
        if (typeof self2.opts.onRemove === "function") {
          self2.opts.onRemove();
        }
      });
    }
    if (self2.gridFilterSet.gridTable) {
      self2.gridFilterSet.gridTable.on("columnResize", function() {
        self2.adjustInputWidth({ useSizingElement: true, fromColumnResize: true });
      });
    }
  });
}();
GridFilter.prototype.getValue = function() {
  var self2 = this, fti = self2.gridFilterSet.view.typeInfo.get(self2.field);
  switch (fti.type) {
    case "date":
    case "time":
    case "datetime":
      if (self2.input.val() === "") {
        return void 0;
      }
      return fti.internalType === "moment" ? moment_default(self2.input.val()) : self2.input.val();
    case "number":
    case "currency":
      if (self2.input.val() === "") {
        return void 0;
      }
      switch (fti.internalType) {
        case "bignumber":
          return new import_bignumber5.default(self2.input.val());
        case "numeral":
          return (0, import_numeral5.default)(self2.input.val());
        case "primitive":
          return isInt(self2.input.val()) ? toInt2(self2.input.val()) : isFloat(self2.input.val()) ? toFloat(self2.input.val()) : self2.input.val();
        default:
          return self2.input.val();
      }
    case "string":
    default:
      return self2.input.val();
  }
};
GridFilter.prototype.setValue = function(val) {
  var self2 = this;
  if (["$exists", "$notexists"].indexOf(self2.getOperator()) < 0) {
    if (import_numeral5.default && import_numeral5.default.isNumeral(val)) {
      self2.input.val(val._value);
    } else {
      self2.input.val(val);
    }
  }
};
GridFilter.prototype.getOperator = function() {
  var self2 = this;
  return self2.operatorDrop.val();
};
GridFilter.prototype.setOperator = function(op) {
  var self2 = this;
  if (self2.operatorDrop) {
    self2.operatorDrop.val(op);
    self2.operatorDrop.change();
  }
};
GridFilter.prototype.getId = function() {
  return this.id;
};
GridFilter.prototype.makeOperatorDrop = function(include) {
  var self2 = this;
  var operators = [
    ["$contains", ""],
    ["$notcontains", ""],
    ["$eq", "="],
    ["$ne", ""],
    ["$gt", ">"],
    ["$gte", ""],
    ["$lt", "<"],
    ["$lte", ""],
    ["$in", "in"],
    ["$nin", "not in"],
    ["$exists", "not blank"],
    ["$notexists", "blank"]
  ];
  if (include !== void 0 && index_default_default.isArray(include)) {
    operators = index_default_default.reject(operators, function(elt2) {
      return include.indexOf(elt2[0]) < 0;
    });
  }
  var operatorDrop = (0, import_jquery3.default)("<select>");
  operatorDrop.css({ "margin-right": "0.5em" });
  index_default_default.each(operators, function(op) {
    var value = op[0], name = op[1];
    operatorDrop.append((0, import_jquery3.default)("<option>", { value }).text(name));
  });
  operatorDrop.on("change", function() {
    if (self2.input) {
      ["$exists", "$notexists"].indexOf(self2.getOperator()) >= 0 ? self2.hideInput() : self2.showInput();
    }
    if (["$exists", "$notexists"].indexOf(self2.getOperator()) >= 0 || self2.getValue() !== "") {
      self2.gridFilterSet.update();
    }
  });
  return operatorDrop;
};
GridFilter.prototype.makeRemoveBtn = function() {
  var self2 = this;
  var removeBtn = (0, import_jquery3.default)(fontAwesome("F00D", null, "Click to remove filter"));
  removeBtn.css({ "cursor": "pointer", "margin-left": "0.5em" });
  return removeBtn;
};
GridFilter.prototype.remove = function() {
  var self2 = this;
  self2.div.remove();
  self2.gridFilterSet.update(false);
};
GridFilter.prototype.isRange = function() {
  return false;
};
GridFilter.prototype.adjustInputWidth = function(opts) {
  var self2 = this;
  if (!self2.opts.autoUpdateInputWidth) {
    return;
  }
  if (opts === void 0) {
    opts = {};
  }
  index_default_default.defaults(opts, {
    useSizingElement: false,
    input: self2.input
  });
  console.debug("[DataVis // Grid Filter // Adjust Input Width] Target: %O", opts.input);
  var targetWidth = opts.useSizingElement ? self2.opts.sizingElement.width() : self2.div.width();
  console.debug("[DataVis // Grid Filter // Adjust Input Width] Available Space: " + targetWidth + "px " + (opts.useSizingElement ? "[sizing element]" : "[div]"));
  if (self2.removeBtn) {
    targetWidth -= self2.removeBtn.outerWidth();
    console.debug("[DataVis // Grid Filter // Adjust Input Width] Remove Button: " + self2.removeBtn.outerWidth() + "px");
  }
  if (self2.operatorDrop !== void 0) {
    targetWidth -= self2.operatorDrop.outerWidth();
    console.debug("[DataVis // Grid Filter // Adjust Input Width] Operator Drop: " + self2.operatorDrop.outerWidth() + "px");
  }
  console.debug("[DataVis // Grid Filter" + (opts.fromColumnResize ? " // Handler(columnResize)" : "") + "] Adjusting " + self2.field + " filter widget width to " + targetWidth + "px to match column width");
  opts.input.outerWidth(targetWidth);
  if (typeof opts.callback === "function") {
    opts.callback(targetWidth);
  }
};
GridFilter.prototype.showInput = function(input) {
  var self2 = this;
  self2.input.show();
};
GridFilter.prototype.hideInput = function(input) {
  var self2 = this;
  self2.input.hide();
};
var grid_filter_default = GridFilter;

// node_modules/wcdatavis/src/ui/filters/date.js
var import_jquery4 = __toESM(require_jquery());
var DateFilter = makeSubclass("DateFilter", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.limit = 1;
  self2.operatorDrop = self2.makeOperatorDrop();
  var everyOpts = {
    day: [
      "MONDAY",
      "TUESDAY",
      "WEDNESDAY",
      "THURSDAY",
      "FRIDAY",
      "SATURDAY",
      "SUNDAY"
    ],
    month: [
      "JANUARY",
      "FEBRUARY",
      "MARCH",
      "APRIL",
      "MAY",
      "JUNE",
      "JULY",
      "AUGUST",
      "SEPTEMBER",
      "OCTOBER",
      "NOVEMBER",
      "DECEMBER"
    ]
  };
  var lastOpts = [
    "DATE",
    "WEEK",
    "MONTH",
    "QUARTER",
    "YEAR"
  ];
  self2.inputs = {};
  self2.inputs.single = (0, import_jquery4.default)("<input>").attr({
    type: self2.typeInfo.type === "date" ? "date" : "datetime-local"
  }).on("blur", function() {
    self2.gridFilterSet.update(false);
  });
  self2.inputs.range = (0, import_jquery4.default)("<div>");
  self2.inputs.rangeStart = (0, import_jquery4.default)("<input>").attr({
    type: self2.typeInfo.type === "date" ? "date" : "datetime-local"
  }).on("blur", function() {
    self2.gridFilterSet.update(false);
  });
  self2.inputs.rangeEnd = (0, import_jquery4.default)("<input>").attr({
    type: self2.typeInfo.type === "date" ? "date" : "datetime-local"
  }).on("blur", function() {
    self2.gridFilterSet.update(false);
  });
  self2.inputs.range.append(self2.inputs.rangeStart).append("  ").append(self2.inputs.rangeEnd);
  self2.inputs.every = (0, import_jquery4.default)("<div>");
  self2.inputs.everyDay = (0, import_jquery4.default)("<select>").on("change", function() {
    self2.gridFilterSet.update(false);
  });
  self2.inputs.everyMonth = (0, import_jquery4.default)("<select>").on("change", function() {
    self2.gridFilterSet.update(false);
  });
  index_default_default.each(everyOpts.day, function(v) {
    self2.inputs.everyDay.append((0, import_jquery4.default)("<option>", { value: v }).text(trans("CALENDAR.DAY." + v)));
  });
  index_default_default.each(everyOpts.month, function(v) {
    self2.inputs.everyMonth.append((0, import_jquery4.default)("<option>", { value: v }).text(trans("CALENDAR.MONTH." + v)));
  });
  self2.inputs.everyDropdown = (0, import_jquery4.default)("<select>").css({ "margin-right": "0.5em" }).append((0, import_jquery4.default)("<option>", { value: "DAY" }).text(trans("CALENDAR.DAY"))).append((0, import_jquery4.default)("<option>", { value: "MONTH" }).text(trans("CALENDAR.MONTH"))).on("change", function() {
    self2.inputs.everyDay.hide();
    self2.inputs.everyMonth.hide();
    switch (this.value) {
      case "DAY":
        self2.inputs.everyDay.show();
        break;
      case "MONTH":
        self2.inputs.everyMonth.show();
        break;
    }
    self2.gridFilterSet.update(false);
  });
  self2.inputs.every.append(self2.inputs.everyDropdown.show()).append(self2.inputs.everyDay.show()).append(self2.inputs.everyMonth.hide());
  self2.inputs.last = (0, import_jquery4.default)("<select>").on("change", function() {
    self2.gridFilterSet.update(false);
  });
  index_default_default.each(lastOpts, function(v) {
    self2.inputs.last.append((0, import_jquery4.default)("<option>", { value: v }).text(trans("CALENDAR." + v)));
  });
  self2.div.append(self2.operatorDrop).append(self2.inputs.single.show()).append(self2.inputs.range.hide()).append(self2.inputs.every.hide()).append(self2.inputs.last.hide());
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
});
DateFilter.prototype.makeOperatorDrop = function() {
  var self2 = this;
  var operators = [
    ["$eq", "ON"],
    ["$bet", "BETWEEN"],
    ["$lte", "BEFORE"],
    ["$gte", "AFTER"],
    ["$every", "EVERY"],
    ["$this", "CURRENT"],
    ["$last", "LAST"]
  ];
  var operatorDrop = (0, import_jquery4.default)("<select>");
  operatorDrop.css({ "margin-right": "0.5em" });
  index_default_default.each(operators, function(op) {
    var value = op[0], name = op[1];
    operatorDrop.append((0, import_jquery4.default)("<option>", { value }).text(trans("FILTER.DATE.OPERATOR." + name)));
  });
  operatorDrop.on("change", function() {
    self2.inputs.single.hide();
    self2.inputs.range.hide();
    self2.inputs.every.hide();
    self2.inputs.last.hide();
    switch (this.value) {
      case "$eq":
      case "$ne":
      case "$lte":
      case "$gte":
        self2.inputs.single.show();
        break;
      case "$bet":
        self2.inputs.range.show();
        break;
      case "$every":
        self2.inputs.every.show();
        break;
      case "$this":
      case "$last":
        self2.inputs.last.show();
        break;
    }
    self2.gridFilterSet.update();
  });
  return operatorDrop;
};
DateFilter.prototype.getValue = function() {
  var self2 = this, result2;
  switch (self2.getOperator()) {
    case "$eq":
    case "$ne":
    case "$gte":
    case "$lte":
      if (self2.inputs.single.val() === "") {
        break;
      }
      result2 = self2.typeInfo.type === "date" ? self2.inputs.single.val() : self2.inputs.single.val().replace("T", " ");
      if (self2.typeInfo.internalType === "moment") {
        result2 = moment_default(result2);
      }
      break;
    case "$bet":
      if (self2.inputs.rangeStart.val() === "" || self2.inputs.rangeEnd.val() === "") {
        break;
      }
      switch (self2.typeInfo.type) {
        case "date":
          result2 = [
            self2.inputs.rangeStart.val(),
            self2.inputs.rangeEnd.val()
          ];
          break;
        case "datetime":
          result2 = [
            self2.inputs.rangeStart.val().replace("T", " "),
            self2.inputs.rangeEnd.val().replace("T", " ")
          ];
          break;
      }
      if (self2.typeInfo.internalType === "moment") {
        result2[0] = moment_default(result2[0]);
        result2[1] = moment_default(result2[1]);
      }
      break;
    case "$every":
      result2 = self2.inputs.everyDropdown.val() === "DAY" ? self2.inputs.everyDay.val() : self2.inputs.everyDropdown.val() === "MONTH" ? self2.inputs.everyMonth.val() : null;
      break;
    case "$this":
    case "$last":
      result2 = self2.inputs.last.val();
      break;
  }
  return result2;
};
DateFilter.prototype.setValue = function(val1, val2) {
  var self2 = this;
  switch (self2.getOperator()) {
    case "$bet":
      self2.inputs.rangeStart.val(val1);
      self2.inputs.rangeEnd.val(val2);
      break;
    case "$eq":
    case "$ne":
    case "$lte":
    case "$gte":
      self2.inputs.single.val(val1);
      break;
    case "$every":
      var days2 = ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"];
      var months2 = ["JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER"];
      var dayIdx = days2.indexOf(val1);
      var monthIdx = months2.indexOf(val1);
      if (dayIdx >= 0) {
        self2.inputs.everyDropdown.val("DAY").change();
        self2.inputs.everyDay.val(val1);
      } else if (monthIdx >= 0) {
        self2.inputs.everyDropdown.val("MONTH").change();
        self2.inputs.everyMonth.val(val1);
      } else {
        console.error('Invalid filter for operator "' + self2.getOperator() + '" and value "' + val1 + '"');
      }
      break;
    case "$this":
    case "$last":
      self2.inputs.last.val(val1);
      break;
  }
};
var date_default = DateFilter;

// node_modules/wcdatavis/src/grid_filter.js
var StringTextboxGridFilter = makeSubclass("StringTextboxGridFilter", grid_filter_default, function() {
  var self2 = this;
  self2.ctor.apply(self2, arguments);
  self2.input = jQuery('<input type="text">');
  self2.input.on("change", function(evt) {
    self2.gridFilterSet.update(false);
  });
  self2.operatorDrop = self2.makeOperatorDrop(
    /*['$eq', '$ne']*/
  );
  self2.div.append(self2.operatorDrop).append(self2.input);
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
});
var StringDropdownGridFilterChosen = makeSubclass("StringDropdownGridFilterChosen", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.super = makeSuper(self2, grid_filter_default);
  self2.limit = 1;
  self2.input = jQuery("<select>").attr({
    "multiple": true
  });
  self2.input.on("change", function(evt) {
    self2.gridFilterSet.update(false);
  });
  self2.div.append(self2.input);
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
  self2.afterAdd = function(target) {
    self2.gridFilterSet.view.getUniqueVals(function(uniqueVals) {
      index_default_default.each(getPropDef([], uniqueVals, self2.field, "values"), function(val) {
        jQuery("<option>").attr({
          "value": val
        }).text(val).appendTo(self2.input);
      });
      self2.input.chosen({ "width": self2.div.innerWidth() - self2.removeBtn.outerWidth() });
      self2.chosen = self2.input.next("div.chosen-container");
    });
  };
  if (self2.gridFilterSet.gridTable) {
    self2.gridFilterSet.gridTable.on("columnResize", function() {
      var targetWidth = self2.opts.sizingElement.innerWidth() - self2.removeBtn.outerWidth() - 14;
      console.debug("[DataVis // Grid Filter // Handler(GridTablePlain.columnResize)] Adjusting Chosen widget width to " + targetWidth + "px to match column width");
      self2.chosen.innerWidth(targetWidth);
    });
  }
});
StringDropdownGridFilterChosen.prototype.getOperator = function() {
  return "$in";
};
StringDropdownGridFilterChosen.prototype.getValue = function() {
  var self2 = this, val = self2.super.getValue(self2);
  return val === null ? void 0 : val;
};
var StringDropdownGridFilterSumo = makeSubclass("StringDropdownGridFilterSumo", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.super = makeSuper(self2, grid_filter_default);
  self2.limit = 1;
  self2.minDropdownWidth = 200;
  self2.input = jQuery("<select>").attr({
    "multiple": true
  }).on("change", function(evt) {
    if (self2.pleaseDontFireChangeEvent) {
      delete self2.pleaseDontFireChangeEvent;
      return;
    }
    self2.gridFilterSet.update(false);
  });
  self2.operatorDrop = self2.makeOperatorDrop(["$in", "$nin", "$exists", "$notexists"]);
  self2.div.append(self2.operatorDrop);
  self2.div.append(self2.input);
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
  self2.afterAdd = function(target) {
    self2.gridFilterSet.view.getUniqueVals(function(uniqueVals) {
      index_default_default.each(getPropDef([], uniqueVals, self2.field, "values"), function(val) {
        jQuery("<option>").attr({
          "value": val
        }).text(val === "" ? "[blank]" : val).appendTo(self2.input);
      });
      self2.input.SumoSelect({
        triggerChangeCombined: true,
        selectAll: true,
        search: true,
        okCancelInMulti: true,
        isClickAwayOk: true
      });
      self2.optWrapper = self2.input.closest("div.SumoSelect").find("div.optWrapper");
    });
  };
});
StringDropdownGridFilterSumo.prototype.adjustInputWidth = function(opts) {
  var self2 = this;
  if (opts === void 0) {
    opts = {};
  }
  opts.input = self2.input.closest("div.SumoSelect");
  opts.callback = function(width) {
    self2.optWrapper.outerWidth(Math.max(width, self2.minDropdownWidth));
  };
  self2.super.adjustInputWidth(opts);
};
StringDropdownGridFilterSumo.prototype.getValue = function() {
  var self2 = this, val = self2.super.getValue();
  return val === null ? void 0 : val;
};
StringDropdownGridFilterSumo.prototype.setValue = function(val) {
  var self2 = this;
  if (!index_default_default.isArray(val)) {
    val = [val];
  } else {
    val = index_default_default.flatten(val);
  }
  index_default_default.each(val, function(v) {
    if (typeof v === "string") {
      self2.pleaseDontFireChangeEvent = true;
      self2.input.get(0).sumo.selectItem(v);
    }
  });
};
StringDropdownGridFilterSumo.prototype.setOperator = function(op) {
  var self2 = this;
  if (op === "$eq") {
    op = "$in";
  }
  return self2.super.setOperator(op);
};
StringDropdownGridFilterSumo.prototype.showInput = function(op) {
  var self2 = this;
  self2.input.closest("div.SumoSelect").show();
};
StringDropdownGridFilterSumo.prototype.hideInput = function(op) {
  var self2 = this;
  self2.input.closest("div.SumoSelect").hide();
};
var NumberTextboxGridFilter = makeSubclass("NumberTextboxGridFilter", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.input = jQuery("<input>", {
    "type": "text"
  });
  self2.input.attr("size", "10");
  self2.input.on("change", function(evt) {
    self2.gridFilterSet.update(false);
  });
  self2.operatorDrop = self2.makeOperatorDrop(["$eq", "$ne", "$lt", "$lte", "$gt", "$gte", "$exists", "$notexists"]);
  self2.div.append(self2.operatorDrop);
  self2.div.append(self2.input);
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
});
var NumberCheckboxGridFilter = makeSubclass("NumberCheckboxGridFilter", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.input = jQuery("<input>", { "id": gensym(), "type": "checkbox" });
  self2.input.on("change", function() {
    self2.gridFilterSet.update(false);
  });
  self2.div.append(jQuery("<label>").append(self2.input).append(" Filter"));
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
  self2.limit = 1;
});
NumberCheckboxGridFilter.prototype.getValue = function() {
  return this.input[0].checked ? 1 : 0;
};
NumberCheckboxGridFilter.prototype.getOperator = function() {
  return "$eq";
};
var NumberTriBoolGridFilter = makeSubclass("NumberTriBoolGridFilter", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.inputName = gensym();
  var trueRadio = jQuery("<input>", { "type": "radio", "name": self2.inputName, "value": "true" });
  var falseRadio = jQuery("<input>", { "type": "radio", "name": self2.inputName, "value": "false" });
  var bothRadio = jQuery("<input>", { "type": "radio", "name": self2.inputName, "value": "both" });
  self2.inputs = jQuery([trueRadio.get(0), falseRadio.get(0), bothRadio.get(0)]);
  self2.inputs.css("margin-right", "0.4em");
  self2.inputs.each(function(i2, elt2) {
    elt2 = jQuery(elt2);
    elt2.on("change", function(evt) {
      self2.gridFilterSet.update(false);
    });
  });
  self2.div.append(jQuery("<label>").append(trueRadio).append("True")).append(jQuery("<label>").css("padding-left", "0.8em").append(falseRadio).append("False")).append(jQuery("<label>").css("padding-left", "0.8em").append(bothRadio).append("Both"));
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
  self2.limit = 1;
});
NumberTriBoolGridFilter.prototype.getValue = function() {
  var self2 = this;
  var val = self2.inputs.filter(":checked").val();
  switch (val) {
    case "true":
      return 1;
    case "false":
      return 0;
    case "both":
      return void 0;
    default:
      throw new Error("Impossible");
  }
};
NumberTriBoolGridFilter.prototype.setValue = function(val) {
  var self2 = this;
  var internalVal;
  switch (val) {
    case 0:
      internalVal = "false";
      break;
    case 1:
      internalVal = "true";
      break;
    default:
      internalVal = "both";
  }
  self2.inputs.filter('[value="' + internalVal + '"]').prop("checked", true);
};
NumberTriBoolGridFilter.prototype.getOperator = function() {
  return "$eq";
};
var DateSingleGridFilter = makeSubclass("DateSingleGridFilter", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.input = jQuery("<input>").attr({
    "type": "text",
    "placeholder": "Select date..."
  });
  self2.input.flatpickr({
    "altInput": false,
    "allowInput": true,
    "onChange": function(selectedDates, dateStr, instance) {
      console.log(selectedDates, dateStr);
    }
  });
  self2.div.append(self2.input);
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
});
var DateRangeGridFilter = makeSubclass("DateRangeGridFilter", grid_filter_default, function() {
  var self2 = this;
  grid_filter_default.apply(self2, arguments);
  self2.limit = 1;
  self2.input = jQuery("<input>").attr({
    "type": "text",
    "placeholder": "Click here; pick start/end dates.",
    "size": 28
  });
  self2.widget = self2.input.flatpickr({
    "altInput": false,
    "allowInput": true,
    "mode": "range",
    "onChange": function(selectedDates, dateStr, instance) {
      self2.selectedDates = selectedDates;
      self2.gridFilterSet.update(false);
    }
  });
  self2.div.append(self2.input);
  if (self2.removeBtn) {
    self2.div.append(self2.removeBtn);
  }
});
DateRangeGridFilter.prototype.getValue = function() {
  var self2 = this, result2;
  if (self2.selectedDates == null) {
    return void 0;
  }
  if (self2.isRange()) {
    result2 = {
      "start": moment_default(self2.selectedDates[0]),
      "end": moment_default(self2.selectedDates[1]).hour(23).minute(59).second(59)
    };
    if (self2.typeInfo.internalType === "string") {
      if (self2.typeInfo.type === "date") {
        result2 = index_default_default.mapObject(result2, function(m2) {
          return m2.format("YYYY-MM-DD");
        });
      } else if (self2.typeInfo.type === "datetime") {
        result2 = index_default_default.mapObject(result2, function(m2) {
          return m2.format("YYYY-MM-DD HH:mm:ss");
        });
      }
    }
  } else {
    result2 = moment_default(self2.selectedDates[0]);
    if (self2.typeInfo.internalType === "string") {
      if (self2.typeInfo.type === "date") {
        result2 = result2.format("YYYY-MM-DD");
      } else if (self2.typeInfo.type === "datetime") {
        result2 = result2.format("YYYY-MM-DD HH:mm:ss");
      }
    }
  }
  return result2;
};
DateRangeGridFilter.prototype.setValue = function(val) {
  var self2 = this;
  self2.selectedDates = val;
  self2.widget.setDate(val);
};
DateRangeGridFilter.prototype.getOperator = function() {
  var self2 = this;
  if (self2.isRange()) {
    return ["$gte", "$lte"];
  }
  return "$gte";
};
DateRangeGridFilter.prototype.isRange = function() {
  var self2 = this;
  return self2.selectedDates != null && self2.selectedDates.length > 1;
};
var BooleanCheckboxGridFilter = makeSubclass("BooleanCheckboxGridFilter", grid_filter_default, function(field, gridFilter) {
});
BooleanCheckboxGridFilter.prototype.getValue = function() {
  return this.input.val();
};
BooleanCheckboxGridFilter.prototype.getOperator = function() {
  return "$eq";
};
BooleanCheckboxGridFilter.prototype.getId = function() {
  return this.input.attr("id");
};
grid_filter_default.widgets = {
  "string": {
    "textbox": StringTextboxGridFilter,
    "dropdown": StringDropdownGridFilterSumo
  },
  "number": {
    "textbox": NumberTextboxGridFilter,
    "checkbox": NumberCheckboxGridFilter,
    "tribool": NumberTriBoolGridFilter
  },
  "currency": {
    "textbox": NumberTextboxGridFilter
  },
  "date": {
    "single": DateSingleGridFilter,
    "range": DateRangeGridFilter,
    "neon": date_default
  },
  "datetime": {
    "single": DateSingleGridFilter,
    "range": DateRangeGridFilter,
    "neon": date_default
  }
};
grid_filter_default.defaultWidgets = {
  "string": "dropdown",
  "number": "textbox",
  "currency": "textbox",
  "date": "neon",
  "datetime": "neon"
};
var GridFilterSet = makeSubclass("GridFilterSet", Object, function(view, prefs, gridTable, progress, opts) {
  var self2 = this;
  self2.view = view;
  self2.prefs = prefs;
  self2.gridTable = gridTable;
  self2.progress = progress;
  self2.opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true
  });
  self2.filters = {
    all: [],
    byId: {},
    byCol: {}
  };
  self2.delayUpdate = false;
});
mixinEventHandling(GridFilterSet, [
  "filterAdded",
  "filterRemoved",
  "widgetResizedHoriz",
  "widgetResizedVert"
]);
GridFilterSet.prototype.add = function(field, target, opts) {
  var self2 = this, filter2;
  opts = opts || {};
  filter2 = self2.build(field, target, opts);
  if (filter2 == null) {
    return null;
  }
  if (self2.filters.byCol[field] === void 0) {
    self2.filters.byCol[field] = [];
  }
  self2.filters.all.push(filter2);
  self2.filters.byCol[field].push(filter2);
  self2.filters.byId[filter2.getId()] = filter2;
  target.append(filter2.div);
  if (typeof filter2.afterAdd === "function") {
    filter2.afterAdd(target);
  }
  filter2.adjustInputWidth();
  if (opts.filterBtn && self2.filters.byCol[field].length === filter2.limit) {
    opts.filterBtn.hide();
  }
  self2.fire(GridFilterSet.events.filterAdded);
  if (filter2.applyImmediately) {
    self2.update();
  }
  return filter2;
};
GridFilterSet.prototype.build = function(field, target, opts) {
  var self2 = this;
  var fti = self2.view.typeInfo.get(field);
  if (fti == null) {
    return null;
  }
  var colType = fti.type;
  if (colType == null) {
    throw new Error('Unable to determine type of column "' + field + '"');
  }
  if (grid_filter_default.widgets[colType] === void 0) {
    throw new Error('Unknown type "' + colType + '" for column "' + field + '"');
  }
  var filterType = opts.filterType || grid_filter_default.defaultWidgets[colType];
  var ctor2 = grid_filter_default.widgets[colType][filterType];
  if (ctor2 === void 0) {
    throw new Error('Invalid filter type "' + filterType + '" for type "' + colType + '" of column "' + field + '"');
  }
  console.debug('[DataVis // Grid Filter] Creating new widget: column type = "' + colType + '" ; filter type = "' + filterType + '"');
  return new ctor2(field, self2, fti, opts);
};
GridFilterSet.prototype.remove = function(id, filterBtn, noEvent) {
  var self2 = this, filter2 = self2.filters.byId[id];
  if (filter2 === void 0) {
    log.warn('Attempted to remove filter with ID "' + id + `" from the grid, but it doesn't exist`);
    return;
  }
  var sameId = function(elt2) {
    return elt2.getId() === id;
  };
  var allIndex = index_default_default.findIndex(self2.filters.all, sameId);
  var colIndex = index_default_default.findIndex(self2.filters.byCol[filter2.field], sameId);
  delete self2.filters.byId[id];
  self2.filters.all.splice(allIndex, 1);
  self2.filters.byCol[filter2.field].splice(colIndex, 1);
  filter2.remove();
  if (filterBtn && self2.filters.byCol[filter2.field].length < filter2.limit) {
    filterBtn.show();
  }
  if (!noEvent) {
    self2.fire(GridFilterSet.events.filterRemoved);
  }
};
GridFilterSet.prototype.removeField = function(fieldName, filterBtn) {
  var self2 = this;
  index_default_default.each(self2.filters.byCol[fieldName], function(filter2) {
    self2.remove(filter2.getId(), filterBtn, true);
  });
  self2.fire(GridFilterSet.events.filterRemoved);
};
GridFilterSet.prototype.reset = function(opts) {
  var self2 = this;
  opts = opts || {};
  index_default_default.defaults(opts, {
    updateView: true
  });
  self2.delayUpdate = true;
  index_default_default.each(self2.filters.all, function(filter2) {
    filter2.remove();
  });
  self2.filters = {
    all: [],
    byId: {},
    byCol: {}
  };
  if (opts.updateView) {
    self2.view.clearFilter();
  }
  self2.delayUpdate = false;
};
GridFilterSet.prototype.update = function() {
  var self2 = this, spec = {};
  if (self2.delayUpdate) {
    return;
  }
  if (self2.filters.all.length === 0) {
    self2.view.setFilter(null);
    return;
  }
  index_default_default.each(self2.filters.byCol, function(filterList, field) {
    index_default_default.each(filterList, function(filter2) {
      var operator = filter2.getOperator();
      var value = filter2.getValue();
      if (value === void 0 && ["$exists", "$notexists"].indexOf(operator) < 0) {
        return;
      }
      if (spec[field] === void 0) {
        spec[field] = {};
      }
      if (operator === "$exists") {
        spec[field]["$exists"] = true;
      } else if (operator === "$notexists") {
        spec[field]["$notexists"] = true;
      } else if (operator === "$bet") {
        spec[field]["$gte"] = value[0];
        spec[field]["$lte"] = value[1];
      } else if (spec[field][operator] === void 0) {
        spec[field][operator] = value;
      } else if (index_default_default.isArray(spec[field][operator])) {
        spec[field][operator].push(value);
      } else if (["$eq", "$ne", "$contains"].indexOf(operator) >= 0) {
        spec[field][operator] = [spec[field][operator], value];
      } else {
        spec[field][operator] = value;
      }
    });
  });
  console.debug("[DataVis // Grid Filter Set] Updating with " + self2.filters.all.length + " filters: ", spec);
  self2.view.setFilter(spec, self2.progress, self2.opts);
};
GridFilterSet.prototype.set = function(field, fieldSpec, opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    updateView: true
  });
  if (typeof fieldSpec !== "object") {
    fieldSpec = { "$eq": fieldSpec };
  }
  var filters = self2.filters.byCol[field];
  if (filters == null || filters.length == null || filters.length === 0) {
    return;
  }
  var widget = filters[0];
  if (!opts.updateView) {
    self2.delayUpdate = true;
  }
  if (widget instanceof DateRangeGridFilter && "$lte" in fieldSpec && "$gte" in fieldSpec) {
    widget.setValue([fieldSpec["$gte"], fieldSpec["$lte"]]);
  } else if (widget instanceof date_default && "$lte" in fieldSpec && "$gte" in fieldSpec) {
    widget.setOperator("$bet");
    widget.setValue(fieldSpec["$gte"], fieldSpec["$lte"]);
  } else {
    index_default_default.each(fieldSpec, function(val, op) {
      console.debug(
        "[DataVis // Grid Filter Set] Setting filter: { field = %s ; operator = %s ; value = %s }",
        field,
        op,
        typeof val === "object" ? JSON.stringify(val) : val
      );
      widget.setOperator(op);
      widget.setValue(val);
    });
  }
  if (!opts.updateView) {
    self2.delayUpdate = false;
  }
};

// node_modules/wcdatavis/src/group_fun_win.js
var GroupFunWin = makeSubclass("GroupFunWin", Object, function(title, groupFuns) {
  var self2 = this;
  var winEffect = {
    effect: "fade",
    duration: 100
  };
  var selected = null;
  self2.win = jQuery("<div>", { title }).dialog({
    autoOpen: false,
    modal: true,
    width: "600",
    position: {
      my: "center",
      at: "center",
      of: window
    },
    classes: {
      "ui-dialog": "ui-corner-all wcdv_dialog",
      "ui-dialog-titlebar": "ui-corner-all"
    },
    show: winEffect,
    hide: winEffect,
    open: function() {
      selected = null;
    },
    close: function() {
      self2.cb(selected);
    }
  });
  var root2 = jQuery("<div>").css({
    "display": "flex"
  }).appendTo(self2.win);
  var categories = new ordmap_default();
  categories.set("repeating", { display: trans("GRID.GROUP_FUN.DIALOG.REPEATING") });
  categories.set("date", { display: trans("GRID.GROUP_FUN.DIALOG.DATE") });
  categories.set("datetime", { display: trans("GRID.GROUP_FUN.DIALOG.DATE_TIME") });
  categories.set("time", { display: trans("GRID.GROUP_FUN.DIALOG.TIME") });
  categories.set("other", { display: trans("GRID.GROUP_FUN.DIALOG.OTHER") });
  categories.each(function(c2) {
    c2.div = jQuery("<div>", { "class": "wcdv_groupfun_buttons" });
    c2.root = jQuery("<div>").css({ "flex": "1 1 auto" });
    c2.root.append(jQuery("<h1>", { "class": "wcdv_groupfun_header" }).text(c2.display));
    c2.root.append(c2.div);
    c2.members = 0;
  });
  self2.buttons = {};
  groupFuns.each(function(gf, gfName) {
    self2.buttons[gfName] = jQuery("<button>", {
      "type": "button",
      "class": "wcdv_option",
      "data-wcdv-groupfunname": gfName,
      "title": gf.displayName
    }).text(gf.displayName).on("click", function() {
      selected = gfName;
      self2.win.dialog("close");
    });
    var c2 = categories.get(gf.category) || categories.get("other");
    c2.div.append(self2.buttons[gfName]);
    c2.members += 1;
  });
  categories.each(function(c2) {
    if (c2.members > 0) {
      root2.append(c2.root);
    }
  });
  self2.buttons["none"] = jQuery("<button>", {
    "type": "button",
    "class": "wcdv_option",
    "data-wcdv-groupfunname": "none",
    "title": trans("GRID.GROUP_FUN.NONE")
  }).text(trans("GRID.GROUP_FUN.NONE")).on("click", function() {
    selected = "none";
    self2.win.dialog("close");
  });
  self2.win.append(jQuery("<div>").append(self2.buttons["none"]));
});
GroupFunWin.prototype.show = function(gfName, cb2) {
  var self2 = this;
  self2.cb = cb2;
  self2.win.dialog("open");
  if (gfName != null && self2.buttons[gfName] != null) {
    self2.buttons[gfName].focus();
  }
};

// node_modules/wcdatavis/src/grid_control.js
var GridControlField = function() {
  var CONTROL_FIELD_ID = 0;
  return makeSubclass("GridControlField", Object, function(control, spec, displayText, colConfig, opts) {
    var self2 = this;
    self2.control = control;
    if (typeof spec === "string") {
      self2.field = {
        field: spec
      };
    } else {
      self2.field = deepCopy(spec);
    }
    self2.displayText = displayText;
    self2.colConfig = colConfig;
    self2.opts = opts;
    self2.fti = self2.control.typeInfo.get(self2.field.field);
    self2.ui = {};
    self2.id = CONTROL_FIELD_ID++;
  });
}();
GridControlField.prototype.draw = function() {
  var self2 = this;
  var label = self2.displayText || self2.colConfig && self2.colConfig.displayText || self2.field.field;
  self2.ui.removeButton = jQuery("<button>", { "type": "button" }).append(fontAwesome("F146")).attr("title", trans("GRID_CONTROL.FIELD.REMOVE")).addClass("wcdv_icon_button wcdv_remove wcdv_text-primary").on("click", function() {
    self2.control.removeField(self2);
  });
  self2.ui.fieldLabel = jQuery("<span>", {
    "class": "wcdv_field_name",
    "title": label
  }).text(label);
  self2.ui.root = jQuery("<div>", { "class": "wcdv_field" }).append(self2.ui.removeButton).append(self2.ui.fieldLabel);
  self2._addErrorIndicator(self2.ui.root, "wcdv_aggregate_control_error");
  return self2.ui.root;
};
GridControlField.prototype.getElement = function() {
  var self2 = this;
  return self2.ui.root;
};
GridControlField.prototype.destroy = function() {
};
GridControlField.prototype.showError = function(errMsg) {
  var self2 = this;
  debug.error("GRID // CONTROL", errMsg);
  if (self2.ui.error) {
    self2.ui.error.attr("title", errMsg);
    self2.ui.error.show();
  } else {
    log.error("Call Error: Attempted to call `showError()` on a ControlField subclass instance that does not provide a way of indicating errors in the user interface.");
  }
};
GridControlField.prototype._addErrorIndicator = function(parent, cls) {
  var self2 = this;
  self2.ui.error = fontAwesome("fa-exclamation-triangle", cls).hide().tooltip({
    classes: {
      "ui-tooltip": "ui-corner-all ui-widget-shadow " + cls + "_tooltip"
    },
    show: { delay: 1e3 }
  }).appendTo(parent);
};
GridControlField.prototype.getSpec = function() {
  var self2 = this;
  return {
    field: self2.field.field
  };
};
var FunGridControlField = makeSubclass("FunGridControlField", GridControlField);
FunGridControlField.prototype.draw = function() {
  var self2 = this;
  self2.super.draw();
  var applicableGroupFuns = GROUP_FUNCTION_REGISTRY.filter(function(gf2) {
    if (self2.fti == null) {
      return false;
    }
    return gf2.allowedTypes.indexOf(self2.fti.type) >= 0;
  });
  if (applicableGroupFuns.size() > 0) {
    self2.ui.groupFunWin = new GroupFunWin(trans("GRID.GROUP_FUN.DIALOG.TITLE", self2.field.field), applicableGroupFuns);
    self2.ui.groupFunWinBtn = jQuery("<button>", {
      "type": "button",
      "data-wcdv-role": "set-group-fun",
      title: trans("GRID_CONTROL.FIELD.SHOW_FUNCTIONS")
    }).addClass("wcdv_icon_button wcdv_button_left wcdv_text-primary").on("click", function() {
      self2.showFunWin();
    }).append(fontAwesome("fa-bolt")).appendTo(self2.ui.root);
    if (self2.field.fun != null) {
      var gf = GROUP_FUNCTION_REGISTRY.get(self2.field.fun);
      self2.ui.fieldLabel.text(self2.field.field + " (" + gf.displayName + ")");
      self2.ui.fieldLabel.attr("title", self2.field.field + " (" + gf.displayName + ")");
    }
    self2.ui.fieldLabel.after(self2.ui.groupFunWinBtn);
  }
  return self2.ui.root;
};
FunGridControlField.prototype.getSpec = function() {
  var self2 = this;
  return {
    field: self2.field.field,
    fun: self2.field.fun
  };
};
FunGridControlField.prototype.showFunWin = function() {
  var self2 = this;
  self2.ui.groupFunWin.show(self2.field.fun || "none", function(groupFunName) {
    if (groupFunName != null) {
      if (groupFunName === "none") {
        self2.field.fun = null;
        self2.ui.fieldLabel.text(self2.field.field);
      } else {
        self2.field.fun = groupFunName;
        var gf = GROUP_FUNCTION_REGISTRY.get(self2.field.fun);
        self2.ui.fieldLabel.text(self2.field.field + " (" + gf.displayName + ")");
      }
      self2.control.updateView();
    } else if (self2.field.fun === void 0) {
      self2.field.fun = null;
      self2.control.updateView();
    }
  });
};
var GroupControlField = makeSubclass("GroupControlField", FunGridControlField);
var PivotControlField = makeSubclass("PivotControlField", FunGridControlField);
var FilterControlField = makeSubclass("FilterControlField", GridControlField);
FilterControlField.prototype.draw = function() {
  var self2 = this;
  self2.super.draw();
  self2.ui.filterContainer = jQuery("<div>").addClass("wcdv_filter_control_filter_container").appendTo(self2.ui.root);
  self2.control.gfs.add(self2.field.field, self2.ui.filterContainer, {
    filterType: self2.colConfig && self2.colConfig.filter
  });
  return self2.ui.root;
};
var AggregateControlField = makeSubclass("AggregateControlField", GridControlField, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.fieldDropdowns = [];
  self2.shouldGraph = false;
});
AggregateControlField.prototype.draw = function() {
  var self2 = this;
  self2.super.draw();
  self2._addErrorIndicator(self2.ui.root, "wcdv_aggregate_control_error");
  var aggDefn = AGGREGATE_REGISTRY.get(self2.field.field);
  var fieldList = jQuery("<ul>", {
    "class": "wcdv_aggregate_control_fieldlist"
  }).appendTo(self2.ui.root);
  for (var i2 = 0; i2 < aggDefn.prototype.fieldCount; i2 += 1) {
    var li = jQuery("<li>").addClass("wcdv_aggregate_field").appendTo(fieldList);
    if (getProp(aggDefn.prototype, "fieldInfo", i2, "name")) {
      var label = jQuery("<label>").text(aggDefn.prototype.fieldInfo[i2].name + ":").appendTo(li);
    }
    var select = jQuery("<select>").on("change", function(evt) {
      select.children("option[data-wcdv-bad-field]").filter(function(eltIndex, elt2) {
        return jQuery(elt2).attr("value") !== select.val();
      }).remove();
      self2.control.updateView();
    }).appendTo(li);
    self2.fieldDropdowns.push(select);
  }
  index_default_default.each(determineColumns(self2.control.colConfig, null, self2.control.typeInfo), function(fieldName) {
    var text = getProp(self2.control.colConfig.get(fieldName), "displayText") || fieldName;
    index_default_default.each(self2.fieldDropdowns, function(dropdown, i3) {
      jQuery("<option>", { "value": fieldName }).text(text).appendTo(dropdown);
    });
  });
  index_default_default.each(self2.fieldDropdowns, function(dropdown, i3) {
    if (getProp(self2.opts, "fields", i3)) {
      var matchingOption = dropdown.children("option").filter(function(eltIndex, elt2) {
        return jQuery(elt2).attr("value") === self2.opts.fields[i3];
      });
      if (matchingOption.length === 0) {
        jQuery("<option>", {
          "value": self2.opts.fields[i3],
          "data-wcdv-bad-field": "yup"
        }).text(self2.opts.fields[i3] + "  Invalid").appendTo(dropdown);
      }
      dropdown.val(self2.opts.fields[i3]);
    }
  });
  if (aggDefn.prototype.options != null) {
    jQuery("<button>", {
      "type": "button",
      title: trans("GRID_CONTROL.AGGREGATE.EDIT_OPTIONS")
    }).addClass("wcdv_icon_button wcdv_button_left wcdv_text-primary").on("click", function() {
      self2.ui.optionsDialog.dialog("open");
    }).append(fontAwesome("F044")).appendTo(self2.ui.root);
    self2._makeOptionsDialog(aggDefn);
  }
  if (self2.control.view.hasClientKind("graph")) {
    self2.ui.graphBtn = jQuery("<button>", {
      "type": "button"
    }).addClass("wcdv_icon_button wcdv_text-primary").on("click", function() {
      self2.control.clearGraphFlag();
      self2.shouldGraph = true;
      self2.control.updateView();
    }).append(fontAwesome("fa-bar-chart")).appendTo(self2.ui.root);
  }
  self2.ui.isHiddenCheckbox = jQuery("<input>", {
    "type": "checkbox"
  }).prop("checked", getProp(self2.opts, "isHidden")).on("change", function() {
    self2.control.updateView();
  }).appendTo(self2.ui.root)._makeIconCheckbox("fa-eye-slash wcdv_text-primary", "fa-eye wcdv_text-primary");
  return self2.ui.root;
};
AggregateControlField.prototype._makeOptionsDialog = function(aggDefn) {
  var self2 = this;
  self2.ui.optionsDiv = jQuery("<div>").css("display", "none").appendTo(document.body);
  var table = jQuery("<table>").appendTo(self2.ui.optionsDiv);
  var opts = {};
  index_default_default.each(aggDefn.prototype.options, function(optConfig, optName) {
    optConfig = deepDefaults(optConfig, {
      type: "string",
      widget: "text",
      displayText: optName
    });
    var id = gensym();
    var input = jQuery("<input>", {
      "type": "text",
      "id": id
    });
    opts[optName] = input;
    var label = jQuery("<label>", {
      "for": id
    }).text(optConfig.displayText);
    jQuery("<tr>").append(jQuery("<td>").append(label)).append(jQuery("<td>").append(input)).appendTo(table);
  });
  jQuery("<div>").css({
    "text-align": "center",
    "margin-top": "1ex"
  }).append(jQuery("<button>", { "type": "button" }).append(fontAwesome("F00C")).append("OK").on("click", function() {
    self2.aggFunOpts = opts;
    self2.control.updateView();
    self2.ui.optionsDialog.dialog("close");
  })).append(jQuery("<button>", { "type": "button" }).css("margin-left", "1em").append(fontAwesome("F05E")).append("Cancel").on("click", function() {
    self2.ui.optionsDialog.dialog("close");
  })).appendTo(self2.ui.optionsDiv);
  self2.ui.optionsDialog = self2.ui.optionsDiv.dialog({
    autoOpen: false,
    modal: true,
    title: trans("GRID_CONTROL.AGGREGATE.OPTIONS_DIALOG.TITLE", aggDefn.prototype.name),
    minHeight: 0
  });
};
AggregateControlField.prototype.destroy = function() {
  var self2 = this;
  if (self2.ui.optionsDiv != null) {
    self2.ui.optionsDialog.dialog("destroy");
    self2.ui.optionsDiv.remove();
  }
  self2.super.destroy();
};
AggregateControlField.prototype.getInfo = function() {
  var self2 = this;
  return {
    fun: self2.field.field,
    name: null,
    fields: index_default_default.map(self2.fieldDropdowns, function(dropdown) {
      return dropdown.val();
    }),
    isHidden: self2.ui.isHiddenCheckbox._isChecked(),
    shouldGraph: self2.shouldGraph,
    opts: index_default_default.mapObject(self2.aggFunOpts, function(input, optName) {
      return input.val();
    })
  };
};
var GridControl = makeSubclass("GridControl", Object, function(grid, colConfig, view, features, timing) {
  var self2 = this;
  if (!(grid instanceof Grid)) {
    throw new Error("Call Error: `grid` must be an instance of MIE.WC_DataVis.Grid");
  }
  self2.grid = grid;
  self2.colConfig = colConfig;
  self2.view = view;
  self2.features = features;
  self2.timing = timing;
  self2.fields = [];
  self2.controlFields = [];
  self2.controlFieldsByField = {};
  self2.controlFieldsById = {};
  self2.ui = {};
  self2.grid.on("colConfigUpdate", function(colConfig2) {
    self2.colConfig = colConfig2;
  });
}, {
  isHorizontal: false,
  isReorderable: true,
  showColumns: true,
  disableUsedItems: false,
  useColConfig: true,
  updateCanHide: true
});
mixinEventHandling(GridControl, [
  "fieldAdded",
  "fieldRemoved",
  "cleared"
]);
GridControl.prototype.makeClearButton = function(target) {
  var self2 = this;
  return jQuery(fontAwesome("F05E")).addClass("wcdv_button wcdv_text-primary wcdv_control_clear_button").hide().on("click", function() {
    jQuery(this).hide();
    self2.clear();
  }).appendTo(target);
};
GridControl.prototype.addField = function(field, displayText, opts, controlFieldOpts, next) {
  var self2 = this, args = Array.prototype.slice.call(arguments), fieldName;
  opts = deepDefaults(opts, {
    updateView: true,
    silent: false,
    openControls: false
  });
  if (field == null || field === "") {
    return typeof next === "function" ? next(false) : void 0;
  }
  fieldName = typeof field === "string" ? field : field.field;
  if (fieldName == null || fieldName === "" || self2.disableUsedItems && self2.fields.indexOf(fieldName) >= 0) {
    return typeof next === "function" ? next(false) : void 0;
  }
  if (self2.typeInfo == null) {
    return self2.view.getTypeInfo(function(ok, typeInfo) {
      if (!ok) {
        return typeof next === "function" ? next(false) : void 0;
      }
      self2.typeInfo = typeInfo;
      return GridControl.prototype.addField.apply(self2, args);
    });
  }
  if (opts.openControls) {
    self2.grid.showControls();
  }
  if (self2.updateCanHide && self2.colConfig != null && self2.colConfig.isSet(fieldName)) {
    self2.colConfig.get(fieldName).isHidden = false;
    self2.colConfig.get(fieldName).canHide = false;
  }
  var cf = new self2.controlFieldCtor(self2, field, displayText, self2.useColConfig ? self2.colConfig.get(fieldName) : null, controlFieldOpts);
  self2.controlFields.push(cf);
  self2.controlFieldsById[cf.id] = cf;
  if (self2.controlFieldsByField[fieldName] == null) {
    self2.controlFieldsByField[fieldName] = [];
  }
  self2.controlFieldsByField[fieldName].push(cf);
  self2.ui.clearBtn.show();
  var li = jQuery("<li>").attr({
    "data-wcdv-field": fieldName,
    "data-wcdv-control-field-id": cf.id,
    "data-wcdv-draggable-origin": "GRID_CONTROL_FIELD"
  });
  if (self2.isHorizontal) {
    li.append(fontAwesome("F178"));
  }
  li.append(cf.draw());
  li.appendTo(self2.ui.fields);
  if (self2.disableUsedItems) {
    self2.ui.dropdown.find("option").filter(function() {
      return jQuery(this).val() === fieldName;
    }).prop("disabled", true);
  }
  self2.ui.dropdown.val("");
  self2.fields.push(fieldName);
  if (typeof self2.updateView === "function" && opts.updateView) {
    self2.updateView();
  }
  if (!opts.silent) {
    self2.fire("fieldAdded", null, fieldName, self2.fields);
  }
  return typeof next === "function" ? next(true, cf) : void 0;
};
GridControl.prototype.removeField = function(cf) {
  var self2 = this, fieldName = cf.field.field;
  if (self2.updateCanHide && self2.colConfig != null && self2.colConfig.isSet(fieldName)) {
    self2.colConfig.get(fieldName).canHide = true;
  }
  cf.destroy();
  cf.getElement().parent("li").remove();
  self2.controlFields = index_default_default.without(self2.controlFields, cf);
  self2.controlFieldsById[cf.id] = void 0;
  self2.controlFieldsByField[fieldName] = index_default_default.without(self2.controlFieldsByField[fieldName], cf);
  self2.fields.splice(self2.fields.indexOf(fieldName), 1);
  if (self2.disableUsedItems) {
    self2.ui.dropdown.find("option").filter(function() {
      return jQuery(this).val() === fieldName;
    }).prop("disabled", false);
  }
  if (self2.controlFields.length === 0) {
    self2.ui.clearBtn.hide();
  }
  self2.updateView();
  self2.fire(GridControl.events.fieldRemoved, null, fieldName, self2.fields);
};
GridControl.prototype.clear = function(opts) {
  var self2 = this;
  opts = opts || {};
  index_default_default.defaults(opts, {
    updateView: true
  });
  if (self2.updateCanHide && self2.colConfig != null) {
    self2.colConfig.each(function(cc) {
      cc.canHide = true;
    });
  }
  self2.fields = [];
  self2.controlFields = [];
  self2.controlFieldsById = {};
  self2.controlFieldsByField = {};
  self2.ui.fields.children().remove();
  self2.ui.dropdown.find("option:disabled").filter(function() {
    return jQuery(this).val() !== "";
  }).prop("disabled", false);
  self2.ui.clearBtn.hide();
  if (opts.updateView) {
    self2.updateView();
  }
  self2.fire(GridControl.events.cleared);
};
GridControl.prototype.destroy = function() {
  var self2 = this;
  console.debug("[DataVis // GridControl] Good-bye, cruel world!");
  self2.view.off("*", self2);
  self2.grid.off("*", self2);
  self2.ui.root.remove();
};
GridControl.prototype.addViewConfigChangeHandler = function(event, sync) {
  var self2 = this;
  var clearDropdown = function() {
    self2.ui.dropdown.children().remove();
    jQuery("<option>", {
      "value": "",
      "disabled": true,
      "selected": true
    }).text(trans("GRID_CONTROL.SELECT_FIELD")).appendTo(self2.ui.dropdown);
  };
  var sync_colConfig = function(colConfig) {
    console.debug("[DataVis // %s // %s Control] Synchronizing column configuration with grid", self2.grid.toString(), self2.controlType.toUpperCase());
    self2.colConfig = colConfig;
    if (self2.showColumns) {
      clearDropdown();
      colConfig.each(function(fcc) {
        jQuery("<option>", { "value": fcc.field }).text(fcc.displayText || fcc.field).appendTo(self2.ui.dropdown);
      });
    }
  };
  var sync_view = function() {
    console.debug("[DataVis // %s // %s Control] Synchronizing user interface with view", self2.grid.toString(), self2.controlType.toUpperCase());
    sync();
  };
  if (self2.grid.colConfig != null) {
    sync_colConfig(self2.grid.colConfig);
    self2.grid.on("colConfigUpdate", sync_colConfig);
    if (self2.view.typeInfo != null) {
      sync_view();
      self2.view.on(event, sync_view, { who: self2 });
    } else {
      self2.view.on("getTypeInfo", function() {
        sync_view();
        self2.view.on(event, sync_view, { who: self2 });
      }, { limit: 1 });
    }
  } else {
    self2.grid.on("colConfigUpdate", function(colConfig) {
      sync_colConfig(colConfig);
      self2.grid.on("colConfigUpdate", sync_colConfig);
      if (self2.view.typeInfo != null) {
        sync_view();
        self2.view.on(event, sync_view, { who: self2 });
      } else {
        self2.view.on("getTypeInfo", function(ok) {
          sync_view();
          self2.view.on(event, sync_view, { who: self2 });
        }, { limit: 1 });
      }
    }, { limit: 1 });
  }
};
GridControl.prototype.getListElement = function() {
  var self2 = this;
  return self2.ui.fields;
};
GridControl.prototype.draw = function(parent) {
  throw new Error("ABSTRACT");
};
GridControl.prototype.updateView = function() {
  throw new Error("ABSTRACT");
};
var GroupControl = makeSubclass("GroupControl", GridControl, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.view.on(ComputedView.events.invalidGroupField, function(field) {
    index_default_default.each(self2.controlFieldsByField[field], function(cf) {
      cf.showError("This field does not exist in the data.");
    });
  });
}, {
  controlFieldCtor: GroupControlField,
  controlType: "Group"
});
GroupControl.prototype.draw = function(parent) {
  var self2 = this;
  parent.droppable({
    classes: {
      "ui-droppable-hover": "wcdv_drop_target_hover"
    },
    drop: function(evt, ui) {
      if (ui.draggable.attr("data-wcdv-draggable-origin") === "GRID_TABLE_HEADER") {
        var field = ui.draggable.attr("data-wcdv-field");
        self2.addField(field, getProp(self2.colConfig.get(field), "displayText"), {
          autoShowFunWin: true
        });
      }
    }
  })._addEventDebugging("drop", "GROUP");
  self2.ui.root = jQuery("<div>").appendTo(parent);
  self2.ui.title = jQuery("<div>").addClass("wcdv_control_title_bar").appendTo(self2.ui.root);
  jQuery("<span>", { "class": "wcdv_control_title" }).text(trans("GRID_CONTROL.GROUP.TITLE")).appendTo(self2.ui.title);
  self2.ui.clearBtn = self2.makeClearButton(self2.ui.title);
  self2.ui.fields = jQuery("<ul>", {
    id: gensym(),
    "class": self2.isHorizontal ? "wcdv_control_horizontal" : "wcdv_control_vertical"
  }).appendTo(self2.ui.root);
  var dropdownContainer = jQuery("<div>").appendTo(self2.ui.root);
  self2.ui.dropdown = jQuery("<select>", { "class": "wcdv_control_addField" }).appendTo(dropdownContainer);
  self2.ui.dropdown.on("change", function() {
    self2.addField(self2.ui.dropdown.val(), self2.ui.dropdown.find("option:selected").text(), {
      autoShowFunWin: true
    });
  });
  self2.addViewConfigChangeHandler("groupSet", function() {
    var spec = self2.view.getGroup();
    var fields = !self2.view.source.origin.isLimited && spec && spec.fieldNames || [];
    self2.clear({ updateView: false });
    console.debug("[DataVis // %s // Group Control] View set group fields to: %s", self2.grid.toString(), JSON.stringify(fields));
    index_default_default.each(fields, function(field) {
      self2.addField(field, getProp(self2.colConfig.get(field), "displayText"), { updateView: false });
    });
  });
  return self2.ui.root;
};
GroupControl.prototype.updateView = function() {
  var self2 = this;
  var fieldNames = index_default_default.map(self2.controlFields, function(cf) {
    return cf.getSpec();
  });
  if (fieldNames.length > 0) {
    self2.view.setGroup({ fieldNames }, {
      dontSendEventTo: self2
    });
  } else {
    self2.view.clearGroup();
  }
};
GroupControl.prototype.toString = function() {
  var self2 = this;
  return self2.grid.id + ", Group";
};
GroupControl.prototype.sortableSync = function() {
  var self2 = this;
  var controlFieldIds = self2.ui.fields.children("li").map(function(index2, elt2) {
    return jQuery(elt2).attr("data-wcdv-control-field-id");
  }).get();
  self2.controlFields = [];
  index_default_default.each(controlFieldIds, function(id) {
    self2.controlFields.push(self2.controlFieldsById[id]);
  });
  return self2.updateView();
};
GroupControl.prototype.addField = function(field, displayText, opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    autoShowFunWin: false,
    updateView: true
  });
  var updateView = opts.updateView;
  opts.updateView = false;
  self2.super.addField(field, displayText, opts, null, function(ok, cf) {
    if (!ok) {
      return;
    }
    if (opts.autoShowFunWin && cf.fti != null && ["date", "datetime"].indexOf(cf.fti.type) >= 0 && cf.field.fun === void 0) {
      cf.showFunWin();
    } else if (updateView) {
      self2.updateView();
    }
  });
};
var PivotControl = makeSubclass("PivotControl", GridControl, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.view.on(ComputedView.events.invalidPivotField, function(field) {
    index_default_default.each(self2.controlFieldsByField[field], function(cf) {
      cf.showError("This field does not exist in the data.");
    });
  });
}, {
  controlFieldCtor: PivotControlField,
  controlType: "Pivot"
});
PivotControl.prototype.draw = function(parent) {
  var self2 = this;
  parent.droppable({
    classes: {
      "ui-droppable-hover": "wcdv_drop_target_hover"
    },
    drop: function(evt, ui) {
      if (ui.draggable.attr("data-wcdv-draggable-origin") === "GRID_TABLE_HEADER") {
        var field = ui.draggable.attr("data-wcdv-field");
        self2.addField(field, getProp(self2.colConfig.get(field), "displayText"), {
          autoShowFunWin: true
        });
      }
    }
  })._addEventDebugging("drop", "PIVOT");
  self2.ui.root = jQuery("<div>").appendTo(parent);
  self2.ui.title = jQuery("<div>").addClass("wcdv_control_title_bar").appendTo(self2.ui.root);
  jQuery("<span>").addClass("wcdv_control_title").text(trans("GRID_CONTROL.PIVOT.TITLE")).appendTo(self2.ui.title);
  self2.ui.clearBtn = self2.makeClearButton(self2.ui.title);
  self2.ui.fields = jQuery("<ul>", {
    id: gensym(),
    "class": self2.isHorizontal ? "wcdv_control_horizontal" : "wcdv_control_vertical"
  }).appendTo(self2.ui.root);
  var dropdownContainer = jQuery("<div>").appendTo(self2.ui.root);
  self2.ui.dropdown = jQuery("<select>", { "class": "wcdv_control_addField" }).appendTo(dropdownContainer);
  self2.ui.dropdown.on("change", function() {
    self2.addField(self2.ui.dropdown.val(), self2.ui.dropdown.find("option:selected").text(), {
      autoShowFunWin: true
    });
  });
  self2.addViewConfigChangeHandler("pivotSet", function(spec) {
    spec = self2.view.getPivot();
    var fields = !self2.view.source.origin.isLimited && spec && spec.fieldNames || [];
    self2.clear({ updateView: false });
    console.debug("[DataVis // %s // Pivot Control] View set pivot fields to: %s", self2.grid.toString(), JSON.stringify(fields));
    index_default_default.each(fields, function(field) {
      self2.addField(field, getProp(self2.colConfig.get(field), "displayText"), { updateView: false });
    });
  });
  return self2.ui.root;
};
PivotControl.prototype.updateView = function() {
  var self2 = this;
  var fieldNames = index_default_default.map(self2.controlFields, function(cf) {
    return cf.getSpec();
  });
  if (fieldNames.length > 0) {
    self2.view.setPivot({ fieldNames }, {
      dontSendEventTo: self2
    });
  } else {
    self2.view.clearPivot();
  }
};
PivotControl.prototype.toString = function() {
  var self2 = this;
  return self2.grid.id + ", Pivot";
};
PivotControl.prototype.sortableSync = function() {
  var self2 = this;
  var controlFieldIds = self2.ui.fields.children("li").map(function(index2, elt2) {
    return jQuery(elt2).attr("data-wcdv-control-field-id");
  }).get();
  self2.controlFields = [];
  index_default_default.each(controlFieldIds, function(id) {
    self2.controlFields.push(self2.controlFieldsById[id]);
  });
  return self2.updateView();
};
PivotControl.prototype.addField = function(field, displayText, opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    autoShowFunWin: false,
    updateView: true
  });
  var updateView = opts.updateView;
  opts.updateView = false;
  self2.super.addField(field, displayText, opts, null, function(ok, cf) {
    if (!ok) {
      return;
    }
    if (opts.autoShowFunWin && cf.fti != null && ["date", "datetime"].indexOf(cf.fti.type) >= 0 && cf.field.fun === void 0) {
      cf.showFunWin();
    } else if (updateView) {
      self2.updateView();
    }
  });
};
var AggregateControl = makeSubclass("AggregateControl", GridControl, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.view.on(ComputedView.events.invalidAggregate, function(aggNum, errMsg) {
    self2.controlFields[aggNum].showError(errMsg);
  });
}, {
  disableUsedItems: false,
  showColumns: false,
  updateCanHide: false,
  controlFieldCtor: AggregateControlField,
  controlType: "Aggregate"
});
AggregateControl.prototype.draw = function(parent) {
  var self2 = this;
  self2.ui.root = jQuery("<div>").appendTo(parent);
  self2.ui.title = jQuery("<div>").addClass("wcdv_control_title_bar").appendTo(self2.ui.root);
  jQuery("<span>").addClass("wcdv_control_title").text(trans("GRID_CONTROL.AGGREGATE.TITLE")).appendTo(self2.ui.title);
  self2.ui.clearBtn = self2.makeClearButton(self2.ui.title);
  self2.ui.fields = jQuery("<ul>", {
    id: gensym(),
    "class": self2.isHorizontal ? "wcdv_control_horizontal" : "wcdv_control_vertical"
  }).appendTo(self2.ui.root);
  var dropdownContainer = jQuery("<div>").appendTo(self2.ui.root);
  self2.ui.dropdown = jQuery("<select>", { "class": "wcdv_control_addField" }).appendTo(dropdownContainer);
  self2.ui.dropdown.on("change", function() {
    self2.addField(self2.ui.dropdown.val(), self2.ui.dropdown.find("option:selected").text());
  });
  jQuery("<option>", { "value": "", "disabled": true, "selected": true }).text(trans("GRID_CONTROL.SELECT_AGGREGATE")).appendTo(self2.ui.dropdown);
  AGGREGATE_REGISTRY.each(function(aggFunDefn, aggFunShortName) {
    jQuery("<option>", { "value": aggFunShortName }).text(aggFunDefn.prototype.name).appendTo(self2.ui.dropdown);
  });
  self2.addViewConfigChangeHandler("aggregateSet", function() {
    var spec = self2.view.getAggregate();
    self2.clear({ updateView: false });
    if (spec != null) {
      console.debug("[DataVis // %s // Aggregate Control] View set aggregate to: %s", self2.grid.toString(), JSON.stringify(spec.all));
      index_default_default.each(spec.all, function(agg) {
        self2.addField(agg.fun, AGGREGATE_REGISTRY.get(agg.fun).prototype.name, { updateView: false }, {
          fields: agg.fields,
          isHidden: agg.isHidden
        });
      });
    }
  });
  return self2.ui.root;
};
AggregateControl.prototype.updateView = function() {
  var self2 = this;
  var info = index_default_default.map(self2.controlFields, function(cf) {
    return cf.getInfo();
  });
  self2.ui.root.find(".wcdv_aggregate_control_error").hide();
  self2.view.setAggregate(objFromArray(["group", "pivot", "cell", "all"], [info]), {
    dontSendEventTo: self2
  });
};
AggregateControl.prototype.clearGraphFlag = function() {
  var self2 = this;
  index_default_default.each(self2.controlFields, function(cf) {
    cf.shouldGraph = false;
  });
};
AggregateControl.prototype.triggerAggChange = function() {
  var self2 = this;
  var agg = AGGREGATE_REGISTRY.get(self2.ui.funDropdown.val());
  if (agg.prototype.fieldCount > self2.ui.fields.length) {
    self2.addFieldDropdowns(agg);
  }
  self2.showHideFields(agg);
  var aggSpec = objFromArray(["group", "pivot", "cell", "all"], [[{
    fun: self2.ui.funDropdown.val(),
    fields: agg.prototype.fieldCount > 0 && mapLimit(self2.ui.fields, function(f2) {
      return f2.dropdown.val();
    }, agg.prototype.fieldCount)
  }]]);
  var i2;
  var div;
  self2.view.setAggregate(aggSpec, {
    dontSendEventTo: self2
  });
};
AggregateControl.prototype.showHideFields = function(agg) {
  var self2 = this;
  var i2;
  for (i2 = 0; i2 < self2.ui.fields.length; i2 += 1) {
    if (i2 < agg.prototype.fieldCount) {
      self2.ui.fields[i2].div.show();
    } else {
      self2.ui.fields[i2].div.hide();
    }
  }
};
AggregateControl.prototype.addFieldDropdowns = function(agg) {
  var self2 = this;
  console.debug(
    "[DataVis // %s // Aggregate Control] Adding %s extra field dropdowns for the %s aggregate function",
    self2.grid.toString(),
    agg.prototype.fieldCount - self2.ui.fields.length,
    agg.prototype.name
  );
  while (self2.ui.fields.length < agg.prototype.fieldCount) {
    var x = {};
    x.div = jQuery("<div>").css({ "margin-top": "4px" }).appendTo(self2.ui.root);
    x.label = jQuery("<label>").text(trans("GRID_CONTROL.FIELD") + ":").appendTo(x.div);
    x.dropdown = jQuery("<select>").on("change", function() {
      self2.triggerAggChange();
    }).appendTo(x.div);
    self2.ui.fields.push(x);
  }
  self2.updateFieldDropdowns();
};
AggregateControl.prototype.updateFieldDropdowns = function() {
  var self2 = this;
  index_default_default.each(self2.ui.fields, function(f2) {
    f2.dropdown.children().remove();
  });
  index_default_default.each(determineColumns(self2.colConfig, null, self2.typeInfo), function(fieldName) {
    var text = getProp(self2.colConfig.get(fieldName), "displayText") || fieldName;
    index_default_default.each(self2.ui.fields, function(f2) {
      jQuery("<option>", { "value": fieldName }).text(text).appendTo(f2.dropdown);
    });
  });
};
AggregateControl.prototype.toString = function() {
  var self2 = this;
  return self2.grid.id + ", Aggregate";
};
var FilterControl = makeSubclass("FilterControl", GridControl, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.gfs = new GridFilterSet(self2.view, null, null, null, {
    dontSendEventTo: self2
  });
}, {
  isReorderable: false,
  disableUsedItems: true,
  controlFieldCtor: FilterControlField,
  controlType: "Filter"
});
FilterControl.prototype.draw = function(parent) {
  var self2 = this;
  parent.droppable({
    classes: {
      "ui-droppable-hover": "wcdv_drop_target_hover"
    },
    drop: function(evt, ui) {
      var field = ui.draggable.attr("data-wcdv-field");
      self2.addField(field, getProp(self2.colConfig.get(field), "displayText"));
    }
  })._addEventDebugging("drop", "FILTER");
  self2.ui.root = jQuery("<div>").appendTo(parent);
  self2.ui.title = jQuery("<div>").addClass("wcdv_control_title_bar").appendTo(self2.ui.root);
  jQuery("<span>", { "class": "wcdv_control_title" }).text(trans("GRID_CONTROL.FILTER.TITLE")).appendTo(self2.ui.title);
  self2.ui.clearBtn = self2.makeClearButton(self2.ui.title);
  self2.ui.fields = jQuery("<ul>", {
    id: gensym(),
    "class": self2.isHorizontal ? "wcdv_control_horizontal" : "wcdv_control_vertical"
  }).appendTo(self2.ui.root);
  var dropdownContainer = jQuery("<div>").appendTo(self2.ui.root);
  self2.ui.dropdown = jQuery("<select>", { "class": "wcdv_control_addField" }).appendTo(dropdownContainer);
  self2.ui.dropdown.on("change", function() {
    self2.addField(self2.ui.dropdown.val(), self2.ui.dropdown.find("option:selected").text());
  });
  self2.addViewConfigChangeHandler("filterSet", function() {
    var spec = self2.view.getFilter();
    console.debug("[DataVis // %s // Filter Control] View set filter to: %s", self2.grid.toString(), JSON.stringify(spec));
    self2.clear({ updateView: false });
    index_default_default.each(spec, function(fieldSpec, field) {
      self2.addField(field, getProp(self2.colConfig.get(field), "displayText"), { updateView: false });
      self2.gfs.set(field, fieldSpec, { updateView: false });
    });
  });
  return self2.ui.root;
};
FilterControl.prototype.addField = function(field, displayText, opts) {
  var self2 = this;
  self2.super.addField(field, displayText || getProp(self2.colConfig.get(field), "displayText"), opts);
};
FilterControl.prototype.removeField = function(cf) {
  var self2 = this;
  self2.gfs.removeField(cf.field.field);
  self2.super.removeField(cf);
};
FilterControl.prototype.clear = function(opts) {
  var self2 = this;
  self2.gfs.reset(opts);
  self2.super.clear(opts);
};
FilterControl.prototype.updateView = function() {
};
FilterControl.prototype.toString = function() {
  var self2 = this;
  return self2.grid.id + ", Filter";
};

// node_modules/wcdatavis/src/view.js
var import_bignumber7 = __toESM(require_bignumber());
var import_numeral7 = __toESM(require_numeral());
var View = makeSubclass("View", Object, function(name, source, opts) {
  var self2 = this;
  if (!(source instanceof Source2) && !(source instanceof View)) {
    throw new Error("Call Error: `source` must be an instance of MIE.WC_DataVis.Source or MIE.WC_DataVis.View");
  }
  opts = deepDefaults(opts, {
    prefs: null,
    saveViewConfig: true,
    groupIsPivot: false
  });
  if (opts.prefs != null && !(opts.prefs instanceof Prefs)) {
    throw new Error("Call Error: `opts.prefs` must be null or an instance of MIE.WC_DataVis.Prefs");
  }
  self2.source = source;
  self2.opts = opts;
  self2.source.on("dataUpdated", function() {
    self2.clearCache();
    self2.fire("dataUpdated");
  });
  self2.source.on("fetchDataCancel", function() {
    self2.lock.clear();
  });
  self2.echo(self2.source, ["fetchDataBegin", "fetchDataEnd"]);
  self2.name = name || source.getName() || gensym();
  self2.colConfig = new ordmap_default();
  self2.timing = new Timing();
  self2.lock = new lock_default(self2.toString());
  self2.sortSpec = null;
  self2.filterSpec = null;
  self2.groupSpec = null;
  self2.pivotSpec = null;
  self2.aggregateSpec = objFromArray(["group", "pivot", "cell", "all"], [[{ fun: "count" }]]);
  if (opts.prefs != null) {
    self2.setPrefs(opts.prefs);
  }
  self2.isBoundToPrefs = false;
});
mixinEventHandling(View, [
  "fetchDataBegin",
  "fetchDataEnd",
  "getTypeInfo",
  "dataUpdated",
  "workBegin",
  "workEnd",
  "sortSet",
  "filterSet",
  "groupSet",
  "pivotSet",
  "aggregateSet",
  "sortBegin",
  "sort",
  "sortEnd",
  "filterBegin",
  "filter",
  "filterEnd",
  "invalidFilterField",
  "invalidGroupField",
  "invalidPivotField",
  "invalidSortField",
  "invalidAggregate"
  // An aggregate function is invalid.
]);
delegate(View, "source", ["getUniqueVals", "decodeAll", "setToolbar"]);
makeSetters(View, [
  { name: "setFilter", prop: "filterSpec", event: "filterSet" },
  { name: "setGroup", prop: "groupSpec", event: "groupSet" },
  { name: "setPivot", prop: "pivotSpec", event: "pivotSet" },
  { name: "setAggregate", prop: "aggregateSpec", event: "aggregateSet" },
  { name: "setSort", prop: "sortSpec", event: "sortSet" }
]);
mixinDebugging(View);
mixinLogging(View);
View.prototype.toString = function() {
  var self2 = this;
  return "View(" + self2.name + ")";
};
View.prototype.addClient = function(client, kind) {
  var self2 = this;
  self2.clients = self2.clients || {};
  self2.clients[kind] = self2.clients[kind] || [];
  self2.clients[kind].push(client);
};
View.prototype.hasClientKind = function(kind) {
  var self2 = this;
  return getPropDef(0, self2.clients, kind, "length") > 0;
};
View.prototype.getRowCount = function() {
  var self2 = this;
  if (self2.data.isPlain) {
    return self2.data.data.length;
  } else if (self2.data.isGroup) {
    return index_default_default.reduce(self2.data.data, function(prev1, groupedData, rowValNum) {
      return prev1 + groupedData.length;
    }, 0);
  } else if (self2.data.isPivot) {
    return index_default_default.reduce(self2.data.data, function(prev1, groupedData, rowValNum) {
      return prev1 + index_default_default.reduce(groupedData, function(prev2, pivottedData, colValNum) {
        return prev2 + pivottedData.length;
      }, 0);
    }, 0);
  } else {
    throw new Error("Unable to determine row count when data is not plain, but also not grouped.");
  }
};
View.prototype.getTotalRowCount = function() {
  return this.source.cache.data.length;
};
View.prototype._setSort = function(spec, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setSort.apply(self2, args);
    }, "Waiting to set sort: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET SORT", "spec = %O", spec);
  isDifferent = !index_default_default.isEqual(self2.sortSpec, spec);
  self2.sortSpec = spec;
  if (opts.sendEvent) {
    self2.fire("sortSet", {
      notTo: opts.dontSendEventTo
    }, spec);
  }
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (opts.updateData) {
    self2.getData();
  }
  return true;
};
View.prototype.getSort = function() {
  var self2 = this;
  return self2.sortSpec;
};
View.prototype.clearSort = function(opts) {
  return this.setSort(null, opts);
};
View.prototype.sort = function(cont) {
  var self2 = this, timingEvt = ['Data Source "' + self2.source.name + '" : ' + self2.name, "Sorting"], conv = I, aggInfo = getProp(self2.data, "agg", "info");
  if (self2.sortSpec == null) {
    return cont(false);
  }
  self2.debug("SORT", "Beginning sort: %s", JSON.stringify(self2.sortSpec));
  var determineCmp = function(spec, fti) {
    var cmp2;
    if (fti == null) {
      log.error("Unable to sort: no type information {spec = %O}", spec);
      return null;
    }
    if (typeof fti === "string" || fti instanceof String) {
      fti = {
        type: fti
      };
    }
    if (fti.type == null) {
      log.error("Unable to sort: type unknown {spec = %O, fti = %O}", spec, fti);
      return null;
    }
    cmp2 = getComparisonFn.byType(fti.type);
    if (cmp2 == null) {
      log.error("Unable to sort: no comparison function for type {spec = %O, type = %s}", spec, fti.type);
      return null;
    }
    if (typeof cmp2 !== "function") {
      log.error("Unable to sort: invalid comparison function for type {spec = %O, type = %s}", spec, fti.type);
      return null;
    }
    self2._maybeDecode("SORT", fti);
    return cmp2;
  };
  var packBundle = function(spec, orientation, sortSourceFn) {
    var bundle, len;
    if (sortSourceFn == null) {
      log.error("Unable to sort: no sort source function given {spec = %O}", spec);
      return null;
    }
    switch (orientation) {
      case "vertical":
        len = self2.data.isPlain ? self2.data.data.length : self2.data.rowVals.length;
        break;
      case "horizontal":
        len = self2.data.isPlain ? self2.data.data.length : self2.data.colVals.length;
        break;
      default:
        return null;
    }
    bundle = new Array(len);
    for (var i2 = 0; i2 < len; i2 += 1) {
      bundle[i2] = {
        oldIndex: i2,
        sortSource: sortSourceFn(i2)
      };
    }
    return bundle;
  };
  var unpackBundle = function(orientation) {
    return function(sorted) {
      self2.debug(
        "SORT // UNPACK",
        "Unpacking bundle of %d sorted chunks in %s orientation",
        sorted.length,
        orientation
      );
      var origData = self2.data.data;
      var origRowVals = getProp(self2.data, "rowVals");
      var origColVals = getProp(self2.data, "colVals");
      var origCellAgg = getProp(self2.data, "agg", "results", "cell");
      var origGroupAgg = getProp(self2.data, "agg", "results", "group");
      var origPivotAgg = getProp(self2.data, "agg", "results", "pivot");
      var ai, rvi;
      switch (orientation) {
        case "vertical":
          self2.data.data = [];
          if (origRowVals != null) {
            self2.data.rowVals = [];
          }
          if (origCellAgg != null) {
            self2.data.agg.results.cell = [];
          }
          if (origGroupAgg != null) {
            self2.data.agg.results.group = [];
          }
          var rowValIdxMap = {};
          index_default_default.each(sorted, function(s2, newIndex) {
            if (self2.data.isPlain) {
              self2.fire("sort", {
                silent: true
              }, origData[s2.oldIndex].rowNum, newIndex);
            }
            self2.data.data[newIndex] = origData[s2.oldIndex];
            if (origRowVals != null) {
              self2.data.rowVals[newIndex] = origRowVals[s2.oldIndex];
            }
            rowValIdxMap[s2.oldIndex] = newIndex;
          });
          if (self2.data.isGroup || self2.data.isPivot) {
            var postorder = function(node, depth) {
              if (node.children == null) {
                node.rowValIndex = rowValIdxMap[node.rowValIndex];
                self2.data.groupMetadata.lookup.byRowValIndex[node.rowValIndex] = node;
              } else {
                index_default_default.each(node.children, function(child) {
                  postorder(child, depth + 1);
                });
                if (depth > 0) {
                  node.rowValIndex = node.children[index_default_default.keys(node.children)[0]].rowValIndex;
                }
              }
            };
            postorder(self2.data.groupMetadata, 0);
          }
          if (origCellAgg != null) {
            for (ai = 0; ai < origCellAgg.length; ai += 1) {
              self2.data.agg.results.cell[ai] = [];
              index_default_default.each(sorted, function(s2, newIndex) {
                self2.data.agg.results.cell[ai][newIndex] = origCellAgg[ai][s2.oldIndex];
              });
            }
          }
          if (origGroupAgg != null) {
            for (ai = 0; ai < origGroupAgg.length; ai += 1) {
              self2.data.agg.results.group[ai] = [];
              index_default_default.each(sorted, function(s2, newIndex) {
                self2.data.agg.results.group[ai][newIndex] = origGroupAgg[ai][s2.oldIndex];
              });
            }
          }
          break;
        case "horizontal":
          self2.data.data = [];
          if (origColVals != null) {
            self2.data.colVals = [];
          }
          if (origCellAgg != null) {
            self2.data.agg.results.cell = [];
          }
          if (origPivotAgg != null) {
            self2.data.agg.results.pivot = [];
          }
          index_default_default.each(sorted, function(s2, newIndex) {
            self2.data.colVals[newIndex] = origColVals[s2.oldIndex];
            if (origColVals != null) {
              for (var rvi2 = 0; rvi2 < self2.data.rowVals.length; rvi2 += 1) {
                if (self2.data.data[rvi2] === void 0) {
                  self2.data.data[rvi2] = [];
                }
                self2.data.data[rvi2][newIndex] = origData[rvi2][s2.oldIndex];
              }
            }
          });
          if (origCellAgg != null) {
            for (ai = 0; ai < origCellAgg.length; ai += 1) {
              self2.data.agg.results.cell[ai] = new Array(self2.data.rowVals.length);
              for (rvi = 0; rvi < self2.data.rowVals.length; rvi += 1) {
                self2.data.agg.results.cell[ai][rvi] = new Array(self2.data.colVals.length);
                index_default_default.each(sorted, function(s2, newIndex) {
                  self2.data.agg.results.cell[ai][rvi][newIndex] = origCellAgg[ai][rvi][s2.oldIndex];
                });
              }
            }
          }
          if (origPivotAgg != null) {
            for (ai = 0; ai < origPivotAgg.length; ai += 1) {
              self2.data.agg.results.pivot[ai] = new Array(self2.data.colVals.length);
              index_default_default.each(sorted, function(s2, newIndex) {
                self2.data.agg.results.pivot[ai][newIndex] = origPivotAgg[ai][s2.oldIndex];
              });
            }
          }
          break;
      }
    };
  };
  var makeFinishCb = function(postProcess, next) {
    return function(sorted) {
      if (typeof postProcess === "function") {
        postProcess(sorted);
      } else {
        self2.data.data = sorted;
      }
      return next(true);
    };
  };
  var performSort = function(orientation, next) {
    var fti, sortSourceFn, spec = getProp(self2, "sortSpec", orientation), sortAlgorithm = "mergeSort";
    var rvi, cvi, gfi;
    if (spec == null) {
      return next(false);
    }
    spec = deepCopy(spec);
    if (self2.data.isPlain) {
      if (orientation === "horizontal") {
        log.error("Unable to sort: cannot perform horizontal sort on plain data");
        return next(false);
      }
      if (spec.field) {
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else {
          fti = self2.typeInfo.get(spec.field);
        }
        sortSourceFn = function(i2) {
          return self2.data.data[i2].rowData[spec.field].value;
        };
      }
    } else if (self2.data.isGroup) {
      if (orientation === "horizontal") {
        log.error("Unable to sort: cannot perform horizontal sort on grouped data");
        return next(false);
      }
      if (spec.field != null) {
        gfi = self2.data.groupFields.indexOf(spec.field);
        if (gfi < 0) {
          log.error('Unable to sort: `field` property does not refer to a grouped field {field = "%s", groupFields = %s}', spec.field, self2.data.groupFields);
        } else {
          spec.groupFieldIndex = gfi;
        }
      }
      if (spec.groupFieldIndex != null) {
        if (spec.groupFieldIndex < 0 || spec.groupFieldIndex >= self2.data.groupFields.length) {
          log.error(
            "Unable to sort: groupFieldIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.groupFields.length
          );
          return next(false);
        }
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else if (self2.data.groupSpec[spec.groupFieldIndex].fun != null) {
          fti = {
            type: GROUP_FUNCTION_REGISTRY.get(self2.data.groupSpec[spec.groupFieldIndex].fun).sortType
          };
        } else {
          fti = self2.typeInfo.get(self2.data.groupFields[spec.groupFieldIndex]);
        }
        sortSourceFn = function(i2) {
          return self2.data.rowVals[i2][spec.groupFieldIndex];
        };
      } else if (spec.aggType === "group" && spec.aggNum != null) {
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.group.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.group.length
          );
          return next(false);
        }
        fti = aggInfo.group[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.group[spec.aggNum][i2];
        };
      }
    } else if (self2.data.isPivot) {
      if (spec.field != null) {
        switch (orientation) {
          case "vertical":
            gfi = self2.data.groupFields.indexOf(spec.field);
            if (gfi < 0) {
              log.error('Unable to sort: `field` property does not refer to a grouped field {field = "%s", groupFields = %s}', spec.field, self2.data.groupFields);
            } else {
              spec.groupFieldIndex = gfi;
            }
            break;
          case "horizontal":
            var pfi = self2.data.pivotFields.indexOf(spec.field);
            if (pfi < 0) {
              log.error('Unable to sort: `field` property does not refer to a pivotted field {field = "%s", pivotFields = %s}', spec.field, self2.data.pivotFields);
            } else {
              spec.pivotFieldIndex = pfi;
            }
            break;
        }
      }
      if (spec.groupFieldIndex != null) {
        if (spec.groupFieldIndex < 0 || spec.groupFieldIndex >= self2.data.groupFields.length) {
          log.error(
            "Unable to sort: groupFieldIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.groupFields.length
          );
          return next(false);
        }
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else if (self2.data.groupSpec[spec.groupFieldIndex].fun != null) {
          fti = {
            type: GROUP_FUNCTION_REGISTRY.get(self2.data.groupSpec[spec.groupFieldIndex].fun).sortType
          };
        } else {
          fti = self2.typeInfo.get(self2.data.groupFields[spec.groupFieldIndex]);
        }
        sortSourceFn = function(i2) {
          return self2.data.rowVals[i2][spec.groupFieldIndex];
        };
      } else if ((spec.rowVal || spec.rowValIndex != null) && spec.aggNum != null) {
        if (spec.rowVal) {
          spec.rowValIndex = -1;
          for (rvi = 0; rvi < self2.data.rowVals.length; rvi += 1) {
            if (index_default_default.isEqual(self2.data.rowVals[rvi], spec.rowVal)) {
              spec.rowValIndex = rvi;
              break;
            }
          }
          if (spec.rowValIndex === -1) {
            log.error("Unable to sort: invalid rowVal {spec = %O}", spec);
            return next(false);
          }
        }
        if (spec.rowValIndex < 0 || spec.rowValIndex >= self2.data.rowVals.length) {
          log.error(
            "Unable to sort: rowValIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.rowVals.length
          );
          return next(false);
        }
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.cell.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.cell.length
          );
          return next(false);
        }
        fti = aggInfo.cell[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.cell[spec.aggNum][spec.rowValIndex][i2];
        };
      } else if (spec.pivotFieldIndex != null) {
        if (spec.pivotFieldIndex < 0 || spec.pivotFieldIndex >= self2.data.pivotFields.length) {
          log.error(
            "Unable to sort: pivotFieldIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.pivotFields.length
          );
          return next(false);
        }
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else if (self2.data.pivotSpec[spec.pivotFieldIndex].fun != null) {
          fti = {
            type: GROUP_FUNCTION_REGISTRY.get(self2.data.pivotSpec[spec.pivotFieldIndex].fun).sortType
          };
        } else {
          fti = self2.typeInfo.get(self2.data.pivotFields[spec.pivotFieldIndex]);
        }
        sortSourceFn = function(i2) {
          return self2.data.colVals[i2][spec.pivotFieldIndex];
        };
      } else if ((spec.colVal || spec.colValIndex != null) && spec.aggNum != null) {
        if (spec.colVal) {
          spec.colValIndex = -1;
          for (cvi = 0; cvi < self2.data.colVals.length; cvi += 1) {
            if (index_default_default.isEqual(self2.data.colVals[cvi], spec.colVal)) {
              spec.colValIndex = cvi;
              break;
            }
          }
          if (spec.colValIndex === -1) {
            log.error("Unable to sort: invalid colVal {spec = %O}", spec);
            return next(false);
          }
        }
        if (spec.colValIndex < 0 || spec.colValIndex >= self2.data.colVals.length) {
          log.error(
            "Unable to sort: colValIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.colVals.length
          );
          return next(false);
        }
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.cell.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.cell.length
          );
          return next(false);
        }
        fti = aggInfo.cell[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.cell[spec.aggNum][i2][spec.colValIndex];
        };
      } else if (spec.aggType === "pivot" && spec.aggNum != null) {
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.pivot.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.pivot.length
          );
          return next(false);
        }
        fti = aggInfo.pivot[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.pivot[spec.aggNum][i2];
        };
      } else if (spec.aggType === "group" && spec.aggNum != null) {
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.group.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.group.length
          );
          return next(false);
        }
        fti = aggInfo.group[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.group[spec.aggNum][i2];
        };
      } else {
        log.error("Invalid sort spec for pivotted data: " + JSON.stringify(spec));
        return next(false);
      }
    }
    var cmp2, comparison;
    if (sortAlgorithm === "mergeSort") {
      cmp2 = determineCmp(spec, fti);
      if (cmp2 == null) {
        return next(false);
      }
      comparison = function(a2, b) {
        if (spec.dir.toUpperCase() === "ASC") {
          return cmp2(a2.sortSource, b.sortSource) <= 0;
        } else if (spec.dir.toUpperCase() === "DESC") {
          return cmp2(a2.sortSource, b.sortSource) > 0;
        } else {
          throw new Error('Invalid sort spec: `dir` must be either "ASC" or "DESC"');
        }
      };
    }
    var bundle = packBundle(spec, orientation, sortSourceFn);
    if (bundle == null) {
      return next(false);
    }
    var finish = makeFinishCb(unpackBundle(orientation), next);
    self2.debug("SORT", "Performing sort using %s algorithm", sortAlgorithm);
    switch (sortAlgorithm) {
      case "mergeSort":
        return mergeSort4(bundle, comparison, finish, self2.sortProgress && self2.sortProgress.update);
      case "pigeonHole":
        return pigeonHoleSort(bundle, spec.values, finish);
      default:
        throw new Error("Internal Error: Invalid sort algorithm: " + sortAlgorithm);
    }
  };
  self2.fire("sortBegin");
  self2.timing.start(timingEvt);
  if (self2.sortProgress && typeof self2.sortProgress.begin === "function") {
    self2.sortProgress.begin();
  }
  performSort("horizontal", function(didHorizontal) {
    performSort("vertical", function(didVertical) {
      if (self2.sortProgress && typeof self2.sortProgress.end === "function") {
        self2.sortProgress.end();
      }
      self2.timing.stop(timingEvt);
      self2.fire("sortEnd");
      return cont(didHorizontal || didVertical);
    });
  });
};
View.prototype._setFilter = function(spec, progress, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  opts = deepCopy(opts) || {};
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setFilter.apply(self2, args);
    }, "Waiting to set filter: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET FILTER", "spec = %O ; options = %O", spec, opts);
  isDifferent = !index_default_default.isEqual(self2.filterSpec, spec);
  if (self2.filterSpec != null && spec == null) {
    self2.wasPreviouslyFiltered = true;
  }
  self2.filterSpec = spec;
  self2.filterProgress = progress;
  if (opts.sendEvent) {
    self2.fire("filterSet", {
      notTo: opts.dontSendEventTo
    }, spec);
  }
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (opts.updateData) {
    self2.getData();
  }
  return true;
};
View.prototype.getFilter = function() {
  var self2 = this;
  return self2.filterSpec;
};
View.prototype.clearFilter = function(opts) {
  this.setFilter(null, null, opts);
};
View.prototype.isFiltered = function() {
  return this.filterSpec != null;
};
View.prototype.filter = function(cont) {
  var self2 = this, timingEvt = ['Data Source "' + self2.source.name + '" : ' + self2.name, "Filtering"];
  if (self2.filterSpec == null) {
    if (!self2.wasPreviouslyFiltered) {
      return cont(false, self2.data.data);
    } else {
      self2.wasPreviouslyFiltered = false;
    }
  }
  index_default_default.each(self2.filterSpec, function(fieldSpec, field) {
    var fti = self2.typeInfo.get(field);
    if (fti === void 0) {
      log.error('Filter field "' + field + '" does not exist in the source');
      self2.fire("invalidFilterField", null, field);
      delete self2.filterSpec[field];
      return;
    }
    if (fti.type === void 0) {
      log.error('Unable to filter field "' + field + '", type is unknown');
      self2.fire("invalidFilterField", null, field);
      delete self2.filterSpec[field];
      return;
    }
    if (["date", "datetime"].indexOf(fti.type) >= 0 && fti.internalType === "moment") {
      index_default_default.each(fieldSpec, function(val, op) {
        if (typeof val === "string") {
          fieldSpec[op] = moment_default(val);
        }
      });
    }
    self2._maybeDecode("FILTER", fti);
  });
  function passesFilter(fltr, field, row) {
    var fti = self2.typeInfo.get(field);
    var datum = row[field].value;
    if (datum === void 0) {
      debug.warn(
        "VIEW (" + self2.name + ") // FILTER",
        "Attempted to filter by non-existent column: " + field
      );
      return false;
    }
    var isMoment2 = moment_default.isMoment(datum);
    var isNumeral = import_numeral7.default.isNumeral(datum);
    var isString2 = typeof datum === "string";
    var isNumber3 = typeof datum === "number";
    var pred = {};
    var cmp2 = getComparisonFn.byType(fti.type);
    pred["$eq"] = function(operand2) {
      return cmp2(datum, operand2) === 0;
    };
    pred["$ne"] = function(operand2) {
      return !pred["$eq"](operand2);
    };
    pred["$contains"] = function(operand2) {
      return isMoment2 && false || isNumeral && false || isString2 && datum.indexOf(operand2.toString().toLowerCase()) >= 0 || isNumber3 && false;
    };
    pred["$notcontains"] = function(operand2) {
      return !pred["$notcontains"](operand2);
    };
    pred["$gt"] = function(operand2) {
      return cmp2(datum, operand2) > 0;
    };
    pred["$gte"] = function(operand2) {
      return pred["$gt"](operand2) || pred["$eq"](operand2);
    };
    pred["$lt"] = function(operand2) {
      return cmp2(datum, operand2) < 0;
    };
    pred["$lte"] = function(operand2) {
      return pred["$lt"](operand2) || pred["$eq"](operand2);
    };
    if (index_default_default.isArray(fltr)) {
      fltr = { "$in": fltr };
    } else if (!index_default_default.isObject(fltr)) {
      fltr = { "$eq": fltr };
    }
    for (var operator in fltr) {
      if (!Object.prototype.hasOwnProperty.call(fltr, operator)) {
        continue;
      }
      var operand = fltr[operator];
      if (pred[operator] !== void 0) {
        if (index_default_default.isArray(operand)) {
          if (index_default_default.every(operand, pred[operator]) === false) {
            return false;
          }
        } else if (pred[operator](operand) === false) {
          return false;
        }
      } else {
        switch (operator) {
          case "$in":
            if (!index_default_default.isArray(operand)) {
              throw new Error('Invalid filter spec, operator "$in" for column "' + field + '" requires array value');
            }
            if (index_default_default.map(operand, function(elt2) {
              return elt2.toString().toLowerCase();
            }).indexOf(datum.toString().toLowerCase()) < 0) {
              return false;
            }
            break;
          case "$nin":
            if (!index_default_default.isArray(operand)) {
              throw new Error('Invalid filter spec, operator "$nin" for column "' + field + '" requires array value');
            }
            if (index_default_default.map(operand, function(elt2) {
              return elt2.toString().toLowerCase();
            }).indexOf(datum.toString().toLowerCase()) >= 0) {
              return false;
            }
            break;
          default:
            throw new Error('Invalid operator "' + operator + '" for column "' + field + '"');
        }
      }
    }
    return true;
  }
  function passesAllFilters(row) {
    var passes = self2.filterSpec == null ? true : eachUntilObj(self2.filterSpec, passesFilter, false, row.rowData);
    self2.fire("filter", {
      silent: true
    }, row.rowNum, !passes);
    return passes;
  }
  var i0 = {
    val: 0
  }, i_step = self2.filterProgress ? 100 : self2.data.data.length;
  var newData = [];
  var doFilter = function() {
    var i2;
    for (i2 = i0.val; i2 < self2.data.data.length && i2 < i0.val + i_step; i2 += 1) {
      if (passesAllFilters(self2.data.data[i2])) {
        newData.push(self2.data.data[i2]);
      }
    }
    if (i2 < self2.data.data.length) {
      i0.val = i2;
      if (self2.filterProgress && typeof self2.filterProgress.update === "function") {
        self2.filterProgress.update(i2, self2.data.data.length);
      }
      logAsync("View#filter");
      return window.setTimeout(doFilter);
    } else {
      if (self2.filterProgress && typeof self2.filterProgress.end === "function") {
        self2.filterProgress.end();
      }
      self2.fire("filterEnd");
      self2.timing.stop(timingEvt);
      return cont(true, newData);
    }
  };
  self2.timing.start(timingEvt);
  if (self2.filterProgress && typeof self2.filterProgress.begin === "function") {
    self2.filterProgress.begin();
  }
  self2.fire("filterBegin");
  return doFilter();
};
View.prototype._setGroup = function(spec, opts, cont) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setGroup.apply(self2, args);
    }, "Waiting to set group: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET GROUP", "spec = %O", spec);
  if (spec == null && self2.pivotSpec != null) {
    log.warn("VIEW (" + self2.name + ") // SET GROUP", "Having a pivot without a group is not allowed");
    self2.clearPivot(opts);
  }
  if (spec != null) {
    if (!index_default_default.isArray(spec.fieldNames)) {
      log.warn("VIEW (" + self2.name + ") // SET GROUP", "`spec.fieldNames` is not an array");
      spec.fieldNames = [];
    }
    for (var i2 = 0; i2 < spec.fieldNames.length; i2 += 1) {
      if (typeof spec.fieldNames[i2] === "string") {
        spec.fieldNames[i2] = { field: spec.fieldNames[i2] };
      }
    }
  }
  isDifferent = !index_default_default.isEqual(self2.groupSpec, spec);
  self2.groupSpec = spec;
  if (opts.sendEvent) {
    self2.fire("groupSet", {
      notTo: opts.dontSendEventTo
    }, spec);
  }
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (!opts.updateData) {
    return true;
  }
  self2.getData();
  return true;
};
View.prototype.getGroup = function() {
  var self2 = this;
  return self2.groupSpec;
};
View.prototype.clearGroup = function(opts) {
  return this.setGroup(null, opts);
};
View.prototype.group = function() {
  var self2 = this, finalGroupSpec = [], newData, rowVals;
  if (self2.groupSpec == null) {
    return false;
  }
  if (self2.typeInfo == null) {
    log.error("Source type information is missing");
    return false;
  }
  index_default_default.each(self2.groupSpec.fieldNames, function(fieldObj) {
    var fti = self2.typeInfo.get(fieldObj.field);
    if (fti == null) {
      log.error("Group field does not exist in the source: " + fieldObj.field);
      self2.fire("invalidGroupField", null, fieldObj.field);
    } else if (fti.type == null) {
      log.error('Unable to group by field "%s": type is undefined');
    } else {
      self2._maybeDecode("GROUP", fti);
      finalGroupSpec.push(fieldObj);
    }
  });
  if (finalGroupSpec.length === 0) {
    return false;
  }
  var origKeys = [];
  var buildRowVals = function(addRowVals) {
    var rowVals2 = [], rowVal, row, rowIndex, groupSpecElt, groupFieldIndex2, cell, value, natRep, groupFun, groupFunResult;
    for (rowIndex = 0; rowIndex < self2.data.data.length; rowIndex += 1) {
      row = self2.data.data[rowIndex];
      rowVal = [];
      for (groupFieldIndex2 = 0; groupFieldIndex2 < finalGroupSpec.length; groupFieldIndex2 += 1) {
        groupSpecElt = finalGroupSpec[groupFieldIndex2];
        cell = row.rowData[groupSpecElt.field];
        value = cell.value;
        if (groupSpecElt.fun == null) {
          natRep = getNatRep(value);
          origKeys[groupFieldIndex2][natRep] = value;
        } else {
          groupFun = GROUP_FUNCTION_REGISTRY.get(groupSpecElt.fun);
          groupFunResult = groupFun.applyValueFun(value, self2.typeInfo.get(groupSpecElt.field));
          natRep = getNatRep(groupFunResult);
          origKeys[groupFieldIndex2][natRep] = groupFunResult;
        }
        rowVal[groupFieldIndex2] = natRep;
        setProp(natRep, cell, "natRep", "group", groupFieldIndex2);
      }
      if (index_default_default.findIndex(rowVals2, function(x) {
        return arrayEqual(rowVal, x);
      }) === -1) {
        rowVals2.push(rowVal);
      }
    }
    if (addRowVals != null) {
      for (var arvIndex = 0; arvIndex < addRowVals.length; arvIndex += 1) {
        rowVal = addRowVals[arvIndex];
        if (rowVal.length != finalGroupSpec.length) {
          log.error(
            "Unable to add rowVal %s when grouping by %s: the lengths must be the same",
            JSON.stringify(rowVal),
            JSON.stringify(finalGroupSpec)
          );
          continue;
        }
        for (groupFieldIndex2 = 0; groupFieldIndex2 < rowVal.length; groupFieldIndex2 += 1) {
          value = rowVal[groupFieldIndex2];
          natRep = getNatRep(value);
          origKeys[groupFieldIndex2][natRep] = value;
          rowVal[groupFieldIndex2] = natRep;
        }
        if (index_default_default.findIndex(rowVals2, function(x) {
          return arrayEqual(rowVal, x);
        }) === -1) {
          rowVals2.push(rowVal);
        }
      }
    }
    rowVals2.sort(function(a2, b) {
      return arrayCompare(a2, b);
    });
    return rowVals2;
  };
  var buildData = function(data, rowVals2) {
    var rowVal, rowValIndex, metadataLeaf, row, rowIndex, groupSpecElt, groupFieldIndex2, value, groupFun;
    var result2 = new Array(rowVals2.length);
    var metadataTree = {
      lookup: {
        byRowNum: new Array(data.length),
        byRowValIndex: new Array(rowVals2.length),
        byId: []
      }
    };
    for (rowValIndex = 0; rowValIndex < rowVals2.length; rowValIndex += 1) {
      rowVal = rowVals2[rowValIndex];
      metadataLeaf = {
        rowValIndex,
        rowValElt: rowVal[rowVal.length - 1],
        parent: null,
        numRows: 0,
        rows: []
      };
      result2[rowValIndex] = metadataLeaf.rows;
      setProp(metadataLeaf, metadataTree, "children", interleaveWith(rowVal, "children"));
      metadataTree.lookup.byRowValIndex[rowValIndex] = metadataLeaf;
    }
    for (rowIndex = 0; rowIndex < data.length; rowIndex += 1) {
      row = data[rowIndex];
      rowVal = new Array(finalGroupSpec.length);
      for (groupFieldIndex2 = 0; groupFieldIndex2 < finalGroupSpec.length; groupFieldIndex2 += 1) {
        groupSpecElt = finalGroupSpec[groupFieldIndex2];
        rowVal[groupFieldIndex2] = row.rowData[groupSpecElt.field].natRep.group[groupFieldIndex2];
      }
      metadataLeaf = getProp(metadataTree, "children", interleaveWith(rowVal, "children"));
      metadataTree.lookup.byRowNum[row.rowNum] = metadataLeaf;
      metadataLeaf.rows.push(row);
    }
    var metadataId = 0;
    var postorder = function(node, depth) {
      node.id = metadataId++;
      node.numRows = 0;
      metadataTree.lookup.byId[node.id] = node;
      if (node.children == null) {
        if (node.rows != null) {
          node.numRows = node.rows.length;
        }
      } else {
        node.numChildren = index_default_default.keys(node.children).length;
        node.rows = [];
        index_default_default.each(node.children, function(child) {
          child.parent = node;
          postorder(child, depth + 1);
          node.numRows += child.numRows;
          node.rows = node.rows.concat(child.rows);
        });
        if (depth > 0) {
          node.rowValIndex = node.children[index_default_default.keys(node.children)[0]].rowValIndex;
          node.rowValElt = rowVals2[node.rowValIndex][depth - 1];
        }
      }
      if (depth > 0) {
        node.groupFieldIndex = depth - 1;
        node.groupField = finalGroupSpec[node.groupFieldIndex].field;
        node.groupSpec = finalGroupSpec[node.groupFieldIndex];
        if (node.rows != null && node.rows.length > 0) {
          node.rowValCell = node.rows[0].rowData[node.groupField];
        }
      }
    };
    postorder(metadataTree, 0);
    return {
      data: result2,
      metadata: metadataTree
    };
  };
  var convertRowVals = function(rowVals2) {
    var result2 = [];
    for (var rowValIndex = 0; rowValIndex < rowVals2.length; rowValIndex += 1) {
      var rowVal = rowVals2[rowValIndex];
      result2[rowValIndex] = [];
      for (var groupFieldIndex2 = 0; groupFieldIndex2 < finalGroupSpec.length; groupFieldIndex2 += 1) {
        result2[rowValIndex][groupFieldIndex2] = origKeys[groupFieldIndex2][rowVal[groupFieldIndex2]];
      }
    }
    return result2;
  };
  for (var groupFieldIndex = 0; groupFieldIndex < finalGroupSpec.length; groupFieldIndex += 1) {
    origKeys[groupFieldIndex] = {};
  }
  rowVals = buildRowVals(self2.groupSpec.addRowVals);
  newData = buildData(self2.data.data, rowVals);
  rowVals = convertRowVals(rowVals);
  self2.debug("GROUP", "Group Spec: %O", finalGroupSpec);
  self2.debug("GROUP", "Row Vals: %O", rowVals);
  self2.debug("GROUP", "New Data: %O", newData.data);
  self2.data.isPlain = false;
  self2.data.isGroup = true;
  self2.data.groupFields = index_default_default.pluck(finalGroupSpec, "field");
  self2.data.groupSpec = finalGroupSpec;
  self2.data.rowVals = rowVals;
  self2.data.data = newData.data;
  self2.data.groupMetadata = newData.metadata;
  self2.debug("GROUP", "Final Data: %O", self2.data);
  return true;
};
View.prototype._setPivot = function(spec, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setPivot.apply(self2, args);
    }, "Waiting to set pivot: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET PIVOT", "spec = %O", spec);
  if (self2.groupSpec == null && spec != null) {
    log.warn("VIEW (" + self2.name + ") // SET PIVOT", "Having a pivot without a group is not allowed");
    self2.clearPivot(opts);
    return false;
  }
  if (spec != null) {
    if (!index_default_default.isArray(spec.fieldNames)) {
      log.warn("VIEW (" + self2.name + ") // SET PIVOT", "`spec.fieldNames` is not an array");
      spec.fieldNames = [];
    }
    for (var i2 = 0; i2 < spec.fieldNames.length; i2 += 1) {
      if (typeof spec.fieldNames[i2] === "string") {
        spec.fieldNames[i2] = { field: spec.fieldNames[i2] };
      }
    }
  }
  isDifferent = !index_default_default.isEqual(self2.pivotSpec, spec);
  self2.pivotSpec = spec;
  if (opts.sendEvent) {
    self2.fire("pivotSet", {
      notTo: opts.dontSendEventTo
    }, spec);
  }
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (!opts.updateData) {
    return true;
  }
  self2.getData();
  return true;
};
View.prototype.getPivot = function() {
  var self2 = this;
  return self2.pivotSpec;
};
View.prototype.clearPivot = function(opts) {
  return this.setPivot(null, opts);
};
View.prototype.pivot_orig = function() {
  var self2 = this, pivotFields = [], colValsTree, colVals;
  if (!self2.data.isGroup) {
    return false;
  }
  if (self2.pivotSpec == null) {
    return false;
  }
  if (self2.typeInfo == null) {
    log.error("Source type information is missing");
    return false;
  }
  index_default_default.each(self2.pivotSpec.fieldNames, function(field, fieldIdx) {
    if (!self2.typeInfo.isSet(field)) {
      log.error("Pivot field does not exist in the source: " + field);
      self2.fire("invalidPivotField", null, field);
    } else {
      pivotFields.push(field);
    }
  });
  if (pivotFields.length === 0) {
    return false;
  }
  var buildColValsTree = function(pivotFields2) {
    var colValsTree2 = {};
    index_default_default.each(self2.data.data, function(groupedRows) {
      (function RECUR(fieldNames, data, tree) {
        var field = car(fieldNames), tmp = {};
        index_default_default.each(data, function(row) {
          var value = row.rowData[field].orig || row.rowData[field].value;
          if (tree[value] === void 0) {
            tree[value] = fieldNames.length > 1 ? {} : true;
          }
          if (tmp[value] === void 0) {
            tmp[value] = [];
          }
          tmp[value].push(row);
        });
        if (fieldNames.length > 1) {
          index_default_default.each(tmp, function(pivottedRows, value) {
            RECUR(cdr(fieldNames), pivottedRows, tree[value]);
          });
        }
      })(pivotFields2, groupedRows, colValsTree2);
    });
    return colValsTree2;
  };
  var buildColVals = function(colValsTree2) {
    var colVals2 = [];
    (function RECUR(tree, level, path) {
      if (level === self2.pivotSpec.fieldNames.length) {
        index_default_default.each(index_default_default.keys(tree).sort(), function(value) {
          colVals2.push(path.concat([value]));
        });
      } else {
        index_default_default.each(tree, function(subtree, value) {
          RECUR(subtree, level + 1, path.concat([value]));
        });
      }
    })(colValsTree2, 1, []);
    return colVals2;
  };
  var buildData = function(data) {
    var result2 = [];
    index_default_default.each(data, function(groupedRows, groupNum) {
      var newData = [];
      index_default_default.each(colVals, function(colVal) {
        var tmp = [];
        index_default_default.each(groupedRows, function(row) {
          if (index_default_default.every(colVal, function(colValElt, colValNum) {
            var pivotField = pivotFields[colValNum];
            var value = row.rowData[pivotField].value;
            var natRep = getNatRep(value);
            return colValElt === natRep;
          })) {
            tmp.push(row);
          }
        });
        newData.push(tmp);
      });
      result2.push(newData);
    });
    return result2;
  };
  colValsTree = buildColValsTree(pivotFields);
  colVals = buildColVals(colValsTree);
  self2.data.data = buildData(self2.data.data, colVals);
  self2.debug("PIVOT", "Pivot Fields: %O", pivotFields);
  self2.debug("PIVOT", "Col Vals Tree: %O", colValsTree);
  self2.debug("PIVOT", "Col Vals: %O", colVals);
  self2.debug("PIVOT", "New Data: %O", self2.data);
  self2.data.isPlain = false;
  self2.data.isGroup = false;
  self2.data.isPivot = true;
  self2.data.pivotFields = pivotFields;
  self2.data.colVals = colVals;
  return true;
};
View.prototype.pivot = function() {
  var self2 = this, finalPivotSpec = [], colValsTree, colVals, newData;
  if (!self2.data.isGroup) {
    return false;
  }
  if (self2.pivotSpec == null) {
    return false;
  }
  if (self2.typeInfo == null) {
    log.error("Source type information is missing");
    return false;
  }
  index_default_default.each(self2.pivotSpec.fieldNames, function(fieldObj) {
    var fti = self2.typeInfo.get(fieldObj.field);
    if (fti == null) {
      log.error("Pivot field does not exist in the source: " + fieldObj.field);
      self2.fire("invalidPivotField", null, fieldObj.field);
    } else if (fti.type == null) {
      log.error('Unable to pivot by field "%s": type is undefined');
    } else {
      self2._maybeDecode("PIVOT", fti);
      finalPivotSpec.push(fieldObj);
    }
  });
  if (finalPivotSpec.length === 0) {
    return false;
  }
  var origKeys = [];
  var buildColVals = function(addColVals) {
    var colVal, pivotFieldIndex2, pivotSpecElt, value, natRep, groupFun, groupIndex, group2, row, rowIndex, acvIndex, colVals2 = [];
    for (groupIndex = 0; groupIndex < self2.data.data.length; groupIndex += 1) {
      group2 = self2.data.data[groupIndex];
      for (rowIndex = 0; rowIndex < group2.length; rowIndex += 1) {
        row = group2[rowIndex];
        colVal = [];
        for (pivotFieldIndex2 = 0; pivotFieldIndex2 < finalPivotSpec.length; pivotFieldIndex2 += 1) {
          pivotSpecElt = finalPivotSpec[pivotFieldIndex2];
          value = row.rowData[pivotSpecElt.field].value;
          if (pivotSpecElt.fun == null) {
            natRep = getNatRep(value);
            origKeys[pivotFieldIndex2][natRep] = value;
          } else {
            groupFun = GROUP_FUNCTION_REGISTRY.get(pivotSpecElt.fun);
            natRep = groupFun.applyValueFun(value, self2.typeInfo.get(pivotSpecElt.field));
            origKeys[pivotFieldIndex2][natRep] = natRep;
          }
          setProp(natRep, row.rowData[pivotSpecElt.field], "natRep", "pivot", pivotFieldIndex2);
          colVal[pivotFieldIndex2] = natRep;
        }
        if (index_default_default.findIndex(colVals2, function(x) {
          return arrayEqual(colVal, x);
        }) === -1) {
          colVals2.push(colVal);
        }
      }
    }
    if (addColVals != null) {
      for (acvIndex = 0; acvIndex < addColVals.length; acvIndex += 1) {
        colVal = addColVals[acvIndex];
        if (colVal.length != finalPivotSpec.length) {
          log.error(
            "Unable to add colVal %s when pivotting by %s: the lengths must be the same",
            JSON.stringify(colVal),
            JSON.stringify(finalPivotSpec)
          );
          continue;
        }
        for (pivotFieldIndex2 = 0; pivotFieldIndex2 < colVal.length; pivotFieldIndex2 += 1) {
          value = colVal[pivotFieldIndex2];
          natRep = getNatRep(value);
          origKeys[pivotFieldIndex2][natRep] = value;
          colVal[pivotFieldIndex2] = natRep;
        }
        if (index_default_default.findIndex(colVals2, function(x) {
          return arrayEqual(colVal, x);
        }) === -1) {
          colVals2.push(colVal);
        }
      }
    }
    colVals2.sort(function(a2, b) {
      return arrayCompare(a2, b);
    });
    return colVals2;
  };
  var buildData = function(data) {
    var result2 = [];
    index_default_default.each(data, function(groupedRows, groupNum) {
      var newData2 = [];
      index_default_default.each(colVals, function(colVal) {
        var tmp = [];
        index_default_default.each(groupedRows, function(row) {
          if (index_default_default.every(colVal, function(colValElt, colValIndex) {
            var pivotSpecElt = finalPivotSpec[colValIndex];
            return colValElt === row.rowData[pivotSpecElt.field].natRep.pivot[colValIndex];
          })) {
            tmp.push(row);
          }
        });
        newData2.push(tmp);
      });
      result2.push(newData2);
    });
    return result2;
  };
  var convertColVals = function(colVals2) {
    var result2 = [];
    for (var colValIndex = 0; colValIndex < colVals2.length; colValIndex += 1) {
      var colVal = colVals2[colValIndex];
      result2[colValIndex] = [];
      for (var pivotFieldIndex2 = 0; pivotFieldIndex2 < finalPivotSpec.length; pivotFieldIndex2 += 1) {
        result2[colValIndex][pivotFieldIndex2] = origKeys[pivotFieldIndex2][colVal[pivotFieldIndex2]];
      }
    }
    return result2;
  };
  for (var pivotFieldIndex = 0; pivotFieldIndex < finalPivotSpec.length; pivotFieldIndex += 1) {
    origKeys[pivotFieldIndex] = {};
  }
  colVals = buildColVals(self2.pivotSpec.addColVals);
  newData = buildData(self2.data.data, colVals);
  colVals = convertColVals(colVals);
  self2.debug("PIVOT", "Pivot Spec: %O", finalPivotSpec);
  self2.debug("PIVOT", "Orig Keys: %O", origKeys);
  self2.debug("PIVOT", "Col Vals: %O", colVals);
  self2.debug("PIVOT", "New Data: %O", newData);
  self2.data.isPlain = false;
  self2.data.isGroup = false;
  self2.data.isPivot = true;
  self2.data.pivotFields = index_default_default.pluck(finalPivotSpec, "field");
  self2.data.pivotSpec = finalPivotSpec;
  self2.data.colVals = colVals;
  self2.data.data = newData;
  self2.debug("GROUP", "Final Data: %O", self2.data);
  return true;
};
View.prototype._setAggregate = function(spec, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  var shouldGraph = {
    group: [],
    pivot: []
  };
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setAggregate.apply(self2, args);
    }, "Waiting to set aggregate: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET AGGREGATE", "spec = %O ; options = %O", spec, opts);
  isDifferent = !index_default_default.isEqual(self2.aggregateSpec, spec);
  if (spec == null) {
    self2.aggregateSpec = null;
  } else {
    index_default_default.each(spec, function(aggSpec, aggType) {
      aggSpec = index_default_default.filter(aggSpec, function(agg) {
        var a2 = AGGREGATE_REGISTRY.get(agg.fun);
        if (a2 == null) {
          log.error('Ignoring aggregate "' + agg.fun + '" because no such aggregate function exists');
          return false;
        }
        if ((aggType === "group" || aggType === "pivot") && agg.shouldGraph) {
          shouldGraph[aggType].push(agg);
        }
        return true;
      });
      spec[aggType] = aggSpec;
    });
    self2.aggregateSpec = deepCopy(spec);
  }
  if (opts.sendEvent) {
    self2.fire("aggregateSet", {
      notTo: opts.dontSendEventTo
    }, spec, shouldGraph);
  }
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (!opts.updateData) {
    return true;
  }
  self2.getData();
  return true;
};
View.prototype.getAggregate = function() {
  var self2 = this;
  return self2.aggregateSpec;
};
View.prototype.clearAggregate = function(opts) {
  var self2 = this;
  return self2.setAggregate(objFromArray(["group", "pivot", "cell", "all"], [[{ fun: "count" }]]), opts);
};
View.prototype.aggregate = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  if (!(self2.aggregateSpec && (self2.data.isGroup || self2.data.isPivot))) {
    return cont(false);
  }
  index_default_default.each(["group", "pivot", "cell", "all"], function(what) {
    self2.debug(
      "AGGREGATE",
      "Computing %s aggregate functions: %s",
      what,
      index_default_default.pluck(getProp(self2, "aggregateSpec", what), "fun").join(", ")
    );
  });
  var groupResults = [];
  var pivotResults = [];
  var cellResults = [];
  var allResults = [];
  var info = {
    group: [],
    pivot: [],
    cell: [],
    all: []
  };
  index_default_default.each(["group", "pivot", "cell", "all"], function(what) {
    index_default_default.each(self2.aggregateSpec[what], function(spec, aggNum) {
      try {
        info[what][aggNum] = new AggregateInfo(what, spec, aggNum, self2.colConfig, self2.typeInfo, index_default_default.bind(self2._maybeDecode, self2));
      } catch (e2) {
        log.error("Invalid Aggregate: " + what + "[" + aggNum + "] - " + e2.message);
        info[what][aggNum] = null;
        self2.fire("invalidAggregate", null, aggNum, e2.message);
      }
    });
    info[what] = index_default_default.without(info[what], null);
  });
  index_default_default.each(self2.data.rowVals, function(rowVal, rowValIdx) {
    index_default_default.each(info.group, function(aggInfo, aggNum) {
      if (groupResults[aggNum] === void 0) {
        groupResults[aggNum] = [];
      }
      var aggResult = aggInfo.instance.calculate(index_default_default.flatten(self2.data.data[rowValIdx]));
      groupResults[aggNum][rowValIdx] = aggResult;
      if (aggInfo.debug) {
        self2.debug(
          "AGGREGATE",
          "Group aggregate [%d] (%s) : Group [%s] = %s",
          aggNum,
          info.group[aggNum].instance.name + (info.group[aggNum].name ? " -> " + info.group[aggNum].name : ""),
          rowVal.join(", "),
          isElement2(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult)
        );
      }
    });
    if (self2.data.isPivot) {
      index_default_default.each(info.cell, function(aggInfo, aggNum) {
        if (cellResults[aggNum] === void 0) {
          cellResults[aggNum] = [];
        }
        cellResults[aggNum][rowValIdx] = [];
        index_default_default.each(self2.data.colVals, function(colVal, colValIdx) {
          var aggResult = aggInfo.instance.calculate(self2.data.data[rowValIdx][colValIdx]);
          cellResults[aggNum][rowValIdx][colValIdx] = aggResult;
          if (aggInfo.debug) {
            self2.debug(
              "AGGREGATE",
              "Cell aggregate [%d] (%s) : Cell [%s ; %s] = %s",
              aggNum,
              info.cell[aggNum].instance.name + (info.cell[aggNum].name ? " -> " + info.cell[aggNum].name : ""),
              rowVal.join(", "),
              colVal.join(", "),
              isElement2(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult)
            );
          }
        });
      });
    }
  });
  if (self2.data.isPivot && info.pivot) {
    index_default_default.each(info.pivot, function(aggInfo, aggNum) {
      pivotResults[aggNum] = [];
      index_default_default.each(self2.data.colVals, function(colVal, colValIdx) {
        var aggResult = aggInfo.instance.calculate(index_default_default.flatten(index_default_default.pluck(self2.data.data, colValIdx)));
        pivotResults[aggNum][colValIdx] = aggResult;
        if (aggInfo.debug) {
          self2.debug(
            "AGGREGATE",
            "Pivot aggregate [%d] (%s) : Col Val [%s] = %s",
            aggNum,
            info.pivot[aggNum].instance.name + (info.pivot[aggNum].name ? " -> " + info.pivot[aggNum].name : ""),
            colVal.join(", "),
            isElement2(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult)
          );
        }
      });
    });
  }
  if (info.all && (self2.data.isGroup || self2.data.isPivot)) {
    index_default_default.each(info.all, function(aggInfo, aggNum) {
      var aggResult = aggInfo.instance.calculate(index_default_default.flatten(self2.data.data));
      allResults[aggNum] = aggResult;
      if (aggInfo.debug) {
        self2.debug(
          "AGGREGATE",
          "All aggregate [%d] (%s) = %s",
          aggNum,
          info.all[aggNum].instance.name + (info.all[aggNum].name ? " -> " + info.all[aggNum].name : ""),
          JSON.stringify(aggResult)
        );
      }
    });
  }
  self2.data.agg = {
    info,
    results: {
      group: groupResults,
      pivot: pivotResults,
      cell: cellResults,
      all: allResults
    }
  };
  cont(true);
};
View.prototype.getData = function(cont, reason) {
  throw new Error("Implementation Error: `getData()` is abstract and must be implemented by a subclass of View");
};
View.prototype.getTypeInfo = function(cont) {
  throw new Error("Implementation Error: `getTypeInfo()` is abstract and must be implemented by a subclass of View");
};
View.prototype.clearCache = function() {
  var self2 = this;
  self2.data = void 0;
  self2.typeInfo = void 0;
  self2.debug(null, "Cleared cache");
};
View.prototype.clearSourceData = function() {
  var self2 = this;
  if (self2.source instanceof Source2) {
    self2.source.clearCachedData();
  } else if (self2.source instanceof View) {
    self2.source.clearSourceData();
  }
  self2.debug(null, "Cleared source data");
};
View.prototype.refresh = function() {
  var self2 = this;
  self2.debug(null, "Refreshing...");
  self2.source.refresh();
};
View.prototype.reset = function(opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  var clearOpts = jQuery.extend({}, opts, {
    updateData: false
  });
  self2.debug(null, "RESET!");
  self2.clearSort(clearOpts);
  self2.clearFilter(clearOpts);
  self2.clearAggregate(clearOpts);
  self2.clearPivot(clearOpts);
  self2.clearGroup(clearOpts);
  if (!opts.updateData) {
    delete self2.lastOps;
    return;
  }
  self2.getData();
};
View.prototype.getLastOps = function() {
  var self2 = this;
  return self2.lastOps;
};
View.prototype.setColConfig = function(colConfig) {
  var self2 = this;
  if (!(colConfig instanceof ordmap_default)) {
    throw new Error("Call Error: `colConfig` must be an instance of OrdMap");
  }
  self2.debug(null, "Setting column configuration");
  self2.colConfig = colConfig;
};
View.prototype.setPrefs = function(prefs) {
  var self2 = this;
  if (!(prefs instanceof Prefs)) {
    throw new Error("Call Error: `prefs` must be an instance of Prefs");
  }
  self2.prefs = prefs;
  self2.prefs.bind(self2.prefsModule, self2);
};

// node_modules/wcdatavis/src/mirage_source.js
var MirageSource = makeSubclass("MirageSource", Object, function(opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    backend: {
      type: "IndexedDB",
      dbName: "datavis_mirage"
    }
  });
  if (!MIRAGE_BACKEND_REGISTRY.isSet(opts.backend.type)) {
    throw new Error('Call Error: requested backend type "' + opts.backend.type + '" does not exist');
  }
  var cls = MIRAGE_BACKEND_REGISTRY.get(opts.backend.type);
  self2.backend = new cls(opts.backend);
});
mixinLogging(MirageSource);
MirageSource.prototype.initFromView = function(prefs, view, source) {
  var self2 = this;
  if (!(prefs instanceof Prefs)) {
    throw new Error("Call Error: `prefs` must be an instance of Prefs");
  }
  if (!(view instanceof View)) {
    throw new Error("Call Error: `view` must be an instance of View");
  }
  if (!(source instanceof Source2)) {
    throw new Error("Call Error: `source` must be an instance of Source");
  }
  self2.prefsName = prefs.name;
  self2.perspectiveName = prefs.currentPerspective.name;
  self2.viewConfig = {
    filterSpec: view.getFilter(),
    groupSpec: view.getGroup(),
    pivotSpec: view.getPivot(),
    aggregateSpec: view.getAggregate()
  };
  self2.sourceType = source.type;
  self2.sourceName = source.getName();
  self2.sourceParams = source.createParams();
};
MirageSource.prototype.initFromPrefs = function(prefs) {
  var self2 = this;
  if (!(prefs instanceof Prefs)) {
    throw new Error("Call Error: `prefs` must be an instance of Prefs");
  }
  self2.prefsName = prefs.name;
  self2.perspectiveName = prefs.currentPerspective.name;
};
MirageSource.prototype.setPerspectiveName = function(perspectiveName) {
  var self2 = this;
  self2.perspectiveName = perspectiveName;
};
MirageSource.prototype.toString = function() {
  var self2 = this;
  return 'MIRAGE SOURCE {prefsName="' + self2.prefsName + '", perspectiveName="' + self2.perspectiveName + '"}';
};
MirageSource.prototype.save = function(data, typeInfo, ok, fail) {
  var self2 = this;
  if (data.isPlain) {
    throw new Error("Cannot store mirage data for plain data.");
  }
  self2.logDebug("SAVE", "Processing view data to store in backend");
  var aggRes = [];
  for (var aggNum = 0; aggNum < data.agg.info.cell.length; aggNum += 1) {
    for (var rvi = 0; rvi < data.rowVals.length; rvi += 1) {
      for (var cvi = 0; cvi < data.colVals.length; cvi += 1) {
        if (data.data[rvi][cvi].length > 0) {
          aggRes.push({
            aggType: "cell",
            aggNum,
            coordinates: [].concat(data.rowVals[rvi], data.colVals[cvi]),
            result: data.agg.results.cell[aggNum][rvi][cvi]
          });
        }
      }
    }
  }
  for (var aggNum = 0; aggNum < data.agg.info.group.length; aggNum += 1) {
    for (var rvi = 0; rvi < data.rowVals.length; rvi += 1) {
      aggRes.push({
        aggType: "group",
        aggNum,
        coordinates: data.rowVals[rvi],
        result: data.agg.results.group[aggNum][rvi]
      });
    }
  }
  for (var aggNum = 0; aggNum < data.agg.info.pivot.length; aggNum += 1) {
    for (var cvi = 0; cvi < data.colVals.length; cvi += 1) {
      aggRes.push({
        aggType: "pivot",
        aggNum,
        coordinates: data.colVals[cvi],
        result: data.agg.results.pivot[aggNum][cvi]
      });
    }
  }
  for (var aggNum = 0; aggNum < data.agg.info.all.length; aggNum += 1) {
    aggRes.push({
      aggType: "all",
      aggNum,
      coordinates: [],
      result: data.agg.results.all[aggNum]
    });
  }
  var metadata = {
    prefsName: self2.prefsName,
    perspectiveName: self2.perspectiveName,
    sourceType: self2.sourceType,
    sourceName: self2.sourceName,
    sourceParams: self2.sourceParams,
    typeInfo: typeInfo.serialize(),
    filterSpec: self2.viewConfig.filterSpec,
    groupSpec: self2.viewConfig.groupSpec,
    pivotSpec: self2.viewConfig.pivotSpec,
    aggregateSpec: self2.viewConfig.aggregateSpec
  };
  self2.logDebug("SAVE", "Sending processed data to backend: {metadata=%O, aggRes=%O}", metadata, aggRes);
  self2.backend.save(metadata, aggRes, ok, fail);
};
MirageSource.prototype.load = function(ok, fail) {
  var self2 = this;
  var data = {
    groupFields: [],
    pivotFields: [],
    rowVals: [],
    colVals: [],
    agg: {
      results: {
        cell: [],
        group: [],
        pivot: [],
        all: []
      },
      info: {
        cell: [],
        group: [],
        pivot: [],
        all: []
      }
    },
    data: [],
    groupMetadata: {
      lookup: {
        byRowValIndex: []
      }
    }
  };
  return self2.backend.load(self2.prefsName, self2.perspectiveName, function(metadata, aggRes) {
    var sourceConfig = {};
    var viewConfig = {};
    copyProps(metadata, sourceConfig, ["sourceType", "sourceName", "sourceParams"]);
    copyProps(metadata, viewConfig, ["filterSpec", "groupSpec", "pivotSpec", "aggregateSpec"]);
    data.groupSpec = metadata.groupSpec.fieldNames;
    data.groupFields = index_default_default.pluck(data.groupSpec, "field");
    data.pivotSpec = metadata.pivotSpec.fieldNames;
    data.pivotFields = index_default_default.pluck(data.pivotSpec, "field");
    index_default_default.each(aggRes, function(ar) {
      var rv = null, cv = null, rvi2 = null, cvi2 = null;
      switch (ar.aggType) {
        case "cell":
          rv = ar.coordinates.slice(0, data.groupFields.length);
          cv = ar.coordinates.slice(data.groupFields.length);
          break;
        case "group":
          rv = ar.coordinates;
          break;
        case "pivot":
          cv = ar.coordinates;
          break;
      }
      if (rv != null) {
        rvi2 = index_default_default.findIndex(data.rowVals, function(x) {
          return arrayEqual(x, rv);
        });
      }
      if (cv != null) {
        cvi2 = index_default_default.findIndex(data.colVals, function(x) {
          return arrayEqual(x, cv);
        });
      }
      if (rvi2 != null && rvi2 < 0) {
        rvi2 = data.rowVals.length;
        data.rowVals.push(rv);
        var metadataLeaf = {
          rowValIndex: rvi2,
          rowValElt: rv[rv.length - 1]
        };
        setProp(metadataLeaf, data.groupMetadata, "children", interleaveWith(rv, "children"));
        data.groupMetadata.lookup.byRowValIndex[rvi2] = metadataLeaf;
      }
      if (cvi2 != null && cvi2 < 0) {
        cvi2 = data.colVals.length;
        data.colVals.push(cv);
      }
      switch (ar.aggType) {
        case "cell":
          setProp(ar.result, data.agg.results.cell, ar.aggNum, rvi2, cvi2);
          break;
        case "group":
          setProp(ar.result, data.agg.results.group, ar.aggNum, rvi2);
          break;
        case "pivot":
          setProp(ar.result, data.agg.results.pivot, ar.aggNum, cvi2);
          break;
        case "all":
          setProp(ar.result, data.agg.results.all, ar.aggNum);
          break;
      }
      if (data.agg.info[ar.aggType][ar.aggNum] == null) {
        var ai = new AggregateInfo(ar.aggType, metadata.aggregateSpec[ar.aggType][ar.aggNum], ar.aggNum, null, null, null);
        setProp(ai, data.agg.info[ar.aggType], ar.aggNum);
      }
    });
    for (var rvi = 0; rvi < data.rowVals.length; rvi += 1) {
      data.data[rvi] = [];
      for (var cvi = 0; cvi < data.colVals.length; cvi += 1) {
        data.data[rvi][cvi] = [];
        for (var aggNum = 0; aggNum < metadata.aggregateSpec.cell.length; aggNum += 1) {
          if (data.agg.results.cell[aggNum][rvi][cvi] === void 0) {
            data.agg.results.cell[aggNum][rvi][cvi] = data.agg.info.cell[aggNum].instance.bottomValue;
          }
        }
      }
    }
    for (var rvi = 0; rvi < data.rowVals.length; rvi += 1) {
      for (var aggNum = 0; aggNum < metadata.aggregateSpec.group.length; aggNum += 1) {
        if (data.agg.results.group[aggNum][rvi] === void 0) {
          data.agg.results.group[aggNum][rvi] = data.agg.info.group[aggNum].instance.bottomValue;
        }
      }
    }
    for (var cvi = 0; cvi < data.colVals.length; cvi += 1) {
      for (var aggNum = 0; aggNum < metadata.aggregateSpec.pivot.length; aggNum += 1) {
        if (data.agg.results.pivot[aggNum][cvi] === void 0) {
          data.agg.results.pivot[aggNum][cvi] = data.agg.info.pivot[aggNum].instance.bottomValue;
        }
      }
    }
    for (var aggNum = 0; aggNum < metadata.aggregateSpec.all.length; aggNum += 1) {
      if (data.agg.results.all[aggNum] === void 0) {
        data.agg.results.all[aggNum] = data.agg.info.all[aggNum].instance.bottomValue;
      }
    }
    var metadataId = 0;
    var postorder = function(node, depth) {
      if (node.children != null) {
        index_default_default.each(node.children, function(child) {
          child.parent = node;
          postorder(child, depth + 1);
        });
        if (depth > 0) {
          node.rowValIndex = node.children[index_default_default.keys(node.children)[0]].rowValIndex;
          node.rowValElt = data.rowVals[node.rowValIndex][depth - 1];
        }
      }
      if (depth > 0) {
        node.groupFieldIndex = depth - 1;
        node.groupField = data.groupSpec[node.groupFieldIndex].field;
        node.groupSpec = data.groupSpec[node.groupFieldIndex];
      }
    };
    postorder(data.groupMetadata, 0);
    if (data.colVals.length > 0) {
      index_default_default.extend(data, { isPlain: false, isGroup: false, isPivot: true });
    } else if (data.rowVals.length > 0) {
      index_default_default.extend(data, { isPlain: false, isGroup: true, isPivot: false });
    } else {
      index_default_default.extend(data, { isPlain: true, isGroup: false, isPivot: false });
    }
    return ok(ordmap_default.deserialize(metadata.typeInfo), data, viewConfig, sourceConfig);
  }, fail);
};
var MirageBackend = makeSubclass("MirageBackend", Object, function(opts) {
});
MirageBackend.prototype.save = function(cont) {
  throw new Error("Abstract Method Error: this method must be implemented by a concrete derived class");
};
MirageBackend.prototype.load = function(cont) {
  throw new Error("Abstract Method Error: this method must be implemented by a concrete derived class");
};
var MirageBackend_IndexedDB = makeSubclass("MirageBackend_IndexedDB", MirageBackend, function(opts) {
  var self2 = this;
  if (!index_default_default.isString(opts.dbName)) {
    throw new Error("Call Error: `opts.dbName` must be a string");
  }
  self2.dbName = opts.dbName;
  if (!window.indexedDB) {
    throw new Error("Browser does not support indexedDB");
  }
}, {
  DB_CURRENT_VERSION: 1
});
mixinLogging(MirageBackend_IndexedDB);
MirageBackend_IndexedDB.prototype.toString = function() {
  var self2 = this;
  return 'MIRAGE BACKEND // INDEXEDDB {dbName="' + self2.dbName + '"}';
};
MirageBackend_IndexedDB.prototype.open = function(ok, fail) {
  var self2 = this;
  if (self2.db != null) {
    return ok();
  }
  var request = window.indexedDB.open(self2.dbName, self2.DB_CURRENT_VERSION);
  request.onupgradeneeded = function(evt) {
    self2.logInfo("OPEN", "Upgrading database from version " + evt.target.version + " to " + self2.DB_CURRENT_VERSION + "...");
    self2.db = evt.target.result;
    var metadata = self2.db.createObjectStore("metadata", { keyPath: "metadataId", autoIncrement: true });
    metadata.createIndex("primary", ["prefsName", "perspectiveName"], { unique: true });
    var aggResult = self2.db.createObjectStore("aggResult", { keyPath: "aggResultId", autoIncrement: true });
    aggResult.createIndex("primary", ["metadataId", "coordinates", "aggType", "aggNum"], { unique: true });
    aggResult.createIndex("metadata", ["metadataId"], { unique: false });
  };
  request.onsuccess = function(evt) {
    self2.db = evt.target.result;
    return ok();
  };
  request.onerror = fail;
};
MirageBackend_IndexedDB.prototype.close = function() {
  var self2 = this;
  self2.db.close();
  delete self2.db;
};
MirageBackend_IndexedDB.prototype.save = function(metadata, aggResult, ok, fail) {
  var self2 = this;
  self2.open(function() {
    var txn = self2.db.transaction(["metadata", "aggResult"], "readwrite");
    txn.oncomplete = function(evt) {
      self2.logInfo("SAVE", "Successfully stored all mirage data.");
      return ok();
    };
    txn.onerror = function(evt) {
      return fail(evt.target.error.message);
    };
    var mdStore = txn.objectStore("metadata");
    var arStore = txn.objectStore("aggResult");
    var req;
    req = mdStore.add(metadata);
    req.onsuccess = function(evt) {
      index_default_default.each(aggResult, function(ar) {
        ar.metadataId = evt.target.result;
        var req2 = arStore.add(ar);
        req2.onerror = function(evt2) {
          self2.logError("SAVE", "Failed to add aggregate results: %O", ar);
          return fail(evt2.target.error.message);
        };
      });
    };
    req.onerror = function(evt) {
      self2.logError("SAVE", "Failed to add metadata: %O", metadata);
      return fail(evt.target.error.message);
    };
  }, function(evt) {
    self2.logError("SAVE", "Failed to open database.");
    return fail(evt.target.error.message);
  });
};
MirageBackend_IndexedDB.prototype.load = function(prefsName, perspectiveName, ok, fail) {
  var self2 = this;
  self2.open(function() {
    var txn = self2.db.transaction(["metadata", "aggResult"], "readonly");
    txn.oncomplete = function(evt) {
      self2.logInfo("SAVE", "Successfully loaded all mirage data.");
    };
    txn.onerror = function(evt) {
      return fail(evt.target.error.message);
    };
    var mdStore = txn.objectStore("metadata");
    var arStore = txn.objectStore("aggResult");
    var mdIndex = mdStore.index("primary");
    var arIndex = arStore.index("metadata");
    var req;
    req = mdIndex.get([prefsName, perspectiveName]);
    req.onsuccess = function(evt) {
      var metadata = evt.target.result;
      if (metadata == null) {
        return fail('Mirage metadata for {prefs = "' + prefsName + '", perspective = "' + perspectiveName + '"} does not exist');
      }
      var req2 = arIndex.getAll([metadata.metadataId]);
      req2.onsuccess = function(evt2) {
        var aggRes = evt2.target.result;
        if (aggRes == null) {
          return fail('Mirage aggregate results for {prefs = "' + prefsName + '", perspective = "' + perspectiveName + '", metadataId = ' + metadata.metadataId + "} do not exist");
        }
        return ok(metadata, aggRes);
      };
      req2.onerror = function(evt2) {
        self2.logError("SAVE", "Failed to retrieve aggregate results.");
        return fail(evt2.target.error.message);
      };
    };
    req.onerror = function(evt) {
      self2.logError("SAVE", "Failed to retrieve metadata.");
      return fail(evt.target.error.message);
    };
  }, function(evt) {
    self2.logError("SAVE", "Failed to open database.");
    return fail(evt.target.error.message);
  });
};
var MIRAGE_BACKEND_REGISTRY = new ordmap_default();
MIRAGE_BACKEND_REGISTRY.set("IndexedDB", MirageBackend_IndexedDB);

// node_modules/wcdatavis/src/mirage_view.js
var MirageView = makeSubclass("MirageView", View, function(opts) {
  var self2 = this;
  self2.opts = deepDefaults(opts, {});
  self2.setName(self2.opts.name);
  self2.source = new MirageSource(self2.opts);
}, {
  prefsModule: "mirage"
});
MirageView.prototype.initFromView = function(prefs, view, source, ok, fail) {
  var self2 = this;
  if (!(prefs instanceof Prefs)) {
    throw new Error("Call Error: `prefs` must be an instance of Prefs");
  }
  if (!(view instanceof View)) {
    throw new Error("Call Error: `view` must be an instance of View");
  }
  if (!(source instanceof Source2)) {
    throw new Error("Call Error: `source` must be an instance of Source");
  }
  if (ok != null && typeof ok !== "function") {
    throw new Error("Call Error: `ok` must be null or a function");
  }
  if (fail != null && typeof fail !== "function") {
    throw new Error("Call Error: `fail` must be null or a function");
  }
  ok = ok || I;
  fail = fail || I;
  self2.setFilter(view.getFilter());
  self2.setGroup(view.getGroup());
  self2.setPivot(view.getPivot());
  self2.setAggregate(view.getAggregate());
  self2.setSort(view.getSort());
  view.getTypeInfo(function(isOk, typeInfo) {
    if (isOk) {
      self2.typeInfo = typeInfo;
      view.getData(function(isOk2, data) {
        if (isOk2) {
          self2.data = data;
          self2.source.initFromView(prefs, view, source);
          return ok();
        } else {
          return fail();
        }
      });
    } else {
      return fail();
    }
  });
};
MirageView.prototype.initFromPrefs = function(prefs, config) {
  var self2 = this;
  self2.opts = config;
  self2.source.initFromPrefs(prefs);
};
mixinNameSetting(MirageView);
MirageView.prototype.toString = function() {
  var self2 = this;
  return "MirageView(" + self2.name + ")";
};
MirageView.prototype.prime = function(cont) {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  if (self2.isPrimed) {
    return cont(false);
  }
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.prime.apply(self2, args);
    }, "Waiting to prime");
  }
  self2.lock.lock("Priming!");
  self2.prefs.prime(function() {
    self2.source.getData(function() {
      self2.prefs.bind("mirage_view", self2);
      self2.isPrimed = true;
      self2.lock.unlock();
      cont(true);
    });
  });
};
MirageView.prototype.getData = function(cont, reason) {
  var self2 = this;
  if (self2.data) {
    return cont(true, self2.data);
  }
  self2.load(function(typeInfo, data, viewConfig, sourceConfig) {
    var setConfigOpts = {
      updateData: false,
      savePrefs: false
    };
    self2.typeInfo = typeInfo;
    self2.data = data;
    self2.setFilter(viewConfig.filterSpec, null, setConfigOpts);
    self2.setGroup(viewConfig.groupSpec, setConfigOpts);
    self2.setPivot(viewConfig.pivotSpec, setConfigOpts);
    self2.setAggregate(viewConfig.aggregateSpec, setConfigOpts);
    self2.setSort(viewConfig.sortSpec, setConfigOpts);
    return cont(true, self2.data);
  }, function(msg) {
    self2.logError("GET DATA", msg);
    return cont(false);
  });
};
MirageView.prototype.getTypeInfo = function(cont) {
  var self2 = this;
  if (self2.typeInfo) {
    return cont(true, self2.typeInfo);
  }
  self2.load(function(typeInfo, data) {
    self2.typeInfo = typeInfo;
    self2.data = data;
    return cont(true, self2.typeInfo);
  }, function() {
    return cont(false);
  });
};
MirageView.prototype.refresh = function() {
  var self2 = this;
};
MirageView.prototype.save = function(ok, fail) {
  var self2 = this;
  return self2.source.save(self2.data, self2.typeInfo, ok, fail);
};
MirageView.prototype.load = function(ok, fail) {
  var self2 = this;
  return self2.source.load(ok, fail);
};
MirageView.prototype.setPerspectiveName = function(perspectiveName) {
  var self2 = this;
  self2.source.setPerspectiveName(perspectiveName);
  self2.perspectiveName = perspectiveName;
};

// node_modules/wcdatavis/src/grid_renderer.js
var import_jquery6 = __toESM(require_jquery());
var import_handlebars = __toESM(require_handlebars());
var GridRenderer = function() {
  var UNIQUE_ID = 0;
  return makeSubclass("GridRenderer", Object, function(grid, defn, view, features, opts, timing, id, colConfig) {
    var self2 = this;
    self2.UNIQUE_ID = UNIQUE_ID++;
    self2.id = id;
    self2.grid = grid;
    self2.defn = defn;
    self2.view = view;
    self2.features = deepCopy(features);
    self2.opts = opts;
    self2.timing = timing;
    self2.colConfig = colConfig;
    self2.hasRendered = false;
    self2._validateFeatures();
    self2.drawLock = new lock_default("GridRenderer/draw");
    self2.grid.on("colConfigUpdate", function(newColConfig) {
      console.debug("[DataVis // GridRenderer // Handler(colConfigUpdate)] Received new colConfig: %O", newColConfig);
      self2.colConfig = newColConfig;
      if (self2.hasRendered) {
        console.debug("[DataVis // GridRenderer // Handler(colConfigUpdate)] Redrawing with new colConfig");
        self2.draw(self2.root, self2.drawOpts);
      }
    }, { who: self2 });
  });
}();
mixinEventHandling(GridRenderer, [
  "columnResize",
  "unableToRender",
  "limited",
  "unlimited",
  "csvReady",
  "generateCsvProgress",
  "renderBegin",
  "renderEnd",
  "selectionChange"
]);
GridRenderer.prototype.canRender = function() {
  throw new Error("ABSTRACT");
};
GridRenderer.prototype.draw = function(root2, opts, cont1) {
  var self2 = this;
  var args = Array.prototype.slice.call(arguments);
  console.debug("[DataVis // GridRenderer // Draw] Beginning draw operation; opts = %O", opts);
  opts = opts || {};
  self2.root = root2;
  self2.drawOpts = opts;
  if (self2.drawLock.isLocked()) {
    return self2.drawLock.onUnlock(function() {
      GridRenderer.prototype.draw.apply(self2, args);
    });
  }
  self2.drawLock.lock();
  self2.clear();
  return self2.view.getData(function(ok, data) {
    if (!ok) {
      return cont1(false);
    }
    console.debug("[DataVis // GridRenderer // Draw] Data = %O", data);
    return self2.view.getTypeInfo(function(ok2, typeInfo) {
      if (!ok2) {
        return cont1(false);
      }
      if (data == null || typeInfo == null) {
        log.error("Provided data or typeInfo is null");
        return cont1(false);
      }
      console.debug("[DataVis // GridRenderer // Draw] TypeInfo = %O", typeInfo.asMap());
      if (data.isPlain && !self2.canRender("plain") || data.isGroup && !self2.canRender("group") || data.isPivot && !self2.canRender("pivot")) {
        console.debug("[DataVis // GridRenderer // Draw] Unable to render data using current grid table: { isPlain = %s ; isGroup = %s ; isPivot = %s }", data.isPlain, data.isGroup, data.isPivot);
        return self2.fire("unableToRender");
      }
      self2.hasRendered = true;
      self2.fire("renderBegin");
      self2.data = data;
      self2.typeInfo = typeInfo;
      self2.timing.start(["Grid Renderer", "Draw"]);
      return cont1(true, data, typeInfo, function(cont2) {
        self2.fire("renderEnd");
        if (self2.drawLock._lockCount > 0) {
          self2.drawLock.unlock();
        }
        if (typeof cont2 === "function") {
          return cont2();
        }
      });
    });
  });
};
GridRenderer.prototype.clear = function() {
  var self2 = this;
  self2.root.children().remove();
};
GridRenderer.prototype.destroy = function() {
  var self2 = this;
  self2.clear();
  self2.grid.off("*", self2);
};
GridRenderer.prototype.toString = function() {
  var self2 = this;
  return "GridRenderer(" + self2.UNIQUE_ID + ")";
};
GridRenderer.prototype._validateFeatures = function() {
  return true;
};
GridRenderer.prototype.hasOperations = function(type, field) {
  var self2 = this;
  if (!self2.features.operations) {
    return false;
  }
  switch (type) {
    case "all":
      return getPropDef(0, self2.defn, "operations", "all", "length") > 0;
    case "row":
      return getPropDef(0, self2.defn, "operations", "row", "length") > 0;
    case "cell":
      return getPropDef(0, self2.defn, "operations", "cell", field, "length") > 0;
    default:
      return false;
  }
};
GridRenderer.registry = new ordmap_default();

// node_modules/wcdatavis/src/renderers/grid/handlebars.js
var import_handlebars3 = __toESM(require_handlebars());

// node_modules/wcdatavis/src/util/handlebars.js
var import_handlebars2 = __toESM(require_handlebars());
function makeEnv() {
  return import_handlebars2.default.create();
}
function addHelpers(env, data) {
  var ai = objFromArray(["cell", "group", "pivot", "all"], [[]]);
  ai = index_default_default.mapObject(ai, function(val, key) {
    return index_default_default.filter(
      getPropDef([], data, "agg", "info", key),
      function(aggInfo) {
        return !aggInfo.isHidden;
      }
    );
  });
  env.registerHelper("rowval", function(groupField) {
    if (["number", "string"].indexOf(typeof groupField) < 0) {
      throw new Error('In Handlebars "rowval" helper, `groupField` must be a number or string');
    }
    var gfi;
    if (typeof groupField === "number") {
      gfi = groupField;
      if (gfi < 0) {
        throw new Error('In Handlebars "rowval" helper, group field index "' + groupField + '" out of range');
      }
    } else {
      gfi = data.groupFields.indexOf(groupField);
      if (gfi < 0) {
        throw new Error('In Handlebars "rowval" helper, specified field "' + groupField + '" is not part of group');
      }
    }
    return data.rowVals[this.rowValIdx][gfi];
  });
  env.registerHelper("colval", function(pivotField) {
    if (["number", "string"].indexOf(typeof pivotField) < 0) {
      throw new Error('In Handlebars "rowval" helper, `pivotField` must be a number or string');
    }
    var pivotFieldIndex;
    if (typeof pivotField === "number") {
      pivotFieldIndex = pivotField;
      if (pivotFieldIndex < 0) {
        throw new Error('In Handlebars "rowval" helper, pivot field index "' + pivotField + '" out of range');
      }
    } else {
      pivotFieldIndex = data.pivotFields.indexOf(pivotField);
      if (pivotFieldIndex < 0) {
        throw new Error('In Handlebars "rowval" helper, specified field "' + pivotField + '" is not part of pivot');
      }
    }
    return data.colVals[this.colValIdx][pivotFieldIndex];
  });
  env.registerHelper("aggregate", function(type, aggNum) {
    var ctx = this;
    if (data.isPlain) {
      throw new Error('In Handlebars "aggregate" helper, data must be grouped to use this helper');
    } else if (data.isGroup && ["group", "all"].indexOf(type) < 0) {
      throw new Error('In Handlebars "aggregate" helper, `type` must be one of: { group, all }');
    } else if (data.isPivot && ["cell", "group", "pivot", "all"].indexOf(type) < 0) {
      throw new Error('In Handlebars "aggregate" helper, `type` must be one of: { cell, group, pivot, all }');
    }
    if (data.isGroup && ctx.rowValIdx == null) {
      throw new Error("missing rowvalidx from context");
    }
    if (data.isPivot && (ctx.rowValIdx == null || ctx.colValIdx == null)) {
      throw new Error("missing rowValIdx or colValIdx from context");
    }
    if (typeof aggNum !== "number" || parseInt(aggNum) != aggNum) {
      return "[HELPER/AGGREGATE: AGGNUM MUST BE AN INT]";
    }
    if (ai[type].length <= aggNum) {
      return "[HELPER/AGGREGATE: AGGNUM OUT OF RANGE]";
    }
    var aggInfo = data.agg.info[type][aggNum];
    var aggResult = data.isGroup ? data.agg.results[type][aggNum][ctx.rowValIdx] : data.isPivot ? data.agg.results[type][aggNum][ctx.rowValIdx][ctx.colValIdx] : null;
    var text;
    if (aggResult instanceof jQuery) {
      aggResult = aggResult.get(0);
    }
    if (aggResult instanceof Element) {
      return aggResult;
    } else {
      if (aggInfo.instance.inheritFormatting) {
        text = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
          overrideType: aggInfo.instance.getType()
        });
        return text;
      } else {
        text = format2(null, null, aggResult, {
          overrideType: aggInfo.instance.getType(),
          decode: false
        });
        return text;
      }
    }
  });
}
var handlebars_default = {
  makeEnv,
  addHelpers
};

// node_modules/wcdatavis/src/renderers/grid/handlebars.js
var GridRendererHandlebars = makeSubclass("GridRendererHandlebars", GridRenderer, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.hbEnv = handlebars_default.makeEnv();
});
GridRendererHandlebars.prototype._validateFeatures = function() {
  var self2 = this;
  self2.features.limit = false;
};
GridRendererHandlebars.prototype.canRender = function(what) {
  return true;
};
GridRendererHandlebars.prototype._draw_plain = function(root2, data, typeInfo, opts) {
  var self2 = this;
  var html = "";
  if (data.data.length === 0) {
    if (self2.empty != null) {
      html += self2.empty();
    }
  } else {
    if (self2.before != null) {
      html += self2.before();
    }
    if (self2.item != null) {
      index_default_default.each(data.data, function(row) {
        var context = {};
        index_default_default.each(row.rowData, function(cell, field) {
          var fcc = self2.colConfig.get(field) || {};
          var value = format2(fcc, typeInfo.get(field), cell);
          if (value instanceof Element || value instanceof jQuery) {
            value = outerHtml(value);
          }
          context[field] = value;
        });
        html += self2.item(context);
      });
    }
    if (self2.after != null) {
      html += self2.after();
    }
  }
  root2.html(html);
};
GridRendererHandlebars.prototype._draw_group = function(root2, data, typeInfo, opts) {
  var self2 = this;
  var html = "";
  if (data.data.length === 0) {
    if (self2.empty != null) {
      html += self2.empty();
    }
  } else {
    if (self2.before != null) {
      html += self2.before();
    }
    if (self2.item != null) {
      index_default_default.each(data.data, function(group2, rowValIdx) {
        var context = {
          rowValIdx
        };
        html += self2.item(context);
      });
    }
    if (self2.after != null) {
      html += self2.after();
    }
  }
  root2.html(html);
};
GridRendererHandlebars.prototype._draw_pivot = function(root2, data, typeInfo, opts) {
  var self2 = this;
  var html = "";
  if (data.data.length === 0) {
    if (self2.empty != null) {
      html += self2.empty();
    }
  } else {
    if (self2.before != null) {
      html += self2.before();
    }
    if (self2.item != null) {
      index_default_default.each(data.data, function(group2, rowValIdx) {
        index_default_default.each(group2, function(pivot, colValIdx) {
          var div = jQuery("<div>").appendTo(root2);
          var context = {
            rowValIdx,
            colValIdx
          };
          html += self2.item(context);
        });
      });
    }
    if (self2.after != null) {
      html += self2.after();
    }
  }
  root2.html(html);
};
GridRendererHandlebars.prototype.draw = function(root2, cont, opts) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  return self2.super.draw(root2, opts, function(ok, data, typeInfo) {
    if (!ok) {
      return cont();
    }
    handlebars_default.addHelpers(self2.hbEnv, data);
    var k1 = data.isPlain ? "plain" : data.isGroup ? "group" : data.isPivot ? "pivot" : null;
    var configKey = data.isPlain ? "whenPlain" : data.isGroup ? "whenGroup" : data.isPivot ? "whenPivot" : null;
    var config = self2.opts[configKey] || {};
    if (config.empty != null) {
      self2.empty = self2.hbEnv.compile(config.empty);
    }
    if (config.before != null) {
      self2.before = self2.hbEnv.compile(config.before);
    }
    if (config.item != null) {
      self2.item = self2.hbEnv.compile(config.item);
    }
    if (config.after != null) {
      self2.after = self2.hbEnv.compile(config.after);
    }
    self2["_draw_" + k1](root2, data, typeInfo, opts);
    self2.addWorkHandler();
    self2.fire("renderEnd");
    self2.drawLock.unlock();
    if (typeof cont === "function") {
      return cont();
    }
  });
};
GridRendererHandlebars.prototype.addWorkHandler = function() {
  var self2 = this;
  self2.view.on("workEnd", function(info, ops) {
    self2.draw(self2.root, null, self2.drawOpts);
  }, { who: self2, limit: 1 });
};
GridRenderer.registry.set("handlebars", GridRendererHandlebars);

// node_modules/wcdatavis/src/renderers/grid/squirrelly.js
var import_jquery8 = __toESM(require_jquery());
var Sqrl = __toESM(require_squirrelly_min());

// node_modules/wcdatavis/src/util/squirrelly.js
var import_handlebars5 = __toESM(require_handlebars());
var import_jquery7 = __toESM(require_jquery());
function addHelpers2(env, data) {
  var ai = objFromArray(["cell", "group", "pivot", "all"], [[]]);
  ai = index_default_default.mapObject(ai, function(val, key) {
    return index_default_default.filter(
      getPropDef([], data, "agg", "info", key),
      function(aggInfo) {
        return !aggInfo.isHidden;
      }
    );
  });
  env.define("rowval", function(content) {
    var [ctx, groupField] = content.params;
    if (["number", "string"].indexOf(typeof groupField) < 0) {
      throw new Error('In Handlebars "rowval" helper, `groupField` must be a number or string');
    }
    var gfi;
    if (typeof groupField === "number") {
      gfi = groupField;
      if (gfi < 0) {
        throw new Error('In Handlebars "rowval" helper, group field index "' + groupField + '" out of range');
      }
    } else {
      gfi = data.groupFields.indexOf(groupField);
      if (gfi < 0) {
        throw new Error('In Handlebars "rowval" helper, specified field "' + groupField + '" is not part of group');
      }
    }
    return data.rowVals[ctx.rowValIdx][gfi];
  });
  env.define("colval", function(content) {
    let [ctx, pivotField] = content.params;
    if (["number", "string"].indexOf(typeof pivotField) < 0) {
      throw new Error('In Handlebars "rowval" helper, `pivotField` must be a number or string');
    }
    var pivotFieldIndex;
    if (typeof pivotField === "number") {
      pivotFieldIndex = pivotField;
      if (pivotFieldIndex < 0) {
        throw new Error('In Handlebars "rowval" helper, pivot field index "' + pivotField + '" out of range');
      }
    } else {
      pivotFieldIndex = data.pivotFields.indexOf(pivotField);
      if (pivotFieldIndex < 0) {
        throw new Error('In Handlebars "rowval" helper, specified field "' + pivotField + '" is not part of pivot');
      }
    }
    return data.colVals[ctx.colValIdx][pivotFieldIndex];
  });
  env.define("aggregate", function(content) {
    let [ctx, type, aggNum] = content.params;
    if (data.isPlain) {
      throw new Error('In Handlebars "aggregate" helper, data must be grouped to use this helper');
    } else if (data.isGroup && ["group", "all"].indexOf(type) < 0) {
      throw new Error('In Handlebars "aggregate" helper, `type` must be one of: { group, all }');
    } else if (data.isPivot && ["cell", "group", "pivot", "all"].indexOf(type) < 0) {
      throw new Error('In Handlebars "aggregate" helper, `type` must be one of: { cell, group, pivot, all }');
    }
    if (data.isGroup && ctx.rowValIdx == null) {
      throw new Error("missing rowvalidx from context");
    }
    if (data.isPivot && (ctx.rowValIdx == null || ctx.colValIdx == null)) {
      throw new Error("missing rowValIdx or colValIdx from context");
    }
    if (typeof aggNum !== "number" || parseInt(aggNum) != aggNum) {
      return "[HELPER/AGGREGATE: AGGNUM MUST BE AN INT]";
    }
    if (ai[type].length <= aggNum) {
      return "[HELPER/AGGREGATE: AGGNUM OUT OF RANGE]";
    }
    var aggInfo = data.agg.info[type][aggNum];
    var aggResult = data.isGroup ? data.agg.results[type][aggNum][ctx.rowValIdx] : data.isPivot ? data.agg.results[type][aggNum][ctx.rowValIdx][ctx.colValIdx] : null;
    var text;
    if (aggResult instanceof import_jquery7.default) {
      aggResult = aggResult.get(0);
    }
    if (aggResult instanceof Element) {
      return aggResult;
    } else {
      if (aggInfo.instance.inheritFormatting) {
        text = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
          overrideType: aggInfo.instance.getType()
        });
        return text;
      } else {
        text = format2(null, null, aggResult, {
          overrideType: aggInfo.instance.getType(),
          decode: false
        });
        return text;
      }
    }
  });
}
var squirrelly_default = {
  addHelpers: addHelpers2
};

// node_modules/wcdatavis/src/renderers/grid/squirrelly.js
var GridRendererSquirrelly = makeSubclass("GridRendererSquirrelly", GridRenderer, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.config = deepCopy(Sqrl.defaultConfig);
  self2.config.useWith = true;
});
GridRendererSquirrelly.prototype._validateFeatures = function() {
  var self2 = this;
  self2.features.limit = false;
};
GridRendererSquirrelly.prototype.canRender = function(what) {
  return true;
};
GridRendererSquirrelly.prototype._draw_plain = function(root2, data, typeInfo, opts) {
  var self2 = this;
  var html = "";
  if (data.data.length === 0) {
    if (self2.empty != null) {
      html += self2.empty({}, self2.config);
    }
  } else {
    if (self2.before != null) {
      html += self2.before({}, self2.config);
    }
    if (self2.item != null) {
      index_default_default.each(data.data, function(row) {
        var context = {};
        index_default_default.each(row.rowData, function(cell, field) {
          var fcc = self2.colConfig.get(field) || {};
          var value = format2(fcc, typeInfo.get(field), cell);
          if (value instanceof Element || value instanceof import_jquery8.default) {
            value = outerHtml(value);
          }
          context[field] = value;
        });
        html += self2.item(context, self2.config);
      });
    }
    if (self2.after != null) {
      html += self2.after({}, self2.config);
    }
  }
  root2.html(html);
};
GridRendererSquirrelly.prototype._draw_group = function(root2, data, typeInfo, opts) {
  var self2 = this;
  var html = "";
  if (data.data.length === 0) {
    if (self2.empty != null) {
      html += self2.empty();
    }
  } else {
    if (self2.before != null) {
      html += self2.before();
    }
    if (self2.item != null) {
      index_default_default.each(data.data, function(group2, rowValIdx) {
        var context = {
          rowValIdx
        };
        html += self2.item(context, self2.config);
      });
    }
    if (self2.after != null) {
      html += self2.after();
    }
  }
  root2.html(html);
};
GridRendererSquirrelly.prototype._draw_pivot = function(root2, data, typeInfo, opts) {
  var self2 = this;
  var html = "";
  if (data.data.length === 0) {
    if (self2.empty != null) {
      html += self2.empty();
    }
  } else {
    if (self2.before != null) {
      html += self2.before();
    }
    if (self2.item != null) {
      index_default_default.each(data.data, function(group2, rowValIdx) {
        if (self2.beforeGroup != null) {
          html += self2.beforeGroup();
        }
        index_default_default.each(group2, function(pivot, colValIdx) {
          var div = (0, import_jquery8.default)("<div>").appendTo(root2);
          var context = {
            rowValIdx,
            colValIdx
          };
          html += self2.item(context, self2.config);
        });
        if (self2.afterGroup != null) {
          html += self2.afterGroup();
        }
      });
    }
    if (self2.after != null) {
      html += self2.after();
    }
  }
  root2.html(html);
};
GridRendererSquirrelly.prototype.draw = function(root2, cont, opts) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  return self2.super.draw(root2, opts, function(ok, data, typeInfo) {
    if (!ok) {
      return cont();
    }
    squirrelly_default.addHelpers(Sqrl.helpers, data);
    var k1 = data.isPlain ? "plain" : data.isGroup ? "group" : data.isPivot ? "pivot" : null;
    var configKey = data.isPlain ? "whenPlain" : data.isGroup ? "whenGroup" : data.isPivot ? "whenPivot" : null;
    var config = self2.opts[configKey] || {};
    index_default_default.each(["empty", "before", "beforeGroup", "item", "afterGroup", "after"], function(x) {
      if (config[x] != null) {
        self2[x] = Sqrl.compile(config[x], self2.config);
      }
    });
    self2["_draw_" + k1](root2, data, typeInfo, opts);
    self2.addWorkHandler();
    self2.fire("renderEnd");
    self2.drawLock.unlock();
    if (typeof cont === "function") {
      return cont();
    }
  });
};
GridRendererSquirrelly.prototype.addWorkHandler = function() {
  var self2 = this;
  self2.view.on("workEnd", function(info, ops) {
    self2.draw(self2.root, null, self2.drawOpts);
  }, { who: self2, limit: 1 });
};
GridRenderer.registry.set("squirrelly", GridRendererSquirrelly);

// node_modules/wcdatavis/src/ui/windows/col_config.js
var ColConfigWin = makeSubclass("ColConfigWin", Object, function(grid) {
  var self2 = this;
  self2.grid = grid;
  grid.on("colConfigUpdate", function(colConfig, initColConfig) {
    self2.colConfig = colConfig;
    self2.initColConfig = initColConfig;
  });
});
ColConfigWin.prototype.show = function(posElt, onSave) {
  var self2 = this;
  var current = self2.colConfig.clone();
  var orderWinEffect = {
    effect: "fade",
    duration: 100
  };
  var orderWin = jQuery("<div>", { title: trans("GRID.COLCONFIG_WIN.TITLE") }).dialog({
    autoOpen: false,
    modal: true,
    width: 600,
    position: {
      my: "center",
      at: "center",
      of: window
    },
    classes: {
      "ui-dialog": "ui-corner-all wcdv_dialog",
      "ui-dialog-titlebar": "ui-corner-all"
    },
    show: orderWinEffect,
    hide: orderWinEffect,
    close: function() {
      orderWin.dialog("destroy");
    }
  });
  var pinnedCount = 0;
  var colTable = jQuery("<table>").addClass("wcdv_colconfigwin_table").appendTo(jQuery("<div>").css({
    "max-height": "40ex",
    "overflow-y": "scroll"
  }).appendTo(orderWin));
  var colTableHeader = jQuery('<thead><th class="wcdv_bottom_border_teal wcdv_width_1em"></th><th class="wcdv_bottom_border_teal">' + trans("GRID.COLCONFIG_WIN.TBL.FIELD") + '</th><th class="wcdv_bottom_border_teal">' + trans("GRID.COLCONFIG_WIN.TBL.DISPLAY") + '</th><th colspan="6" class="wcdv_bottom_border_teal">' + trans("GRID.COLCONFIG_WIN.TBL.OPTIONS") + "</th></thead>").appendTo(colTable);
  var keys3 = current.keys();
  var colTableBody = jQuery("<tbody>")._makeSortableTable(function(oldIndex, newIndex) {
    colTableBody.children("tr").eq(newIndex).effect("highlight", 750);
    moveArrayElement(keys3, oldIndex, newIndex);
  }).appendTo(colTable);
  var trsByField = {};
  current.each(function(colConfig, field) {
    var tr, td;
    tr = jQuery("<tr>", {
      "data-field": field
    });
    trsByField[field] = tr;
    td = jQuery("<td>").addClass("wcdv_width_1em").appendTo(tr);
    jQuery("<button>", {
      "type": "button",
      "title": trans("GRID.COLCONFIG_WIN.REORDER_COLS")
    }).addClass("wcdv_icon_button drag-handle wcdv_button_right").append(fontAwesome("fa-bars")).appendTo(td);
    td = jQuery("<td>").text(field).appendTo(tr);
    td = jQuery("<td>").css("color", colConfig.displayText ? "#000000" : "#C0C0C0").text(colConfig.displayText || field).appendTo(tr);
    var displayTextTd = td;
    td = jQuery("<td>").addClass("wcdv_width_1em").appendTo(tr);
    var renameBtn = jQuery("<button>", {
      "type": "button",
      "title": trans("GRID.COLCONFIG_WIN.RENAME_COL")
    }).addClass("wcdv_icon_button").append(fontAwesome("fa-pencil")).on("click", function() {
      var newName = prompt(trans("GRID.COLCONFIG_WIN.RENAME_COL.PROMPT", field));
      if (newName) {
        colConfig.displayText = newName;
        displayTextTd.css("color", colConfig.displayText ? "#000000" : "#C0C0C0").text(newName);
      }
    }).appendTo(td);
    td = jQuery("<td>").addClass("wcdv_width_1em").appendTo(tr);
    var isPinnedCheckbox = jQuery("<input>", {
      "type": "checkbox",
      "title": trans("GRID.COLCONFIG_WIN.PIN_COL")
    }).prop("checked", getPropDef(false, colConfig, "isPinned")).on("change", function() {
      colConfig.isPinned = isPinnedCheckbox.prop("checked");
      if (colConfig.isPinned) {
        pinnedCount += 1;
      } else {
        pinnedCount -= 1;
      }
      if (pinnedCount > 0) {
        pinnedMsg.show();
      } else {
        pinnedMsg.hide();
      }
    }).appendTo(td)._makeIconCheckbox("fa-thumb-tack");
    if (getPropDef(false, colConfig, "isPinned")) {
      pinnedCount += 1;
    }
    td = jQuery("<td>").addClass("wcdv_width_1em").appendTo(tr);
    var isHiddenCheckbox = jQuery("<input>", {
      "type": "checkbox",
      "title": trans("GRID.COLCONFIG_WIN.HIDE_COL")
    }).prop("disabled", !getPropDef(true, colConfig, "canHide")).prop("checked", getPropDef(false, colConfig, "isHidden")).on("change", function() {
      colConfig.isHidden = isHiddenCheckbox.prop("checked");
    }).appendTo(td)._makeIconCheckbox("fa-ban");
    td = jQuery("<td>").addClass("wcdv_width_1em").appendTo(tr);
    var allowHtmlCheckbox = jQuery("<input>", {
      "type": "checkbox",
      "title": trans("GRID.COLCONFIG_WIN.ALLOW_HTML")
    }).prop("checked", getPropDef(false, colConfig, "allowHtml")).on("change", function() {
      colConfig.allowHtml = allowHtmlCheckbox.prop("checked");
    }).appendTo(td)._makeIconCheckbox("fa-code");
    td = jQuery("<td>").addClass("wcdv_width_1em").appendTo(tr);
    jQuery("<button>", {
      "type": "button",
      "title": trans("GRID.COLCONFIG_WIN.MOVE_COL_TO_TOP")
    }).addClass("wcdv_icon_button wcdv_button_left").on("click", function() {
      var oldIndex = tr.index();
      colTableBody.prepend(tr);
      var newIndex = tr.index();
      colTableBody.children("tr").eq(oldIndex).effect("highlight", 750);
      colTableBody.children("tr").eq(newIndex).effect("highlight", 750);
      moveArrayElement(keys3, oldIndex, newIndex);
    }).append(fontAwesome("fa-angle-double-up")).appendTo(td);
    td = jQuery("<td>").addClass("wcdv_width_1em").appendTo(tr);
    jQuery("<button>", {
      "type": "button",
      "title": trans("GRID.COLCONFIG_WIN.MOVE_COL_TO_BOTTOM")
    }).addClass("wcdv_icon_button wcdv_button_left").on("click", function() {
      var oldIndex = tr.index();
      colTableBody.append(tr);
      var newIndex = tr.index();
      colTableBody.children("tr").eq(oldIndex).effect("highlight", 750);
      colTableBody.children("tr").eq(newIndex).effect("highlight", 750);
      moveArrayElement(keys3, oldIndex, newIndex);
    }).append(fontAwesome("fa-angle-double-down")).appendTo(td);
    tr.appendTo(colTableBody);
  });
  var pinnedMsg = jQuery("<div>").addClass("wcdv_info_banner").append(fontAwesome("fa-info-circle")).append(" ").append(trans("GRID.COLCONFIG_WIN.PINNED_COL_WARNING")).hide().appendTo(orderWin);
  if (pinnedCount > 0) {
    pinnedMsg.show();
  }
  jQuery("<hr>").appendTo(orderWin);
  var buttonBar = jQuery("<div>").addClass("wcdv_button_bar").appendTo(orderWin);
  if (self2.initColConfig) {
    jQuery("<button>", {
      "type": "button",
      "class": "",
      "title": trans("GRID.COLCONFIG_WIN.RESET_COL_ORDER")
    }).append(fontAwesome("fa-undo")).append(trans("GRID.COLCONFIG_WIN.RESET_COL_ORDER")).on("click", function(evt) {
      keys3 = self2.initColConfig.keys();
      index_default_default.each(keys3, function(k) {
        if (trsByField[k] !== null) {
          colTableBody.append(trsByField[k]);
          trsByField[k].effect("highlight", 750);
        }
      });
    }).appendTo(buttonBar);
  }
  jQuery("<button>", {
    "type": "button",
    "class": "",
    "title": trans("DIALOG.OK"),
    "data-role": "ok"
  }).append(fontAwesome("fa-check")).append(trans("DIALOG.OK")).on("click", function() {
    self2.colConfig.clear();
    index_default_default.each(keys3, function(k) {
      self2.colConfig.set(k, current.get(k));
    });
    orderWin.dialog("close");
    onSave(self2.colConfig);
  }).appendTo(buttonBar);
  jQuery("<button>", {
    "type": "button",
    "class": "",
    "title": trans("DIALOG.CANCEL"),
    "data-role": "cancel"
  }).append(fontAwesome("fa-ban")).append(trans("DIALOG.CANCEL")).on("click", function() {
    orderWin.dialog("close");
  }).appendTo(buttonBar);
  orderWin.dialog("open");
};

// node_modules/wcdatavis/src/ui/windows/debug.js
var DebugWin = makeSubclass("DebugWin", Object, function() {
  var self2 = this;
});
DebugWin.prototype.show = function(grid, view, source) {
  var self2 = this;
  var winEffect = {
    effect: "fade",
    duration: 100
  };
  var win = jQuery("<div>", { id: "wcdv_debugwin", title: "Debug Info" }).css({
    "display": "flex",
    "flex-direction": "column"
  }).dialog({
    autoOpen: false,
    modal: true,
    width: 600,
    maxHeight: 600,
    position: {
      my: "center",
      at: "top",
      of: window
    },
    classes: {
      "ui-dialog": "ui-corner-all wcdv_dialog",
      "ui-dialog-titlebar": "ui-corner-all"
    },
    show: winEffect,
    hide: winEffect,
    close: function() {
      win.dialog("destroy");
    }
  });
  var tabs = [{
    name: "Source",
    id: "sourceTab",
    items: [{
      name: "Configuration",
      elt: function() {
        var info = new ordmap_default();
        info.set("Source type", source.type);
        info.set("Source name", source.name);
        info.set("Source spec", source.origin.spec);
        return jQuery("<div>").append(info.asHtmlDefnList());
      }()
    }, {
      name: "Params",
      elt: jQuery("<div>").append(new json_formatter_esm_default(source.params, 0).render())
    }, {
      name: "Type Info",
      elt: jQuery("<div>").append(new json_formatter_esm_default(source.cache.typeInfo.asMap(), 0).render())
    }]
  }, {
    name: "View",
    id: "viewTab",
    items: [{
      name: "Current Config",
      elt: function() {
        var info = new ordmap_default();
        info.set("View name", view.name);
        info.set("Filter config", view.getFilter());
        info.set("Group config", view.getGroup());
        info.set("Pivot config", view.getPivot());
        info.set("Aggregate config", view.getAggregate());
        return jQuery("<div>").append(info.asHtmlDefnList());
      }()
    }]
  }, {
    name: "Grid",
    id: "gridTab",
    items: [{
      name: "Columns",
      elt: jQuery("<div>").append(new json_formatter_esm_default(grid.colConfig.asMap(), 0).render())
    }]
  }, {
    name: "Prefs",
    id: "prefsTab",
    items: [{
      name: "Configuration",
      elt: function() {
        var info = new ordmap_default();
        info.set("Auto-Save", grid.prefs.opts.autoSave);
        info.set("Backend Type", grid.prefs.opts.backend.type);
        info.set("Current Perspective", jQuery("<span>" + grid.prefs.currentPerspective.id + "<br/><i>" + grid.prefs.currentPerspective.name + "</i></span>"));
        info.set("Bardo", grid.prefs.bardo);
        return jQuery("<div>").append(info.asHtmlDefnList());
      }()
    }, {
      name: "Perspectives",
      elt: function() {
        var info = new ordmap_default();
        index_default_default.each(grid.prefs.perspectives, function(p) {
          info.set(p.id, {
            "Name": p.name,
            "Config": p.config,
            "Status": p.isUnsaved ? "Modified" : "Saved"
          });
        });
        return jQuery("<div>").append(info.asHtmlDefnList());
      }()
    }]
  }];
  var tabsList = jQuery("<ul>").css({
    "flex-grow": "0",
    "flex-shrink": "0",
    "flex-basis": "auto"
  });
  index_default_default.each(tabs, function(t2) {
    var tabAnchor = jQuery("<a>", { href: "#" + t2.id }).text(t2.name);
    tabsList.append(jQuery("<li>").append(tabAnchor));
  });
  var tabsDiv = jQuery("<div>").css({
    "flex": "auto",
    "overflow": "hidden",
    "display": "flex",
    "flex-direction": "column"
  }).append(tabsList);
  index_default_default.each(tabs, function(t2) {
    var container = jQuery("<div>", { id: t2.id }).css({
      "flex-grow": "1",
      "flex-shrink": "1",
      "flex-basis": "auto",
      "overflow": "scroll"
    });
    index_default_default.each(t2.items, function(ti) {
      container.append(jQuery("<h3>").text(ti.name));
      container.append(ti.elt);
    });
    container.accordion({
      heightStyle: "content"
    });
    tabsDiv.append(container);
  });
  tabsDiv.appendTo(win).tabs();
  var buttonBar = jQuery("<div>").css({
    "flex-grow": "0",
    "flex-shrink": "0",
    "flex-basis": "auto",
    "padding-top": "2ex"
  }).addClass("wcdv_button_bar").appendTo(win);
  var words = ["Very Cool", "Thanks", "Nice!", "All Right", "Whatever"];
  jQuery("<button>", {
    "type": "button",
    "class": "",
    "title": "Very Cool"
  }).append(fontAwesome("fa-thumbs-up")).append(words[Math.floor(Math.random() * words.length)]).on("click", function() {
    win.dialog("close");
  }).appendTo(buttonBar);
  win.dialog("open");
};

// node_modules/wcdatavis/src/ui/templates.js
var TemplatesEditor = makeSubclass("TemplatesEditor", Object, function(grid, onSave, onCancel) {
  var self2 = this;
  var winEffect = {
    effect: "fade",
    duration: 100
  };
  self2.grid = grid;
  self2.win = jQuery("<div>", { title: trans("GRID.TEMPLATE_EDITOR.TITLE") }).dialog({
    autoOpen: false,
    modal: true,
    width: "auto",
    position: {
      my: "center",
      at: "center",
      of: window
    },
    classes: {
      "ui-dialog": "ui-corner-all wcdv_dialog",
      "ui-dialog-titlebar": "ui-corner-all"
    },
    buttons: [{
      text: trans("DIALOG.OK"),
      icon: "ui-icon-check",
      click: function() {
        self2.tabData.each(function(v, k) {
          index_default_default.each(["empty", "before", "beforeGroup", "item", "afterGroup", "after"], function(t2) {
            if (v.inputs[t2] != null) {
              setProp(v.inputs[t2].val(), self2.grid.defn, "rendererOpts", k, t2);
            }
          });
        });
        self2.win.dialog("close");
        if (typeof onSave === "function") {
          onSave();
        }
      }
    }, {
      text: trans("DIALOG.CANCEL"),
      icon: "ui-icon-cancel",
      click: function() {
        self2.win.dialog("close");
        if (typeof onCancel === "function") {
          onCancel();
        }
      }
    }],
    show: winEffect,
    hide: winEffect
  });
  var makeTab = function(name, displayName) {
    var inputs = {};
    var labels = {};
    var li = jQuery("<li>").append(jQuery("<a>", { href: "#wcdv_hbe_" + name }).text(displayName));
    var div = jQuery("<div>", { id: "wcdv_hbe_" + name });
    index_default_default.each([
      { id: "empty", label: trans("GRID.TEMPLATE_EDITOR.CONFIG.EMPTY"), rows: 2 },
      { id: "before", label: trans("GRID.TEMPLATE_EDITOR.CONFIG.BEFORE"), rows: 2 },
      { id: "beforeGroup", label: trans("GRID.TEMPLATE_EDITOR.CONFIG.BEFORE_GROUP"), rows: 2, modes: ["whenPivot"] },
      { id: "item", label: trans("GRID.TEMPLATE_EDITOR.CONFIG.ITEM"), rows: name === "whenPlain" ? 8 : 4 },
      { id: "afterGroup", label: trans("GRID.TEMPLATE_EDITOR.CONFIG.AFTER_GROUP"), rows: 2, modes: ["whenPivot"] },
      { id: "after", label: trans("GRID.TEMPLATE_EDITOR.CONFIG.AFTER"), rows: 2 }
    ], function(x) {
      if (x.modes != null && x.modes.indexOf(name) < 0) {
        return;
      }
      labels[x.id] = jQuery("<label>", {
        for: "wcdv_hbe_" + name + "_" + x.id
      }).css("display", "block").text(x.label + ":");
      inputs[x.id] = jQuery("<textarea>", {
        id: "wcdv_hbe_" + name + "_" + x.id,
        rows: x.rows,
        cols: 80
      }).css("font-family", "monospace");
      div.append(labels[x.id]);
      div.append(inputs[x.id]);
    });
    return { li, div, inputs };
  };
  self2.tabData = new ordmap_default();
  self2.tabData.set("whenPlain", makeTab("whenPlain", trans("GRID.TEMPLATE_EDITOR.PLAIN")));
  self2.tabData.set("whenGroup", makeTab("whenGroup", trans("GRID.TEMPLATE_EDITOR.GROUPED")));
  self2.tabData.set("whenPivot", makeTab("whenPivot", trans("GRID.TEMPLATE_EDITOR.PIVOTTED")));
  var tabs = jQuery("<div>").appendTo(self2.win);
  var ul = jQuery("<ul>").appendTo(tabs);
  self2.tabData.each(function(x) {
    ul.append(x.li);
    tabs.append(x.div);
  });
  tabs.tabs();
});
TemplatesEditor.prototype.show = function() {
  var self2 = this;
  self2.tabData.each(function(v, k) {
    var config = getProp(self2.grid.defn, "rendererOpts", k);
    if (config != null) {
      index_default_default.each(["empty", "before", "beforeGroup", "item", "afterGroup", "after"], function(t2) {
        if (v.inputs[t2] && config[t2]) {
          v.inputs[t2].val(config[t2]);
        }
      });
    }
  });
  self2.win.dialog("open");
};

// node_modules/wcdatavis/src/ui/toolbars/grid.js
var import_sprintf_js10 = __toESM(require_sprintf());

// node_modules/wcdatavis/src/ui/toolbar.js
var ToolbarSection = makeSubclass("ToolbarSection", Object, function() {
  var self2 = this;
  self2.ui = {};
  self2.ui.root = jQuery("<div>");
});
ToolbarSection.prototype.attach = function(parent) {
  var self2 = this;
  self2.ui.root.appendTo(parent);
};
ToolbarSection.prototype.detach = function() {
  var self2 = this;
  self2.ui.root.remove();
};
ToolbarSection.prototype.show = function() {
  var self2 = this;
  self2.update();
  self2.ui.root.show();
};
ToolbarSection.prototype.hide = function() {
  var self2 = this;
  self2.ui.root.hide();
};
ToolbarSection.prototype.isVisible = function() {
  var self2 = this;
  return isVisible(self2.ui.root);
};
ToolbarSection.prototype.update = function() {
};

// node_modules/wcdatavis/src/prefs_backend.js
var import_sprintf_js7 = __toESM(require_sprintf());
var import_numeral14 = __toESM(require_numeral());

// node_modules/wcdatavis/src/renderers/graph/chartjs.js
var import_numeral9 = __toESM(require_numeral());
var import_jquery9 = __toESM(require_jquery());

// node_modules/@kurkle/color/dist/color.esm.js
function round2(v) {
  return v + 0.5 | 0;
}
var lim = (v, l2, h) => Math.max(Math.min(v, h), l2);
function p2b(v) {
  return lim(round2(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round2(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round2(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round2(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq2 = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq2(v.r) && eq2(v.g) && eq2(v.b) && eq2(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a2, f2) => a2 < 255 ? f2(a2) : "";
function hexString(v) {
  var f2 = isShort(v) ? h1 : h2;
  return v ? "#" + f2(v.r) + f2(v.g) + f2(v.b) + alpha(v.a, f2) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s2, l2) {
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = (n2, k = (n2 + h / 30) % 12) => l2 - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f2(0), f2(8), f2(4)];
}
function hsv2rgbn(h, s2, v) {
  const f2 = (n2, k = (n2 + h / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f2(5), f2(3), f2(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i2;
  if (w + b > 1) {
    i2 = 1 / (w + b);
    w *= i2;
    b *= i2;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] *= 1 - w - b;
    rgb[i2] += w;
  }
  return rgb;
}
function hueValue(r2, g, b, d2, max3) {
  if (r2 === max3) {
    return (g - b) / d2 + (g < b ? 6 : 0);
  }
  if (g === max3) {
    return (b - r2) / d2 + 2;
  }
  return (r2 - g) / d2 + 4;
}
function rgb2hsl(v) {
  const range2 = 255;
  const r2 = v.r / range2;
  const g = v.g / range2;
  const b = v.b / range2;
  const max3 = Math.max(r2, g, b);
  const min3 = Math.min(r2, g, b);
  const l2 = (max3 + min3) / 2;
  let h, s2, d2;
  if (max3 !== min3) {
    d2 = max3 - min3;
    s2 = l2 > 0.5 ? d2 / (2 - max3 - min3) : d2 / (max3 + min3);
    h = hueValue(r2, g, b, d2, max3);
    h = h * 60 + 0.5;
  }
  return [h | 0, s2 || 0, l2];
}
function calln(f2, a2, b, c2) {
  return (Array.isArray(a2) ? f2(a2[0], a2[1], a2[2]) : f2(a2, b, c2)).map(n2b);
}
function hsl2rgb(h, s2, l2) {
  return calln(hsl2rgbn, h, s2, l2);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s2, v) {
  return calln(hsv2rgbn, h, s2, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m2 = HUE_RE.exec(str);
  let a2 = 255;
  let v;
  if (!m2) {
    return;
  }
  if (m2[5] !== v) {
    a2 = m2[6] ? p2b(+m2[5]) : n2b(+m2[5]);
  }
  const h = hue(+m2[2]);
  const p1 = +m2[3] / 100;
  const p2 = +m2[4] / 100;
  if (m2[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m2[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a2
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a2 = rgb2hsl(v);
  const h = a2[0];
  const s2 = n2p(a2[1]);
  const l2 = n2p(a2[2]);
  return v.a < 255 ? `hsla(${h}, ${s2}%, ${l2}%, ${b2n(v.a)})` : `hsl(${h}, ${s2}%, ${l2}%)`;
}
var map3 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys3 = Object.keys(names$1);
  const tkeys = Object.keys(map3);
  let i2, j, k, ok, nk;
  for (i2 = 0; i2 < keys3.length; i2++) {
    ok = nk = keys3[i2];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map3[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a2 = names[str.toLowerCase()];
  return a2 && {
    r: a2[0],
    g: a2[1],
    b: a2[2],
    a: a2.length === 4 ? a2[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m2 = RGB_RE.exec(str);
  let a2 = 255;
  let r2, g, b;
  if (!m2) {
    return;
  }
  if (m2[7] !== r2) {
    const v = +m2[7];
    a2 = m2[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r2 = +m2[1];
  g = +m2[3];
  b = +m2[5];
  r2 = 255 & (m2[2] ? p2b(r2) : lim(r2, 0, 255));
  g = 255 & (m2[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m2[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r2,
    g,
    b,
    a: a2
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to2 = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from2 = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t2) {
  const r2 = from2(b2n(rgb1.r));
  const g = from2(b2n(rgb1.g));
  const b = from2(b2n(rgb1.b));
  return {
    r: n2b(to2(r2 + t2 * (from2(b2n(rgb2.r)) - r2))),
    g: n2b(to2(g + t2 * (from2(b2n(rgb2.g)) - g))),
    b: n2b(to2(b + t2 * (from2(b2n(rgb2.b)) - b))),
    a: rgb1.a + t2 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i2, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone3(v, proto2) {
  return v ? Object.assign(proto2 || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone3(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class _Color {
  constructor(input) {
    if (input instanceof _Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone3(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a2 = c1.a - c2.a;
      const w1 = ((w * a2 === -1 ? w : (w + a2) / (1 + w * a2)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t2) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t2);
    }
    return this;
  }
  clone() {
    return new _Color(this.rgb);
  }
  alpha(a2) {
    this._rgb.a = n2b(a2);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round2(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop2() {
}
var uid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray2(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject3(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each2(loopable, fn, thisArg, reverse) {
  let i2, len, keys3;
  if (isArray2(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i2 = len - 1; i2 >= 0; i2--) {
        fn.call(thisArg, loopable[i2], i2);
      }
    } else {
      for (i2 = 0; i2 < len; i2++) {
        fn.call(thisArg, loopable[i2], i2);
      }
    }
  } else if (isObject3(loopable)) {
    keys3 = Object.keys(loopable);
    len = keys3.length;
    for (i2 = 0; i2 < len; i2++) {
      fn.call(thisArg, loopable[keys3[i2]], keys3[i2]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i2, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
    v0 = a0[i2];
    v1 = a1[i2];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone4(source) {
  if (isArray2(source)) {
    return source.map(clone4);
  }
  if (isObject3(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys3 = Object.keys(source);
    const klen = keys3.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys3[k]] = clone4(source[keys3[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject3(tval) && isObject3(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone4(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray2(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject3(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i2 = 0; i2 < ilen; ++i2) {
    current = sources[i2];
    if (!isObject3(current)) {
      continue;
    }
    const keys3 = Object.keys(current);
    for (let k = 0, klen = keys3.length; k < klen; ++k) {
      merger(keys3[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject3(tval) && isObject3(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone4(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o2) => o2.x,
  y: (o2) => o2.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys3 = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys3.push(tmp);
      tmp = "";
    }
  }
  return keys3;
}
function _getKeyResolver(key) {
  const keys3 = _splitKey(key);
  return (obj) => {
    for (const k of keys3) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction3 = (value) => typeof value === "function";
var setsEqual = (a2, b) => {
  if (a2.size !== b.size) {
    return false;
  }
  for (const item of a2) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e2) {
  return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign2 = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range2) {
  const roundedRange = Math.round(range2);
  range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
  const niceRange = Math.pow(10, Math.floor(log10(range2)));
  const fraction = range2 / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result2 = [];
  const sqrt = Math.sqrt(value);
  let i2;
  for (i2 = 1; i2 < sqrt; i2++) {
    if (value % i2 === 0) {
      result2.push(i2);
      result2.push(value / i2);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result2.push(sqrt);
  }
  result2.sort((a2, b) => a2 - b).pop();
  return result2;
}
function isNumber2(n2) {
  return !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property2) {
  let i2, ilen, value;
  for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
    value = array[i2][property2];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e2 = 1;
  let p = 0;
  while (Math.round(x * e2) / e2 !== x) {
    e2 *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a2, b) {
  return (a2 - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a2) {
  return (a2 % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a2 = _normalizeAngle(angle);
  const s2 = _normalizeAngle(start);
  const e2 = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s2 - a2);
  const angleToEnd = _normalizeAngle(e2 - a2);
  const startToAngle = _normalizeAngle(a2 - s2);
  const endToAngle = _normalizeAngle(a2 - e2);
  return a2 === s2 || a2 === e2 || sameAngleIsFullCircle && s2 === e2 || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min3, max3) {
  return Math.max(min3, Math.min(max3, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp2) {
  cmp2 = cmp2 || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp2(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last2) => _lookup(table, value, last2 ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values2, min3, max3) {
  let start = 0;
  let end = values2.length;
  while (start < end && values2[start] < min3) {
    start++;
  }
  while (end > start && values2[end - 1] > max3) {
    end--;
  }
  return start > 0 || end < values2.length ? values2.slice(start, end) : values2;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object2) => {
          if (typeof object2[method] === "function") {
            object2[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set3 = new Set(items);
  if (set3.size === items.length) {
    return items;
  }
  return Array.from(set3);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce3(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min: min3, max: max3, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min3).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min3)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max3, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max3), true).hi + 1
      ), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t2) => t2 === 0 || t2 === 1;
var elasticIn = (t2, s2, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * TAU / p));
var elasticOut = (t2, s2, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * TAU / p) + 1;
var effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s2 = 0.1125;
    const p = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s2, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s2, p);
  },
  easeInBack(t2) {
    const s2 = 1.70158;
    return t2 * t2 * ((s2 + 1) * t2 - s2);
  },
  easeOutBack(t2) {
    const s2 = 1.70158;
    return (t2 -= 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
  },
  easeInOutBack(t2) {
    let s2 = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m2 = 7.5625;
    const d2 = 2.75;
    if (t2 < 1 / d2) {
      return m2 * t2 * t2;
    }
    if (t2 < 2 / d2) {
      return m2 * (t2 -= 1.5 / d2) * t2 + 0.75;
    }
    if (t2 < 2.5 / d2) {
      return m2 * (t2 -= 2.25 / d2) * t2 + 0.9375;
    }
    return m2 * (t2 -= 2.625 / d2) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults4) {
  defaults4.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults4.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults4.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults4.describe("animations", {
    _fallback: "animation"
  });
  defaults4.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults4) {
  defaults4.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
var formatters = {
  values(value) {
    return isArray2(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults4) {
  defaults4.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults4.route("scale.ticks", "color", "", "color");
  defaults4.route("scale.grid", "color", "", "borderColor");
  defaults4.route("scale.border", "color", "", "borderColor");
  defaults4.route("scale.title", "color", "", "color");
  defaults4.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults4.describe("scales", {
    _fallback: "scale"
  });
  defaults4.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys3 = key.split(".");
  for (let i2 = 0, n2 = keys3.length; i2 < n2; ++i2) {
    const k = keys3[i2];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set2(root2, scope, values2) {
  if (typeof scope === "string") {
    return merge(getScope$1(root2, scope), values2);
  }
  return merge(getScope$1(root2, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values2) {
    return set2(this, scope, values2);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values2) {
    return set2(descriptors, scope, values2);
  }
  override(scope, values2) {
    return set2(overrides, scope, values2);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject3(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults3 = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i2, j, jlen, thing, nestedThing;
  for (i2 = 0; i2 < ilen; i2++) {
    thing = arrayOfThings[i2];
    if (thing !== void 0 && thing !== null && !isArray2(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray2(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray2(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i2 = 0; i2 < gcLen; i2++) {
      delete data[gc[i2]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size2, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    // Default includes circle
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size2 = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size2;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size2);
      yOffset = Math.sin(rad + QUARTER_PI) * size2;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size2);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size2 = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size2;
        ctx.rect(x - width, y - size2, 2 * width, 2 * size2);
        break;
      }
      rad += QUARTER_PI;
    /* falls through */
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    /* falls through */
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray2(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i2, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i2 = 0; i2 < lines.length; ++i2) {
    line = lines[i2];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size2) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size2 * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size2 * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject3(props);
  const keys3 = objProps ? Object.keys(props) : props;
  const read = isObject3(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys3) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults3.font;
  let size2 = valueOrDefault(options.size, fallback.size);
  if (typeof size2 === "string") {
    size2 = parseInt(size2, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size2),
    size: size2,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i2, ilen, value;
  for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
    value = inputs[i2];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray2(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min: min3, max: max3 } = minmax;
  const change = toDimension(grace, (max3 - min3) / 2);
  const keepZero = (value, add2) => beginAtZero && value === 0 ? 0 : value + add2;
  return {
    min: keepZero(min3, -Math.abs(change)),
    max: keepZero(max3, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults4 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults4.scriptable, _indexable = defaults4.indexable, _allKeys = defaults4.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction3(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction3(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject3(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction3(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray2(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject3(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction3(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set3, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set3.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set3 = /* @__PURE__ */ new Set();
  set3.add(value);
  let key = addScopesFromKey(set3, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set3, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set3), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set3, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set3, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray2(target) && isObject3(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys3 = target._keys;
  if (!keys3) {
    keys3 = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys3;
}
function resolveKeysFromAllScopes(scopes) {
  const set3 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set3.add(key);
    }
  }
  return Array.from(set3);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i2, ilen, index2, item;
  for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
    index2 = i2 + start;
    item = data[index2];
    parsed[i2] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t2 * s01;
  const fb = t2 * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i2], 0, EPSILON)) {
      mK[i2] = mK[i2 + 1] = 0;
      continue;
    }
    alphaK = mK[i2] / deltaK[i2];
    betaK = mK[i2 + 1] / deltaK[i2];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i2] = alphaK * tauK * deltaK[i2];
    mK[i2 + 1] = betaK * tauK * deltaK[i2];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis2 = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis2];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis2}`] = vPixel - delta * mK[i2];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis2}`] = vPixel + delta * mK[i2];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis2 = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i2, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis2] - pointCurrent[valueAxis2]) / slopeDelta : 0;
    }
    mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign2(deltaK[i2 - 1]) !== sign2(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min3, max3) {
  return Math.max(Math.min(pt, max3), min3);
}
function capBezierPoints(points, area) {
  let i2, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i2];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i2, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      point = points[i2];
      controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property2) {
  return getComputedStyle(el).getPropertyValue(property2);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result2 = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i2 = 0; i2 < 4; i2++) {
    const pos = positions[i2];
    result2[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result2.width = result2.left + result2.right;
  result2.height = result2.top + result2.bottom;
  return result2;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e2, canvas) {
  const touches = e2.touches;
  const source = touches && touches.length ? touches[0] : e2;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e2.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e2) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property2) {
  const value = getStyle(element, property2);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: p1.y + t2 * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t2, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a2 = _pointInLine(p1, cp1, t2);
  const b = _pointInLine(cp1, cp2, t2);
  const c2 = _pointInLine(cp2, p2, t2);
  const d2 = _pointInLine(a2, b, t2);
  const e2 = _pointInLine(b, c2, t2);
  return _pointInLine(d2, e2, t2);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property2) {
  if (property2 === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a2, b) => a2 - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property: property2, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property2);
  const count = points.length;
  let { start, end, loop } = segment;
  let i2, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      if (!between(normalize(points[start % count][property2]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property: property2, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property2);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result2 = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i2 = start, prev = start; i2 <= end; ++i2) {
    point = points[i2 % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property2]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i2 : prev;
    }
    if (subStart !== null && shouldStop()) {
      result2.push(normalizeSegment({
        start: subStart,
        end: i2,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i2;
    prevValue = value;
  }
  if (subStart !== null) {
    result2.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result2;
}
function _boundSegments(line, bounds) {
  const result2 = [];
  const segments = line.segments;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const sub = _boundSegment(segments[i2], line.points, bounds);
    if (sub.length) {
      result2.push(...sub);
    }
  }
  return result2;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max3, loop) {
  const count = points.length;
  const result2 = [];
  let last2 = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max3; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result2.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last2 = cur.stop ? end : null;
      }
    } else {
      last2 = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last2 !== null) {
    result2.push({
      start: start % count,
      end: last2 % count,
      loop
    });
  }
  return result2;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max3 = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max3, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result2 = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i2 = start;
  function addStyle(s2, e2, l2, st) {
    const dir = spanGaps ? -1 : 1;
    if (s2 === e2) {
      return;
    }
    s2 += count;
    while (points[s2 % count].skip) {
      s2 -= dir;
    }
    while (points[e2 % count].skip) {
      e2 += dir;
    }
    if (s2 % count !== e2 % count) {
      result2.push({
        start: s2 % count,
        end: e2 % count,
        loop: l2,
        style: st
      });
      prevStyle = st;
      start = e2 % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i2 = start + 1; i2 <= segment.end; i2++) {
      const pt = points[i2 % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i2 - 1) % count,
        p1DataIndex: i2 % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i2 - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i2 - 1) {
      addStyle(start, i2 - 1, segment.loop, prevStyle);
    }
  }
  return result2;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      let draw2 = false;
      let item;
      for (; i2 >= 0; --i2) {
        item = items[i2];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i2] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb2) {
    this._getAnims(chart).listeners[event].push(cb2);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i2 = items.length - 1;
    for (; i2 >= 0; --i2) {
      items[i2].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from3, to3, factor) {
    return factor > 0.5 ? to3 : from3;
  },
  color(from3, to3, factor) {
    const c0 = color(from3 || transparent);
    const c1 = c0.valid && color(to3 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to3;
  },
  number(from3, to3, factor) {
    return from3 + (to3 - from3) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to3) {
    const currentValue = target[prop];
    to3 = resolve([
      cfg.to,
      to3,
      currentValue,
      cfg.from
    ]);
    const from3 = resolve([
      cfg.from,
      currentValue,
      to3
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from3];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from3;
    this._to = to3;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to3, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to3,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to3
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration2 = this._duration;
    const prop = this._prop;
    const from3 = this._from;
    const loop = this._loop;
    const to3 = this._to;
    let factor;
    this._active = from3 !== to3 && (loop || elapsed < duration2);
    if (!this._active) {
      this._target[prop] = to3;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from3;
      return;
    }
    factor = elapsed / duration2 % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from3, to3, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i2 = 0; i2 < promises.length; i2++) {
      promises[i2][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject3(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults3.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject3(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray2(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values2) {
    const newOptions = values2.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values2) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values2);
    const date = Date.now();
    let i2;
    for (i2 = props.length - 1; i2 >= 0; --i2) {
      const prop = props[i2];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values2));
        continue;
      }
      const value = values2[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values2) {
    if (this._properties.size === 0) {
      Object.assign(target, values2);
      return;
    }
    const animations = this._createAnimations(target, values2);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys3 = Object.keys(properties);
  for (let i2 = 0; i2 < keys3.length; i2++) {
    const anim = animations[keys3[i2]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min3 = opts.min === void 0 ? allowedOverflow : 0;
  const max3 = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max3 : min3,
    end: reverse ? min3 : max3
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t2, r2, b, l2;
  if (isObject3(value)) {
    t2 = value.top;
    r2 = value.right;
    b = value.bottom;
    l2 = value.left;
  } else {
    t2 = r2 = b = l2 = value;
  }
  return {
    top: t2,
    right: r2,
    bottom: b,
    left: l2,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys3 = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i2, ilen;
  for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    keys3.push(metasets[i2].index);
  }
  return keys3;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys3 = stack.keys;
  const singleMode = options.mode === "single";
  let i2, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i2 = 0, ilen = keys3.length; i2 < ilen; ++i2) {
    datasetIndex = +keys3[i2];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign2(value) === sign2(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys3 = Object.keys(data);
  const adata = new Array(keys3.length);
  let i2, ilen, key;
  for (i2 = 0, ilen = keys3.length; i2 < ilen; ++i2) {
    key = keys3[i2];
    adata[i2] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min: min3, max: max3, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min3 : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max3 : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i2 = 0; i2 < ilen; ++i2) {
    const item = parsed[i2];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r2) => axis === "x" ? x : axis === "r" ? r2 : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject3(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i2, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray2(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject3(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i2 = 0; i2 < count; ++i2) {
        meta._parsed[i2 + start] = cur = parsed[i2];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i2, ilen, index2;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      parsed[i2] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values2 = stack && parsed._stacks[scale.axis];
    if (stack && values2) {
      stack.values = values2;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range2.min = Math.min(range2.min, value);
    range2.max = Math.max(range2.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i2, parsed;
    function _skip() {
      parsed = _parsed[i2];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i2 = 0; i2 < ilen; ++i2) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range2, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i2 = ilen - 1; i2 >= 0; --i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        break;
      }
    }
    return range2;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values2 = [];
    let i2, ilen, value;
    for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
      value = parsed[i2][scale.axis];
      if (isNumberFinite(value)) {
        values2.push(value);
      }
    }
    return values2;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i2;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const element = elements2[i2];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i2 = 0; i2 < active.length; ++i2) {
      active[i2].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults3.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values2 = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values2.$shared) {
      values2.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values2, sharing));
    }
    return values2;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i2;
    const move = (arr) => {
      arr.length += count;
      for (i2 = arr.length - 1; i2 >= end; i2--) {
        arr[i2] = arr[i2 - count];
      }
    };
    move(data);
    for (i2 = start; i2 < end; ++i2) {
      data[i2] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values2 = [];
    for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
      values2 = values2.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values2.sort((a2, b) => a2 - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values2 = getAllScaleValues(scale, meta.type);
  let min3 = scale._length;
  let i2, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min3 = Math.min(min3, Math.abs(curr - prev) || min3);
    }
    prev = curr;
  };
  for (i2 = 0, ilen = values2.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForValue(values2[i2]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForTick(i2);
    updateMinAndPrev();
  }
  return min3;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size2, ratio;
  if (isNullOrUndef(thickness)) {
    size2 = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size2 = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size2 / stackCount,
    ratio,
    start: ruler.pixels[index2] - size2 / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size2 = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size2 / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i2) {
  const startValue = vScale.parse(entry[0], i2);
  const endValue = vScale.parse(entry[1], i2);
  const min3 = Math.min(startValue, endValue);
  const max3 = Math.max(startValue, endValue);
  let barStart = min3;
  let barEnd = max3;
  if (Math.abs(min3) > Math.abs(max3)) {
    barStart = max3;
    barEnd = min3;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min: min3,
    max: max3
  };
}
function parseValue(entry, item, vScale, i2) {
  if (isArray2(entry)) {
    parseFloatBar(entry, item, vScale, i2);
  } else {
    item[vScale.axis] = vScale.parse(entry, i2);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i2, ilen, item, entry;
  for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
    entry = data[i2];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
    parsed.push(parseValue(entry, item, vScale, i2));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size2, vScale, actualBase) {
  if (size2 !== 0) {
    return sign2(size2);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a2, b, reverse) {
  if (reverse) {
    edge = swap(edge, a2, b);
    edge = startEnd(edge, b, a2);
  } else {
    edge = startEnd(edge, a2, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i2, ilen, item, obj;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
      obj = data[i2];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
    }
    return parsed;
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    super.updateRangeFromParsed(range2, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range2.min = Math.min(range2.min, custom.min);
      range2.max = Math.max(range2.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i2 = start; i2 < start + count; i2++) {
      const parsed = this.getParsed(i2);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i2);
      const ipixels = this._calculateBarIndexPixels(i2, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
      }
      const options = properties.options || bars[i2].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i2], i2, properties, mode);
    }
  }
  _getStacks(last2, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last2) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i2, ilen;
    for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
    }
    const barThickness = opts.barThickness;
    const min3 = barThickness || computeMinSampleSize(meta);
    return {
      min: min3,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size2;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign2(value) !== sign2(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size2 = head - base;
    if (Math.abs(size2) < minBarLength) {
      size2 = barSign(size2, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size2 / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min3 = Math.min(startPixel, endPixel);
      const max3 = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max3), min3);
      head = base + size2;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign2(size2) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size2 -= halfGrid;
    }
    return {
      size: size2,
      base,
      head,
      center: head + size2 / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size2;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
      size2 = Math.min(maxBarThickness, range2.chunk * range2.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size2 = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size2 / 2,
      head: center + size2 / 2,
      center,
      size: size2
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i2 = 0;
    for (; i2 < ilen; ++i2) {
      if (this.getParsed(i2)[vScale.axis] !== null) {
        rects[i2].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      parsed[i2]._custom = this.resolveDataElementOptions(i2 + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      const item = data[start + i2];
      parsed[i2]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i2 + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      const item = data[start + i2];
      parsed[i2]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i2 + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max3 = 0;
    for (let i2 = data.length - 1; i2 >= 0; --i2) {
      max3 = Math.max(max3, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
    }
    return max3 > 0 && max3;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r2 = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r2 ? ", " + r2 : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i2 = start; i2 < start + count; i2++) {
      const point = points[i2];
      const parsed = !reset && this.getParsed(i2);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i2, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values2 = super.resolveDataElementOptions(index2, mode);
    if (values2.$shared) {
      values2 = Object.assign({}, values2, {
        $shared: false
      });
    }
    const radius = values2.radius;
    if (mode !== "active") {
      values2.radius = 0;
    }
    values2.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values2;
  }
};
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a2, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a2, a2 * cutout, b, b * cutout);
    const calcMin = (angle, a2, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a2, a2 * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i3) => +data[i3];
      if (isObject3(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i3) => +resolveObjectKey(data[i3], key);
      }
      let i2, ilen;
      for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
        meta._parsed[i2] = getter(i2);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min3 = TAU;
    let max3 = -TAU;
    for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
      if (this.chart.isDatasetVisible(i2) && this.chart.getDatasetMeta(i2).type === this._type) {
        const controller = this.chart.getDatasetMeta(i2).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min3 = Math.min(min3, rotation);
        max3 = Math.max(max3, rotation + circumference);
      }
    }
    return {
      rotation: min3,
      circumference: max3 - min3
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i2, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i2;
    for (i2 = 0; i2 < start; ++i2) {
      startAngle += this._circumference(i2, reset);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const circumference = this._circumference(i2, reset);
      const arc = arcs[i2];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i2, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i2;
    for (i2 = 0; i2 < metaData.length; i2++) {
      const value = meta._parsed[i2];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max3 = 0;
    const chart = this.chart;
    let i2, ilen, meta, controller, options;
    if (!arcs) {
      for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
        if (chart.isDatasetVisible(i2)) {
          meta = chart.getDatasetMeta(i2);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      options = controller.resolveDataElementOptions(i2);
      if (options.borderAlign !== "inner") {
        max3 = Math.max(max3, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max3;
  }
  getMaxOffset(arcs) {
    let max3 = 0;
    for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      const options = this.resolveDataElementOptions(i2);
      max3 = Math.max(max3, options.offset || 0, options.hoverOffset || 0);
    }
    return max3;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i2 = 0; i2 < datasetIndex; ++i2) {
      if (this.chart.isDatasetVisible(i2)) {
        ringWeightOffset += this._getRingWeight(i2);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i2),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e2, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i2 = 0; i2 < pointsCount; ++i2) {
      const point = points[i2];
      const properties = directUpdate ? point : {};
      if (i2 < start || i2 >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i2);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range2.min) {
          range2.min = parsed;
        }
        if (parsed > range2.max) {
          range2.max = parsed;
        }
      }
    });
    return range2;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i2;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i2 = 0; i2 < start; ++i2) {
      angle += this._computeAngle(i2, mode, defaultAngle);
    }
    for (i2 = start; i2 < start + count; i2++) {
      const arc = arcs[i2];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i2, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i2) ? scale.getDistanceFromCenterForValue(this.getParsed(i2).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i2, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i2, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i2),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e2, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i2 = start; i2 < start + count; i2++) {
      const point = points[i2];
      const options = this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i2, this.getParsed(i2).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i2, properties, mode);
    }
  }
};
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
var ScatterController = class extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i2 = start; i2 < start + count; ++i2) {
      const point = points[i2];
      const parsed = this.getParsed(i2);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max3 = 0;
      for (let i2 = data.length - 1; i2 >= 0; --i2) {
        max3 = Math.max(max3, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
      }
      return max3 > 0 && max3;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class _DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(_DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range2 = typeof el.getRange === "function" && el.getRange(axis);
      if (range2) {
        const start = lookupMethod(data, axis, value - range2);
        const end = lookupMethod(data, axis, value + range2);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    const { index: index2, data } = metasets[i2];
    const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i2 = 0; i2 < data.length; ++i2) {
          items.push({
            element: data[i2],
            datasetIndex,
            index: i2
          });
        }
      }
      return items;
    },
    point(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a2, b) => {
    const v0 = reverse ? b : a2;
    const v1 = reverse ? a2 : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i2, ilen, box, pos, stack, stackWeight;
  for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
    box = boxes[i2];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i2,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap2 of layouts2) {
    const { stack, pos, stackWeight } = wrap2;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i2, ilen, layout;
  for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
    layout = layouts2[i2];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap2) => wrap2.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a2, b) {
  return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject3(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i2, ilen, layout, box, refit, changed;
  for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
    layout = boxes[i2];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each2(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap2) => wrap2.box.options && wrap2.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each2(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial2 = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial2[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial2.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element2 = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber2(this.x) && isNumber2(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element2, "defaults", {});
__publicField(Element2, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first2 = majorIndices[0];
  const last2 = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i2, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last2 - first2) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first2 - avgMajorSpacing, first2);
    for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
      skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
    }
    skip(ticks, newTicks, spacing, last2, isNullOrUndef(avgMajorSpacing) ? ticks.length : last2 + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset2 = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
    const factor = factors[i2];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result2 = [];
  let i2, ilen;
  for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
    if (ticks[i2].major) {
      result2.push(i2);
    }
  }
  return result2;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i2;
  spacing = Math.ceil(spacing);
  for (i2 = 0; i2 < ticks.length; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i2, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i2 = Math.max(start, 0); i2 < end; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i2, diff2;
  if (len < 2) {
    return false;
  }
  for (diff2 = arr[0], i2 = 1; i2 < len; ++i2) {
    if (arr[i2] - arr[i2 - 1] !== diff2) {
      return false;
    }
  }
  return diff2;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample2(arr, numItems) {
  const result2 = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i2 = 0;
  for (; i2 < len; i2 += increment) {
    result2.push(arr[Math.floor(i2)]);
  }
  return result2;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset2;
  if (offsetGridLines) {
    if (length === 1) {
      offset2 = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset2 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset2 : -offset2;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each2(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i2;
    if (gcLen > length) {
      for (i2 = 0; i2 < gcLen; ++i2) {
        delete cache.data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray2(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset2, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject3(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset2;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
    } else {
      titleY = offsetFromEdge(scale, position, offset2);
    }
    maxWidth = right - left;
  } else {
    if (isObject3(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset2;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
    } else {
      titleX = offsetFromEdge(scale, position, offset2);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class _Scale extends Element2 {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min: min3, max: max3, minDefined, maxDefined } = this.getUserBounds();
    let range2;
    if (minDefined && maxDefined) {
      return {
        min: min3,
        max: max3
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      range2 = metas[i2].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min3 = Math.min(min3, range2.min);
      }
      if (!maxDefined) {
        max3 = Math.max(max3, range2.max);
      }
    }
    min3 = maxDefined && min3 > max3 ? max3 : min3;
    max3 = minDefined && min3 > max3 ? min3 : max3;
    return {
      min: finiteOrDefault(min3, finiteOrDefault(max3, min3)),
      max: finiteOrDefault(max3, finiteOrDefault(min3, max3))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample2(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      tick = ticks[i2];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i2,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first: first2, last: last2, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first2, last2, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first2, last2, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first2.width;
          paddingRight = sin * last2.height;
        } else {
          paddingLeft = sin * first2.height;
          paddingRight = cos * last2.width;
        }
      } else if (align === "start") {
        paddingRight = last2.width;
      } else if (align === "end") {
        paddingLeft = first2.width;
      } else if (align !== "inner") {
        paddingLeft = first2.width / 2;
        paddingRight = last2.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last2.height / 2;
      let paddingBottom = first2.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first2.height;
      } else if (align === "end") {
        paddingTop = last2.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (isNullOrUndef(ticks[i2].label)) {
        ticks.splice(i2, 1);
        ilen--;
        i2--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample2(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i2, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i2 = 0; i2 < length; i2 += increment) {
      label = ticks[i2].label;
      tickFont = this._resolveTickFontOptions(i2);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray2(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray2(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: min3, max: max3 } = this;
    return min3 < 0 && max3 < 0 ? max3 : min3 > 0 && max3 > 0 ? min3 : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset2 = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset2 ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i2, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject3(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject3(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i2 = 0; i2 < ticksLength; i2 += step) {
      const context = this.getContext(i2);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i2, offset2);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i2, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject3(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject3(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i2));
      pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i2);
      lineHeight = font.lineHeight;
      lineCount = isArray2(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i2 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i2 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i2];
        const width = labelSizes.widths[i2];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t2) => t2.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i2, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        const item = items[i2];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset2 = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject3(position)) {
      offset2 += padding.bottom;
      if (isArray2(title.text)) {
        offset2 += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset2 += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result2 = [];
    let i2, ilen;
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      const meta = metas[i2];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result2.push(meta);
      }
    }
    return result2;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto2 = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto2)) {
      parentScope = this.register(proto2);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults3.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults3[scope]) {
      delete defaults3[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults3.get(parentScope) : {},
    defaults3.get(scope),
    item.defaults
  ]);
  defaults3.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults3.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property2) => {
    const propertyParts = property2.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property2].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults3.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto2) {
  return "id" in proto2 && "defaults" in proto2;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element2, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each2(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
      const reg = this._typedRegistries[i2];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter2) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter2 ? this._descriptors(chart).filter(filter2) : this._descriptors(chart);
    const result2 = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result2;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff2 = (a2, b) => a2.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff2(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff2(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys3 = Object.keys(registry.plugins.items);
  for (let i2 = 0; i2 < keys3.length; i2++) {
    plugins2.push(registry.getPlugin(keys3[i2]));
  }
  const local = config.plugins || [];
  for (let i2 = 0; i2 < local.length; i2++) {
    const plugin = local[i2];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result2 = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result2.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result2;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys3 = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys3);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults3.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d2) => d2.xAxisID === id || d2.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject3(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults3.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults3.scales[scale.type],
      defaults3.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys3 = keyCache.get(cacheKey);
  if (!keys3) {
    keys3 = generate();
    keyCache.set(cacheKey, keys3);
    keysCached.add(keys3);
  }
  return keys3;
}
var addIfFound = (set3, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set3.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys3) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys3.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys3.forEach((key) => addIfFound(scopes, options, key));
      keys3.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys3.forEach((key) => addIfFound(scopes, defaults3, key));
      keys3.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults3.datasets[type] || {},
      {
        type
      },
      defaults3,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result2 = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result2.$shared = false;
      context = isFunction3(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result2[prop] = options[prop];
    }
    return result2;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject3(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject3(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction3(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction3(value) || hasFunction(value)) || indexable && isArray2(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.0";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a2, b) {
    return a2[l1] === b[l1] ? a2[l2] - b[l2] : a2[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys3 = Object.keys(obj);
  for (const key of keys3) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e2.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e2;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce3((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each2(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each2(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each2(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each2(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a2, b) => a2.index - b.index);
    if (numMeta > numData) {
      for (let i2 = numData; i2 < numMeta; ++i2) {
        this._destroyDatasetMeta(i2);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i2, ilen;
    this._removeUnreferencedMetasets();
    for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
      const dataset = datasets[i2];
      let meta = this.getDatasetMeta(i2);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i2);
        meta = this.getDatasetMeta(i2);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i2;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i2);
      if (meta.controller) {
        meta.controller.updateIndex(i2);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults3.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i2);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each2(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
      const { controller } = this.getDatasetMeta(i2);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each2(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each2(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i2 = 1; i2 < datasetCount; i2++) {
      if (!setsEqual(changeSet, makeSet(i2))) {
        return;
      }
    }
    return Array.from(changeSet).map((c2) => c2.split(",")).map((a2) => ({
      method: a2[1],
      start: +a2[2],
      count: +a2[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each2(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this.getDatasetMeta(i2).controller.configure();
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._updateDataset(i2, isFunction3(mode) ? mode({
        datasetIndex: i2
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i2;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i2 < layers.length; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result2 = [];
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const meta = metasets[i2];
      if (!filterVisible || meta.visible) {
        result2.push(meta);
      }
    }
    return result2;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      this._drawDataset(metasets[i2]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e2, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e2, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i2, ilen;
    this.stop();
    animator.remove(this);
    for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._destroyDatasetMeta(i2);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e2, x, y) => {
      e2.offsetX = x;
      e2.offsetY = y;
      this._eventHandler(e2);
    };
    each2(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each2(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each2(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i2, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      item = items[i2];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter2) {
    return this._plugins.notify(this, hook, args, filter2);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff2 = (a2, b) => a2.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff2(lastActive, active);
    const activated = replay ? active : diff2(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e2, replay) {
    const args = {
      event: e2,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e2)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e2.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e2, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e2, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e2);
    const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e2,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e2,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults3);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each2(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o2 = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o2.outerStart),
    outerEnd: computeOuterLimit(o2.outerEnd),
    innerStart: _limitValue(o2.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o2.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r2, theta, x, y) {
  return {
    x: x + r2 * Math.cos(theta),
    y: y + r2 * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset2, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset2 / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset2, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset2, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset2, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element2 {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset: offset2, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset2 = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset2, Math.sin(halfAngle) * offset2);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset2 * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i2, point, prev;
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[(start + (reverse ? ilen - i2 : i2)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i2, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[pointIndex(i2)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property2) {
    const options = this.options;
    const value = point[property2];
    const points = this.points;
    const segments = _boundSegments(this, {
      property: property2,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result2 = [];
    const _interpolate = _getInterpolationMethod(options);
    let i2, ilen;
    for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
      const { start, end } = segments[i2];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result2.push(p1);
        continue;
      }
      const t2 = Math.abs((value - p1[property2]) / (p2[property2] - p1[property2]));
      const interpolated = _interpolate(p1, p2, t2, options.stepped);
      interpolated[property2] = point[property2];
      result2.push(interpolated);
    }
    return result2.length === 1 ? result2[0] : result2;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element2 {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min3, max3) {
  return skip2 ? 0 : _limitValue(value, min3, max3);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o2 = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o2.top, 0, maxH),
    r: skipOrLimit(skip2.right, o2.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o2.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o2 = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject3(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element2 {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
var BACKGROUND_COLORS = BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i2) {
  return BORDER_COLORS[i2 % BORDER_COLORS.length];
}
function getBackgroundColor(i2) {
  return BACKGROUND_COLORS[i2 % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i2) {
  dataset.borderColor = getBorderColor(i2);
  dataset.backgroundColor = getBackgroundColor(i2);
  return ++i2;
}
function colorizeDoughnutDataset(dataset, i2) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i2++));
  return i2;
}
function colorizePolarAreaDataset(dataset, i2) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i2++));
  return i2;
}
function getColorizer(chart) {
  let i2 = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i2 = colorizeDoughnutDataset(dataset, i2);
    } else if (controller instanceof PolarAreaController) {
      i2 = colorizePolarAreaDataset(dataset, i2);
    } else if (controller) {
      i2 = colorizeDefaultDataset(dataset, i2);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a2 = start;
  let i2, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a2];
  for (i2 = 0; i2 < samples - 2; i2++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i2 + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i2 + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i2 * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i2 + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a2];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a2 = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i2, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i2 = start; i2 < start + count; ++i2) {
    point = data[i2];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i2;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i2;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i2 - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i2 > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i2;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min: min3, max: max3, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min3).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max3).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d2) {
            this._data = d2;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property2) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property2, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property2, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property2]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property2]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property2, first2, last2, loop) {
  if (loop) {
    return;
  }
  let start = first2[property2];
  let end = last2[property2];
  if (property2 === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property: property2,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first2 = linePoints[start];
    const last2 = linePoints[end];
    if (y !== null) {
      points.push({
        x: first2.x,
        y
      });
      points.push({
        x: last2.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first2.y
      });
      points.push({
        x,
        y: last2.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a2, b, prop, fn) {
  if (a2 && b) {
    return fn(a2[prop], b[prop]);
  }
  return a2 ? a2[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray2(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject3(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject3(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject3(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i2 = 0; i2 < segments.length; i2++) {
    const segment = segments[i2];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i2 = 0; i2 < metas.length; i2++) {
    const meta = metas[i2];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first: first2, last: last2, point } = findPoint(line, sourcePoint, "x");
    if (!point || first2 && last2) {
      continue;
    }
    if (first2) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last2) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property2) {
  const point = line.interpolate(sourcePoint, property2);
  if (!point) {
    return {};
  }
  const pointValue = point[property2];
  const segments = line.segments;
  const linePoints = line.points;
  let first2 = false;
  let last2 = false;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const segment = segments[i2];
    const firstValue = linePoints[segment.start][property2];
    const lastValue = linePoints[segment.end][property2];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first2 = pointValue === firstValue;
      last2 = pointValue === lastValue;
      break;
    }
  }
  return {
    first: first2,
    last: last2,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i2 = 0; i2 < length; ++i2) {
    target.push(scale.getPointPositionForValue(i2, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property2 = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property2 === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property: property2
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property: property2
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first2 = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first2) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first2 = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property: property2, color: color2, scale } = cfg;
  const segments = _segments(line, target, property2);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property2, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property2);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property2);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property: property2, start, end } = bounds || {};
  if (property2 === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property2) {
  const interpolatedPoint = target.interpolate(point, property2);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i2, line, source;
    for (i2 = 0; i2 < count; ++i2) {
      meta = chart.getDatasetMeta(i2);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i2),
          index: i2,
          fill: _decodeFill(line, i2, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i2 = 0; i2 < count; ++i2) {
      source = sources[i2];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i2, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      const source = metasets[i2].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      const source = metasets[i2].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a2, b) => a2 !== null && b !== null && a2.datasetIndex === b.datasetIndex && a2.index === b.index;
var Legend = class extends Element2 {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a2, b) => labelOpts.sort(a2, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i2) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i2] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i2) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i2] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults3.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i2) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i2 > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i2 > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size2) => Math.max(acc, size2.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i2, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i2 = 0; i2 < lh.length; ++i2) {
        hitBox = lh[i2];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i2];
        }
      }
    }
    return null;
  }
  handleEvent(e2) {
    const opts = this.options;
    if (!isListened(e2.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
    if (e2.type === "mousemove" || e2.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e2,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e2,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e2,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a2, b) => a2.length > b.length ? a2 : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e2, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element2 {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray2(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset2) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset2;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset2;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset2;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset2 = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map4 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map4.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map4.get(chart));
    map4.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map4.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i2, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i2, len, nearestElement;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d2 = distanceBetweenPoints(eventPosition, center);
        if (d2 < minDistance) {
          minDistance = d2;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray2(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each2(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each2(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each2(body, (bodyItem) => {
    each2(bodyItem.before, maxLineWidth);
    each2(bodyItem.lines, maxLineWidth);
    each2(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each2(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size2) {
  const { y, height } = size2;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size2) {
  const { x, width } = size2;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size2, yAlign) {
  const { x, width } = size2;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size2)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size2) {
  const yAlign = size2.yAlign || options.yAlign || determineYAlign(chart, size2);
  return {
    xAlign: size2.xAlign || options.xAlign || determineXAlign(chart, options, size2, yAlign),
    yAlign
  };
}
function alignX(size2, xAlign) {
  let { x, width } = size2;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size2, yAlign, paddingAndSize) {
  let { y, height } = size2;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size2, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size2, xAlign);
  const y = alignY(size2, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size2.width),
    y: _limitValue(y, 0, chart.height - size2.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop2,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop2,
  beforeBody: noop2,
  beforeLabel: noop2,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop2,
  afterBody: noop2,
  beforeFooter: noop2,
  footer: noop2,
  afterFooter: noop2
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result2 = callbacks[name].call(ctx, arg);
  if (typeof result2 === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result2;
}
var Tooltip = class extends Element2 {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each2(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i2, len;
    for (i2 = 0, len = active.length; i2 < len; ++i2) {
      tooltipItems.push(createTooltipItem(this.chart, active[i2]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a2, b) => options.itemSort(a2, b, data));
    }
    each2(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size2 = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size2);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size2.width,
        height: size2.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size2, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size2, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size2, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size2;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(title[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i2 + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i2, rtlHelper, options) {
    const labelColor = this.labelColors[i2];
    const labelPointStyle = this.labelPointStyles[i2];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject3(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i2];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i2, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each2(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
      bodyItem = body[i2];
      textColor = this.labelTextColors[i2];
      ctx.fillStyle = textColor;
      each2(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i2, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each2(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each2(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size2 = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size2.width;
        this.height = size2.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e2, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e2);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e2.x,
          y: e2.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e2, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e2) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e2);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first2 = labels.indexOf(raw);
  if (first2 === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last2 = labels.lastIndexOf(raw);
  return first2 !== last2 ? index2 : first2;
}
var validIndex = (index2, max3) => index2 === null ? null : _limitValue(Math.round(index2), 0, max3);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min3, max: max3 } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min3 = 0;
      }
      if (!maxDefined) {
        max3 = this.getLabels().length - 1;
      }
    }
    this.min = min3;
    this.max = max3;
  }
  buildTicks() {
    const min3 = this.min;
    const max3 = this.max;
    const offset2 = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min3 === 0 && max3 === labels.length - 1 ? labels : labels.slice(min3, max3 + 1);
    this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
    this._startValue = this.min - (offset2 ? 0.5 : 0);
    for (let value = min3; value <= max3; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min: min3, max: max3, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min3);
  const maxDefined = !isNullOrUndef(max3);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max3 - min3) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max3 - min3) / spacing, maxTicks));
    spacing = (max3 - min3) / numSpaces;
    niceMin = min3;
    niceMax = max3;
  } else if (countDefined) {
    niceMin = minDefined ? min3 : niceMin;
    niceMax = maxDefined ? max3 : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min3) {
      ticks.push({
        value: min3
      });
      if (niceMin < min3) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min3, relativeLabelSize(min3, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min3) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max3) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max3) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max3, relativeLabelSize(max3, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max3;
    } else {
      ticks.push({
        value: max3
      });
    }
  } else if (!maxDefined || niceMax === max3) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min3, max: max3 } = this;
    const setMin = (v) => min3 = minDefined ? min3 : v;
    const setMax = (v) => max3 = maxDefined ? max3 : v;
    if (beginAtZero) {
      const minSign = sign2(min3);
      const maxSign = sign2(max3);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min3 === max3) {
      let offset2 = max3 === 0 ? 1 : Math.abs(max3 * 0.05);
      setMax(max3 + offset2);
      if (!beginAtZero) {
        setMin(min3 - offset2);
      }
    }
    this.min = min3;
    this.max = max3;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset2;
      end += offset2;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min: min3, max: max3 } = this.getMinMax(true);
    this.min = isNumberFinite(min3) ? min3 : 0;
    this.max = isNumberFinite(max3) ? max3 : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m2) => Math.pow(10, log10Floor(v) + m2);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min3, max3, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min3 / rangeStep);
  const end = Math.ceil(max3 / rangeStep);
  return end - start;
}
function startExp(min3, max3) {
  const range2 = max3 - min3;
  let rangeExp = log10Floor(range2);
  while (steps(min3, max3, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min3, max3, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min3));
}
function generateTicks(generationOptions, { min: min3, max: max3 }) {
  min3 = finiteOrDefault(generationOptions.min, min3);
  const ticks = [];
  const minExp = log10Floor(min3);
  let exp = startExp(min3, max3);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min3 - base) * precision) / precision;
  const offset2 = Math.floor((min3 - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset2) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max3) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min: min3, max: max3 } = this.getMinMax(true);
    this.min = isNumberFinite(min3) ? Math.max(0, min3) : null;
    this.max = isNumberFinite(max3) ? Math.max(0, max3) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min3 === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min3 = this.min;
    let max3 = this.max;
    const setMin = (v) => min3 = minDefined ? min3 : v;
    const setMax = (v) => max3 = maxDefined ? max3 : v;
    if (min3 === max3) {
      if (min3 <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min3, -1));
        setMax(changeExponent(max3, 1));
      }
    }
    if (min3 <= 0) {
      setMin(changeExponent(max3, -1));
    }
    if (max3 <= 0) {
      setMax(changeExponent(min3, 1));
    }
    this.min = min3;
    this.max = max3;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults3.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray2(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size2, min3, max3) {
  if (angle === min3 || angle === max3) {
    return {
      start: pos - size2 / 2,
      end: pos + size2 / 2
    };
  } else if (angle < min3 || angle > max3) {
    return {
      start: pos - size2,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size2
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i2 = 0; i2 < valueCount; i2++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
    padding[i2] = opts.padding;
    const pointPosition = scale.getPointPosition(i2, scale.drawingArea + padding[i2], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
    labelSizes[i2] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size: size2 } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size2.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size2.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size2.w,
    bottom: y + size2.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i2 = 0; i2 < valueCount; i2++) {
    itemOpts.padding = padding[i2];
    itemOpts.size = labelSizes[i2];
    const item = createPointLabelItem(scale, i2, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i2 = labelCount - 1; i2 >= 0; i2--) {
    const item = scale._pointLabelItems[i2];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i2], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i2 = 1; i2 < labelCount; i2++) {
      pointPosition = scale.getPointPosition(i2, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min: min3, max: max3 } = this.getMinMax(false);
    this.min = isNumberFinite(min3) && !isNaN(min3) ? min3 : 0;
    this.max = isNumberFinite(max3) && !isNaN(max3) ? max3 : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i2) => this.chart.getDataVisibility(i2));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i2, offset2, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0) {
          offset2 = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset2, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i2 = labelCount - 1; i2 >= 0; i2--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i2, offset2);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset2, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset2 = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset2, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a2, b) {
  return a2 - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round3, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round3) {
    value = round3 === "week" && (isNumber2(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round3);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min3, max3, capacity) {
  const ilen = UNITS.length;
  for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
    const interval = INTERVALS[UNITS[i2]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max3 - min3) / (factor * interval.size)) <= capacity) {
      return UNITS[i2];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min3, max3) {
  for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
    const unit = UNITS[i2];
    if (INTERVALS[unit].common && scale._adapter.diff(max3, min3, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
    if (INTERVALS[UNITS[i2]].common) {
      return UNITS[i2];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map5, majorUnit) {
  const adapter = scale._adapter;
  const first2 = +adapter.startOf(ticks[0].value, majorUnit);
  const last2 = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first2; major <= last2; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map5[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values2, majorUnit) {
  const ticks = [];
  const map5 = {};
  const ilen = values2.length;
  let i2, value;
  for (i2 = 0; i2 < ilen; ++i2) {
    value = values2[i2];
    map5[value] = i2;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map5, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min: min3, max: max3, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min3 = Math.min(min3, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max3 = Math.max(max3, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min3 = isNumberFinite(min3) && !isNaN(min3) ? min3 : +adapter.startOf(Date.now(), unit);
    max3 = isNumberFinite(max3) && !isNaN(max3) ? max3 : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min3, max3 - 1);
    this.max = Math.max(min3 + 1, max3);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min3 = Number.POSITIVE_INFINITY;
    let max3 = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min3 = arr[0];
      max3 = arr[arr.length - 1];
    }
    return {
      min: min3,
      max: max3
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min3 = this.min;
    const max3 = this.max;
    const ticks = _filterBetween(timestamps, min3, max3);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min3)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first2, last2;
    if (this.options.offset && timestamps.length) {
      first2 = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first2;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first2) / 2;
      }
      last2 = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last2;
      } else {
        end = (last2 - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min3 = this.min;
    const max3 = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min3, max3, this._getLabelCapacity(min3));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber2(weekday) || weekday === true;
    const ticks = {};
    let first2 = min3;
    let time, count;
    if (hasWeekday) {
      first2 = +adapter.startOf(first2, "isoWeek", weekday);
    }
    first2 = +adapter.startOf(first2, hasWeekday ? "day" : minor);
    if (adapter.diff(max3, min3, minor) > 1e5 * stepSize) {
      throw new Error(min3 + " and " + max3 + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first2, count = 0; time < max3; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max3 || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format3) {
    const options = this.options;
    const formats2 = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format3 || formats2[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format3) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats2 = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats2[unit];
    const majorFormat = majorUnit && formats2[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format3 || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      tick.label = this._tickFormatFunction(tick.value, i2, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format3 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format3);
    const size2 = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size2.w : this.height / size2.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
      timestamps.push(parse(this, labels[i2]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values2) {
    return _arrayUnique(values2.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min: min3, max: max3 } = this;
    const items = [];
    const table = [];
    let i2, ilen, prev, curr, next;
    for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
      curr = timestamps[i2];
      if (curr >= min3 && curr <= max3) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min3,
          pos: 0
        },
        {
          time: max3,
          pos: 1
        }
      ];
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      next = items[i2 + 1];
      prev = items[i2 - 1];
      curr = items[i2];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i2 / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min3 = this.min;
    const max3 = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min3) || !timestamps.length) {
      timestamps.splice(0, 0, min3);
    }
    if (!timestamps.includes(max3) || timestamps.length === 1) {
      timestamps.push(max3);
    }
    return timestamps.sort((a2, b) => a2 - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/chart.js/auto/auto.js
Chart.register(...registerables);
var auto_default = Chart;

// node_modules/wcdatavis/src/graph_renderer.js
var import_numeral8 = __toESM(require_numeral());
var GraphRenderer = makeSubclass("GraphRenderer", Object, function(graph, elt2, view, opts) {
  var self2 = this;
  self2.graph = graph;
  self2.elt = elt2;
  self2.view = view;
  self2.opts = opts;
});
GraphRenderer.prototype.toString = function() {
  var self2 = this;
  return '#<GraphRenderer "' + self2.graph.id + '">';
};
GraphRenderer.prototype._validateConfig = function() {
  index_default_default.each(["Plain", "Group", "Pivot"], function(kind) {
    var propName = "when" + kind;
    if (config[propName] == null) {
      return;
    }
    var config = config[propName];
    if (typeof config !== "function" && typeof config !== "object") {
      config[propName] = null;
      return;
    }
  });
};
GraphRenderer.prototype.addRedrawHandlers = function() {
  var self2 = this;
  debug.info("GRAPH // RENDER", "Adding redraw handlers");
  self2.view.off("workEnd", self2);
  self2.view.on("workEnd", function() {
    debug.info(
      "GRAPH RENDERER // HANDLER (View.dataUpdated)",
      "Redrawing graph because the view has finished doing work"
    );
    self2.draw();
  }, { who: self2 });
};

// node_modules/wcdatavis/src/renderers/graph/chartjs.js
var GraphRendererChartJs = makeSubclass("GraphRendererChartJs", GraphRenderer, null, {
  graphTypes: ordmap_default.fromArray([{
    value: "bar",
    name: "Bar Chart",
    modes: ["plain", "group", "pivot"]
  }, {
    value: "column",
    name: "Column Chart",
    modes: ["plain", "group", "pivot"]
  }])
});
GraphRendererChartJs.prototype.draw_plain = function(data, typeInfo, dt, config) {
  var self2 = this;
  if (config == null) {
    return null;
  }
  var convertType = function(t2) {
    switch (t2) {
      case "currency":
        return "number";
      default:
        return t2;
    }
  };
  var getRealValue = function(f2, x) {
    if (typeInfo.get(f2).type === "date" && moment_default.isMoment(x.value)) {
      return { v: x.value.toDate(), f: x.orig };
    } else if (["number", "currency"].indexOf(typeInfo.get(f2).type) >= 0 && import_numeral9.default.isNumeral(x.value)) {
      return { v: x.value._value, f: x.orig };
    } else {
      return x.value;
    }
  };
  switch (config.graphType) {
    case "gantt":
      if (config.nameField == null) {
        throw new Error("Configuration option `nameField` must exist");
      }
      var timeConfigStr = "" + +config.startField + +config.endField + +config.durationField;
      if (timeConfigStr === "100" || timeConfigStr === "010" || timeConfigStr === "000") {
        throw new Error("Time configuration is insufficient to determine offsets");
      }
      dt.addColumn("string", "ID");
      dt.addColumn("string", "Name");
      dt.addColumn("string", "Resource");
      dt.addColumn("date", "Start");
      dt.addColumn("date", "End");
      dt.addColumn("number", "Duration");
      dt.addColumn("number", "Completion");
      dt.addColumn("string", "Dependencies");
      var configOpts = [
        { name: "id", default: function() {
          var x = 0;
          return function() {
            return x++;
          };
        } },
        { name: "name" },
        { name: "resource", default: null },
        { name: "start", default: null },
        { name: "end", default: null },
        { name: "duration", default: null },
        { name: "completion", default: 0 },
        { name: "dependencies", default: null }
      ];
      index_default_default.each(configOpts, function(opt) {
        if (config[opt.name + "Field"] != null) {
          Source.decodeAll(data.dataByRowId, config[opt.name + "Field"]);
        }
      });
      index_default_default.each(data.data, function(row) {
        var newRow = [];
        index_default_default.each(configOpts, function(opt) {
          if (config[opt.name + "Field"] != null) {
            newRow.push(getRealValue(config[opt.name + "Field"], row.rowData[config[opt.name + "Field"]]));
          } else if (opt.default === void 0) {
            throw new Error();
          } else if (typeof opt.default === "function") {
            newRow.push(opt.default());
          } else {
            newRow.push(opt.default);
          }
        });
        dt.addRow(newRow);
      });
      break;
    default:
      dt.addColumn(convertType(typeInfo.get(config.categoryField).type), config.categoryField);
      index_default_default.each(config.valueFields, function(field) {
        dt.addColumn(convertType(typeInfo.get(field).type), field);
      });
      index_default_default.each(config.valueFields, function(field) {
        Source.decodeAll(data.dataByRowId, field);
      });
      index_default_default.each(data.data, function(row) {
        var newRow;
        newRow = index_default_default.map([config.categoryField].concat(config.valueFields), function(f2) {
          return getRealValue(f2, row.rowData[f2]);
        });
        dt.addRow(newRow);
      });
  }
  return config;
};
GraphRendererChartJs.prototype.draw_group = function(data, typeInfo, obj, config) {
  var self2 = this;
  var obj = {
    data: {
      datasets: [],
      labels: []
    }
  };
  if (typeof config === "function") {
    config = config(data.groupFields);
  }
  config = deepDefaults(config, {
    graphType: "bar",
    categoryField: data.groupFields[0],
    valueFields: [{
      name: "Count",
      fun: "count"
    }]
  });
  if (config.aggType != null && config.aggNum != null) {
    obj.data.datasets[0] = {};
    obj.data.datasets[0].label = config.categoryField;
    var aggInfo = getProp(data, "agg", "info", config.aggType, config.aggNum);
    if (aggInfo == null) {
      log.error("The specified aggregate does not exist: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    if (data.agg.results[config.aggType][config.aggNum] == null) {
      log.error("No results exist for the specified aggregate: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    var name = aggInfo.name || aggInfo.instance.getFullName();
    var aggResultType = aggInfo.instance.getType();
    if (aggResultType === "currency") {
      aggResultType = "number";
      setProp("currency", config, "options", valueAxis, "format");
    }
    obj.data.datasets[0].data = [];
    index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
      obj.data.labels.push(rowVal.join(", "));
      var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx];
      if (aggResultType === "number") {
        aggResult = +aggResult;
      }
      obj.data.datasets[0].data.push(aggResult);
    });
  } else {
    var ai = [];
    index_default_default.each(config.valueFields, function(v) {
      var aggInfo2 = new AggregateInfo(
        "group",
        v,
        0,
        null,
        self2.typeInfo,
        null
        /* convert */
      );
      ai.push(aggInfo2);
      obj.data.datasets.push({
        label: (aggInfo2.instance.getType(), v.name || aggInfo2.instance.getFullName()),
        data: []
      });
    });
    index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
      obj.data.labels.push(rowVal.join(", "));
      index_default_default.each(ai, function(aggInfo2, i2) {
        var aggResult = aggInfo2.instance.calculate(index_default_default.flatten(data.data[rowValIdx]));
        obj.data.datasets[i2].data.push(aggResult);
        if (aggInfo2.debug) {
          console.debug(
            "[DataVis Graph // Group // Aggregate] Group aggregate (%s) : Group [%s] = %s",
            aggInfo2.instance.name + (aggInfo2.name ? " -> " + aggInfo2.name : ""),
            rowVal.join(", "),
            JSON.stringify(aggResult)
          );
        }
      });
    });
  }
  return obj;
};
GraphRendererChartJs.prototype.draw_pivot = function(data, typeInfo, dt, config) {
  var self2 = this;
  if (typeof config === "function") {
    config = config(data.groupFields, data.pivotFields);
  }
  config = deepDefaults(config, {
    graphType: "column",
    categoryField: data.groupFields[0],
    valueFields: [{
      fun: "count"
    }],
    options: {
      isStacked: true
    }
  });
  var valueAxis2 = config.graphType === "bar" ? "hAxis" : "vAxis";
  dt.addColumn("string", config.categoryField);
  if (config.aggType != null && config.aggNum != null) {
    var aggInfo = getProp(data, "agg", "info", config.aggType, config.aggNum);
    if (aggInfo == null) {
      log.error("The specified aggregate does not exist: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    if (data.agg.results[config.aggType][config.aggNum] == null) {
      log.error("No results exist for the specified aggregate: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    var name = aggInfo.name || aggInfo.instance.getFullName();
    var aggResultType = aggInfo.instance.getType();
    if (aggResultType === "currency") {
      aggResultType = "number";
      setProp("currency", config, "options", valueAxis2, "format");
    }
    switch (config.aggType) {
      case "cell":
        index_default_default.each(data.colVals, function(colVal) {
          dt.addColumn(aggResultType, colVal.join(", "));
        });
        setProp(name, config, "options", valueAxis2, "title");
        index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
          var newRow = [rowVal.join(", ")];
          index_default_default.each(data.colVals, function(colVal, colValIdx) {
            var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx][colValIdx];
            if (aggResultType === "number") {
              aggResult = +aggResult;
            }
            newRow.push(aggResult);
          });
          dt.addRow(newRow);
        });
        break;
      case "group":
        dt.addColumn(aggResultType, name);
        setProp(name, config, "options", valueAxis2, "title");
        index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
          var newRow = [rowVal.join(", ")];
          var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx];
          if (aggResultType === "number") {
            aggResult = +aggResult;
          }
          newRow.push(aggResult);
          dt.addRow(newRow);
        });
        break;
      case "pivot":
        dt.addColumn(aggResultType, name);
        setProp(name, config, "options", valueAxis2, "title");
        index_default_default.each(data.colVals, function(colVal, colValIdx) {
          var newRow = [colVal.join(", ")];
          var aggResult = data.agg.results[config.aggType][config.aggNum][colValIdx];
          if (aggResultType === "number") {
            aggResult = +aggResult;
          }
          newRow.push(aggResult);
          dt.addRow(newRow);
        });
        break;
    }
  } else {
    var ai = [];
    index_default_default.each(config.valueFields, function(v) {
      var aggInfo2 = new AggregateInfo(
        "cell",
        v,
        0,
        null,
        self2.typeInfo,
        null
        /* convert */
      );
      index_default_default.each(data.colVals, function(colVal) {
        dt.addColumn(aggInfo2.instance.getType(), colVal.join(", "));
      });
      ai.push(aggInfo2);
    });
    index_default_default.each(data.rowVals, function(rowVal, rowValIndex) {
      var newRow = [rowVal.join(", ")];
      index_default_default.each(data.colVals, function(colVal, colValIndex) {
        index_default_default.each(ai, function(aggInfo2) {
          var aggResult = aggInfo2.instance.calculate(data.data[rowValIndex][colValIndex]);
          newRow.push(aggResult);
          if (aggInfo2.debug) {
            console.debug(
              "[DataVis // Graph // Group // Aggregate] Group aggregate (%s) : RowVal [%s] x ColVal [%s] = %s",
              aggInfo2.instance.name + (aggInfo2.name ? " -> " + aggInfo2.name : ""),
              rowVal.join(", "),
              colVal.join(", "),
              JSON.stringify(aggResult)
            );
          }
        });
      });
      dt.addRow(newRow);
    });
  }
  return config;
};
GraphRendererChartJs.prototype.draw = function(devConfig, userConfig) {
  var self2 = this;
  self2.super.addRedrawHandlers();
  devConfig = devConfig || {};
  userConfig = userConfig || {};
  self2.view.getData(function(ok, data) {
    self2.view.getTypeInfo(function(ok2, typeInfo) {
      self2.elt.children().remove();
      var id = gensym();
      self2.elt.append((0, import_jquery9.default)("<canvas>", { id }));
      var makeMessage = function(msg) {
        (0, import_jquery9.default)("<div>").addClass("wcdv_graph_message_container").css({ "height": self2.opts.height + "px" }).append(
          (0, import_jquery9.default)("<div>").addClass("wcdv_graph_message").text(msg)
        ).appendTo(self2.elt);
      };
      if (data.data.length === 0) {
        makeMessage("No Data");
        return;
      }
      var config = null;
      if (data.isPlain) {
        config = self2.draw_plain(data, typeInfo, getProp(userConfig, "plain", "graphs", getProp(userConfig, "plain", "current")) || devConfig.whenPlain);
      } else if (data.isGroup) {
        config = self2.draw_group(data, typeInfo, getProp(userConfig, "group", "graphs", getProp(userConfig, "group", "current")) || devConfig.whenGroup);
      } else if (data.isPivot) {
        config = self2.draw_pivot(data, typeInfo, getProp(userConfig, "pivot", "graphs", getProp(userConfig, "pivot", "current")) || devConfig.whenPivot);
      }
      if (config == null) {
        makeMessage("Nothing to Graph");
        return;
      }
      var graphTypeMap = {
        bar: {
          type: "bar",
          options: {
            indexAxis: "y"
          }
        },
        column: {
          type: "bar"
        }
      };
      var obj = deepDefaults({}, graphTypeMap.bar, config);
      console.debug("[DataVis // Graph // Chartjs // Draw] Starting draw: [%O]", obj);
      var chart = new auto_default(document.getElementById(id), obj);
    });
  }, "Drawing Chart.js graph");
};
var chartjs_default = GraphRendererChartJs;

// node_modules/wcdatavis/src/renderers/graph/google.js
var import_numeral10 = __toESM(require_numeral());
var import_jquery10 = __toESM(require_jquery());
var GraphRendererGoogle = makeSubclass("GraphRendererGoogle", GraphRenderer, null, {
  graphTypes: ordmap_default.fromArray([{
    value: "area",
    name: "Area Chart",
    modes: ["plain"]
  }, {
    value: "line",
    name: "Line Chart",
    modes: ["plain"]
  }, {
    value: "bar",
    name: "Bar Chart",
    modes: ["plain", "group", "pivot"]
  }, {
    value: "column",
    name: "Column Chart",
    modes: ["plain", "group", "pivot"]
  }, {
    value: "pie",
    name: "Pie Chart",
    modes: ["plain", "group", "pivot"]
  }, {
    value: "gantt",
    name: "Gantt Chart",
    modes: ["plain"]
  }])
});
GraphRendererGoogle.prototype.draw_plain = function(data, typeInfo, dt, config) {
  var self2 = this;
  if (config == null) {
    return null;
  }
  var convertType = function(t2) {
    switch (t2) {
      case "currency":
        return "number";
      default:
        return t2;
    }
  };
  var getRealValue = function(f2, x) {
    if (typeInfo.get(f2).type === "date" && moment_default.isMoment(x.value)) {
      return { v: x.value.toDate(), f: x.orig };
    } else if (["number", "currency"].indexOf(typeInfo.get(f2).type) >= 0 && import_numeral10.default.isNumeral(x.value)) {
      return { v: x.value._value, f: x.orig };
    } else {
      return x.value;
    }
  };
  switch (config.graphType) {
    case "gantt":
      if (config.nameField == null) {
        throw new Error("Configuration option `nameField` must exist");
      }
      var timeConfigStr = "" + +config.startField + +config.endField + +config.durationField;
      if (timeConfigStr === "100" || timeConfigStr === "010" || timeConfigStr === "000") {
        throw new Error("Time configuration is insufficient to determine offsets");
      }
      dt.addColumn("string", "ID");
      dt.addColumn("string", "Name");
      dt.addColumn("string", "Resource");
      dt.addColumn("date", "Start");
      dt.addColumn("date", "End");
      dt.addColumn("number", "Duration");
      dt.addColumn("number", "Completion");
      dt.addColumn("string", "Dependencies");
      var configOpts = [
        { name: "id", default: function() {
          var x = 0;
          return function() {
            return x++;
          };
        } },
        { name: "name" },
        { name: "resource", default: null },
        { name: "start", default: null },
        { name: "end", default: null },
        { name: "duration", default: null },
        { name: "completion", default: 0 },
        { name: "dependencies", default: null }
      ];
      index_default_default.each(configOpts, function(opt) {
        if (config[opt.name + "Field"] != null) {
          self2.view.source.convertAll(data.dataByRowId, config[opt.name + "Field"]);
        }
      });
      index_default_default.each(data.data, function(row) {
        var newRow = [];
        index_default_default.each(configOpts, function(opt) {
          if (config[opt.name + "Field"] != null) {
            newRow.push(getRealValue(config[opt.name + "Field"], row.rowData[config[opt.name + "Field"]]));
          } else if (opt.default === void 0) {
            throw new Error();
          } else if (typeof opt.default === "function") {
            newRow.push(opt.default());
          } else {
            newRow.push(opt.default);
          }
        });
        dt.addRow(newRow);
      });
      break;
    default:
      dt.addColumn(convertType(typeInfo.get(config.categoryField).type), config.categoryField);
      index_default_default.each(config.valueFields, function(field) {
        dt.addColumn(convertType(typeInfo.get(field).type), field);
      });
      index_default_default.each(config.valueFields, function(field) {
        self2.view.source.convertAll(data.dataByRowId, field);
      });
      index_default_default.each(data.data, function(row) {
        var newRow;
        newRow = index_default_default.map([config.categoryField].concat(config.valueFields), function(f2) {
          return getRealValue(f2, row.rowData[f2]);
        });
        dt.addRow(newRow);
      });
  }
  return config;
};
GraphRendererGoogle.prototype.draw_group = function(data, typeInfo, dt, config) {
  var self2 = this;
  if (typeof config === "function") {
    config = config(data.groupFields);
  }
  config = deepDefaults(config, {
    graphType: "column",
    categoryField: data.groupFields[0],
    valueFields: [{
      name: "Count",
      fun: "count"
    }]
  });
  var valueAxis2 = config.graphType === "bar" ? "hAxis" : "vAxis";
  dt.addColumn("string", config.categoryField);
  if (config.aggType != null && config.aggNum != null) {
    var aggInfo = getProp(data, "agg", "info", config.aggType, config.aggNum);
    if (aggInfo == null) {
      log.error("The specified aggregate does not exist: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    if (data.agg.results[config.aggType][config.aggNum] == null) {
      log.error("No results exist for the specified aggregate: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    var name = aggInfo.name || aggInfo.instance.getFullName();
    var aggResultType = aggInfo.instance.getType();
    if (aggResultType === "currency") {
      aggResultType = "number";
      setProp("currency", config, "options", valueAxis2, "format");
    }
    dt.addColumn(aggResultType, name);
    setProp(name, config, "options", valueAxis2, "title");
    index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
      var newRow = [rowVal.join(", ")];
      var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx];
      if (aggResultType === "number") {
        aggResult = +aggResult;
      }
      newRow.push(aggResult);
      dt.addRow(newRow);
    });
  } else {
    var ai = [];
    index_default_default.each(config.valueFields, function(v) {
      var aggInfo2 = new AggregateInfo(
        "group",
        v,
        0,
        null,
        self2.typeInfo,
        null
        /* convert */
      );
      dt.addColumn(aggInfo2.instance.getType(), v.name || aggInfo2.instance.getFullName());
      ai.push(aggInfo2);
    });
    index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
      var newRow = [rowVal.join(", ")];
      index_default_default.each(ai, function(aggInfo2) {
        var aggResult = aggInfo2.instance.calculate(index_default_default.flatten(data.data[rowValIdx]));
        newRow.push(aggResult);
        if (aggInfo2.debug) {
          debug.info(
            "GRAPH // GROUP // AGGREGATE",
            "Group aggregate (%s) : Group [%s] = %s",
            aggInfo2.instance.name + (aggInfo2.name ? " -> " + aggInfo2.name : ""),
            rowVal.join(", "),
            JSON.stringify(aggResult)
          );
        }
      });
      dt.addRow(newRow);
    });
  }
  return config;
};
GraphRendererGoogle.prototype.draw_pivot = function(data, typeInfo, dt, config) {
  var self2 = this;
  if (typeof config === "function") {
    config = config(data.groupFields, data.pivotFields);
  }
  config = deepDefaults(config, {
    graphType: "column",
    categoryField: data.groupFields[0],
    valueFields: [{
      fun: "count"
    }],
    options: {
      isStacked: true
    }
  });
  var valueAxis2 = config.graphType === "bar" ? "hAxis" : "vAxis";
  dt.addColumn("string", config.categoryField);
  if (config.aggType != null && config.aggNum != null) {
    var aggInfo = getProp(data, "agg", "info", config.aggType, config.aggNum);
    if (aggInfo == null) {
      log.error("The specified aggregate does not exist: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    if (data.agg.results[config.aggType][config.aggNum] == null) {
      log.error("No results exist for the specified aggregate: " + config.aggType + "[" + config.aggNum + "]");
      return null;
    }
    var name = aggInfo.name || aggInfo.instance.getFullName();
    var aggResultType = aggInfo.instance.getType();
    if (aggResultType === "currency") {
      aggResultType = "number";
      setProp("currency", config, "options", valueAxis2, "format");
    }
    switch (config.aggType) {
      case "cell":
        index_default_default.each(data.colVals, function(colVal) {
          dt.addColumn(aggResultType, colVal.join(", "));
        });
        setProp(name, config, "options", valueAxis2, "title");
        index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
          var newRow = [rowVal.join(", ")];
          index_default_default.each(data.colVals, function(colVal, colValIdx) {
            var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx][colValIdx];
            if (aggResultType === "number") {
              aggResult = +aggResult;
            }
            newRow.push(aggResult);
          });
          dt.addRow(newRow);
        });
        break;
      case "group":
        dt.addColumn(aggResultType, name);
        setProp(name, config, "options", valueAxis2, "title");
        index_default_default.each(data.rowVals, function(rowVal, rowValIdx) {
          var newRow = [rowVal.join(", ")];
          var aggResult = data.agg.results[config.aggType][config.aggNum][rowValIdx];
          if (aggResultType === "number") {
            aggResult = +aggResult;
          }
          newRow.push(aggResult);
          dt.addRow(newRow);
        });
        break;
      case "pivot":
        dt.addColumn(aggResultType, name);
        setProp(name, config, "options", valueAxis2, "title");
        index_default_default.each(data.colVals, function(colVal, colValIdx) {
          var newRow = [colVal.join(", ")];
          var aggResult = data.agg.results[config.aggType][config.aggNum][colValIdx];
          if (aggResultType === "number") {
            aggResult = +aggResult;
          }
          newRow.push(aggResult);
          dt.addRow(newRow);
        });
        break;
    }
  } else {
    var ai = [];
    index_default_default.each(config.valueFields, function(v) {
      var aggInfo2 = new AggregateInfo(
        "cell",
        v,
        0,
        null,
        self2.typeInfo,
        null
        /* convert */
      );
      index_default_default.each(data.colVals, function(colVal) {
        dt.addColumn(aggInfo2.instance.getType(), colVal.join(", "));
      });
      ai.push(aggInfo2);
    });
    index_default_default.each(data.rowVals, function(rowVal, rowValIndex) {
      var newRow = [rowVal.join(", ")];
      index_default_default.each(data.colVals, function(colVal, colValIndex) {
        index_default_default.each(ai, function(aggInfo2) {
          var aggResult = aggInfo2.instance.calculate(data.data[rowValIndex][colValIndex]);
          newRow.push(aggResult);
          if (aggInfo2.debug) {
            debug.info(
              "GRAPH // GROUP // AGGREGATE",
              "Group aggregate (%s) : RowVal [%s] x ColVal [%s] = %s",
              aggInfo2.instance.name + (aggInfo2.name ? " -> " + aggInfo2.name : ""),
              rowVal.join(", "),
              colVal.join(", "),
              JSON.stringify(aggResult)
            );
          }
        });
      });
      dt.addRow(newRow);
    });
  }
  return config;
};
GraphRendererGoogle.prototype._ensureGoogleChartsLoaded = function(cont) {
  return loadScript("https://www.gstatic.com/charts/loader.js", function(wasAlreadyLoaded, k) {
    var cb2 = function() {
      k();
      cont();
    };
    if (!wasAlreadyLoaded) {
      debug.info("GRAPH // GOOGLE // DRAW", "Loading support for Google Charts");
      window.google.charts.load("current", { "packages": ["corechart", "gantt"] });
      window.google.charts.setOnLoadCallback(cb2);
    } else {
      cb2();
    }
  }, {
    needAsyncSetup: true
  });
};
GraphRendererGoogle.prototype.draw = function(devConfig, userConfig) {
  var self2 = this;
  self2.super.addRedrawHandlers();
  devConfig = devConfig || {};
  userConfig = userConfig || {};
  self2._ensureGoogleChartsLoaded(function() {
    self2.view.getData(function(ok, data) {
      self2.view.getTypeInfo(function(ok2, typeInfo) {
        self2.elt.children().remove();
        var makeMessage = function(msg) {
          (0, import_jquery10.default)("<div>").addClass("wcdv_graph_message_container").css({ "height": self2.opts.height + "px" }).append(
            (0, import_jquery10.default)("<div>").addClass("wcdv_graph_message").text(msg)
          ).appendTo(self2.elt);
        };
        if (data.data.length === 0) {
          makeMessage("No Data");
          return;
        }
        var config = null;
        var dt = new google.visualization.DataTable();
        if (data.isPlain) {
          config = self2.draw_plain(data, typeInfo, dt, getProp(userConfig, "plain", "graphs", getProp(userConfig, "plain", "current")) || devConfig.whenPlain);
        } else if (data.isGroup) {
          config = self2.draw_group(data, typeInfo, dt, getProp(userConfig, "group", "graphs", getProp(userConfig, "group", "current")) || devConfig.whenGroup);
        } else if (data.isPivot) {
          config = self2.draw_pivot(data, typeInfo, dt, getProp(userConfig, "pivot", "graphs", getProp(userConfig, "pivot", "current")) || devConfig.whenPivot);
        }
        if (config == null) {
          makeMessage("Nothing to Graph");
          return;
        }
        var ctor2 = {
          area: "AreaChart",
          bar: "BarChart",
          column: "ColumnChart",
          line: "LineChart",
          pie: "PieChart",
          gantt: "Gantt"
        };
        var options = {
          title: self2.opts.title,
          width: self2.opts.width,
          height: self2.opts.height,
          isStacked: config.stacked
        };
        var categoryAxis = config.graphType === "bar" ? "vAxis" : "hAxis";
        if (config.graphType === "pie") {
          options.chartArea = {
            top: "5%",
            left: "5%",
            width: "90%",
            height: "90%"
          };
        }
        setProp(config.categoryField, options, categoryAxis, "title");
        import_jquery10.default.extend(true, options, config.options);
        var chart = new google.visualization[ctor2[config.graphType]](self2.elt.get(0));
        google.visualization.events.addListener(chart, "ready", function() {
          var blob = null;
          if (typeof chart.getImageURI === "function") {
            blob = dataURItoBlob(chart.getImageURI());
          }
          self2.graph._setExportBlob(blob);
        });
        google.visualization.events.addListener(chart, "select", function() {
          var sel = chart.getSelection();
          index_default_default.each(sel, function(o2) {
            debug.info("GRAPH // DRILL DOWN", "User selected element in graph: row = %s, column = %s, value = %s, formattedValue = %s", o2.row, o2.column, dt.getValue(o2.row, o2.column), dt.getFormattedValue(o2.row, o2.column));
            var filter2 = deepCopy(self2.view.getFilter());
            index_default_default.each(data.rowVals[o2.row], function(x, i2) {
              var gs = data.groupSpec[i2];
              filter2[data.groupFields[i2]] = gs.fun != null ? GROUP_FUNCTION_REGISTRY.get(gs.fun).valueToFilter(x) : { "$eq": x };
            });
            if (data.isPivot) {
              index_default_default.each(data.colVals[o2.column - 1], function(x, i2) {
                var ps = data.pivotSpec[i2];
                filter2[data.pivotFields[i2]] = ps.fun != null ? GROUP_FUNCTION_REGISTRY.get(ps.fun).valueToFilter(x) : { "$eq": x };
              });
            }
            debug.info(
              "GRAPH // DRILL DOWN",
              "Creating new perspective: filter = %O",
              filter2
            );
            window.setTimeout(function() {
              self2.view.prefs.addPerspective(null, "Drill Down", { view: { filter: filter2 } }, { isTemporary: true }, null, { onDuplicate: "replace" });
            });
          });
        });
        debug.info("GRAPH // GOOGLE // DRAW", "Starting draw: [config = %O ; options = %O]", config, options);
        chart.draw(dt, options);
      });
    }, "Drawing Google graph");
  });
};
var google_default = GraphRendererGoogle;

// node_modules/wcdatavis/src/renderers/graph/jit.js
var import_numeral11 = __toESM(require_numeral());
var import_jquery11 = __toESM(require_jquery());
var GraphRendererJit = makeSubclass("GraphRendererJit", GraphRenderer);
GraphRendererJit.prototype.draw = function() {
  var self2 = this;
  elt.children().remove();
  self2.view.getData(function(ok, data) {
    self2.view.getTypeInfo(function() {
      var ctor2 = {
        area: "AreaChart",
        bar: "BarChart",
        line: "LineChart"
      };
      var json = {
        label: [],
        values: []
      };
      index_default_default.each(self2.opts.valueFields, function(f2) {
        json.label.push(f2);
      });
      index_default_default.each(data.data, function(row) {
        var newRow = {};
        newRow.label = row.rowData[self2.opts.categoryField].value;
        newRow.values = index_default_default.map(self2.opts.valueFields, function(f2) {
          return row.rowData[f2].value;
        });
        json.values.push(newRow);
      });
      var options = {
        injectInto: elt.attr("id")
      };
      import_jquery11.default.extend(true, options, self2.opts.options);
      var chart = new $jit[ctor2[self2.opts.type]](options);
      chart.loadJSON(json);
    });
  }, "Drawing JIT graph");
};
var jit_default = GraphRendererJit;

// node_modules/wcdatavis/src/reg/graph_renderer.js
var GRAPH_RENDERER_REGISTRY = new ordmap_default();
GRAPH_RENDERER_REGISTRY.set("chartjs", chartjs_default);
GRAPH_RENDERER_REGISTRY.set("google", google_default);
GRAPH_RENDERER_REGISTRY.set("jit", jit_default);
var graph_renderer_default = GRAPH_RENDERER_REGISTRY;

// node_modules/wcdatavis/src/graph.js
var Graph = makeSubclass("Graph", Object, function(id, view, devConfig, opts) {
  var self2 = this;
  self2.id = id;
  self2.view = view;
  self2.devConfig = devConfig || {};
  self2.userConfig = {
    plain: {},
    group: {},
    pivot: {}
  };
  self2.opts = deepDefaults(opts, {
    title: "Graph",
    runImmediately: true,
    showToolbar: true,
    showOnDataChange: false
  });
  self2.hasRun = false;
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (!(view instanceof ComputedView)) {
    throw new Error("Call Error: `view` must be an instance of MIE.WC_DataVis.ComputedView");
  }
  if (self2.opts.prefs != null && !(self2.opts.prefs instanceof Prefs)) {
    throw new Error("Call Error: `opts.prefs` must be an instance of MIE.WC_DataVis.Prefs");
  }
  if (self2.opts.prefs != null) {
    self2.prefs = self2.opts.prefs;
  } else if (self2.view.prefs != null) {
    self2.prefs = self2.view.prefs;
  } else {
    self2.prefs = new Prefs(self2.id);
  }
  self2.prefs.bind("graph", self2);
  self2._makeUserInterface();
  self2.view.addClient(self2, "graph");
  self2.view.on("fetchDataBegin", function() {
    self2._setSpinner("loading");
    self2._showSpinner();
  });
  self2.view.on("fetchDataEnd", function() {
    self2._hideSpinner();
  });
  self2.view.on("workBegin", function() {
    self2._setSpinner("working");
    self2._showSpinner();
  });
  self2.view.on("workEnd", function() {
    self2._hideSpinner();
  });
  self2.view.on("workEnd", function(info, ops) {
    var config;
    if (ops.pivot) {
      config = getProp(self2.userConfig, "pivot", "graphs", getProp(self2.userConfig, "pivot", "current")) || self2.devConfig.whenPivot;
    } else if (ops.group) {
      config = getProp(self2.userConfig, "group", "graphs", getProp(self2.userConfig, "group", "current")) || self2.devConfig.whenGroup;
    } else {
      config = getProp(self2.userConfig, "plain", "graphs", getProp(self2.userConfig, "plain", "current")) || self2.devConfig.whenPlain;
    }
    if (config != null) {
      console.debug("[DataVis // Graph // Handler(ComputedView.workEnd)] Matching configuration: %O", config);
      var graphType = config.graphType;
      var axis = graphType === "bar" ? "hAxis" : "vAxis";
      self2.ui.graphTypeDropdown.val(config.graphType);
    }
    if (ops.group) {
      self2.ui.toolbar_aggregates.show();
      if (config != null) {
        self2.ui.aggDropdown.val(config.aggNum);
        self2.ui.zeroAxisCheckbox.prop("checked", getProp(config, "options", axis, "minValue") == 0);
      }
    } else {
      self2.ui.toolbar_aggregates.hide();
    }
    if (ops.pivot) {
      self2.ui.toolbar_pivot.show();
      if (config != null) {
        self2.ui.stackCheckbox.prop("checked", !!getProp(config, "options", "isStacked"));
      }
    } else {
      self2.ui.toolbar_pivot.hide();
    }
  }, {
    who: self2
  });
  self2.view.on("dataUpdated", function() {
    if (self2.opts.showOnDataChange && !self2.isVisible()) {
      self2.show({ redraw: false });
    }
    self2.redraw();
  });
  if (self2.opts.runImmediately) {
    self2.show();
  } else {
    self2.hasRun = false;
    self2.hide();
  }
});
Graph.prototype.toString = function() {
  return 'Graph(id="' + this.id + '")';
};
Graph.prototype._makeUserInterface = function() {
  var self2 = this;
  self2.ui = {};
  self2.ui.root = jQuery(document.getElementById(self2.id));
  self2.ui.root.addClass("wcdv_graph");
  self2.ui.root.children().remove();
  self2.ui.titlebar = jQuery("<div>").addClass("wcdv_grid_titlebar").on("click", function(evt) {
    evt.stopPropagation();
    self2.toggle();
  }).appendTo(self2.ui.root);
  self2._addTitleWidgets(self2.ui.titlebar);
  self2.ui.content = jQuery("<div>", {
    "class": "wcdv_grid_content"
  }).appendTo(self2.ui.root);
  self2.ui.toolbar = jQuery("<div>").addClass("wcdv_grid_toolbar").appendTo(self2.ui.content);
  if (!self2.opts.showToolbar) {
    self2.ui.toolbar.hide();
  }
  self2.ui.toolbar_pivot = jQuery("<div>").addClass("wcdv_toolbar_section").hide().appendTo(self2.ui.toolbar);
  self2._addPivotButtons(self2.ui.toolbar_pivot);
  self2.ui.toolbar_aggregates = jQuery("<div>").addClass("wcdv_toolbar_section pull-right").hide().appendTo(self2.ui.toolbar);
  self2._addAggregateButtons(self2.ui.toolbar_aggregates);
  self2.ui.graph = jQuery("<div>", { "id": self2.id, "class": "wcdv_graph_render" });
  self2.ui.root.append(self2.ui.titlebar).append(self2.ui.content.append(self2.ui.toolbar).append(self2.ui.graph));
};
Graph.prototype._addTitleWidgets = function(titlebar) {
  var self2 = this;
  self2.ui.spinner = jQuery("<span>", {
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_spinner"
  }).appendTo(titlebar);
  self2._setSpinner(self2.opts.runImmediately ? "loading" : "not-loaded");
  jQuery("<strong>").text(self2.opts.title).appendTo(titlebar);
  self2.ui.titlebar_controls = jQuery("<div>").addClass("wcdv_titlebar_controls pull-right").appendTo(titlebar);
  self2.ui.exportBtn = jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary"
  }).on("click", function(evt) {
    evt.stopPropagation();
    self2.export();
  }).append(fontAwesome("f019")).appendTo(self2.ui.titlebar_controls);
  self2.ui.refreshBtn = jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary"
  }).attr("title", "Refresh").on("click", function(evt) {
    evt.stopPropagation();
    self2.refresh();
  }).append(fontAwesome("f021")).appendTo(self2.ui.titlebar_controls);
  jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary"
  }).attr("title", trans("GRAPH.TITLEBAR.SHOW_HIDE_CONTROLS")).click(function(evt) {
    evt.stopPropagation();
    self2.ui.toolbar.toggle();
  }).append(jQuery(fontAwesome("fa-cog"))).appendTo(self2.ui.titlebar_controls);
  self2.ui.showHideButton = jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary showhide"
  }).attr("title", trans("GRAPH.TITLEBAR.SHOW_HIDE")).click(function(evt) {
    evt.stopPropagation();
    self2.toggle();
  }).append(jQuery(fontAwesome("f078"))).appendTo(self2.ui.titlebar_controls);
};
Graph.prototype._addAggregateButtons = function(toolbar) {
  var self2 = this;
  var graphTypeDropdownId = gensym();
  jQuery("<label>", { "for": graphTypeDropdownId }).text("Graph Type: ").appendTo(toolbar);
  self2.ui.graphTypeDropdown = jQuery("<select>", { "id": graphTypeDropdownId }).on("change", function() {
    self2.drawInteractive();
  }).appendTo(toolbar);
  if (getProp(self2.renderer, "prototype", "graphTypes")) {
    self2.renderer.prototype.graphTypes.each(function(gt) {
      self2.ui.graphTypeDropdown.append(jQuery("<option>", { "value": gt.value }).text(gt.name));
    });
  }
  var aggDropdownId = gensym();
  jQuery("<label>", { "for": aggDropdownId }).text("Aggregate: ").appendTo(toolbar);
  self2.ui.aggDropdown = jQuery("<select>", { "id": aggDropdownId }).on("change", function() {
    self2.drawInteractive();
  }).appendTo(toolbar);
  self2.ui.zeroAxisCheckbox = makeToggleCheckbox(
    null,
    null,
    false,
    "Y-Axis Starts at Zero",
    toolbar,
    function() {
      self2.drawInteractive();
    }
  );
  self2.view.on("workEnd", function() {
    self2._updateAggDropdown();
  });
};
Graph.prototype._addPivotButtons = function(toolbar) {
  var self2 = this;
  self2.ui.stackCheckbox = makeToggleCheckbox(
    null,
    null,
    true,
    "Stack",
    toolbar,
    function() {
      self2.drawInteractive();
    }
  );
};
Graph.prototype._updateAggDropdown = function() {
  var self2 = this;
  var options = [];
  var addOption = function(aggInfo, appendToName) {
    var name = aggInfo.name || aggInfo.instance.getFullName();
    if (appendToName != null) {
      name += appendToName;
    }
    options.push({
      name,
      type: aggInfo.aggType,
      num: aggInfo.aggNum
    });
  };
  self2.view.getData(function(ok, data) {
    self2.ui.aggDropdown.children().remove();
    if (data.isGroup) {
      index_default_default.each(getPropDef([], data, "agg", "info", "group"), function(ai) {
        addOption(ai);
      });
    } else if (data.isPivot) {
      index_default_default.each(getPropDef([], data, "agg", "info", "group"), function(ai) {
        addOption(ai, " by " + data.groupFields.join(", "));
      });
      index_default_default.each(getPropDef([], data, "agg", "info", "pivot"), function(ai) {
        addOption(ai, " by " + data.pivotFields.join(", "));
      });
      index_default_default.each(getPropDef([], data, "agg", "info", "cell"), function(ai) {
        addOption(ai);
      });
    }
    index_default_default.each(index_default_default.sortBy(index_default_default.sortBy(options, "type"), "num"), function(opt) {
      var option = jQuery("<option>", {
        "value": opt.name,
        "data-wcdv-agg-type": opt.type,
        "data-wcdv-agg-num": opt.num
      }).text(opt.name);
      self2.ui.aggDropdown.append(option);
    });
  }, "Updating graph aggregate dropdown");
};
Graph.prototype.export = function() {
  var self2 = this;
  if (self2.exportBlob == null) {
    return;
  }
  var fileName = (self2.opts.title || self2.id) + ".png";
  presentDownload(self2.exportBlob, fileName);
};
Graph.prototype._setExportBlob = function(blob) {
  var self2 = this;
  self2.exportBlob = blob;
  self2.ui.exportBtn.prop("disabled", blob == null);
};
Graph.prototype._clearExportBlob = function() {
  var self2 = this;
  self2.exportBlob = null;
  self2.ui.exportBtn.prop("disabled", true);
};
Graph.prototype.drawFromConfig = function() {
  var self2 = this;
  self2.lastDrawnFrom = "config";
  self2.renderer.draw(self2.devConfig, self2.userConfig);
};
Graph.prototype.drawInteractive = function() {
  var self2 = this;
  var graphType = self2.ui.graphTypeDropdown.val();
  var minValue = self2.ui.zeroAxisCheckbox.prop("checked") ? 0 : null;
  var config = {
    group: {
      graphs: {},
      current: graphType
    },
    pivot: {
      graphs: {},
      current: graphType
    }
  };
  var selOptIdx = self2.ui.aggDropdown.get(0).selectedIndex;
  var selOpt = self2.ui.aggDropdown.get(0).options[selOptIdx];
  config.group.graphs[graphType] = {
    graphType,
    aggType: selOpt.getAttribute("data-wcdv-agg-type"),
    aggNum: toInt2(selOpt.getAttribute("data-wcdv-agg-num")),
    options: {}
  };
  switch (graphType) {
    case "bar":
      config.group.graphs[graphType].options = {
        vAxis: {
          minValue
        }
      };
      break;
    default:
      config.group.graphs[graphType].options = {
        vAxis: {
          minValue
        }
      };
  }
  config.pivot = deepCopy(config.group);
  config.pivot.graphs[graphType].options.isStacked = self2.ui.stackCheckbox.prop("checked");
  index_default_default.extend(self2.userConfig, config);
  if (self2.prefs != null) {
    self2.prefs.save();
  }
  console.debug("[DataVis // Graph] Drawing graph based on interactive config [userConfig = %O]", self2.userConfig);
  self2.lastDrawnFrom = "interactive";
  self2.renderer.draw(self2.devConfig, self2.userConfig);
};
Graph.prototype.checkGraphConfig = function() {
  if (self.devConfig == null) {
    return;
  }
  index_default_default.each(["whenPlain", "whenGroup", "whenPivot"], function(dataFormat) {
    if (self.devConfig[dataFormat] === void 0) {
      return;
    }
    var config = self.devConfig[dataFormat];
    if (config.graphType != null) {
      if (!index_default_default.isString(config.graphType)) {
        throw new Error('Graph config error: data format "' + dataFormat + '": `graphType` must be a string');
      }
      if (["area", "bar", "column", "line", "pie"].indexOf(config.graphType) === -1) {
        throw new Error('Graph config error: data format "' + dataFormat + '": invalid `graphType`: ' + config.graphType);
      }
    }
    switch (config.graphType) {
      case "area":
      case "bar":
      case "column":
      case "line":
      case "pie":
        if (config.valueField != null && config.valueFields != null) {
          throw new Error('Graph config error: data format "' + dataFormat + "\": can't define both `valueField` and `valueFields`");
        }
        if (config.valueField != null) {
          if (!index_default_default.isString(config.valueField)) {
            throw new Error('Graph config error: data format "' + dataFormat + '": `valueField` must be a string');
          }
          config.valueFields = [config.valueField];
          delete config.valueField;
        }
        if (config.valueFields != null) {
          if (!index_default_default.isArray(config.valueFields)) {
            throw new Error('Graph config error: data format "' + dataFormat + '": `valueFields` must be an array');
          }
          index_default_default.each(config.valueFields, function(f2, i2) {
            if (!index_default_default.isString(f2)) {
              throw new Error('Graph config error: data format "' + dataFormat + '": `valueFields[' + i2 + "]` must be a string");
            }
          });
        }
    }
  });
};
Graph.prototype.refresh = function() {
  var self2 = this;
  self2.view.clearSourceData();
};
Graph.prototype.redraw = function() {
  var self2 = this;
  self2.prefs.prime(function() {
    self2.checkGraphConfig();
    var ctor2 = getProp(self2.opts, "renderer") && graph_renderer_default.isSet(self2.opts.renderer) ? graph_renderer_default.get(self2.opts.renderer) : graph_renderer_default.get("google");
    self2.renderer = new ctor2(self2, self2.ui.graph, self2.view, self2.opts);
    self2.drawFromConfig();
  }, {
    who: self2
  });
};
Graph.prototype.hide = function() {
  var self2 = this;
  self2.ui.content.hide({
    duration: 0,
    done: function() {
      if (self2.opts.title) {
        self2.ui.showHideButton.removeClass("open fa-rotate-180");
      }
    }
  });
};
Graph.prototype.show = function(opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    redraw: true
  });
  self2.ui.content.show({
    duration: 0,
    done: function() {
      if (self2.opts.title) {
        self2.ui.showHideButton.addClass("open fa-rotate-180");
      }
      if (!self2.hasRun && opts.redraw) {
        self2.hasRun = true;
        self2.redraw();
      }
    }
  });
};
Graph.prototype.toggle = function() {
  var self2 = this;
  if (self2.ui.content.css("display") === "none") {
    self2.show();
  } else {
    self2.hide();
  }
};
Graph.prototype.isVisible = function() {
  var self2 = this;
  return self2.ui.content.css("display") !== "none";
};
Graph.prototype._setSpinner = function(what) {
  var self2 = this;
  switch (what) {
    case "loading":
      self2.ui.spinner.html(fontAwesome("F021", "fa-spin", "Loading..."));
      break;
    case "not-loaded":
      self2.ui.spinner.html(fontAwesome("F05E", null, "Not Loaded"));
      break;
    case "working":
      self2.ui.spinner.html(fontAwesome("F1CE", "fa-spin", "Working..."));
      break;
  }
};
Graph.prototype._showSpinner = function() {
  var self2 = this;
  self2.ui.spinner.show();
};
Graph.prototype._hideSpinner = function() {
  var self2 = this;
  self2.ui.spinner.hide();
};
Graph.prototype.setUserConfig = function(config) {
  var self2 = this;
  self2.userConfig = config;
  if (self2.renderer != null) {
    self2.renderer.draw(self2.devConfig, self2.userConfig);
  }
};
var GraphControl = makeSubclass("GraphControl", Object, function() {
  var self2 = this;
  self2.ui = {};
});
GraphControl.prototype.draw = function() {
  var self2 = this;
  self2.view.on("getTypeInfo", function(typeInfo) {
    var fields = [];
    index_default_default.each(determineColumns(null, null, typeInfo), function(fieldName) {
      var text = getProp(self2.colConfig, fieldName, "displayText") || fieldName;
      fields.push({ fieldName, displayText: text });
    });
    self2.ui.graphType = jQuery("<select>");
    if (getProp(self2.renderer, "prototype", "graphTypes")) {
      self2.renderer.prototype.graphTypes.each(function(gt) {
        self2.ui.graphType.append(jQuery("<option>", { "value": gt.value }).text(gt.name));
      });
    }
    self2.ui.root.append(jQuery("<div>").append(self2.ui.graphType));
    self2.ui.plainCheckbox = jQuery("<input>", { "type": "checkbox", "checked": "checked" }).on("change", function() {
      if (self2.ui.plainCheckbox.prop("checked")) {
        self2.ui.plainConfig.show();
      } else {
        self2.ui.plainConfig.hide();
      }
    });
    self2.ui.root.append(
      jQuery("<span>", { "class": "wcdv_title" }).append(self2.ui.plainCheckbox).append("Plain Data")
    );
    self2.ui.plainCategoryField = jQuery("<select>").on("change", function() {
      self2.defn.whenPlain.categoryField = self2.ui.plainCategoryField.val();
    });
    self2.ui.plainValueField = jQuery("<select>").on("change", function() {
      self2.defn.whenPlain.valueField = self2.ui.plainValueField.val();
    });
    index_default_default.each(fields, function(f2) {
      self2.ui.plainCategoryField.append(
        jQuery("<option>", { "value": f2.fieldName }).text(f2.displayText)
      );
      self2.ui.plainValueField.append(
        jQuery("<option>", { "value": f2.fieldName }).text(f2.displayText)
      );
    });
    self2.ui.plainConfig = jQuery("<div>").append(
      jQuery("<div>").append("Category Field: ").append(self2.ui.plainCategoryField)
    ).append(
      jQuery("<div>").append("Value Field: ").append(self2.ui.plainValueField)
    ).appendTo(self2.ui.root);
  }, { limit: 1 });
};

// node_modules/wcdatavis/src/perspective.js
var import_sprintf_js6 = __toESM(require_sprintf());
var import_numeral13 = __toESM(require_numeral());

// node_modules/wcdatavis/src/prefs_module.js
var import_sprintf_js5 = __toESM(require_sprintf());
var import_numeral12 = __toESM(require_numeral());
var PrefsModule = makeSubclass("PrefsModule", Object, function(prefs, target) {
  var self2 = this;
  self2.prefs = prefs;
  self2.target = target;
});
PrefsModule.prototype.load = function(config) {
  throw new Error("Abstract method load() not implemented by subclass " + this.constructor.name);
};
PrefsModule.prototype.save = function() {
  throw new Error("Abstract method save() not implemented by subclass " + this.constructor.name);
};
var PrefsModuleComputedView = makeSubclass("PrefsModuleComputedView", PrefsModule, function() {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  self2.super.ctor.apply(self2, args);
  if (!(self2.target instanceof ComputedView)) {
    throw new Error("Call Error: `target` must be an instance of ComputedView");
  }
}, {
  defaultConfig: {}
});
PrefsModuleComputedView.prototype.load = function(config) {
  var self2 = this;
  if (config.filter != null) {
    self2.target.setFilter(config.filter, null, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.group != null) {
    self2.target.setGroup(config.group, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.pivot != null) {
    self2.target.setPivot(config.pivot, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.aggregate != null) {
    self2.target.setAggregate(config.aggregate, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.sort != null) {
    self2.target.setSort(config.sort, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.sort == null) {
    self2.target.clearSort({
      updateData: false,
      savePrefs: false
    });
  }
  if (config.aggregate == null) {
    self2.target.clearAggregate({
      updateData: false,
      savePrefs: false
    });
  }
  if (config.pivot == null) {
    self2.target.clearPivot({
      updateData: false,
      savePrefs: false
    });
  }
  if (config.group == null) {
    self2.target.clearGroup({
      updateData: false,
      savePrefs: false
    });
  }
  if (config.filter == null) {
    self2.target.clearFilter({
      updateData: false,
      savePrefs: false
    });
  }
};
PrefsModuleComputedView.prototype.save = function() {
  var self2 = this;
  var prefs = {};
  var sortSpec = self2.target.getSort();
  if (sortSpec) {
    prefs.sort = sortSpec;
  }
  var filterSpec = self2.target.getFilter();
  if (filterSpec) {
    prefs.filter = deepCopy(filterSpec);
    walkObj(prefs.filter, function(x) {
      if (window.numeral && import_numeral12.default.isNumeral(x)) {
        return x._value;
      } else {
        return x;
      }
    }, {
      callOnNodes: true,
      replace: true
    });
  }
  var groupSpec = self2.target.getGroup();
  if (groupSpec) {
    prefs.group = groupSpec;
  }
  var pivotSpec = self2.target.getPivot();
  if (pivotSpec) {
    prefs.pivot = pivotSpec;
  }
  var aggregateSpec = self2.target.getAggregate();
  if (aggregateSpec) {
    prefs.aggregate = aggregateSpec;
  }
  return prefs;
};
PrefsModuleComputedView.prototype.reset = function() {
  var self2 = this;
  self2.target.reset({
    updateData: false,
    savePrefs: false
  });
};
var PrefsModuleMirageView = makeSubclass("PrefsModuleMirageView", PrefsModule, function() {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  self2.super.ctor.apply(self2, args);
  if (!(self2.target instanceof MirageView)) {
    throw new Error("Call Error: `target` must be an instance of MirageView");
  }
}, {
  defaultConfig: {}
});
PrefsModuleMirageView.prototype.load = function(config) {
  var self2 = this;
  if (config.filter == null) {
    self2.target.clearFilter({
      updateData: false,
      savePrefs: false
    });
  } else {
    self2.target.setFilter(config.filter, null, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.sort == null) {
    self2.target.clearSort({
      updateData: false,
      savePrefs: false
    });
  } else {
    self2.target.setSort(config.sort, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.group == null) {
    self2.target.clearGroup({
      updateData: false,
      savePrefs: false
    });
  } else {
    self2.target.setGroup(config.group, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.pivot == null) {
    self2.target.clearPivot({
      updateData: false,
      savePrefs: false
    });
  } else {
    self2.target.setPivot(config.pivot, {
      updateData: false,
      savePrefs: false
    });
  }
  if (config.aggregate == null) {
    self2.target.clearAggregate({
      updateData: false,
      savePrefs: false
    });
  } else {
    self2.target.setAggregate(config.aggregate, {
      updateData: false,
      savePrefs: false
    });
  }
  self2.target.initFromPrefs(self2.prefs);
};
PrefsModuleMirageView.prototype.save = function() {
  var self2 = this;
  var prefs = {};
  var sortSpec = self2.target.getSort();
  if (sortSpec) {
    prefs.sort = sortSpec;
  }
  var filterSpec = self2.target.getFilter();
  if (filterSpec) {
    prefs.filter = deepCopy(filterSpec);
    walkObj(prefs.filter, function(x) {
      if (window.numeral && import_numeral12.default.isNumeral(x)) {
        return x._value;
      } else {
        return x;
      }
    }, {
      callOnNodes: true,
      replace: true
    });
  }
  var groupSpec = self2.target.getGroup();
  if (groupSpec) {
    prefs.group = groupSpec;
  }
  var pivotSpec = self2.target.getPivot();
  if (pivotSpec) {
    prefs.pivot = pivotSpec;
  }
  var aggregateSpec = self2.target.getAggregate();
  if (aggregateSpec) {
    prefs.aggregate = aggregateSpec;
  }
  return prefs;
};
PrefsModuleMirageView.prototype.reset = function() {
  var self2 = this;
  self2.target.reset({
    updateData: false,
    savePrefs: false
  });
};
var PrefsModuleGrid = makeSubclass("PrefsModuleGrid", PrefsModule, function() {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  self2.super.ctor.apply(self2, args);
  if (!(self2.target instanceof Grid)) {
    throw new Error("Call Error: `target` must be an instance of Grid");
  }
});
PrefsModuleGrid.prototype.load = function(config) {
  var self2 = this;
  if (config == null) {
    return;
  }
  if (config.colConfig != null) {
    self2.target.setColConfig(ordmap_default.deserialize(config.colConfig), {
      from: "prefs",
      redraw: false,
      savePrefs: false
    });
  }
};
PrefsModuleGrid.prototype.save = function() {
  var self2 = this;
  var prefs = {};
  var colConfig = self2.target.getColConfig();
  if (colConfig != null) {
    prefs.colConfig = colConfig.serialize();
  }
  return prefs;
};
PrefsModuleGrid.prototype.reset = function() {
  var self2 = this;
  self2.target.resetColConfig();
};
var PrefsModuleGraph = makeSubclass("PrefsModuleGraph", PrefsModule, function() {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  self2.super.ctor.apply(self2, args);
  if (!(self2.target instanceof Graph)) {
    throw new Error("Call Error: `target` must be an instance of Graph");
  }
});
PrefsModuleGraph.prototype.load = function(config) {
  var self2 = this;
  if (config == null) {
    return;
  }
  self2.target.setUserConfig(config);
};
PrefsModuleGraph.prototype.save = function() {
  var self2 = this;
  var prefs = deepDefaults(self2.target.userConfig, {
    plain: {},
    group: {},
    pivot: {}
  });
  return prefs;
};
PrefsModuleGraph.prototype.reset = function() {
  var self2 = this;
};
var PrefsModuleMeta = makeSubclass("PrefsModuleMeta", PrefsModule, function() {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  self2.super.ctor.apply(self2, args);
  if (!(self2.target instanceof Perspective)) {
    throw new Error("Call Error: `target` must be an instance of Perspective");
  }
});
PrefsModuleMeta.prototype.load = function(config) {
  var self2 = this;
  if (config != null) {
    self2.target.meta = config;
  }
};
PrefsModuleMeta.prototype.save = function() {
  var self2 = this;
  return self2.target.meta;
};
PrefsModuleMeta.prototype.reset = function() {
  var self2 = this;
};
var PREFS_MODULE_REGISTRY = new ordmap_default();
PREFS_MODULE_REGISTRY.set("view", PrefsModuleComputedView);
PREFS_MODULE_REGISTRY.set("mirage", PrefsModuleMirageView);
PREFS_MODULE_REGISTRY.set("grid", PrefsModuleGrid);
PREFS_MODULE_REGISTRY.set("graph", PrefsModuleGraph);
PREFS_MODULE_REGISTRY.set("meta", PrefsModuleMeta);

// node_modules/wcdatavis/src/perspective.js
var Perspective = makeSubclass("Perspective", Object, function(id, name, config, modules, opts) {
  var self2 = this;
  if (id != null && typeof id !== "string") {
    throw new Error("Call Error: `id` must be null or a string");
  }
  if (name != null && typeof name !== "string") {
    throw new Error("Call Error: `name` must be null or a string");
  }
  if (id == null) {
    id = uuid();
  }
  if (name == null) {
    name = id;
  }
  self2.id = id;
  self2.name = name;
  self2.config = config;
  self2.modules = modules;
  self2.isUnsaved = false;
  self2.opts = deepDefaults(opts, {
    isEssential: false,
    isTemporary: false,
    isConstant: false
  });
}, {
  CURRENT_VERSION: 2
});
mixinDebugging(Perspective, function() {
  return import_sprintf_js6.default.sprintf("PREFS // PERSPECTIVE (%s)", this.id);
});
mixinLogging(Perspective);
Perspective.prototype.load = function(moduleNames, cont) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  if (moduleNames == null) {
    moduleNames = index_default_default.keys(self2.modules);
  }
  self2.debug(null, "Loading perspective using these modules: %s", JSON.stringify(moduleNames));
  index_default_default.each(moduleNames, function(moduleName) {
    var m2 = self2.modules[moduleName];
    var c2 = self2.config[moduleName];
    if (c2 == null && m2.defaultConfig != null) {
      self2.debug(null, "Using default config for module: moduleName = %s ; config = %O", moduleName, m2.defaultConfig);
      c2 = m2.defaultConfig;
    }
    self2.debug(null, "Loading module: moduleName = %s ; config = %O", moduleName, c2);
    m2.load(c2);
  });
  return cont(true);
};
Perspective.prototype.save = function(cont) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, "Saving perspective");
  index_default_default.each(self2.modules, function(module2, moduleName) {
    self2.config[moduleName] = module2.save();
    self2.debug(null, "Saving module: moduleName = %s ; config = %O", moduleName, self2.config[moduleName]);
  });
  return cont(self2.config);
};
Perspective.prototype.isMirage = function() {
  var self2 = this;
  return self2.config.isMirage;
};
Perspective.prototype.getVersion = function() {
  var self2 = this;
  return self2.config.version;
};

// node_modules/wcdatavis/src/prefs_backend.js
var PrefsBackend = makeSubclass("PrefsBackend", Object, function(id, prefs, opts) {
  var self2 = this;
  self2.id = id;
  self2.prefs = prefs;
  self2.opts = opts;
});
PrefsBackend.prototype.load = function(id, cont) {
  throw new Error("Abstract method load() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.loadAll = function(cont) {
  throw new Error("Abstract method loadAll() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.save = function(perspective, cont) {
  throw new Error("Abstract method save() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.getPerspectives = function(cont) {
  throw new Error("Abstract method getPerspectives() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.getCurrent = function(cont) {
  throw new Error("Abstract method getCurrent() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.setCurrent = function(id, cont) {
  throw new Error("Abstract method setCurrent() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.rename = function(oldName, newName, cont) {
  throw new Error("Abstract method rename() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.deletePerspective = function(id, cont) {
  throw new Error("Abstract method deletePerspective() not implemented by subclass " + this.constructor.name);
};
PrefsBackend.prototype.reset = function(cont) {
  throw new Error("Abstract method reset() not implemented by subclass " + this.constructor.name);
};
var PrefsBackendLocalStorage = makeSubclass("PrefsBackendLocalStorage", PrefsBackend, function() {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  try {
    var storage = window.localStorage;
  } catch (e2) {
    log.error("Access to localStorage is denied; prefs disabled");
    throw e2;
  }
  self2.super.ctor.apply(self2, args);
  self2.opts = deepDefaults(self2.opts, {
    key: "WC_DataVis_Prefs"
  });
  self2.localStorageKey = self2.opts.key;
}, {
  version: 3
});
mixinDebugging(PrefsBackendLocalStorage, function() {
  return "PREFS (" + this.id + ") // BACKEND - LOCAL";
});
PrefsBackendLocalStorage.prototype.load = function(id, cont) {
  var self2 = this;
  var storedPrefStr, storedPrefObj;
  var version2;
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  storedPrefStr = localStorage.getItem(self2.localStorageKey);
  if (storedPrefStr != null) {
    storedPrefObj = JSON.parse(storedPrefStr);
    version2 = getPropDef(0, storedPrefObj, self2.id, "version");
    if (version2 < self2.version) {
      return self2.migrate(version2, function() {
        return self2.loadAll(cont);
      });
    }
  } else {
    storedPrefObj = {};
  }
  var perspective = getProp(storedPrefObj, self2.id, "perspectives", id);
  if (perspective == null) {
    self2.debug(null, 'Perspective does not exist: id = "%s"', id);
    return cont(null);
  }
  self2.debug(
    null,
    'Loaded perspective: id = "%s" ; name = "%s" ; config = %O',
    perspective.id,
    perspective.name,
    perspective.config
  );
  return cont(perspective);
};
PrefsBackendLocalStorage.prototype.loadAll = function(cont) {
  var self2 = this;
  var storedPrefStr, storedPrefObj;
  var version2;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  storedPrefStr = localStorage.getItem(self2.localStorageKey);
  if (storedPrefStr != null) {
    storedPrefObj = JSON.parse(storedPrefStr);
    version2 = getPropDef(0, storedPrefObj, self2.id, "version");
    if (version2 < self2.version) {
      return self2.migrate(version2, function() {
        return self2.loadAll(cont);
      });
    }
  } else {
    storedPrefObj = {};
  }
  var perspectives = getPropDef({}, storedPrefObj, self2.id, "perspectives");
  self2.debug(null, "Loaded all perspectives: %O", perspectives);
  return cont(perspectives);
};
PrefsBackendLocalStorage.prototype.migrate = function(version2, cont) {
  var self2 = this;
  self2.debug(null, "Migrating prefs: v%d -> v%d", version2, self2.version);
  var readConfig = function() {
    var localStorageStr = localStorage.getItem(self2.localStorageKey);
    if (localStorageStr == null) {
      throw new Error("Found no prefs to migrate");
    }
    try {
      var localStorageObj2 = JSON.parse(localStorageStr);
    } catch (e2) {
      throw new Error("Prefs stored are not valid JSON");
    }
    if (localStorageObj2[self2.id] == null) {
      throw new Error('No prefs registered for this system ("' + self2.id + '")');
    }
    if (localStorageObj2[self2.id].perspectives == null) {
      localStorageObj2[self2.id].perspectives = {};
    }
    return localStorageObj2;
  };
  var writeConfig = function(localStorageObj2) {
    localStorageObj2[self2.id].version += 1;
    localStorage.setItem(self2.localStorageKey, JSON.stringify(localStorageObj2));
  };
  for (var i2 = version2; i2 < self2.version; i2 += 1) {
    switch (i2) {
      case 0:
        var oldPrefs = JSON.parse(localStorage.getItem("WC_DataVis_Prefs") || "{}");
        var oldCurrent = JSON.parse(localStorage.getItem("WC_DataVis_Prefs_Current") || "{}");
        var newPrefs = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
        newPrefs[self2.id] = {
          version: i2 + 1,
          current: oldCurrent[self2.id],
          perspectives: index_default_default.mapObject(oldPrefs[self2.id], function(config, id) {
            return {
              view: config
            };
          })
        };
        delete oldCurrent[self2.id];
        if (index_default_default.isEmpty(oldCurrent)) {
          localStorage.removeItem("WC_DataVis_Prefs_Current");
        } else {
          localStorage.setItem("WC_DataVis_Prefs_Current", JSON.stringify(oldCurrent));
        }
        delete oldPrefs[self2.id];
        if (self2.localStorageKey !== "WC_DataVis_Prefs") {
          if (index_default_default.isEmpty(oldPrefs)) {
            localStorage.removeItem("WC_DataVis_Prefs");
          } else {
            localStorage.setItem("WC_DataVis_Prefs", JSON.stringify(oldPrefs));
          }
        }
        localStorage.setItem(self2.localStorageKey, JSON.stringify(newPrefs));
        break;
      case 1:
        var localStorageObj = readConfig();
        index_default_default.each(localStorageObj[self2.id].perspectives, function(p, id) {
          var config = {};
          index_default_default.each(p, function(v, k) {
            config[k] = v;
            p[k] = null;
          });
          p.config = config;
          p.id = id;
          p.name = id;
        });
        writeConfig(localStorageObj);
        break;
      case 2:
        var localStorageObj = readConfig();
        index_default_default.each(localStorageObj[self2.id].perspectives, function(p) {
          if (getProp(p, "config", "view") != null) {
            p.config.computedView = p.config.view;
            delete p.config.view;
          }
        });
        writeConfig(localStorageObj);
        break;
    }
  }
  return typeof cont === "function" ? cont(true) : true;
};
PrefsBackendLocalStorage.prototype.save = function(perspective, cont) {
  var self2 = this;
  if (!(perspective instanceof Perspective)) {
    throw new Error("Call Error: `perspective` must be a Perspective");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(
    null,
    'Saving perspective: id = "%s" ; name = "%s" ; config = %O',
    perspective.id,
    perspective.name,
    perspective.config
  );
  var storedPrefData = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
  setProp(self2.version, storedPrefData, self2.id, "version");
  setProp({
    id: perspective.id,
    name: perspective.name,
    config: perspective.config
  }, storedPrefData, self2.id, "perspectives", perspective.id);
  localStorage.setItem(self2.localStorageKey, JSON.stringify(storedPrefData));
  return cont(true);
};
PrefsBackendLocalStorage.prototype.getPerspectives = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  var storedPrefData = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
  var perspectives = index_default_default.keys(getPropDef({}, storedPrefData, self2.id, "perspectives"));
  self2.debug(null, "Found %d perspectives: %s", perspectives.length, JSON.stringify(perspectives));
  return cont(perspectives);
};
PrefsBackendLocalStorage.prototype.getCurrent = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  var storedPrefData = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
  var current = getProp(storedPrefData, self2.id, "current");
  self2.debug(null, 'Current perspective is "%s"', current);
  return cont(current);
};
PrefsBackendLocalStorage.prototype.setCurrent = function(id, cont) {
  var self2 = this;
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, 'Setting current perspective to "%s"', id);
  var storedPrefData = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
  setProp(self2.version, storedPrefData, self2.id, "version");
  setProp(id, storedPrefData, self2.id, "current");
  localStorage.setItem(self2.localStorageKey, JSON.stringify(storedPrefData));
  return cont(true);
};
PrefsBackendLocalStorage.prototype.rename = function(oldName, newName, cont) {
  var self2 = this;
  if (typeof oldName !== "string") {
    throw new Error("Call Error: `oldName` must be a string");
  }
  if (typeof newName !== "string") {
    throw new Error("Call Error: `newName` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, 'Renaming perspective: "%s" -> "%s"', oldName, newName);
  var storedPrefData = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
  storedPrefData[self2.id]["perspectives"][newName] = storedPrefData[self2.id]["perspectives"][oldName];
  delete storedPrefData[self2.id]["perspectives"][oldName];
  localStorage.setItem(self2.localStorageKey, JSON.stringify(storedPrefData));
  return cont(true);
};
PrefsBackendLocalStorage.prototype.deletePerspective = function(id, cont) {
  var self2 = this;
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, 'Deleting perspective: "%s"', id);
  var storedPrefData = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
  delete storedPrefData[self2.id]["perspectives"][id];
  localStorage.setItem(self2.localStorageKey, JSON.stringify(storedPrefData));
  return cont(true);
};
PrefsBackendLocalStorage.prototype.reset = function(cont) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, "Resetting perspectives");
  var storedPrefData = JSON.parse(localStorage.getItem(self2.localStorageKey) || "{}");
  delete storedPrefData[self2.id];
  localStorage.setItem(self2.localStorageKey, JSON.stringify(storedPrefData));
  return cont(true);
};
var PrefsBackendTemporary = makeSubclass("PrefsBackendTemporary", PrefsBackend, function() {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  self2.super.ctor.apply(self2, args);
  self2.storage = {
    perspectives: {}
  };
});
mixinDebugging(PrefsBackendTemporary, function() {
  return "PREFS (" + this.id + ") // BACKEND - TEMPORARY";
});
PrefsBackendTemporary.prototype.load = function(id, cont) {
  var self2 = this;
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  var perspective = self2.storage.perspectives[id];
  if (perspective == null) {
    self2.debug(null, 'Perspective does not exist: id = "%s"', id);
    return cont(null);
  }
  self2.debug(
    null,
    'Loaded perspective: id = "%s" ; name = "%s" ; config = %O',
    perspective.id,
    perspective.name,
    perspective.config
  );
  return cont(perspective);
};
PrefsBackendTemporary.prototype.loadAll = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  var perspectives = self2.storage.perspectives;
  self2.debug(null, "Loaded all perspectives: %O", perspectives);
  return cont(perspectives);
};
PrefsBackendTemporary.prototype.save = function(perspective, cont) {
  var self2 = this;
  if (!(perspective instanceof Perspective)) {
    throw new Error("Call Error: `perspective` must be a Perspective");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(
    null,
    'Saving perspective: id = "%s" ; name = "%s" ; config = %O',
    perspective.id,
    perspective.name,
    perspective.config
  );
  self2.storage.perspectives[perspective.id] = {
    id: perspective.id,
    name: perspective.name,
    config: perspective.config
  };
  return cont(true);
};
PrefsBackendTemporary.prototype.getPerspectives = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  var perspectives = index_default_default.keys(self2.storage.perspectives);
  self2.debug(null, "Found %d perspectives: %s", perspectives.length, JSON.stringify(perspectives));
  return cont(perspectives);
};
PrefsBackendTemporary.prototype.getCurrent = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  var current = self2.storage.current;
  self2.debug(null, 'Current perspective is "%s"', current);
  return cont(current);
};
PrefsBackendTemporary.prototype.setCurrent = function(id, cont) {
  var self2 = this;
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, 'Setting current perspective to "%s"', id);
  self2.storage.current = id;
  return cont(true);
};
PrefsBackendTemporary.prototype.rename = function(oldName, newName, cont) {
  var self2 = this;
  if (typeof oldName !== "string") {
    throw new Error("Call Error: `oldName` must be a string");
  }
  if (typeof newName !== "string") {
    throw new Error("Call Error: `newName` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, 'Renaming perspective: "%s" -> "%s"', oldName, newName);
  self2.storage.perspectives[newName] = self2.storage.perspectives[oldName];
  delete self2.storage.perspectives[oldName];
  return cont(true);
};
PrefsBackendTemporary.prototype.deletePerspective = function(id, cont) {
  var self2 = this;
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, 'Deleting perspective: "%s"', id);
  delete self2.storage.perspectives[id];
  return cont(true);
};
PrefsBackendTemporary.prototype.reset = function(cont) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  self2.debug(null, "Resetting perspectives");
  self2.storage = {
    perspectives: {}
  };
  return cont(true);
};
var PREFS_BACKEND_REGISTRY = new ordmap_default();
PREFS_BACKEND_REGISTRY.set("localStorage", PrefsBackendLocalStorage);
PREFS_BACKEND_REGISTRY.set("temporary", PrefsBackendTemporary);

// node_modules/wcdatavis/src/renderers/grid/table.js
var import_sprintf_js9 = __toESM(require_sprintf());
var import_jquery13 = __toESM(require_jquery());

// node_modules/wcdatavis/src/util/csv.js
var import_sprintf_js8 = __toESM(require_sprintf());
var import_jquery12 = __toESM(require_jquery());
var TableExport = makeSubclass("TableExport", Object, function(opts) {
  var self2 = this;
});
TableExport.prototype.start = function() {
};
TableExport.prototype.addRow = function() {
};
TableExport.prototype.addCol = function() {
};
TableExport.prototype.finish = function() {
};
var Csv = makeSubclass("Csv", TableExport, function(opts) {
  var self2 = this;
  self2.lastRowId = -2;
  self2.opts = opts || {};
  index_default_default.defaults(self2.opts, {
    separator: ","
  });
  self2.start();
});
Csv.prototype.start = function() {
  var self2 = this;
  self2.lastRowId = -2;
  self2.data = [];
  self2.lastRow = null;
  self2.order = null;
};
Csv.prototype.addRow = function(rowId) {
  var self2 = this;
  if (rowId == null) {
    rowId = ++self2.lastRowId;
  }
  self2.lastRow = {
    rowId,
    rowData: [],
    hidden: false
  };
  self2.data.push(self2.lastRow);
};
Csv.prototype.addCol = function(x, opts) {
  var self2 = this;
  opts = opts || {};
  opts = index_default_default.defaults(opts, {
    prepend: false
  });
  if (x == null) {
    x = "";
  } else if (typeof x !== "string") {
    x = x.toString();
  }
  if (self2.lastRow == null) {
    self2.addRow();
  }
  if (opts.prepend) {
    self2.lastRow.rowData.unshift(x);
  } else {
    self2.lastRow.rowData.push(x);
  }
};
Csv.prototype.toString = function() {
  var self2 = this;
  var i2, row;
  var s2 = "";
  var sep = '"' + self2.opts.separator + '"';
  var len = self2.order != null ? self2.order.length : self2.data.length;
  var quoteRegexp = /"/g;
  for (i2 = 0; i2 < len; i2 += 1) {
    row = self2.order != null ? self2.getRowById(self2.order[i2]) : self2.data[i2];
    if (i2 > 0) {
      s2 += "\r\n";
    }
    s2 += '"' + row.rowData.map(function(s3) {
      return s3.replace(quoteRegexp, '""');
    }).join(sep) + '"';
  }
  return s2;
};
Csv.prototype.getRowById = function(rowId) {
  var self2 = this;
  return self2.data[rowId].rowId === rowId ? self2.data[rowId] : index_default_default.findWhere(self2.data, { rowId });
};
Csv.prototype.updateVisibility = function(rowId, hide) {
  var self2 = this;
  var row = self2.getRowById(rowId);
  if (row != null) {
    row.hidden = hide;
  }
};
Csv.prototype.setOrder = function(rowId, pos) {
  var self2 = this;
  if (self2.order == null) {
    self2.order = [];
  }
  self2.order[pos] = rowId;
};
Csv.prototype.finish = function(cb2) {
  return cb2();
};

// node_modules/wcdatavis/src/renderers/grid/table.js
var GridTable = makeSubclass("GridTable", GridRenderer, function() {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.selection = [];
  self2.needsRedraw = false;
  self2.contextMenuSelectors = [];
  self2.csvLock = new lock_default("GridTable/csv");
  index_default_default.defaults(self2.opts, {
    drawInternalBorders: true,
    zebraStriping: true,
    generateCsv: true,
    stealGridFooter: true
  });
});
mixinEventHandling(GridTable, [
  "columnResize",
  "unableToRender",
  "limited",
  "unlimited",
  "csvReady",
  "generateCsvProgress",
  "renderBegin",
  "renderEnd",
  "selectionChange"
]);
GridTable.prototype._validateFeatures = function() {
  var self2 = this;
  if (self2.features.block && !import_jquery13.default.blockUI) {
    log.error(
      "GRID TABLE // CONFIG",
      'Feature "block" requires BlockUI library, which is not present'
    );
    self2.features.block = false;
  }
  if (self2.features.limit) {
    self2._validateLimit();
    self2.scrollEvents = ["DOMContentLoaded", "load", "resize", "scroll"].map(function(x) {
      return x + ".wcdv_gt_" + self2.UNIQUE_ID;
    }).join(" ");
  }
  if (self2.features.floatingHeader) {
    self2._validateFloatTableHeader();
  }
};
GridTable.prototype._validateLimit = function() {
  var self2 = this;
  if (self2.features.limit) {
    if (self2.defn.table.limit.threshold === void 0) {
      debug.warn("GRID TABLE - PLAIN // DRAW", "Disabling limit feature because no limit threshold was provided");
      self2.features.limit = false;
    }
  }
};
GridTable.prototype._validateFloatTableHeader = function() {
  var self2 = this;
  if (!self2.features.floatingHeader) {
    return;
  }
  var config = getPropDef({}, self2.defn, "table", "floatingHeader");
  if (config.method != null) {
    switch (config.method) {
      case "floatThead":
        if (import_jquery13.default.prototype.floatThead == null) {
          log.error("GRID TABLE // CONFIG", 'Requested floating header method "floatThead" is not available');
          self2.features.floatingHeader = false;
        }
        break;
      case "fixedHeaderTable":
        if (import_jquery13.default.prototype.fixedHeaderTable == null) {
          log.error("GRID TABLE // CONFIG", 'Requested floating header method "fixedHeaderTable" is not available');
          self2.features.floatingHeader = false;
        }
        break;
      case "tabletool":
        if (window.TableTool == null) {
          log.error("GRID TABLE // CONFIG", 'Requested floating header method "tabletool" is not available');
          self2.features.floatingHeader = false;
        }
        break;
      case "css":
        break;
      default:
        log.error("GRID TABLE // CONFIG", "Unrecognized floating header method: " + config.method);
        self2.features.floatingHeader = false;
    }
  } else {
    if (import_jquery13.default.prototype.floatThead) {
      config.method = "floatThead";
    } else if (import_jquery13.default.prototype.fixedHeaderTable) {
      config.method = "fixedHeaderTable";
    } else if (window.TableTool) {
      config.method = "tabletool";
    } else if (true) {
      config.method = "css";
    } else {
      self2.features.floatingHeader = false;
    }
  }
  self2.defn.table.floatingHeader = config;
};
GridTable.prototype.toString = function() {
  var self2 = this;
  return "GridTable(" + self2.UNIQUE_ID + ")";
};
GridTable.prototype.setCss = function(elt2, field) {
  var self2 = this;
  var fcc = self2.colConfig.get(field);
  if (fcc == null) {
    return;
  }
  var css = [
    { configName: "width", cssName: "width" },
    { configName: "minWidth", cssName: "min-width" },
    { configName: "maxWidth", cssName: "max-width" },
    { configName: "cellAlignment", cssName: "text-align" }
  ];
  for (var i2 = 0; i2 < css.length; i2 += 1) {
    if (fcc[css[i2].configName] !== void 0) {
      elt2.css(css[i2].cssName, fcc[css[i2].configName]);
    }
  }
};
GridTable.prototype.setAlignment = function(elt2, fcc, fti, overrideType, fallback) {
  fcc = fcc || {};
  fti = fti || {};
  if (elt2 instanceof import_jquery13.default) {
    elt2 = elt2.get(0);
  }
  if (!(elt2 instanceof Element)) {
    throw new Error("Call Error: `elt` must be an instance of Element");
  }
  var type = overrideType || fti.type;
  var alignment = fcc.cellAlignment || fallback;
  if (alignment == null && (type === "number" || type === "currency")) {
    alignment = "right";
  }
  switch (alignment) {
    case "left":
      elt2.classList.add("wcdvgrid_textLeft");
      break;
    case "right":
      elt2.classList.add("wcdvgrid_textRight");
      break;
    case "center":
      elt2.classList.add("wcdvgrid_textCenter");
      break;
    case "justify":
      elt2.classList.add("wcdvgrid_textJustify");
      break;
    default:
      elt2.style.setProperty("text-align", alignment);
  }
};
GridTable.prototype._addSortingToHeader = function(data, orientation, spec, container, agg) {
  var self2 = this;
  if (!self2.features.sort) {
    return;
  }
  if (["horizontal", "vertical"].indexOf(orientation) < 0) {
    throw new Error('Call Error: `orientation` must be "horizontal" or "vertical"');
  }
  if (!(container instanceof Element)) {
    throw new Error("Call Error: `container` must be an Element");
  }
  var sortIcon_orientationClass = "wcdv_sort_icon_" + orientation;
  var replaceSortIndicator = function(span, dir) {
    var i2;
    if (!(span instanceof Element)) {
      throw new Error("Call Error: `span` must be an Element");
    }
    if (dir != null) {
      if (!index_default_default.isString(dir)) {
        throw new Error("Call Error: `dir` must be null or a string");
      } else if (dir.toUpperCase() !== "ASC" && dir.toUpperCase() !== "DESC") {
        throw new Error('Call Error: `dir` must be either "ASC" or "DESC"');
      }
    }
    var th = container.closest("th");
    for (i2 = 0; i2 < span.children.length; i2 += 1) {
      span.children[i2].classList.remove("wcdv_sort_arrow_active");
    }
    th.classList.remove("wcdv_sort_column_active");
    th.classList.remove("wcdv_bg-primary");
    if (dir != null) {
      th.classList.add("wcdv_sort_column_active");
      th.classList.add("wcdv_bg-primary");
      for (i2 = 0; i2 < span.children.length; i2 += 1) {
        var child = span.children[i2];
        child.classList.remove("wcdv_sort_arrow_active");
        if (child.classList.contains("fa-sort-desc")) {
          child.classList.add("wcdv_sort_arrow_" + (dir.toUpperCase() === "ASC" ? "active" : "inactive"));
        }
        if (child.classList.contains("fa-sort-asc")) {
          child.classList.add("wcdv_sort_arrow_" + (dir.toUpperCase() === "DESC" ? "active" : "inactive"));
        }
      }
    }
  };
  var setSort = function(dir, aggNum) {
    if (!index_default_default.isString(dir)) {
      throw new Error("Call Error: `dir` must be a string");
    } else if (dir.toUpperCase() !== "ASC" && dir.toUpperCase() !== "DESC") {
      throw new Error('Call Error: `dir` must be either "ASC" or "DESC"');
    }
    if (aggNum != null && !index_default_default.isNumber(aggNum)) {
      throw new Error("Call Error: `aggNum` must be a number");
    }
    (0, import_jquery13.default)("span." + sortIcon_orientationClass + ".fa-stack").each(function(i2, elt2) {
      replaceSortIndicator(elt2);
    });
    (0, import_jquery13.default)("span." + sortIcon_class).each(function(i2, elt2) {
      replaceSortIndicator(elt2, dir);
    });
    spec.aggNum = aggNum;
    spec.dir = dir;
    var sortSpec = self2.view.getSort() || {};
    sortSpec[orientation] = deepCopy(spec);
    self2.view.setSort(sortSpec, self2.makeProgress("Sort"));
  };
  var ascArrow = document.createElement("span");
  ascArrow.classList.add("fa");
  ascArrow.classList.add("fa-sort-asc");
  ascArrow.classList.add("fa-stack-1x");
  var descArrow = document.createElement("span");
  descArrow.classList.add("fa");
  descArrow.classList.add("fa-sort-desc");
  descArrow.classList.add("fa-stack-1x");
  var sortIcon_class = gensym();
  var sortIcon_span = fontAwesome("fa-stack", orientation === "horizontal" ? "fa-rotate-270" : null).get(0);
  sortIcon_span.classList.add(sortIcon_class);
  sortIcon_span.classList.add(sortIcon_orientationClass);
  sortIcon_span.classList.add("wcdv_sort_icon");
  sortIcon_span.appendChild(ascArrow);
  sortIcon_span.appendChild(descArrow);
  var sortIcon_menu_items = {};
  if (spec.field != null || spec.groupFieldIndex != null || spec.pivotFieldIndex != null) {
    var name = spec.field != null ? spec.field : spec.groupFieldIndex != null ? data.groupFields[spec.groupFieldIndex] : spec.pivotFieldIndex != null ? data.pivotFields[spec.pivotFieldIndex] : "Unknown";
    sortIcon_menu_items[gensym()] = {
      name: trans("GRID.TABLE.SORT_MENU.ASCENDING", name),
      icon: "fa-sort-amount-asc",
      callback: function() {
        window.setTimeout(function() {
          setSort("asc");
        });
      }
    };
    sortIcon_menu_items[gensym()] = {
      name: trans("GRID.TABLE.SORT_MENU.DESCENDING", name),
      icon: "fa-sort-amount-desc",
      callback: function() {
        window.setTimeout(function() {
          setSort("desc");
        });
      }
    };
    sortIcon_menu_items[gensym()] = "----";
  } else {
    index_default_default.each(agg, function(aggInfo, aggNum) {
      if (spec.aggType != null && spec.aggNum !== aggNum) {
        return;
      }
      sortIcon_menu_items[gensym()] = {
        name: trans("GRID.TABLE.SORT_MENU.ASCENDING", aggInfo.instance.getFullName()),
        icon: "fa-sort-amount-asc",
        callback: function() {
          window.setTimeout(function() {
            setSort("asc", aggNum);
          });
        }
      };
      sortIcon_menu_items[gensym()] = {
        name: trans("GRID.TABLE.SORT_MENU.DESCENDING", aggInfo.instance.getFullName()),
        icon: "fa-sort-amount-desc",
        callback: function() {
          window.setTimeout(function() {
            setSort("desc", aggNum);
          });
        }
      };
      sortIcon_menu_items[gensym()] = "----";
    });
  }
  sortIcon_menu_items.reset = {
    name: trans("GRID.TABLE.SORT_MENU.RESET_SORT"),
    icon: "fa-ban",
    callback: function() {
      window.setTimeout(function() {
        self2.view.clearSort();
      });
    }
  };
  var sortIcon_menu = import_jquery13.default.contextMenu({
    selector: "." + sortIcon_class,
    appendTo: self2.ui.contextMenus,
    trigger: "left",
    callback: function(itemKey, opt) {
      console.log(itemKey);
    },
    items: sortIcon_menu_items
  });
  self2.contextMenuSelectors.push("." + sortIcon_class);
  container.appendChild(sortIcon_span);
  var sortSpec_copy = deepCopy(self2.view.getSort());
  var spec_copy = deepCopy(spec);
  if (sortSpec_copy[orientation]) {
    var currentDir = sortSpec_copy[orientation].dir;
    delete sortSpec_copy[orientation].dir;
    if (spec.aggType == null) {
      delete sortSpec_copy[orientation].aggNum;
      delete spec_copy.aggNum;
    }
    console.debug(
      "[DataVis // %s // Add Sorting] orientation = %s ; spec = %O ; current = %O ; dir = %s",
      self2.toString(),
      orientation,
      spec_copy,
      sortSpec_copy[orientation],
      currentDir
    );
    if (index_default_default.isEqual(sortSpec_copy[orientation], spec_copy)) {
      replaceSortIndicator(sortIcon_span, currentDir);
    }
  }
};
GridTable.prototype._addFilterToHeader = function(container, field, displayText) {
  var self2 = this;
  if (self2.grid.filterControl == null) {
    return;
  }
  (0, import_jquery13.default)(fontAwesome("fa-filter", "wcdv_filter_icon", trans("GRID.TABLE.ADD_FILTER_HELP", field))).on("click", function() {
    self2.grid.filterControl.addField(field, displayText, {
      openControls: true
    });
  }).tooltip({
    classes: {
      "ui-tooltip": "ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary"
    },
    show: { delay: 1e3 }
  }).appendTo(container);
};
GridTable.prototype._addDrillDownHandler = function(tbl, data) {
  var self2 = this;
  tbl.on("mousedown", function(evt) {
    if (evt.detail > 1) {
      evt.preventDefault();
    }
  });
  tbl.on("dblclick", "td.wcdv_drill_down", function() {
    if (window.getSelection) {
      window.getSelection().removeAllRanges();
    } else if (document.selection) {
      document.selection.empty();
    }
    var elt2 = (0, import_jquery13.default)(this);
    var filter2 = deepCopy(self2.view.getFilter());
    var rowValIndex = elt2.dvAttr("rvi");
    var colValIndex = elt2.dvAttr("cvi");
    if (rowValIndex != null) {
      index_default_default.each(data.rowVals[rowValIndex], function(x, i2) {
        var gs = data.groupSpec[i2];
        filter2[data.groupFields[i2]] = gs.fun != null ? GROUP_FUNCTION_REGISTRY.get(gs.fun).valueToFilter(x) : { "$eq": x };
      });
    }
    if (colValIndex != null) {
      index_default_default.each(data.colVals[colValIndex], function(x, i2) {
        var ps = data.pivotSpec[i2];
        filter2[data.pivotFields[i2]] = ps.fun != null ? GROUP_FUNCTION_REGISTRY.get(ps.fun).valueToFilter(x) : { "$eq": x };
      });
    }
    console.debug("[DataVis // %s // Drill Down] Creating new perspective: filter = %O", self2.toString(), filter2);
    window.setTimeout(function() {
      self2.view.prefs.addPerspective(null, "Drill Down", { view: { filter: filter2 } }, { isTemporary: true }, null, { onDuplicate: "replace" });
    });
  });
};
GridTable.prototype._addDrillDownClass = function(elt2) {
  elt2.classList.add("wcdv_drill_down");
};
GridTable.prototype.addSortHandler = function() {
  var self2 = this;
  self2.view.off("sort");
  if (self2.features.sort) {
    self2.view.on("sortEnd", function() {
      console.debug("[DataVis // %s // Handler(ComputedView.sortEnd)] Marking table to be redrawn", self2.toString());
      self2.needsRedraw = true;
    }, { who: self2 });
  }
};
GridTable.prototype.addFilterHandler = function() {
  var self2 = this;
  self2.view.off("filter");
  self2.view.on(ComputedView.events.filterEnd, function() {
    console.debug("[DataVis // %s // Handler(ComputedView.filterEnd)] Marking table to be redrawn", self2.toString());
    self2.needsRedraw = true;
  }, { who: self2 });
};
GridTable.prototype._addRowReorderHandler = function() {
  var self2 = this;
  self2.ui.tbody._makeSortableTable(index_default_default.bind(self2.view.source.swapRows, self2.view.source));
};
GridTable.prototype._addRowSelectHandler = function() {
  var self2 = this;
  self2.ui.tbody.on("change", 'td.wcdv-row-select-col > input[type="checkbox"]', function() {
    if (this.checked) {
      self2.select(+(0, import_jquery13.default)(this).attr("data-row-num"));
    } else {
      self2.unselect(+(0, import_jquery13.default)(this).attr("data-row-num"));
    }
  });
};
GridTable.prototype._getAggInfo = function(data) {
  var ai = objFromArray(["cell", "group", "pivot", "all"], [[]]);
  ai = index_default_default.mapObject(ai, function(val, key) {
    return index_default_default.filter(
      getPropDef([], data, "agg", "info", key),
      function(aggInfo) {
        return !aggInfo.isHidden;
      }
    );
  });
  return ai;
};
GridTable.prototype._getDisplayFormat = function() {
  var self2 = this;
  var df = objFromArray(["cell", "group", "pivot", "all"], [[]]);
  df = index_default_default.mapObject(df, function(val, key) {
    return getPropDef([], self2.opts, "displayFormat", key);
  });
  return df;
};
GridTable.prototype._setupFullValueWin = function(data) {
  var self2 = this;
  var fullValueWinDiv = document.createElement("div");
  var fullValueWinEffect = {
    effect: "fade",
    duration: 100
  };
  var fullValueWin = (0, import_jquery13.default)("<div>", { title: "Full Value" }).dialog({
    autoOpen: false,
    modal: true,
    width: 800,
    maxHeight: 600,
    classes: {
      "ui-dialog": "ui-corner-all wcdv_dialog",
      "ui-dialog-titlebar": "ui-corner-all"
    },
    show: fullValueWinEffect,
    hide: fullValueWinEffect
  });
  fullValueWin.append(fullValueWinDiv);
  self2.ui.tbody.on("click", "button.wcdv_show_full_value", function(evt) {
    evt.stopPropagation();
    var btn = (0, import_jquery13.default)(this);
    var td = btn.parents("td");
    var tr = td.parents("tr");
    var field, rowNum, rvi, cvi, aggScope, aggNum, aggInfo, aggResult, val;
    if (data.isPlain) {
      field = td.attr("data-wcdv-field");
      rowNum = +tr.attr("data-row-num");
      val = getProp(data, "data", rowNum, "rowData", field, "cachedRender");
      setElement(fullValueWinDiv, val);
    } else if (data.isGroup || data.isPivot) {
      aggScope = td.attr("data-wcdv-agg-scope");
      aggNum = +td.attr("data-wcdv-agg-num");
      switch (aggScope) {
        case "cell":
          rvi = +tr.dvAttr("rvi");
          cvi = +td.dvAttr("cvi");
          aggResult = data.agg.results[aggScope][aggNum][rvi][cvi];
          break;
        case "group":
          rvi = +tr.dvAttr("rvi");
          aggResult = data.agg.results[aggScope][aggNum][rvi];
          break;
        case "pivot":
          cvi = +td.dvAttr("cvi");
          aggResult = data.agg.results[aggScope][aggNum][cvi];
          break;
        case "all":
          aggResult = data.agg.results[aggScope][aggNum];
          break;
      }
      aggInfo = data.agg.info[aggScope][aggNum];
      field = getProp(aggInfo, "fields", 0);
      if (isElement2(aggResult)) {
        setElement(fullValueWinDiv, aggResult);
      } else {
        if (aggInfo.instance.inheritFormatting) {
          val = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
            overrideType: aggInfo.instance.getType()
          });
          setElement(fullValueWinDiv, val, {
            field: aggInfo.fields[0],
            colConfig: aggInfo.colConfig[0],
            typeInfo: aggInfo.typeInfo[0]
          });
        } else {
          val = format2(null, null, aggResult, {
            overrideType: aggInfo.instance.getType(),
            decode: false
          });
          setElement(fullValueWinDiv, val);
        }
      }
    }
    fullValueWin.dialog("open");
  });
};
GridTable.prototype.draw = function(root2, opts, cont) {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  if (self2.opts.generateCsv) {
    if (self2.csvLock.isLocked()) {
      return self2.csvLock.onUnlock(function() {
        console.debug("[DataVis // %s // CSV] Retrying table draw due to CSV lock: %O %O", self2.toString(), root2, opts);
        self2.draw.apply(self2, args);
      });
    } else {
      console.debug("[DataVis // %s // CSV] Creating new CSV buffer", self2.toString());
      self2.csvLock.lock();
      self2.csv = new Csv();
    }
  } else {
    self2.csv = new TableExport();
  }
  return self2.super.draw(root2, opts, function(ok, data, typeInfo, andThen) {
    if (!ok) {
      return cont();
    }
    self2.timing.start(["Grid Table", "Draw"]);
    if (!self2.features.floatingHeader || self2.defn.table.floatingHeader.method !== "tabletool") {
      root2.css({ "overflow-x": "auto" });
    }
    if (self2.features.limit && self2.defn.table.limit.method === "more") {
      self2.scrollEventElement = self2.opts.fixedHeight ? self2.root : window;
      (0, import_jquery13.default)(self2.scrollEventElement).on(self2.scrollEvents, function() {
        if (typeof self2.moreVisibleHandler === "function") {
          self2.moreVisibleHandler();
        }
      });
    }
    if (self2.features.operations) {
      (0, import_jquery13.default)(self2.root).on("click.wcdv_operation", "button.wcdv_operation", function() {
        var btn = this;
        var opType = btn.getAttribute("data-operation-type");
        var opIndex = btn.getAttribute("data-operation-index");
        var sel, cellElt, rowElt, rowNum, field, op;
        switch (opType) {
          case "row":
            rowElt = (0, import_jquery13.default)(btn).parents("tr");
            rowNum = +rowElt.attr("data-row-num");
            op = self2.defn.operations.row[opIndex];
            op.callback({
              rowId: rowNum,
              rowElt,
              row: self2.data.dataByRowId[rowNum],
              opBtn: (0, import_jquery13.default)(btn)
            });
            break;
          case "cell":
            cellElt = (0, import_jquery13.default)(btn).parents("td");
            field = (0, import_jquery13.default)(btn).parents("td").attr("data-wcdv-field");
            rowElt = (0, import_jquery13.default)(btn).parents("tr");
            rowNum = +(0, import_jquery13.default)(btn).parents("tr").attr("data-row-num");
            op = self2.defn.operations.cell[field][opIndex];
            op.callback({
              rowId: rowNum,
              rowElt,
              row: self2.data.dataByRowId[rowNum],
              cellElt,
              cell: self2.data.dataByRowId[rowNum][field].value,
              opBtn: (0, import_jquery13.default)(btn)
            });
            break;
        }
      });
    }
    var tr;
    var srcIndex = 0;
    self2.ui = {
      tbl: (0, import_jquery13.default)("<table>"),
      thead: (0, import_jquery13.default)("<thead>"),
      tbody: (0, import_jquery13.default)("<tbody>"),
      tfoot: (0, import_jquery13.default)("<tfoot>"),
      thMap: {},
      tr: {},
      progress: (0, import_jquery13.default)("<div>"),
      contextMenus: (0, import_jquery13.default)("<div>")
    };
    self2._addDrillDownHandler(self2.ui.tbl, data);
    if (self2.features.block) {
      var blockConfig = {
        overlayCSS: {
          opacity: 0.9,
          backgroundColor: "#FFF"
        }
      };
      if (self2.features.progress && getProp(self2.defn, "table", "progress", "method") === "jQueryUI") {
        blockConfig.message = (0, import_jquery13.default)("<div>").append((0, import_jquery13.default)("<h1>").text("Working...")).append(self2.ui.progress);
      }
    }
    self2.ui.contextMenus.appendTo(document.body);
    self2.view.on(ComputedView.events.workBegin, function() {
      if (self2.features.block) {
        console.debug("[DataVis // %s // Handler(ComputedView.workBegin)] Blocking table body", self2.toString());
        if (getProp(self2.defn, "table", "block", "wholePage")) {
          import_jquery13.default.blockUI(blockConfig);
        } else {
          self2.ui.tbl.block(blockConfig);
        }
      }
      if (self2.features.floatingHeader) {
        switch (getProp(self2.defn, "table", "floatingHeader", "method")) {
          case "tabletool":
            window.TableTool.update();
            break;
        }
      }
    }, { who: self2 });
    self2.view.on(ComputedView.events.workEnd, function() {
      if (self2.features.block) {
        console.debug("[DataVis // %s // Handler(ComputedView.workEnd)] Unblocking table body", self2.toString());
        if (getProp(self2.defn, "table", "block", "wholePage")) {
          import_jquery13.default.unblockUI();
        } else {
          self2.ui.tbl.unblock();
        }
      }
      if (self2.features.floatingHeader) {
        switch (getProp(self2.defn, "table", "floatingHeader", "method")) {
          case "tabletool":
            window.TableTool.update();
            break;
        }
      }
    }, { who: self2 });
    var columns = determineColumns(self2.colConfig, data, typeInfo);
    self2.drawHeader(columns, data, typeInfo, opts);
    if (self2.features.footer) {
      self2.drawFooter(columns, data, typeInfo);
    }
    self2.addSortHandler();
    if (self2.features.rowSelect) {
      if (typeof self2._addRowSelectHandler !== "function") {
        log.warn('Requested feature "rowSelect" is not available: `_addRowSelectHandler` method does not exist');
      } else {
        self2._addRowSelectHandler();
      }
    }
    if (self2.features.rowReorder) {
      self2._addRowReorderHandler();
    }
    if (self2.opts.zebraStriping) {
      self2.ui.tbl.addClass("zebra");
    }
    if (getProp(self2.opts, "addClass", "table")) {
      self2.ui.tbl.addClass(getProp(self2.opts, "addClass", "table"));
    }
    self2.ui.tbl.append(self2.ui.thead);
    if (self2.features.incremental && !getProp(self2.defn, "table", "incremental", "appendBodyLast")) {
      self2.ui.tbl.append(self2.ui.tbody);
      if (self2.features.footer) {
        self2.ui.tbl.append(self2.ui.tfoot);
      }
    }
    self2.root.get(0).appendChild(self2.ui.tbl.get(0));
    self2.drawBody(data, typeInfo, columns, function() {
      if (!self2.features.incremental || getProp(self2.defn, "table", "incremental", "appendBodyLast")) {
        self2.ui.tbl.append(self2.ui.tbody);
        if (self2.features.footer) {
          self2.ui.tbl.append(self2.ui.tfoot);
        }
      }
      if (self2.features.floatingHeader) {
        console.debug(
          '[DataVis // %s // Draw] Enabling floating header using method "%s"',
          self2.toString(),
          getProp(self2.defn, "table", "floatingHeader", "method")
        );
        switch (getProp(self2.defn, "table", "floatingHeader", "method")) {
          case "floatThead":
            var floatTheadConfig = {
              zIndex: 1
            };
            if (self2.opts.fixedHeight) {
              floatTheadConfig.position = "fixed";
              floatTheadConfig.scrollContainer = true;
            } else {
              floatTheadConfig.responsiveContainer = function() {
                return self2.root;
              };
            }
            self2.grid.on("showControls", function() {
              self2.ui.tbl.floatThead("reflow");
            }, { who: self2 });
            self2.grid.on("hideControls", function() {
              self2.ui.tbl.floatThead("reflow");
            }, { who: self2 });
            self2.grid.filterControl.on(["fieldAdded", "fieldRemoved"], function() {
              self2.ui.tbl.floatThead("reflow");
            }, { who: self2 });
            self2.grid.aggregateControl.on(["fieldAdded", "fieldRemoved"], function() {
              self2.ui.tbl.floatThead("reflow");
            }, { who: self2 });
            self2.ui.tbl.floatThead(floatTheadConfig);
            break;
          case "tabletool":
            if (self2.opts.fixedHeight) {
              self2.ui.tbl.attr("data-tttype", "fixed");
              self2.ui.tbl.attr("data-ttheight", self2.grid.rootHeight);
            } else {
              self2.ui.tbl.attr("data-tttype", "sticky");
            }
            if (data.isPlain) {
              var pinnedColumns = 0;
              index_default_default.each(columns, function(field) {
                var fcc = self2.colConfig.get(field);
                if (fcc != null && fcc.isPinned) {
                  pinnedColumns += 1;
                }
              });
              if (pinnedColumns > 0) {
                if (self2.features.rowSelect) {
                  pinnedColumns += 1;
                }
                if (self2.hasOperations("row")) {
                  pinnedColumns += 1;
                }
                self2.ui.tbl.attr("data-tttype", "sidescroll");
                self2.ui.tbl.attr("data-ttsidecells", pinnedColumns);
              }
            } else if ((data.isGroup || data.isPivot) && getProp(self2.defn, "table", "whenGroup", "pinRowvals")) {
              self2.ui.tbl.attr("data-tttype", "sidescroll");
              self2.ui.tbl.attr("data-ttsidecells", data.groupFields.length);
            }
            break;
          case "css":
            self2.ui.thead.addClass("sticky");
            self2.ui.tfoot.addClass("sticky");
            break;
        }
      }
      self2.addWorkHandler();
      self2.timing.stop(["Grid Table", "Draw"]);
      andThen(cont);
    }, opts);
  });
};
GridTable.prototype.drawHeader_aggregates = function(data, tr, displayOrderIndex, displayOrderMax) {
  var self2 = this;
  var ai = self2._getAggInfo(data);
  index_default_default.each(ai.group, function(aggInfo, aggIndex) {
    var aggNum = aggInfo.aggNum, text = aggInfo.instance.getFullName(), span = (0, import_jquery13.default)("<span>").addClass("wcdv_heading_title").text(text), headingThControls = (0, import_jquery13.default)("<div>"), headingThContainer = (0, import_jquery13.default)("<div>").addClass("wcdv_heading_container").append(span, headingThControls), th = (0, import_jquery13.default)("<th>").append(headingThContainer).appendTo(tr);
    if (self2.opts.drawInternalBorders || data.agg.info.group.length > 1) {
      if (displayOrderIndex > 0 && aggIndex === 0) {
        th.addClass("wcdv_bld");
      }
      if (displayOrderIndex < displayOrderMax - 1 && aggIndex === ai.group.length - 1) {
        th.addClass("wcdv_brd");
      }
      if (aggIndex > 0) {
        th.addClass("wcdv_pivot_colval_boundary");
      }
    }
    self2.csv.addCol(text);
    self2._addSortingToHeader(data, "vertical", { aggType: "group", aggNum }, headingThControls.get(0), ai.group);
    self2.setAlignment(th, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
  });
};
GridTable.prototype.drawHeader_addCols = function(tr, typeInfo, opts) {
  var self2 = this;
  var span, th;
  if (self2.opts.addCols) {
    index_default_default.each(self2.opts.addCols, function(addCol) {
      span = (0, import_jquery13.default)("<span>").text(addCol.name);
      th = (0, import_jquery13.default)("<th>").append(span).appendTo(tr);
      self2.csv.addCol(addCol.name);
      if (getProp(opts, "pivotConfig", "aggField")) {
        self2.setAlignment(th, self2.colConfig.get(opts.pivotConfig.aggField), typeInfo.get(opts.pivotConfig.aggField));
      }
    });
  }
};
GridTable.prototype.drawBody_rowVals = function(data, tr, rowValIndex) {
  var self2 = this;
  if (!(tr instanceof Element)) {
    throw new Error("Call Error: `tr` must be an instance of Element");
  }
  if (typeof rowValIndex !== "number") {
    throw new Error("Call Error: `rowValIndex` must be a number");
  }
  var leafMetadataNode = data.groupMetadata.lookup.byRowValIndex[rowValIndex];
  var metadataNode = leafMetadataNode;
  var th = [];
  var i2;
  for (i2 = data.groupFields.length - 1; i2 >= 0; i2 -= 1) {
    var groupField = data.groupFields[i2];
    var groupSpec = data.groupSpec[i2];
    var fcc = self2.colConfig.get(groupField) || {};
    var t2 = self2.typeInfo.get(groupField);
    var v = metadataNode.rowValCell || metadataNode.rowValElt;
    if (groupSpec.fun != null) {
      t2 = {
        type: GROUP_FUNCTION_REGISTRY.get(groupSpec.fun).resultType
      };
      v = metadataNode.rowValElt;
    }
    v = format2(fcc, t2, v);
    var headingThValue = document.createElement("span");
    headingThValue.classList.add("wcdv_heading_title");
    var headingThControls = document.createElement("div");
    var headingThContainer = document.createElement("div");
    headingThContainer.classList.add("wcdv_heading_container");
    headingThContainer.appendChild(headingThValue);
    headingThContainer.appendChild(headingThControls);
    th[i2] = document.createElement("th");
    th[i2].appendChild(headingThContainer);
    if (v instanceof import_jquery13.default) {
      v = v.get(0);
    }
    if (v instanceof Element) {
      headingThValue.appendChild(v);
    } else if (fcc.allowHtml) {
      headingThValue.innerHTML = v;
    } else {
      headingThValue.innerText = v;
    }
    self2.csv.addCol(headingThValue.innerText, {
      prepend: true
    });
    if (data.isPivot && i2 === data.groupFields.length - 1) {
      self2._addSortingToHeader(data, "horizontal", { rowVal: data.rowVals[rowValIndex], aggNum: 0 }, headingThControls, getPropDef([], data, "agg", "info", "cell"));
    }
    metadataNode = metadataNode.parent;
  }
  for (i2 = 0; i2 < data.groupFields.length; i2 += 1) {
    tr.appendChild(th[i2]);
  }
};
GridTable.prototype.drawBody_groupAggregates = function(data, tr, groupNum, displayOrderIndex, displayOrderMax) {
  var self2 = this;
  var ai = self2._getAggInfo(data);
  index_default_default.each(ai.group, function(aggInfo, aggGroupIndex) {
    var aggNum = aggInfo.aggNum;
    var aggType = aggInfo.instance.getType();
    var aggResult = data.agg.results.group[aggNum][groupNum];
    var text;
    var td = document.createElement("td");
    td.setAttribute("data-wcdv-rvi", groupNum);
    td.setAttribute("data-wcdv-agg-scope", "group");
    td.setAttribute("data-wcdv-agg-num", aggNum);
    if (aggResult instanceof import_jquery13.default) {
      aggResult = aggResult.get(0);
    }
    if (aggResult instanceof Element) {
      td.appendChild(aggResult);
      self2.csv.addCol(getElement(aggResult).innerText);
    } else {
      if (aggInfo.instance.inheritFormatting) {
        text = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
          overrideType: aggType
        });
        setTableCell(td, text, {
          field: aggInfo.fields[0],
          colConfig: aggInfo.colConfig[0],
          typeInfo: aggInfo.typeInfo[0]
        });
        td.setAttribute("data-wcdv-field", aggInfo.fields[0]);
      } else {
        text = format2(null, null, aggResult, {
          overrideType: aggType,
          decode: false
        });
        setTableCell(td, text);
      }
      self2.csv.addCol(td.innerText);
    }
    if (index_default_default.every(data.groupSpec, function(gs) {
      return gs.fun == null || GROUP_FUNCTION_REGISTRY.get(gs.fun).canFilter;
    })) {
      self2._addDrillDownClass(td);
    }
    if (self2.opts.drawInternalBorders || data.agg.info.group.length > 1) {
      if (displayOrderIndex > 0 && aggGroupIndex === 0) {
        td.classList.add("wcdv_bld");
      }
      if (displayOrderIndex < displayOrderMax - 1 && aggGroupIndex === ai.group.length - 1) {
        td.classList.add("wcdv_brd");
      }
      if (aggGroupIndex > 0) {
        td.classList.add("wcdv_pivot_colval_boundary");
      }
    }
    self2.setAlignment(td, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
    tr.appendChild(td);
  });
};
GridTable.prototype.clear = function() {
  var self2 = this;
  if (getProp(self2, "ui", "contextMenus") != null) {
    self2.ui.contextMenus.remove();
  }
  console.debug("[DataVis // %s // Clear] Removing %d context menus", self2.toString(), self2.contextMenuSelectors.length);
  index_default_default.each(self2.contextMenuSelectors, function(sel) {
    import_jquery13.default.contextMenu("destroy", sel);
  });
  self2.contextMenuSelectors = [];
  if (self2.features.limit && self2.defn.table.limit.method === "more") {
    (0, import_jquery13.default)(self2.scrollEventElement).off(self2.scrollEvents);
  }
  if (self2.features.operations) {
    (0, import_jquery13.default)(self2.root).off("click.wcdv_operation", "button.wcdv_operation");
  }
  if (getProp(self2, "ui", "tbody") != null) {
    self2.ui.tbody.off("click", "button.wcdv_show_full_value");
  }
  self2.view.off("*", self2, { silent: true });
  if (self2.opts.footer != null && self2.opts.stealGridFooter) {
    self2.grid.ui.content.get(0).appendChild(self2.opts.footer.get(0));
  }
  self2.root.children().remove();
};
GridTable.prototype.makeProgress = function(thing) {
  var self2 = this;
  if (!self2.features.progress) {
    return;
  }
  if (getProp(self2.defn, "table", "progress", "method") === "NProgress") {
    return {
      begin: function() {
        console.debug("[DataVis // %s // Progress(%s)] Begin", self2.toString(), thing);
        if (window.NProgress !== void 0) {
          window.NProgress.start();
        }
      },
      update: function(amount, estTotal) {
        console.debug("[DataVis // %s // Progress(%s)] %s", self2.toString(), thing, import_sprintf_js9.default.sprintf("Update: %d / %d = %.0f%%", amount, estTotal, amount / estTotal * 100));
        if (window.NProgress !== void 0) {
          window.NProgress.set(amount / estTotal);
        }
      },
      end: function() {
        console.debug("[DataVis // %s // Progress(%s)] End", self2.toString(), thing);
        if (window.NProgress !== void 0) {
          window.NProgress.done();
          (0, import_jquery13.default)(".nprogress-custom-parent").removeClass("nprogress-custom-parent");
        }
      }
    };
  } else if (getProp(self2.defn, "table", "progress", "method") === "jQueryUI") {
    return {
      begin: function() {
        console.debug("[DataVis // %s // Progress(%s)] Begin", self2.toString(), thing);
        self2.ui.progress.progressbar({
          "classes": {
            "ui-progressbar": "wcdvgrid_progressbar",
            "ui-progressbar-value": "wcdvgrid_progressbar"
          }
        });
      },
      update: function(amount, estTotal) {
        console.debug("[DataVis // %s // Progress(%s)] %s", self2.toString(), thing, import_sprintf_js9.default.sprintf("Update: %d / %d = %.0f%%", amount, estTotal, amount / estTotal * 100));
        self2.ui.progress.progressbar("value", amount / estTotal * 100);
      },
      end: function() {
        console.debug("[DataVis // %s // Progress(%s)] End", self2.toString(), thing);
        self2.ui.progress.progressbar("destroy");
      }
    };
  }
};
GridTable.prototype.getCsv = function() {
  var self2 = this;
  return self2.csv.toString();
};
GridTable.prototype.getSelection = function() {
  var self2 = this;
  return {
    rowIds: self2.selection,
    rows: index_default_default.map(self2.selection, function(rowId) {
      return self2.data.dataByRowId[rowId];
    })
  };
};
GridTable.prototype.setSelection = function(what) {
  var self2 = this;
  var data = self2.data.data;
  if (self2.data.isGroup) {
    data = index_default_default.flatten(data);
  } else if (self2.data.isPivot) {
    log.error("Selection is not supported for pivotted data, because there is no way to see or change the selection in the user interface");
    return;
  }
  if (what == null) {
    self2.selection = [];
  } else if (index_default_default.isArray(what)) {
    self2.selection = what;
  } else {
    log.error("GridTable#setSelection(): parameter `what` must be null/undef or an array");
    return false;
  }
  if (typeof self2._updateSelectionGui === "function") {
    self2._updateSelectionGui();
  }
  self2.fire("selectionChange", null, self2.getSelection().rows);
};
GridTable.prototype.select = function(what) {
  var self2 = this;
  var data = self2.data.data;
  if (self2.data.isGroup) {
    data = index_default_default.flatten(data);
  } else if (self2.data.isPivot) {
    log.error("Selection is not supported for pivotted data, because there is no way to see or change the selection in the user interface");
    return;
  }
  if (what == null) {
    self2.selection = index_default_default.pluck(data, "rowNum");
  } else if (index_default_default.isArray(what)) {
    self2.selection = index_default_default.union(self2.selection, what);
  } else if (typeof what === "function") {
    var passing = index_default_default.filter(data, function(d2) {
      return what(d2.rowData);
    });
    self2.selection = index_default_default.union(self2.selection, index_default_default.pluck(passing, "rowNum"));
  } else if (!index_default_default.contains(self2.selection, what)) {
    self2.selection.push(what);
  }
  if (typeof self2._updateSelectionGui === "function") {
    self2._updateSelectionGui();
  }
  self2.fire("selectionChange", null, self2.getSelection().rows);
};
GridTable.prototype.unselect = function(what) {
  var self2 = this;
  var data = self2.data.data;
  if (self2.data.isGroup) {
    data = index_default_default.flatten(data);
  } else if (self2.data.isPivot) {
    log.error("Selection is not supported for pivotted data, because there is no way to see or change the selection in the user interface");
    return;
  }
  if (what == null) {
    self2.selection = [];
  } else if (index_default_default.isArray(what)) {
    self2.selection = index_default_default.difference(self2.selection, what);
  } else if (typeof what === "function") {
    self2.selection = index_default_default.reject(self2.selection, function(x) {
      return what(self2.data.dataByRowId[x]);
    });
  } else {
    self2.selection = index_default_default.without(self2.selection, what);
  }
  if (typeof self2._updateSelectionGui === "function") {
    self2._updateSelectionGui();
  }
  self2.fire("selectionChange", null, self2.getSelection().rows);
};
GridTable.prototype.isSelected = function(what) {
  var self2 = this;
  return self2.selection.indexOf(what) >= 0;
};
GridTable.prototype._updateSelectionGui = function() {
  log.error("GridTable#_updateSelectionGui(): Must be implemented by subclass");
};
var table_default = GridTable;

// node_modules/wcdatavis/src/ui/windows/grid_table_opts.js
var GridTableOptsWin = makeSubclass("GridTableOptsWin", Object, function(renderer) {
  var self2 = this;
  if (!(renderer instanceof table_default)) {
    throw new Error("Call Error: `renderer` must be an instance of GridTable");
  }
  self2.renderer = renderer;
});
GridTableOptsWin.prototype.show = function(onSave) {
  var self2 = this;
  var curOpts = deepCopy(self2.renderer.opts);
  var canGroup = self2.renderer.canRender("group");
  var canPivot = self2.renderer.canRender("pivot");
  var effectOpts = {
    effect: "fade",
    duration: 100
  };
  var ui = {};
  var win = jQuery("<div>", { title: "Columns" }).dialog({
    autoOpen: false,
    modal: true,
    width: 600,
    position: {
      my: "center",
      at: "center",
      of: window
    },
    classes: {
      "ui-dialog": "ui-corner-all wcdv_dialog",
      "ui-dialog-titlebar": "ui-corner-all"
    },
    buttons: [{
      text: "OK",
      icon: "ui-icon-check",
      click: function() {
        curOpts = deepDefaults(curOpts, {
          displayFormat: {}
        });
        if (canPivot && ui.cellChk.prop("checked")) {
          curOpts.displayFormat.cell = [ui.cellText.val()];
        }
        win.dialog("close");
        onSave(curOpts);
      }
    }, {
      text: "Cancel",
      icon: "ui-icon-cancel",
      click: function() {
        win.dialog("close");
      }
    }],
    show: effectOpts,
    hide: effectOpts,
    close: function() {
      win.dialog("destroy");
    }
  });
  ui.root = jQuery("<div>");
  var inputs = [
    {
      field: "cell",
      available: canPivot,
      label: "Customize cell display"
    }
    /*, {
    	field: 'group',
    	available: canGroup || canPivot,
    	label: 'Customize group display',
    }, {
    	field: 'pivot',
    	available: canPivot,
    	label: 'Customize pivot display',
    }, {
    	field: 'all',
    	available: canGroup || canPivot,
    	label: 'Customize total display',
    }*/
  ];
  index_default_default.each(inputs, function(input) {
    if (input.available) {
      var curVal = getPropDef("", curOpts, "displayFormat", input.field);
      var checkbox = jQuery("<input>", { type: "checkbox", checked: !!curVal });
      var textarea = jQuery("<textarea>", { cols: 60 }).css({ display: "block", fontFamily: "monospace", marginTop: "1ex" }).val(curVal);
      var label = jQuery("<label>").css({ display: "block", marginTop: "1ex" }).append(checkbox).append(input.label);
      checkbox.on("change", function() {
        textarea.toggle();
      });
      ui[input.field + "Chk"] = checkbox;
      ui[input.field + "Text"] = textarea;
      ui.root.append(label);
      ui.root.append(textarea);
      if (!curVal) {
        textarea.hide();
      }
    }
  });
  win.append(ui.root);
  win.dialog("open");
};

// node_modules/wcdatavis/src/ui/toolbars/grid.js
var PlainToolbar = makeSubclass("PlainToolbar", ToolbarSection, function(grid) {
  var self2 = this;
  self2.super.ctor.apply(self2, []);
  self2.ui.root.addClass("wcdv_toolbar_section");
  self2.grid = grid;
  grid.ui.limit_div = jQuery("<div>").css({ "display": "inline-block" }).appendTo(self2.ui.root);
  self2.ui.autoShowMore = makeToggleCheckbox(
    grid.defn,
    ["table", "limit", "autoShowMore"],
    true,
    trans("GRID_TOOLBAR.PLAIN.SHOW_MORE_ON_SCROLL"),
    grid.ui.limit_div
  );
  jQuery("<button>", { "type": "button" }).on("click", function(evt) {
    grid.renderer.updateFeatures({
      "block": true,
      "progress": true,
      "limit": false
    });
  }).text(trans("GRID_TOOLBAR.PLAIN.SHOW_ALL_ROWS")).appendTo(grid.ui.limit_div);
  self2.ui.columnConfig = jQuery("<button>", {
    "type": "button"
  }).append(fontAwesome("fa-columns")).append(trans("GRID_TOOLBAR.PLAIN.COLUMNS")).on("click", function(evt) {
    grid.colConfigWin.show(grid.ui.controls, function(colConfig) {
      grid.setColConfig(colConfig, {
        from: "ui"
      });
    });
  }).appendTo(self2.ui.root);
  self2.ui.TemplatesEditor = jQuery("<button>", {
    "type": "button"
  }).append(fontAwesome("fa-pencil")).append(trans("GRID_TOOLBAR.PLAIN.TEMPLATES_EDITOR")).on("click", function(evt) {
    grid.TemplatesEditor.show();
  }).appendTo(self2.ui.root);
});
PlainToolbar.prototype.update = function() {
  var self2 = this;
  if (self2.grid.renderer.features.limit) {
    self2.grid.ui.limit_div.show();
    self2.ui.autoShowMore.show();
  } else {
    self2.grid.ui.limit_div.hide();
    self2.ui.autoShowMore.hide();
  }
  switch (self2.grid.rendererName) {
    case "table":
      self2.ui.columnConfig.show();
      self2.ui.TemplatesEditor.hide();
      break;
    case "handlebars":
      self2.ui.columnConfig.hide();
      self2.ui.TemplatesEditor.show();
      break;
  }
};
var GroupToolbar = makeSubclass("GroupToolbar", ToolbarSection, function(grid) {
  var self2 = this;
  self2.super.ctor.apply(self2, []);
  self2.ui.root.addClass("wcdv_toolbar_section");
  self2.grid = grid;
  var aggSpec;
  grid.view.on("aggregateSet", function(a2) {
    aggSpec = deepCopy(a2);
  });
  var enableDisable = function(selected) {
    switch (selected) {
      case "summary":
        self2.ui.showTotalRow.prop("disabled", false);
        self2.ui.pinRowVals.prop("disabled", false);
        self2.ui.columnConfig.prop("disabled", true);
        break;
      case "detail":
        self2.ui.showTotalRow.prop("disabled", true);
        self2.ui.pinRowVals.prop("disabled", true);
        self2.ui.columnConfig.prop("disabled", false);
        break;
    }
  };
  self2.ui.groupMode = makeRadioButtons(
    grid.defn,
    ["table", "groupMode"],
    "detail",
    null,
    "groupOutput",
    [
      { label: trans("GRID_TOOLBAR.GROUP.MODE.SUMMARY"), value: "summary" },
      { label: trans("GRID_TOOLBAR.GROUP.MODE.DETAIL"), value: "detail" }
    ],
    null,
    function(selected) {
      enableDisable(selected);
      grid.redraw();
    },
    self2.ui.root
  );
  self2.ui.showTotalRow = makeToggleCheckbox(
    grid.defn,
    ["table", "whenGroup", "showTotalRow"],
    true,
    trans("GRID_TOOLBAR.GROUP.TOTAL_ROW"),
    self2.ui.root,
    function(isChecked) {
      var agg = grid.view.getAggregate();
      if (!isChecked) {
        aggSpec = deepCopy(agg);
        delete agg.all;
      } else {
        agg.all = aggSpec.all;
      }
      grid.view.setAggregate(agg, {
        sendEvent: false
      });
    }
  );
  self2.ui.pinRowVals = makeToggleCheckbox(
    grid.defn,
    ["table", "whenGroup", "pinRowvals"],
    false,
    trans("GRID_TOOLBAR.GROUP.PIN_GROUPS"),
    self2.ui.root,
    function(isChecked) {
      grid.redraw();
    }
  );
  self2.ui.columnConfig = jQuery("<button>", {
    "type": "button"
  }).append(fontAwesome("fa-columns")).append(trans("GRID_TOOLBAR.PLAIN.COLUMNS")).on("click", function(evt) {
    grid.colConfigWin.show(grid.ui.controls, function(colConfig) {
      grid.setColConfig(colConfig, {
        from: "ui"
      });
    });
  }).appendTo(self2.ui.root);
  self2.ui.TemplatesEditor = jQuery("<button>", {
    "type": "button"
  }).append(fontAwesome("fa-pencil")).append(trans("GRID_TOOLBAR.PLAIN.TEMPLATES_EDITOR")).on("click", function(evt) {
    grid.TemplatesEditor.show();
  }).appendTo(self2.ui.root);
  enableDisable(grid.defn.table.groupMode);
});
GroupToolbar.prototype.update = function() {
  var self2 = this;
  switch (self2.grid.rendererName) {
    case "table":
      self2.ui.groupMode.show();
      self2.ui.showTotalRow.show();
      self2.ui.pinRowVals.show();
      self2.ui.columnConfig.show();
      self2.ui.TemplatesEditor.hide();
      break;
    case "handlebars":
      self2.ui.groupMode.hide();
      self2.ui.showTotalRow.hide();
      self2.ui.pinRowVals.hide();
      self2.ui.columnConfig.hide();
      self2.ui.TemplatesEditor.show();
      break;
  }
};
var PivotToolbar = makeSubclass("PivotToolbar", ToolbarSection, function(grid) {
  var self2 = this;
  self2.super.ctor.apply(self2, []);
  self2.ui.root.addClass("wcdv_toolbar_section");
  self2.grid = grid;
  var aggSpec;
  grid.view.on("aggregateSet", function(a2) {
    aggSpec = deepCopy(a2);
  });
  self2.ui.showTotals = makeToggleCheckbox(
    grid.defn,
    ["table", "whenPivot", "showTotalCol"],
    true,
    trans("GRID_TOOLBAR.PIVOT.TOTAL_ROW_COLUMN"),
    self2.ui.root,
    function(isChecked) {
      var agg = grid.view.getAggregate();
      if (!isChecked) {
        aggSpec = deepCopy(agg);
        delete agg.group;
        delete agg.pivot;
        delete agg.all;
      } else {
        agg.group = aggSpec.group;
        agg.pivot = aggSpec.pivot;
        agg.all = aggSpec.all;
      }
      grid.view.setAggregate(agg, {
        sendEvent: false
      });
    }
  );
  self2.ui.pinRowVals = makeToggleCheckbox(
    grid.defn,
    ["table", "whenGroup", "pinRowvals"],
    false,
    trans("GRID_TOOLBAR.GROUP.PIN_GROUPS"),
    self2.ui.root,
    function(isChecked) {
      grid.redraw();
    }
  );
  self2.ui.hideBottomValueAggResults = makeToggleCheckbox(
    grid.defn,
    ["table", "whenPivot", "hideBottomValueAggResults"],
    false,
    trans("GRID_TOOLBAR.PIVOT.HIDE_ZERO_VALUES"),
    self2.ui.root,
    function(isChecked) {
      grid.redraw();
    }
  );
  self2.ui.TemplatesEditor = jQuery("<button>", {
    "type": "button"
  }).append(fontAwesome("fa-pencil")).append(trans("GRID_TOOLBAR.PLAIN.TEMPLATES_EDITOR")).on("click", function(evt) {
    grid.TemplatesEditor.show();
  }).appendTo(self2.ui.root);
});
PivotToolbar.prototype.update = function() {
  var self2 = this;
  switch (self2.grid.rendererName) {
    case "table":
      self2.ui.showTotals.show();
      self2.ui.pinRowVals.show();
      self2.ui.TemplatesEditor.hide();
      break;
    case "handlebars":
      self2.ui.showTotals.hide();
      self2.ui.pinRowVals.hide();
      self2.ui.TemplatesEditor.show();
      break;
  }
};
var PrefsToolbar = makeSubclass("PrefsToolbar", ToolbarSection, function(grid) {
  var self2 = this;
  self2.super.ctor.apply(self2, []);
  self2.ui.root.addClass("wcdv_toolbar_section");
  self2.grid = grid;
  var div = jQuery("<div>").addClass("wcdv_toolbar_view").css({ "display": "inline-block" }).appendTo(self2.ui.root);
  var options = {};
  var showHideBtns = function() {
    var p = grid.prefs.getPerspective({ id: dropdown.val() });
    if (p == null) {
      throw new Error("No such perspective: " + dropdown.val());
    }
    if (p.opts.isTemporary) {
      saveAsBtn.show();
    } else {
      saveAsBtn.hide();
    }
    if (p.opts.isEssential) {
      renameBtn.hide();
      deleteBtn.hide();
    } else {
      renameBtn.show();
      deleteBtn.show();
    }
  };
  var removePerspectiveFromDropdown = function(name) {
    options[name].remove();
    delete options[name];
  };
  var resetBtn = jQuery("<button>", { "type": "button", "title": trans("GRID_TOOLBAR.PREFS.RESET.TOOLTIP") }).addClass("wcdv_icon_button wcdv_text-primary").append(fontAwesome("fa-undo")).on("click", function() {
    if (confirm(trans("GRID_TOOLBAR.PREFS.RESET.CONFIRM"))) {
      grid.prefs.reset();
    }
  }).appendTo(div);
  var backBtn = jQuery("<button>", { "type": "button" }).append(fontAwesome("fa-chevron-circle-left")).attr("title", trans("GRID_TOOLBAR.PREFS.BACK.TOOLTIP")).attr("disabled", true).addClass("wcdv_icon_button wcdv_text-primary").on("click", function() {
    grid.prefs.back();
  }).appendTo(div);
  var forwardBtn = jQuery("<button>", { "type": "button" }).append(fontAwesome("fa-chevron-circle-right")).attr("title", trans("GRID_TOOLBAR.PREFS.FORWARD.TOOLTIP")).attr("disabled", true).addClass("wcdv_icon_button wcdv_text-primary").on("click", function() {
    grid.prefs.forward();
  }).appendTo(div);
  var dropdown = jQuery("<select>").append(jQuery("<option>", { value: "NEW" }).text(trans("GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE"))).on("change", function(evt) {
    if (dropdown.val() === "NEW") {
      var name = prompt(trans("GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE.PROMPT"), grid.prefs.currentPerspective.name);
      if (name) {
        grid.prefs.addPerspective(null, name);
        grid.prefs.save();
      } else {
        dropdown.val(grid.prefs.currentPerspective.id);
      }
      return;
    }
    grid.prefs.setCurrentPerspective(dropdown.val());
    showHideBtns();
  }).appendTo(div);
  var warnMsgText = jQuery("<span>");
  var warnMsgContent = jQuery("<div>").append(fontAwesome("fa-info-circle").css("padding-right", "0.25em").addClass("wcdv_text-primary")).append(warnMsgText);
  var warnMsg = fontAwesome("fa-info-circle", "wcdv_info_icon").attr({ "title": trans("GRID_TOOLBAR.PREFS.INFO.TOOLTIP") }).hide().tooltip({
    classes: {
      "ui-tooltip": "ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary"
    },
    show: { delay: 1e3 },
    content: warnMsgContent
  }).appendTo(div);
  if (grid.prefs.backend instanceof PrefsBackendTemporary) {
    warnMsgText.text(trans("GRID_TOOLBAR.PREFS.BACKEND_DOES_NOT_SAVE"));
    warnMsg.show();
  }
  var saveAsBtnTooltipContent = jQuery("<div>").append(fontAwesome("fa-info-circle").css("padding-right", "0.25em").addClass("wcdv_text-primary")).append(trans("GRID_TOOLBAR.PREFS.SAVE_AS.HELP"));
  var saveAsBtn = jQuery("<button>", { "type": "button", "title": trans("GRID_TOOLBAR.PREFS.SAVE_AS.TOOLTIP") }).append(fontAwesome("fa-save")).addClass("wcdv_icon_button wcdv_text-primary").tooltip({
    classes: {
      "ui-tooltip": "ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary"
    },
    show: { delay: 1e3 },
    content: saveAsBtnTooltipContent
  }).on("click", function() {
    grid.prefs.clonePerspective();
  }).appendTo(div);
  var saveBtnTooltipContent = jQuery("<div>").append(fontAwesome("fa-info-circle").css("padding-right", "0.25em").addClass("wcdv_text-primary")).append(trans("GRID_TOOLBAR.PREFS.SAVE.HELP"));
  var saveBtn = jQuery("<button>", { "type": "button", "title": trans("GRID_TOOLBAR.PREFS.SAVE.TOOLTIP") }).append(fontAwesome("fa-save")).addClass("wcdv_icon_button wcdv_text-primary").hide().on("click", function() {
    grid.prefs.reallySave();
  }).appendTo(div);
  var renameBtn = jQuery("<button>", { "type": "button", "title": trans("GRID_TOOLBAR.PREFS.RENAME.TOOLTIP") }).addClass("wcdv_icon_button wcdv_text-primary").append(fontAwesome("fa-pencil")).on("click", function() {
    var id = dropdown.val();
    var p = grid.prefs.getPerspective({ id });
    if (p.opts.isEssential) {
      alert("Cannot rename essential perspective!");
    } else {
      var newName = prompt(trans("GRID_TOOLBAR.PREFS.RENAME_PERSPECTIVE.PROMPT", p.name));
      if (newName) {
        grid.prefs.renamePerspective(id, newName);
      }
    }
  }).appendTo(div);
  var deleteBtn = jQuery("<button>", { "type": "button", "title": trans("GRID_TOOLBAR.PREFS.DELETE.TOOLTIP") }).addClass("wcdv_icon_button wcdv_text-primary").append(fontAwesome("fa-trash")).on("click", function() {
    if (confirm(trans("GRID_TOOLBAR.PREFS.DELETE_PERSPECTIVE.CONFIRM"))) {
      grid.prefs.deletePerspective(dropdown.val());
    }
  }).appendTo(div);
  setTimeout(function() {
    grid.prefs.prime(function() {
      grid.prefs.getPerspectives(function(ids) {
        index_default_default.each(index_default_default.sortBy(index_default_default.map(ids, function(id) {
          return grid.prefs.getPerspective({ id });
        }), "name"), function(o2) {
          if (options[o2.id] == null) {
            options[o2.id] = jQuery("<option>", { "value": o2.id }).text(o2.name).appendTo(dropdown);
          }
        });
        dropdown.val(grid.prefs.currentPerspective.id);
        showHideBtns();
      });
      grid.prefs.on("perspectiveAdded", function(id) {
        if (options[id] == null) {
          var p = grid.prefs.getPerspective({ id });
          options[id] = jQuery("<option>", { value: id }).text(p.name).appendTo(dropdown);
        }
      }, {
        info: "Adding new perspective to dropdown"
      });
      grid.prefs.on("perspectiveDeleted", function(id) {
        if (options[id] == null) {
          throw new Error(import_sprintf_js10.default.sprintf('Received `perspectiveDeleted` event that references unknown perspective: id = "%s"', id));
        }
        options[id].remove();
        delete options[id];
      }, {
        info: "Removing perspective from dropdown"
      });
      grid.prefs.on("perspectiveRenamed", function(id, newName) {
        if (options[id] == null) {
          throw new Error(import_sprintf_js10.default.sprintf('Received `perspectiveRenamed` event that references unknown perspective: id = "%s"', id));
        }
        options[id].text(newName);
      }, {
        info: "Changing perspective name in dropdown"
      });
      grid.prefs.on("perspectiveChanged", function(id, p) {
        if (options[id] == null) {
          throw new Error(import_sprintf_js10.default.sprintf('Received `perspectiveChanged` event that references unknown perspective: id = "%s"', id));
        }
        if (p.isUnsaved) {
          saveBtn.show();
        } else {
          saveBtn.hide();
        }
        dropdown.val(id);
        showHideBtns();
      }, {
        info: "Changing dropdown to reflect new current perspective"
      });
      grid.prefs.on("prefsReset", function() {
        index_default_default.each(options, function(elt2) {
          elt2.remove();
        });
        options = {};
      }, {
        info: "Deleting all perspectives from the dropdown"
      });
      grid.prefs.on("prefsChanged", function() {
        var cp = grid.prefs.currentPerspective;
        var o2 = options[cp.id];
        o2.text("[*] " + cp.name);
        saveBtn.show();
      });
      grid.prefs.on("prefsSaved", function() {
        var cp = grid.prefs.currentPerspective;
        var o2 = options[cp.id];
        o2.text(cp.name);
        saveBtn.hide();
      });
      grid.prefs.on("prefsHistoryStatus", function(back, forward) {
        backBtn.attr("disabled", !back);
        forwardBtn.attr("disabled", !forward);
      });
    });
  });
});
var RendererToolbar = makeSubclass("RendererToolbar", ToolbarSection, function(grid) {
  var self2 = this;
  self2.super.ctor.apply(self2, []);
  self2.ui.root.addClass("wcdv_toolbar_section");
  self2.grid = grid;
  var div = jQuery("<div>").addClass("wcdv_toolbar_view").css({ "display": "inline-block" }).appendTo(self2.ui.root);
  var configBtn = jQuery("<button>", { "type": "button", "title": trans("GRID_TOOLBAR.RENDERER.DISPLAY_OPTIONS") }).append(fontAwesome("fa-table")).append(trans("GRID_TOOLBAR.RENDERER.DISPLAY_OPTIONS")).on("click", function() {
    var gridTableOptsWin = new GridTableOptsWin(grid.renderer);
    gridTableOptsWin.show(function(newOpts) {
      if (grid.renderer.canRender("plain")) {
        grid.defn.table.whenPlain = newOpts;
      } else if (grid.renderer.canRender("group")) {
        grid.defn.table.whenGroup = newOpts;
      } else if (grid.renderer.canRender("pivot")) {
        grid.defn.table.whenPivot = newOpts;
      }
      grid.redraw();
    });
  }).appendTo(div);
  grid.on("renderEnd", function() {
    configBtn.prop("disabled", grid.renderer.canRender("plain"));
  });
});
var ComputedViewToolbar = makeSubclass("ComputedViewToolbar", ToolbarSection, function(grid) {
  var self2 = this;
  self2.super.ctor.apply(self2, []);
  self2.ui.root.addClass("wcdv_toolbar_section");
  self2.grid = grid;
  var div = jQuery("<div>").addClass("wcdv_toolbar_view").css({ "display": "inline-block" }).appendTo(self2.ui.root);
  jQuery("<button>", { "type": "button", "title": trans("GRID_TOOLBAR.MIRAGE.STORE_DISPLAYED_DATA") }).append(fontAwesome("fa-save")).append(trans("GRID_TOOLBAR.MIRAGE.STORE_DISPLAYED_DATA")).on("click", function() {
    var perspectiveName = prompt(trans("GRID_TOOLBAR.PREFS.NEW_PERSPECTIVE.PROMPT"), grid.prefs.currentPerspective.name);
    if (perspectiveName != null) {
      grid.mirageView.initFromView(grid.view.prefs, grid.view, grid.view.source, function() {
        grid.mirageView.setPerspectiveName(perspectiveName);
        grid.mirageView.save(function() {
          grid.prefs.clonePerspective(null, perspectiveName, function(config) {
            config.mirageView = deepCopy(config.computedView);
            config.isMirage = true;
            return config;
          }, function() {
          }, function(errMsg) {
            if (errMsg != null) {
              alert(errMsg);
            }
          });
        }, function(msg) {
          log.error("Failed to save mirage view: " + msg);
        });
      }, function(msg) {
        log.error("Failed to initialize mirage view: " + msg);
      });
    }
  }).appendTo(div);
  self2.grid.on("renderEnd", function() {
    if (self2.grid.view instanceof ComputedView) {
      self2.show();
    } else {
      self2.hide();
    }
  });
});

// node_modules/wcdatavis/src/operations_palette.js
var import_sprintf_js11 = __toESM(require_sprintf());
var import_jquery14 = __toESM(require_jquery());
var OperationsPalette = makeSubclass("OperationsPalette", Object, function(grid) {
  var self2 = this;
  self2.ui = {
    root: null,
    title: null,
    palette: null
  };
  self2.operations = [];
  if (!(grid instanceof Grid)) {
    throw new Error("Call Error: `grid` must be a Grid");
  }
  self2.grid = grid;
});
OperationsPalette.prototype.draw = function(parent) {
  var self2 = this;
  self2.ui.root = (0, import_jquery14.default)("<div>", {
    "class": "wcdv_control_pane"
  }).css({
    "display": "block"
  }).appendTo(parent);
  self2.ui.title = (0, import_jquery14.default)("<div>").addClass("wcdv_control_title_bar").appendTo(self2.ui.root);
  (0, import_jquery14.default)("<span>", { "class": "wcdv_control_title" }).text(trans("GRID_CONTROL.OPERATIONS.TITLE")).appendTo(self2.ui.title);
  self2.ui.palette = (0, import_jquery14.default)("<div>").css({
    "overflow-x": "auto",
    "white-space": "nowrap"
  }).appendTo(self2.ui.root);
  if (self2.operations.length > 0) {
    self2.drawPalette();
    parent.show();
  } else {
    parent.hide();
  }
  self2.ui.palette.on("click.wcdv_operation", "button.wcdv_operation", function() {
    var btn = this;
    var opIndex = btn.getAttribute("data-operation-index");
    var op = self2.operations[opIndex];
    if (typeof op.callback === "function") {
      op.callback({
        rows: self2.grid.getSelection().rows,
        opBtn: (0, import_jquery14.default)(btn)
      });
    }
  });
};
OperationsPalette.prototype.drawPalette = function() {
  var self2 = this;
  self2.ui.palette.children().remove();
  index_default_default.each(index_default_default.groupBy(self2.operations, "category"), function(ops, c2) {
    var catDiv = (0, import_jquery14.default)("<div>", {
      "class": "wcdv_operations_category"
    }).appendTo(self2.ui.palette);
    if (c2 !== "undefined") {
      var catLabel = (0, import_jquery14.default)("<span>").text(c2).appendTo(catDiv);
    }
    index_default_default.each(ops, function(op) {
      var btn = (0, import_jquery14.default)("<button>", {
        "type": "button",
        "class": "wcdv_operation",
        "data-operation-index": op.idx
      }).appendTo(catDiv);
      if (op.label == null) {
        btn.addClass("no_label");
      }
      if (op.icon) {
        btn.append(fontAwesome(op.icon));
      }
      if (op.label) {
        btn.append(op.label);
      }
    });
  });
};
OperationsPalette.prototype.destroy = function() {
  var self2 = this;
  self2.ui.palette.off("click.wcdv_operation");
  self2.ui.root.remove();
};
OperationsPalette.prototype.setOperations = function(ops) {
  var self2 = this;
  if (ops == null || ops.all == null) {
    return;
  }
  var i2 = 0;
  index_default_default.each(ops.all, function(o2) {
    o2.idx = i2;
    i2 += 1;
  });
  self2.operations = ops.all;
  if (self2.ui.palette != null) {
    self2.drawPalette();
  }
};

// node_modules/wcdatavis/src/renderers/grid/table/plain.js
var import_sprintf_js12 = __toESM(require_sprintf());
var import_jquery15 = __toESM(require_jquery());
var GridTablePlain = makeSubclass("GridTablePlain", table_default, function(grid, defn, view, features, opts, timing, id) {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.features.filter = false;
  console.debug("DataVis // %s // Constructing grid table; features = %O", self2.toString(), features);
  self2.addFilterHandler();
});
GridTablePlain.prototype.canRender = function(what) {
  return ["plain"].indexOf(what) >= 0;
};
GridTablePlain.prototype.drawHeader = function(columns, data, typeInfo, opts) {
  var self2 = this;
  var headingTr, headingSpan, headingTh, filterTr;
  var headingThCss = {
    "white-space": "nowrap"
  };
  var filterThCss = {
    "white-space": "nowrap",
    "padding-top": 4,
    "vertical-align": "top"
  };
  headingTr = (0, import_jquery15.default)("<tr>");
  filterTr = (0, import_jquery15.default)("<tr>", {
    "class": "wcdv_grid_filterrow"
  });
  if (self2.features.rowSelect) {
    self2.ui.checkAll_thead = (0, import_jquery15.default)("<input>", { "name": "checkAll", "type": "checkbox" }).on("change", function(evt) {
      self2.checkAll(evt);
    });
    headingTh = (0, import_jquery15.default)("<th>").addClass("wcdv_group_col_spacer").append(self2.ui.checkAll_thead).appendTo(headingTr);
    if (self2.opts.drawInternalBorders) {
      headingTh.addClass("wcdv_pivot_colval_boundary");
    }
    if (self2.features.filter) {
      filterTr.append((0, import_jquery15.default)("<th>").css(filterThCss));
    }
  }
  if (self2.hasOperations("row")) {
    headingTh = (0, import_jquery15.default)("<th>", {
      "class": "wcdv_group_col_spacer"
    });
    headingTr.append(headingTh);
  }
  var progress = self2.makeProgress("Filter");
  if (self2.features.filter) {
    self2.defn.gridFilterSet = new GridFilterSet(self2.view, null, self2, progress);
  }
  index_default_default.each(columns, function(field, colIndex) {
    var fcc = self2.colConfig.get(field) || {};
    if (self2.features.rowSelect) {
      colIndex += 1;
    }
    if (self2.hasOperations("row")) {
      colIndex += 1;
    }
    var headingText = fcc.displayText || field;
    var headingSpan2 = (0, import_jquery15.default)("<span>", {
      "class": "wcdv_heading_title",
      "data-wcdv-field": field,
      "data-wcdv-draggable-origin": "GRID_TABLE_HEADER"
    }).text(headingText)._makeDraggableField();
    var headingThControls = (0, import_jquery15.default)("<div>");
    var headingThContainer = (0, import_jquery15.default)("<div>").addClass("wcdv_heading_container").append(headingSpan2, headingThControls);
    var headingTh2 = (0, import_jquery15.default)("<th>", { id: gensym() }).css(headingThCss).append(headingThContainer);
    self2._addSortingToHeader(data, "vertical", { field }, headingThControls.get(0));
    self2._addFilterToHeader(headingThControls, field, headingText);
    if (self2.opts.drawInternalBorders) {
      headingTh2.addClass("wcdv_pivot_colval_boundary");
    }
    if (self2.features.filter) {
      var filterThId = gensym();
      var filterTh = (0, import_jquery15.default)("<th>", { id: filterThId }).addClass("wcdv_grid_filtercol filter_col_" + colIndex).css(filterThCss);
      self2.setCss(filterTh, field);
      filterTr.append(filterTh);
      (0, import_jquery15.default)(fontAwesome("F0B0", null, "Click to add a filter on this column")).css({ "cursor": "pointer", "margin-left": "0.5ex" }).on("click", function() {
        var thead = (0, import_jquery15.default)(this).closest("thead");
        var tr = thead.children("tr:eq(1)");
        var th = tr.children("th.filter_col_" + colIndex);
        var adjustTableToolHeight = function() {
          if (self2.features.floatingHeader) {
            var trHeight = tr.innerHeight();
            console.debug("[DataVis // %s // Add Filter] Adjusting original table header height to " + trHeight + "px to match floating header height", self2.toString());
            filterTr.innerHeight(trHeight);
          }
        };
        var onRemove = adjustTableToolHeight;
        self2.defn.gridFilterSet.add(field, th, {
          filterType: fcc.filter,
          filterButton: (0, import_jquery15.default)(this),
          makeRemoveButton: true,
          onRemove,
          autoUpdateInputWidth: true,
          sizingElement: filterTh
        });
        adjustTableToolHeight();
      }).appendTo(headingTh2);
    }
    self2.setCss(headingTh2, field);
    self2.setAlignment(headingTh2, fcc, typeInfo.get(field));
    self2.ui.thMap[field] = headingTh2;
    headingTr.append(headingTh2);
  });
  if (self2.opts.addCols) {
    self2.drawHeader_addCols(headingTr, typeInfo, opts);
  }
  if (self2.features.rowReorder) {
    headingTh = (0, import_jquery15.default)("<th>").text("Options").appendTo(headingTr);
    if (self2.opts.drawInternalBorders) {
      headingTh.addClass("wcdv_pivot_colval_boundary");
    }
    if (self2.features.filter) {
      headingTh = (0, import_jquery15.default)("<th>").css(filterThCss).appendTo(filterTr);
      if (self2.opts.drawInternalBorders) {
        headingTh.addClass("wcdv_pivot_colval_boundary");
      }
    }
  }
  self2.ui.thead.append(headingTr);
  if (self2.features.filter) {
    self2.ui.thead.append(filterTr);
  }
};
GridTablePlain.prototype.drawBody = function(data, typeInfo, columns, cont, opts) {
  var self2 = this;
  var useLimit = self2.features.limit;
  var limitConfig = getPropDef({}, self2.defn, "table", "limit");
  if (self2.features.limit && limitConfig && data.data.length > limitConfig.threshold) {
    console.debug("[DataVis // %s // Draw] Limiting output to first " + limitConfig.threshold + " rows", self2.toString());
  }
  if (self2.opts.generateCsv) {
    self2.addDataToCsv(data);
  }
  self2.ui.tbody.children().remove();
  self2._setupFullValueWin(data);
  var renderDataRow = function(row) {
    var tr, td;
    tr = document.createElement("tr");
    tr.setAttribute("id", self2.defn.table.id + "_" + row.rowNum);
    tr.setAttribute("data-row-num", row.rowNum);
    if (self2.features.rowSelect) {
      var checkbox = (0, import_jquery15.default)("<input>", {
        "type": "checkbox",
        "data-row-num": row.rowNum
      });
      td = (0, import_jquery15.default)("<td>").addClass("wcdv_group_col_spacer").append(checkbox).appendTo(tr);
      if (self2.opts.drawInternalBorders) {
        td.addClass("wcdv_pivot_colval_boundary");
      }
    }
    if (self2.hasOperations("row")) {
      td = document.createElement("td");
      td.classList.add("wcdv_group_col_spacer");
      td.classList.add("wcdv_pivot_colval_boundary");
      td.classList.add("wcdv_nowrap");
      td.classList.add("wcdv_row_operations");
      index_default_default.each(self2.defn.operations.row, function(op, index2) {
        td.appendChild(makeOperationButton("row", op, index2));
      });
      tr.appendChild(td);
    }
    index_default_default.each(columns, function(field, colIndex) {
      var fcc = self2.colConfig.get(field) || {};
      var cell = row.rowData[field];
      var td2 = document.createElement("td");
      var value = format2(fcc, typeInfo.get(field), cell);
      setTableCell(td2, value, {
        field,
        colConfig: self2.colConfig,
        typeInfo,
        operations: getProp(self2.defn, "operations", "cell", field)
      });
      if (fcc.maxHeight != null || self2.hasOperations("cell", field)) {
        td2.setAttribute("data-wcdv-field", field);
      }
      self2.setCss((0, import_jquery15.default)(td2), field);
      self2.setAlignment(td2, fcc, typeInfo.get(field));
      if (self2.opts.drawInternalBorders) {
        td2.classList.add("wcdv_pivot_colval_boundary");
      }
      tr.appendChild(td2);
    });
    if (self2.opts.addCols) {
      index_default_default.each(self2.opts.addCols, function(addColSpec) {
        var value = addColSpec.value(row.rowData, row.rowNum);
        var td2 = document.createElement("td");
        if (!(value instanceof import_jquery15.default || value instanceof Element)) {
          value = format2(null, null, value);
        }
        setTableCell(td2, value);
        if (self2.opts.drawInternalBorders) {
          td2.classList.add("wcdv_pivot_colval_boundary");
        }
        tr.appendChild(td2);
      });
    }
    if (self2.features.rowReorder) {
      (0, import_jquery15.default)("<td>").append(self2.makeRowReorderBtn()).appendTo(tr);
    }
    self2.ui.tr[row.rowNum] = (0, import_jquery15.default)(tr);
    self2.ui.tbody.append(tr);
  };
  var renderShowMore = function(rowNum) {
    var tr;
    tr = document.createElement("tr");
    tr.classList.add("wcdvgrid_more");
    var colSpan = columns.length + (self2.features.rowSelect ? 1 : 0) + (self2.hasOperations("row") ? 1 : 0) + getPropDef(0, self2.opts, "addCols", "length") + (self2.features.rowReorder ? 1 : 0);
    var showMore = function() {
      tr.parentNode.removeChild(tr);
      render(rowNum + 1, limitConfig.chunkSize, nextChunk);
    };
    var td = (0, import_jquery15.default)("<td>", {
      colspan: colSpan
    }).on("click", showMore).append(fontAwesome("F13A")).append((0, import_jquery15.default)("<span>Showing rows 1" + (rowNum + 1) + " of " + data.data.length + ".</span>").css({
      "padding-left": "0.5em"
    })).append((0, import_jquery15.default)("<span>Click to load " + limitConfig.chunkSize + " more rows.</span>").css({
      "padding-left": "0.5em",
      "padding-right": "0.5em"
    })).append(fontAwesome("F13A"));
    self2.moreVisibleHandler = onVisibilityChange(self2.scrollEventElement, td, function(isVisible2) {
      if (isVisible2 && getProp(self2.defn, "table", "limit", "autoShowMore")) {
        console.debug('[DataVis // %s // More] "Show More Rows" button scrolled into view', self2.toString());
        showMore();
      }
    });
    tr.appendChild(td.get(0));
    self2.ui.tbody.append(tr);
  };
  var render = function(startIndex, howMany, nextChunk2) {
    var atLimit = false;
    if (startIndex == null) {
      startIndex = 0;
    }
    if (howMany == null) {
      howMany = data.data.length;
    }
    console.debug("[DataVis // %s // Draw] Rendering rows " + startIndex + " - " + Math.min(
      useLimit && startIndex === 0 ? limitConfig.threshold - 1 : Number.POSITIVE_INFINITY,
      startIndex + howMany - 1,
      data.data.length - 1
    ) + " " + (data.data.length - 1 <= startIndex + howMany - 1 ? "[END]" : "/ " + data.data.length - 1), self2.toString());
    for (var rowNum = startIndex; rowNum < data.data.length && rowNum < startIndex + howMany && !atLimit; rowNum += 1) {
      renderDataRow(data.data[rowNum]);
      if (!self2.features.incremental && useLimit && limitConfig.method === "more" && rowNum !== data.data.length - 1 && (startIndex === 0 && rowNum === limitConfig.threshold - 1 || startIndex > 0 && rowNum === startIndex + limitConfig.chunkSize - 1)) {
        renderShowMore(rowNum);
        atLimit = true;
      }
    }
    if (atLimit) {
      self2.fire("limited");
    } else {
      self2.fire("unlimited");
    }
    self2._updateSelectionGui();
    if (self2.features.floatingHeader) {
      switch (getProp(self2.defn, "table", "floatingHeader", "method")) {
        case "tabletool":
          window.TableTool.update();
          break;
      }
    }
    if (rowNum === data.data.length) {
      delete self2.moreVisibleHandler;
      if (typeof cont === "function") {
        return cont();
      }
      return;
    } else if (typeof nextChunk2 === "function") {
      return nextChunk2(startIndex, howMany);
    }
    if (typeof cont === "function") {
      return cont();
    }
    return;
  };
  var nextChunk;
  if (self2.features.incremental) {
    var incrementalConfig = self2.defn.table.incremental;
    if (incrementalConfig.method === "setTimeout") {
      nextChunk = function(startIndex, howMany) {
        window.setTimeout(function() {
          render(startIndex + howMany, howMany, nextChunk);
        }, incrementalConfig.delay);
      };
      window.setTimeout(function() {
        render(0, incrementalConfig.chunkSize, nextChunk);
      }, incrementalConfig.delay);
    } else if (incrementalConfig.method === "requestAnimationFrame") {
      nextChunk = function(startIndex, howMany) {
        window.requestAnimationFrame(function() {
          render(startIndex + howMany, howMany, nextChunk);
        });
      };
      window.requestAnimationFrame(function() {
        render(0, incrementalConfig.chunkSize, nextChunk);
      });
    } else {
      throw new Error("Invalid value for `table.incremental.method` (" + incrementalConfig.method + ') - must be either "setTimeout" or "requestAnimationFrame"');
    }
  } else {
    render();
  }
};
GridTablePlain.prototype.drawFooter = function(columns, data, typeInfo) {
  var self2 = this;
  var makeSelectAll = function(tr) {
    self2.ui.checkAll_tfoot = (0, import_jquery15.default)("<input>", { "name": "checkAll", "type": "checkbox" }).on("change", function(evt) {
      self2.checkAll(evt);
    });
    (0, import_jquery15.default)("<td>", { "class": "wcdv_group_col_spacer" }).append(self2.ui.checkAll_tfoot).appendTo(tr);
  };
  var makeAggregateRow = function() {
    if (false) {
      return;
    }
    var tr = (0, import_jquery15.default)("<tr>");
    if (self2.features.rowSelect) {
      makeSelectAll(tr);
    }
    var didFooterCell = false;
    tr.append(index_default_default.map(columns, function(field, colIndex) {
      var fcc = self2.colConfig.get(field) || {};
      var colTypeInfo = typeInfo.get(field);
      var td = (0, import_jquery15.default)("<td>");
      var footerConfig = getProp(self2.defn, "table", "footer", field);
      var agg;
      var aggFun;
      var aggResult;
      var footerVal;
      self2.setCss(td, field);
      self2.setAlignment(td, fcc, typeInfo.get(field));
      if (footerConfig == null) {
        if (didFooterCell) {
          td.addClass("wcdv_divider");
        }
        didFooterCell = false;
      } else {
        if (colIndex > 0) {
          td.addClass("wcdv_divider");
        }
        didFooterCell = true;
        if (footerConfig.fields == null) {
          footerConfig.fields = [field];
        }
        console.debug("[DataVis // %s // Footer(%s)] Creating footer using config: %O", self2.toString(), field, footerConfig);
        var aggInfo = new AggregateInfo("all", footerConfig, 0, self2.colConfig, typeInfo, function(tag, fti) {
          if (fti.needsDecoding) {
            console.debug(
              '[DataVis // %s // Footer(%s) // %s] Converting data: { field = "%s", type = "%s" }',
              self2.toString(),
              field,
              tag,
              fti.field,
              fti.type
            );
            Source.decodeAll(data.dataByRowId, fti.field);
          }
          fti.deferDecoding = false;
          fti.needsDecoding = false;
        });
        aggResult = aggInfo.instance.calculate(data.data);
        var aggResult_formatted;
        if (isElement2(aggResult)) {
          footerVal = aggResult;
        } else {
          if (aggInfo.instance.inheritFormatting) {
            aggResult_formatted = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
              overrideType: aggInfo.instance.getType()
            });
          } else {
            aggResult_formatted = format2(null, null, aggResult, {
              overrideType: aggInfo.instance.getType(),
              decode: false
            });
          }
          if (aggInfo.debug) {
            console.debug(
              "[DataVis // %s // Footer(%s)] Aggregate result: %s",
              self2.toString(),
              field,
              JSON.stringify(aggResult)
            );
          }
          switch (typeof footerConfig.format) {
            case "function":
              footerVal = footerConfig.format(aggResult_formatted);
              break;
            case "string":
              footerVal = import_sprintf_js12.default.sprintf(footerConfig.format, aggResult_formatted);
              break;
            default:
              throw new Error('Footer config for field "' + field + '": `format` must be a function or a string');
          }
        }
        if (isElement2(footerVal)) {
          td.append(footerVal);
        } else {
          td.text(footerVal);
        }
      }
      return td;
    }));
    if (self2.features.rowReorder) {
      tr.append((0, import_jquery15.default)("<td>").text("Options"));
    }
    self2.ui.tfoot.append(tr);
  };
  var makeExternalFooterRow = function() {
    if (self2.opts.footer == null || !self2.opts.stealGridFooter) {
      return;
    }
    var tr = (0, import_jquery15.default)("<tr>");
    if (!isVisible(self2.opts.footer)) {
      tr.hide();
    }
    if (self2.features.rowSelect) {
      if (true) {
        (0, import_jquery15.default)("<td>", { "class": "wcdv_group_col_spacer" }).appendTo(tr);
      } else {
        makeSelectAll(tr);
      }
    }
    tr.append((0, import_jquery15.default)("<td>", { "colspan": columns.length }).append(self2.opts.footer));
    if (self2.features.rowReorder) {
      tr.append((0, import_jquery15.default)("<td>"));
    }
    self2.ui.tfoot.append(tr);
  };
  makeAggregateRow();
  makeExternalFooterRow();
};
GridTablePlain.prototype.makeRowReorderBtn = function() {
  var self2 = this;
  return (0, import_jquery15.default)('<button type="button" class="drag-handle fa">').html(fontAwesome("f07d", null, "Drag or press up/down arrows to move"));
};
GridTablePlain.prototype.updateFeatures = function(f2) {
  var self2 = this;
  index_default_default.each(f2, function(v, k) {
    self2.features[k] = v;
  });
  self2.draw(self2.root);
};
GridTablePlain.prototype.addWorkHandler = function() {
  var self2 = this;
  self2.view.on(ComputedView.events.workEnd, function(info, ops) {
    console.debug(
      "[DataVis // %s // Handler(ComputedView.workEnd)] ComputedView has finished doing work",
      self2.toString()
    );
    if (ops.group || ops.pivot) {
      console.debug(
        "[DataVis // %s // Handler(ComputedView.workEnd)] Unable to render this data: %O",
        self2.toString(),
        ops
      );
      self2.fire("unableToRender", null, ops);
      return;
    }
    console.debug(
      "[DataVis // %s // Handler(ComputedView.workEnd)] Redrawing because the view has done work",
      self2.toString()
    );
    self2.draw(self2.root);
  }, { who: self2 });
};
GridTablePlain.prototype.addDataToCsv = function(data) {
  var self2 = this;
  var columns = determineColumns(self2.colConfig, data, self2.typeInfo);
  console.debug("[DataVis // %s // Generate CSV] Started generating CSV file", self2.toString());
  self2.fire("generateCsvProgress", null, 0);
  self2.csv.start();
  self2.csv.addRow();
  index_default_default.each(columns, function(field, colIndex) {
    var fcc = self2.colConfig.get(field) || {};
    self2.csv.addCol(fcc.displayText || field);
  });
  var howMany = data.data.length / 10;
  var f2 = function(startIndex) {
    var endIndex = Math.min(data.data.length, startIndex + howMany);
    for (var i2 = startIndex; i2 < endIndex; i2 += 1) {
      var row = data.data[i2];
      self2.csv.addRow();
      index_default_default.each(columns, function(field, colIndex) {
        var fcc = self2.colConfig.get(field) || {};
        var cell = row.rowData[field];
        var value = format2(fcc, self2.typeInfo.get(field), cell);
        if (value instanceof Element) {
          self2.csv.addCol((0, import_jquery15.default)(value).text());
        } else if (value instanceof import_jquery15.default) {
          self2.csv.addCol(value.text());
        } else if (fcc.allowHtml && self2.typeInfo.get(field).type === "string" && value.charAt(0) === "<") {
          self2.csv.addCol((0, import_jquery15.default)(value).text());
        } else {
          self2.csv.addCol(value);
        }
      });
    }
    if (i2 === data.data.length) {
      self2.csv.finish(function() {
        console.debug("[DataVis // %s // Generate CSV] Finished generating CSV file", self2.toString());
        self2.csvLock.unlock();
        self2.fire("generateCsvProgress", null, 100);
        self2.fire("csvReady");
      });
    } else {
      self2.fire("generateCsvProgress", null, Math.floor(i2 / data.data.length * 100));
      setTimeout(function() {
        return f2(i2);
      }, 100);
    }
  };
  return f2(0);
};
GridTablePlain.prototype._updateSelectionGui = function() {
  var self2 = this;
  var isDisabled = self2.data.data.length === 0;
  var isAllChecked = !isDisabled && self2.selection.length === self2.data.data.length;
  var isIndeterminate = !isDisabled && !isAllChecked && self2.selection.length > 0;
  var updateCheckboxState = function(elt2) {
    elt2.prop("disabled", isDisabled);
    elt2.prop("checked", isAllChecked);
    elt2.prop("indeterminate", isIndeterminate);
  };
  self2.root.find("tbody td.wcdv_selected_row").removeClass("wcdv_selected_row");
  self2.root.find('tbody td:first-child input[type="checkbox"]').prop("checked", false);
  var trs = self2.root.find("tbody tr").filter(function(_idx, elt2) {
    return self2.selection.indexOf(+(0, import_jquery15.default)(elt2).attr("data-row-num")) >= 0;
  });
  if (self2.ui.checkAll_thead) {
    updateCheckboxState(self2.ui.checkAll_thead);
    updateCheckboxState(self2.ui.checkAll_thead.parents("div.tabletool").find('input[name="checkAll"]'));
  }
  if (self2.ui.checkAll_tfoot) {
    updateCheckboxState(self2.ui.checkAll_tfoot);
    updateCheckboxState(self2.ui.checkAll_tfoot.parents("div.tabletool").find('input[name="checkAll"]'));
  }
  trs.children("td").addClass("wcdv_selected_row");
  trs.find('td:first-child input[type="checkbox"]').prop("checked", true);
};
GridTablePlain.prototype.checkAll = function(evt) {
  var self2 = this;
  (0, import_jquery15.default)(evt.target).parents("div.tabletool").find('input[name="checkAll"]').prop("checked", evt.target.checked);
  if (evt.target.checked) {
    self2.select();
  } else {
    self2.unselect();
  }
};
GridTablePlain.prototype._addRowReorderHandler = function() {
  var self2 = this;
};
GridTablePlain.prototype._addRowSelectHandler = function() {
  var self2 = this;
  self2.ui.tbody.on("change", '.wcdv_group_col_spacer > input[type="checkbox"]', function() {
    if (this.checked) {
      self2.select(+(0, import_jquery15.default)(this).attr("data-row-num"));
    } else {
      self2.unselect(+(0, import_jquery15.default)(this).attr("data-row-num"));
    }
  });
};
GridRenderer.registry.set("table_plain", GridTablePlain);

// node_modules/wcdatavis/src/renderers/grid/table/group_detail.js
var import_sprintf_js13 = __toESM(require_sprintf());
var import_jquery16 = __toESM(require_jquery());
var GridTableGroupDetail = makeSubclass("GridTableGroupDetail", table_default, function(grid, defn, view, features, opts, timing, id) {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.features.sort = false;
  console.debug("DataVis // %s // Constructing grid table; features = %O", self2.toString(), features);
});
GridTableGroupDetail.prototype.canRender = function(what) {
  return ["group"].indexOf(what) >= 0;
};
GridTableGroupDetail.prototype.drawHeader = function(columns, data, typeInfo, opts) {
  var self2 = this, headingTr, headingSpan, headingTh, headingThContainer, headingThControls, headingThCss = {
    "white-space": "nowrap"
  }, filterThCss = {
    "white-space": "nowrap",
    "padding-top": 4,
    "vertical-align": "top"
  };
  index_default_default.each(data.groupFields, function(field, fieldIdx) {
    var fcc = self2.colConfig.get(field) || {};
    headingTr = (0, import_jquery16.default)("<tr>");
    if (self2.features.rowSelect) {
      if (fieldIdx === 0) {
        self2.ui.checkAll_thead = (0, import_jquery16.default)("<input>", {
          "name": "checkAll",
          "type": "checkbox",
          "class": "wcdv_select_group",
          "data-group-id": "0"
        }).on("change", function(evt) {
          self2.checkAll(evt);
        });
        headingTh = (0, import_jquery16.default)("<th>").addClass("wcdv_group_col_spacer").append(self2.ui.checkAll_thead).appendTo(headingTr);
      } else {
        (0, import_jquery16.default)("<th>").addClass("wcdv_group_col_spacer").appendTo(headingTr);
      }
    }
    for (var i3 = 0; i3 < fieldIdx + 1; i3 += 1) {
      (0, import_jquery16.default)("<th>").addClass("wcdv_group_col_spacer").appendTo(headingTr);
    }
    headingSpan = (0, import_jquery16.default)("<span>").attr({
      "data-wcdv-field": field,
      "data-wcdv-draggable-origin": "GRID_TABLE_HEADER"
    }).addClass("wcdv_heading_title").text(fcc.displayText || field)._makeDraggableField();
    headingThControls = (0, import_jquery16.default)("<div>");
    headingThContainer = (0, import_jquery16.default)("<div>").addClass("wcdv_heading_container").append(headingSpan, headingThControls);
    headingTh = (0, import_jquery16.default)("<th>").attr("colspan", columns.length - fieldIdx).css(headingThCss).append(headingThContainer);
    self2._addSortingToHeader(data, "vertical", { groupFieldIndex: fieldIdx }, headingThControls.get(0));
    self2.setCss(headingTh, field);
    self2.ui.thMap[field] = headingTh;
    headingTr.append(headingTh);
    self2.ui.thead.append(headingTr);
  });
  headingTr = (0, import_jquery16.default)("<tr>");
  if (self2.features.rowSelect) {
    (0, import_jquery16.default)("<th>").addClass("wcdv_group_col_spacer").appendTo(headingTr);
  }
  for (var i2 = 0; i2 < data.groupFields.length + 1; i2 += 1) {
    (0, import_jquery16.default)("<th>").addClass("wcdv_group_col_spacer").appendTo(headingTr);
  }
  index_default_default.each(columns, function(field, colIndex) {
    var fcc = self2.colConfig.get(field) || {};
    if (data.groupFields.indexOf(field) >= 0) {
      return;
    }
    headingSpan = (0, import_jquery16.default)("<span>").attr({
      "data-wcdv-field": field,
      "data-wcdv-draggable-origin": "GRID_TABLE_HEADER"
    }).addClass("wcdv_heading_title").text(fcc.displayText || field)._makeDraggableField();
    headingThControls = (0, import_jquery16.default)("<div>");
    headingThContainer = (0, import_jquery16.default)("<div>").addClass("wcdv_heading_container").append(headingSpan, headingThControls);
    headingTh = (0, import_jquery16.default)("<th>").css(headingThCss).append(headingThContainer);
    if (colIndex > 0) {
      headingTh.addClass("wcdv_pivot_colval_boundary");
    }
    self2._addSortingToHeader(data, "vertical", { field }, headingThControls.get(0));
    self2.setCss(headingTh, field);
    self2.setAlignment(headingTh, fcc, typeInfo.get(field));
    self2.ui.thMap[field] = headingTh;
    headingTr.append(headingTh);
  });
  self2.ui.thead.append(headingTr);
};
GridTableGroupDetail.prototype.drawBody = function(data, typeInfo, columns, cont, opts) {
  var self2 = this;
  if (!data.isGroup) {
    if (typeof cont === "function") {
      return cont();
    } else {
      return;
    }
  }
  if (self2.opts.generateCsv) {
    self2.addDataToCsv(data);
  }
  function percolateUp(node) {
    var disabled = false;
    var checked = false;
    var indeterminate = false;
    if (node.metadata.children != null) {
      node.numSelected = 0;
      index_default_default.each(node.metadata.children, function(child) {
        node.numSelected += self2.groupInfo[child.id].numSelected;
      });
    }
    if (node.metadata.numRows === 0) {
      disabled = true;
      checked = false;
    } else {
      if (node.numSelected === 0) {
        checked = false;
      } else if (node.numSelected === node.metadata.numRows) {
        checked = true;
      } else {
        indeterminate = true;
      }
    }
    node.checkbox.prop("disabled", disabled);
    node.checkbox.prop("checked", checked);
    node.checkbox.prop("indeterminate", indeterminate);
    if (node.metadata.parent) {
      percolateUp(self2.groupInfo[node.metadata.parent.id]);
    }
  }
  function percolateDown(node, isChecked) {
    node.checkbox.prop("disabled", false);
    node.checkbox.prop("checked", isChecked);
    node.checkbox.prop("indeterminate", false);
    node.numSelected = isChecked ? node.metadata.numRows : 0;
    if (node.metadata.children == null) {
      self2.ui.tbody.find("tr[data-wcdv-in-group=" + node.metadata.id + "]").find('input[type="checkbox"].wcdv_select_row').prop("checked", isChecked);
      index_default_default.each(data.data[node.metadata.rowValIndex], function(row) {
        if (isChecked) {
          self2.select(row.rowNum);
        } else {
          self2.unselect(row.rowNum);
        }
      });
    } else {
      index_default_default.each(node.metadata.children, function(child) {
        percolateDown(self2.groupInfo[child.id], isChecked);
      });
    }
  }
  var isRendered = {};
  var lastRenderedTr = {};
  self2.groupInfo = function() {
    var mapping = {};
    function recur(node) {
      mapping[node.id] = {
        metadata: node,
        numSelected: 0
      };
      if (node.children != null) {
        index_default_default.each(node.children, recur);
      }
    }
    recur(data.groupMetadata);
    mapping[0].checkbox = self2.ui.checkAll_thead;
    return mapping;
  }();
  function toggleGroup() {
    function toggle(metadataId, show, tr2) {
      var rowValIndex = self2.data.groupMetadata.lookup.byId[metadataId].rowValIndex;
      console.debug(
        "[DataVis // %s // Toggle] show = %s, id = %s, rowValIndex = %s",
        self2.toString(),
        show,
        metadataId,
        rowValIndex
      );
      if (show && !isRendered[metadataId]) {
        console.debug(
          "[DataVis // %s // Toggle] Rendering: group metadata ID = %s",
          self2.toString(),
          metadataId
        );
        render(metadataId, 0, tr2);
      }
      self2.ui.tbody.find("tr").filter(function(i2, elt3) {
        return (0, import_jquery16.default)(elt3).attr("data-wcdv-in-group") === "" + metadataId;
      }).each(function(i2, elt3) {
        elt3 = (0, import_jquery16.default)(elt3);
        if (elt3.attr("data-wcdv-toggles-group")) {
          toggle(+elt3.attr("data-wcdv-toggles-group"), show && elt3.attr("data-wcdv-expanded") === "1", elt3);
        }
        if (show) {
          elt3.show();
        } else {
          elt3.hide();
        }
      });
      if (self2.ui.tbl.floatThead) {
        self2.ui.tbl.floatThead("reflow");
      }
    }
    var elt2 = (0, import_jquery16.default)(this);
    var tr = elt2.closest("tr");
    var op = tr.attr("data-wcdv-expanded") === "0" ? "show" : "hide";
    if (op === "show") {
      tr.find(".spinner").show();
    }
    window.setTimeout(function() {
      toggle(+tr.attr("data-wcdv-toggles-group"), op === "show", tr);
      if (op === "show") {
        tr.find(".spinner").hide();
      }
      tr.attr("data-wcdv-expanded", op === "show" ? "1" : "0");
      elt2.attr("data-wcdv-expanded", op === "show" ? "1" : "0");
      elt2.html(fontAwesome(op === "show" ? "fa-minus-square-o" : "fa-plus-square-o"));
    });
  }
  function render(metadataId, startIndex, afterElement, showAll) {
    if (metadataId != null && typeof metadataId !== "number") {
      throw new Error("Call Error: `metadataId` must be null or a number");
    }
    if (startIndex != null && typeof startIndex !== "number") {
      throw new Error("Call Error: `startIndex` must be null or a number");
    }
    if (afterElement != null && !(afterElement instanceof import_jquery16.default)) {
      throw new Error("Call Error: `afterElement` must be null or an instance of jQuery");
    }
    if (metadataId == null) metadataId = 0;
    if (startIndex == null) startIndex = 0;
    if (startIndex > 0 && afterElement == null)
      throw new Error("Call Error: `afterElement` required when `startIndex` > 0");
    var metadataNode = data.groupMetadata.lookup.byId[metadataId];
    if (metadataNode == null)
      throw new Error("No group metadata for specified ID: " + metadataId);
    var limitConfig = self2.defn.table.limit;
    var showMoreTr;
    if (afterElement != null && startIndex > 0) {
      showMoreTr = afterElement.nextAll('tr.wcdvgrid_more[data-wcdv-in-group="' + metadataId + '"]');
      afterElement = showMoreTr.prev();
      showMoreTr.remove();
    }
    if (metadataNode.children) {
      var i2, j;
      var childMetadataNode;
      var childTr;
      var checkbox;
      var expandBtn;
      var infoText, infoTextSpan;
      var fcc;
      var t2, v;
      var rowValElt, rowValEltSpan, rowValEltTh;
      var showMoreTd;
      var colSpan;
      var trans2 = {
        "group:singular": "group",
        "group:plural": "groups",
        "row:singular": "row",
        "row:plural": "rows"
      };
      var childRowValElts = mergeSort2(index_default_default.pluck(metadataNode.children, "rowValElt"));
      var childRowValEltsLen = childRowValElts.length;
      var howMany = !self2.features.limit || showAll ? childRowValEltsLen : startIndex === 0 ? limitConfig.threshold : limitConfig.chunkSize;
      for (i2 = startIndex; i2 < childRowValEltsLen && i2 < startIndex + howMany; i2 += 1) {
        childMetadataNode = metadataNode.children[childRowValElts[i2]];
        childTr = (0, import_jquery16.default)("<tr>").attr("data-wcdv-in-group", metadataNode.id).attr("data-wcdv-toggles-group", childMetadataNode.id).attr("data-wcdv-expanded", "0");
        for (j = 0; j < childMetadataNode.groupFieldIndex; j += 1) {
          (0, import_jquery16.default)("<th>", { "class": "wcdv_group_col_spacer" }).appendTo(childTr);
        }
        var disabled = childMetadataNode.children == null && childMetadataNode.rows.length === 0;
        expandBtn = (0, import_jquery16.default)("<button>", {
          "type": "button",
          "class": "wcdv_icon_button wcdv_expand_button",
          "data-wcdv-expanded": "0",
          "disabled": disabled
        }).html(fontAwesome(disabled ? "fa-square-o" : "fa-plus-square-o"));
        (0, import_jquery16.default)("<th>", { "class": "wcdv_group_col_spacer" }).append(expandBtn).appendTo(childTr);
        if (self2.features.rowSelect) {
          checkbox = (0, import_jquery16.default)("<input>", {
            "type": "checkbox",
            "class": "wcdv_select_group",
            "data-group-id": childMetadataNode.id
          });
          self2.groupInfo[childMetadataNode.id].checkbox = checkbox;
          (0, import_jquery16.default)("<th>", { "class": "wcdv_group_col_spacer" }).append(checkbox).appendTo(childTr);
        }
        fcc = self2.colConfig.get(childMetadataNode.groupField) || {};
        t2 = self2.typeInfo.get(childMetadataNode.groupField);
        v = childMetadataNode.rowValCell || childMetadataNode.rowValElt;
        if (childMetadataNode.groupSpec.fun != null) {
          t2 = {
            type: GROUP_FUNCTION_REGISTRY.get(childMetadataNode.groupSpec.fun).resultType
          };
          v = childMetadataNode.rowValElt;
        }
        rowValElt = format2(fcc, t2, v);
        rowValEltSpan = (0, import_jquery16.default)("<span>");
        if (rowValElt instanceof Element || rowValElt instanceof import_jquery16.default) {
          rowValEltSpan.append(rowValElt);
        } else if (fcc.allowHtml) {
          rowValEltSpan.html(rowValElt);
        } else {
          rowValEltSpan.text(rowValElt);
        }
        infoText = "(";
        if (childMetadataNode.children != null) {
          infoText += childMetadataNode.numChildren + " ";
          infoText += (childMetadataNode.numChildren === 1 ? trans2["group:singular"] : trans2["group:plural"]) + ", ";
        }
        infoText += childMetadataNode.numRows + " ";
        infoText += childMetadataNode.numRows === 1 ? trans2["row:singular"] : trans2["row:plural"];
        infoText += ")";
        infoTextSpan = (0, import_jquery16.default)("<span>").css({ "margin-left": "0.5em" }).text(infoText);
        var spinnerDiv = (0, import_jquery16.default)("<div>", { "class": "spinner" }).append((0, import_jquery16.default)("<div>", { "class": "bounce1" })).append((0, import_jquery16.default)("<div>", { "class": "bounce2" })).append((0, import_jquery16.default)("<div>", { "class": "bounce3" })).hide();
        (0, import_jquery16.default)("<th>", {
          "class": "wcdv_group_value",
          "data-wcdv-field": childMetadataNode.groupField,
          "colspan": columns.length - childMetadataNode.groupFieldIndex
        }).append(rowValEltSpan).append(infoTextSpan).append(spinnerDiv).appendTo(childTr);
        if (afterElement != null) {
          afterElement.after(childTr);
        } else {
          self2.ui.tbody.append(childTr);
        }
        afterElement = childTr;
        var rowRenderCb = getProp(self2.opts, "events", "rowRender");
        if (typeof rowRenderCb === "function") {
          rowRenderCb(childTr, {
            isGroup: true,
            groupMode: "detail",
            groupField: childMetadataNode.groupField,
            rowValElt: childMetadataNode.rowValCell.value,
            groupMetadata: childMetadataNode
          });
        }
      }
      isRendered[metadataNode.id] = true;
      if (i2 < childRowValEltsLen) {
        lastRenderedTr[metadataNode.id] = childTr;
        for (var p = metadataNode.parent; p != null; p = p.parent) {
          lastRenderedTr[p.id] = childTr;
        }
        showMoreTr = (0, import_jquery16.default)("<tr>", { "class": "wcdvgrid_more", "data-wcdv-in-group": metadataNode.id });
        for (j = 0; j < childMetadataNode.groupFieldIndex; j += 1) {
          (0, import_jquery16.default)("<th>", { "class": "wcdv_group_col_spacer" }).appendTo(showMoreTr);
        }
        colSpan = columns.length + 1 + (self2.features.rowSelect ? 1 : 0) + (self2.features.rowReorder ? 1 : 0) - (metadataNode.groupFieldIndex || 0);
        spinnerDiv = (0, import_jquery16.default)("<div>", { "class": "spinner" }).append((0, import_jquery16.default)("<div>", { "class": "bounce1" })).append((0, import_jquery16.default)("<div>", { "class": "bounce2" })).append((0, import_jquery16.default)("<div>", { "class": "bounce3" })).hide();
        showMoreTd = (0, import_jquery16.default)("<td>", {
          "class": "wcdv_show_more",
          "data-wcdv-in-group": metadataNode.id,
          "data-wcdv-show-more-start": i2,
          "colspan": colSpan
        }).append(fontAwesome("F13A")).append((0, import_jquery16.default)("<span>Showing rows 1" + i2 + " of " + childRowValEltsLen + ".</span>").css({ "padding-left": "0.5em" })).append((0, import_jquery16.default)('<button type="button">Load ' + limitConfig.chunkSize + " more rows.</button>").css({ "margin-left": "0.5em" })).append(
          (0, import_jquery16.default)('<button type="button" class="wcdv_show_all">Load all rows.</button>').css({ "margin-left": "0.5em" })
        ).append(spinnerDiv).appendTo(showMoreTr);
        childTr.after(showMoreTr);
      }
    } else if (metadataNode.rows) {
      var isSelected;
      var checkbox;
      var row;
      var rowTr;
      var showMoreTd;
      var colSpan;
      var howMany = !self2.features.limit || showAll ? metadataNode.rows.length - startIndex : startIndex === 0 ? limitConfig.threshold : limitConfig.chunkSize;
      for (i2 = startIndex; i2 < metadataNode.rows.length && i2 < startIndex + howMany; i2 += 1) {
        row = metadataNode.rows[i2];
        rowTr = (0, import_jquery16.default)("<tr>", {
          "id": self2.defn.table.id + "_" + i2,
          "data-row-num": row.rowNum,
          "data-wcdv-in-group": metadataNode.id,
          "data-wcdv-rowValIndex": metadataNode.rowValIndex
        });
        for (var spacerIndex = 0; spacerIndex < data.groupFields.length + 1; spacerIndex += 1) {
          (0, import_jquery16.default)("<td>", { "class": "wcdv_group_col_spacer" }).appendTo(rowTr);
        }
        if (self2.features.rowSelect) {
          isSelected = self2.isSelected(row.rowNum);
          checkbox = (0, import_jquery16.default)("<input>", {
            "type": "checkbox",
            "data-row-num": row.rowNum,
            "class": "wcdv_select_row",
            "checked": isSelected
          });
          (0, import_jquery16.default)("<td>", { "class": "wcdv_group_col_spacer" }).append(checkbox).appendTo(rowTr);
        }
        index_default_default.each(columns, function(field, colIndex) {
          if (data.groupFields.indexOf(field) >= 0) {
            return;
          }
          var fcc2 = self2.colConfig.get(field) || {};
          var cell = row.rowData[field];
          var td = (0, import_jquery16.default)("<td>", { "data-wcdv-field": field });
          if (colIndex > 0) {
            td.addClass("wcdv_pivot_colval_boundary");
          }
          var value = format2(fcc2, typeInfo.get(field), cell);
          if (value instanceof Element || value instanceof import_jquery16.default) {
            td.append(value);
          } else if (fcc2.allowHtml && typeInfo.get(field).type === "string") {
            td.html(value);
          } else if (value === "") {
            td.html("&nbsp;");
          } else {
            td.text(value);
          }
          self2.setCss(td, field);
          self2.setAlignment(td, fcc2, typeInfo.get(field));
          rowTr.append(td);
        });
        if (self2.features.rowSelect && isSelected) {
          rowTr.children("td").addClass("wcdv_selected_row");
        }
        self2.ui.tr[i2] = rowTr;
        afterElement.after(rowTr);
        afterElement = rowTr;
        var rowRenderCb = getProp(self2.opts, "events", "rowRender");
        if (typeof rowRenderCb === "function") {
          rowRenderCb(rowTr, {
            isGroup: true,
            groupMode: "details",
            rowData: row.rowData,
            rowNum: row.rowNum
          });
        }
      }
      isRendered[metadataNode.id] = true;
      if (i2 < metadataNode.rows.length) {
        lastRenderedTr[metadataNode.id] = rowTr;
        for (var p = metadataNode.parent; p != null; p = p.parent) {
          lastRenderedTr[p.id] = rowTr;
        }
        showMoreTr = (0, import_jquery16.default)("<tr>", { "class": "wcdvgrid_more", "data-wcdv-in-group": metadataNode.id });
        for (j = 0; j < metadataNode.groupFieldIndex + 1; j += 1) {
          (0, import_jquery16.default)("<th>", { "class": "wcdv_group_col_spacer" }).appendTo(showMoreTr);
        }
        colSpan = columns.length + 1 + (self2.features.rowSelect ? 1 : 0) + (self2.features.rowReorder ? 1 : 0) - (metadataNode.groupFieldIndex + 1);
        spinnerDiv = (0, import_jquery16.default)("<div>", { "class": "spinner" }).append((0, import_jquery16.default)("<div>", { "class": "bounce1" })).append((0, import_jquery16.default)("<div>", { "class": "bounce2" })).append((0, import_jquery16.default)("<div>", { "class": "bounce3" })).hide();
        showMoreTd = (0, import_jquery16.default)("<td>", {
          "class": "wcdv_show_more",
          "data-wcdv-in-group": metadataNode.id,
          "data-wcdv-show-more-start": i2,
          "colspan": colSpan
        }).append(fontAwesome("F13A")).append((0, import_jquery16.default)("<span>Showing rows 1" + i2 + " of " + metadataNode.rows.length + ".</span>").css({ "padding-left": "0.5em" })).append((0, import_jquery16.default)('<button type="button">Load ' + limitConfig.chunkSize + " more rows.</button>").css({ "margin-left": "0.5em" })).append(
          (0, import_jquery16.default)('<button type="button" class="wcdv_show_all">Load all rows.</button>').css({ "margin-left": "0.5em" })
        ).append(spinnerDiv).appendTo(showMoreTr);
        rowTr.after(showMoreTr);
      }
    }
    self2._updateSelectionGui();
    if (self2.features.floatingHeader) {
      switch (getProp(self2.defn, "table", "floatingHeader", "method")) {
        case "tabletool":
          window.TableTool.update();
          break;
      }
    }
  }
  function showMore(showAll) {
    var elt2 = (0, import_jquery16.default)(this).closest("td");
    var metadataId = +elt2.attr("data-wcdv-in-group");
    var startIndex = +elt2.attr("data-wcdv-show-more-start");
    var afterElement = lastRenderedTr[metadataId];
    afterElement.nextAll('tr.wcdvgrid_more[data-wcdv-in-group="' + metadataId + '"]').find(".spinner").show();
    window.setTimeout(function() {
      render(metadataId, startIndex, afterElement, showAll);
    });
  }
  render();
  self2.ui.tbody.on("click", "button.wcdv_expand_button", toggleGroup);
  self2.ui.tbody.on("click", "td.wcdv_show_more button.wcdv_show_all", function(evt) {
    evt.stopPropagation();
    showMore.call(this, true);
  });
  self2.ui.tbody.on("click", "td.wcdv_show_more", function(evt) {
    showMore.call(this, false);
  });
  self2._updateSelectionGui();
  if (self2.features.floatingHeader) {
    switch (getProp(self2.defn, "table", "floatingHeader", "method")) {
      case "tabletool":
        window.TableTool.update();
        break;
    }
  }
  if (typeof cont === "function") {
    return cont();
  }
};
GridTableGroupDetail.prototype.drawFooter = function(columns, data, typeInfo) {
  var self2 = this;
  var makeSelectAll = function(tr) {
    self2.ui.checkAll_tfoot = (0, import_jquery16.default)("<input>", {
      "name": "checkAll",
      "type": "checkbox",
      "class": "wcdv_select_group",
      "data-group-id": "0"
    }).on("change", function(evt) {
      self2.checkAll(evt);
    });
    (0, import_jquery16.default)("<td>", { "class": "wcdv_group_col_spacer" }).append(self2.ui.checkAll_tfoot).appendTo(tr);
  };
  var makeAggregateRow = function() {
    if (false) {
      return;
    }
    var tr = (0, import_jquery16.default)("<tr>");
    if (self2.features.rowSelect) {
      makeSelectAll(tr);
    }
    for (var spacerIndex = 0; spacerIndex < data.groupFields.length + 1; spacerIndex += 1) {
      (0, import_jquery16.default)("<td>", { "class": "wcdv_group_col_spacer" }).appendTo(tr);
    }
    var didFooterCell = false;
    tr.append(index_default_default.map(columns, function(field, colIndex) {
      if (data.groupFields.indexOf(field) >= 0) {
        return;
      }
      var fcc = self2.colConfig.get(field) || {};
      var colTypeInfo = typeInfo.get(field);
      var td = (0, import_jquery16.default)("<td>");
      var footerConfig = getProp(self2.defn, "table", "footer", field);
      var agg;
      var aggFun;
      var aggResult;
      var footerVal;
      self2.setCss(td, field);
      self2.setAlignment(td, fcc, typeInfo.get(field));
      if (footerConfig == null) {
        if (didFooterCell) {
          td.addClass("wcdv_divider");
        }
        didFooterCell = false;
      } else {
        if (colIndex > 0) {
          td.addClass("wcdv_divider");
        }
        didFooterCell = true;
        if (footerConfig.fields == null) {
          footerConfig.fields = [field];
        }
        console.debug(
          "[DataVis // %s // Footer(%s)] Creating footer using config: %O",
          self2.toString(),
          field,
          footerConfig
        );
        var aggInfo = new AggregateInfo("all", footerConfig, 0, self2.colConfig, typeInfo, function(tag, fti) {
          if (fti.needsDecoding) {
            console.debug(
              '[DataVis // %s // Footer(%s) // %s] Converting data: { field = "%s", type = "%s" }',
              self2.toString(),
              field,
              tag,
              fti.field,
              fti.type
            );
            Source.decodeAll(data.dataByRowId, fti.field);
          }
          fti.deferDecoding = false;
          fti.needsDecoding = false;
        });
        aggResult = aggInfo.instance.calculate(data.groupMetadata.rows);
        var aggResult_formatted;
        if (isElement2(aggResult)) {
          footerVal = aggResult;
        } else {
          if (aggInfo.instance.inheritFormatting) {
            aggResult_formatted = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], aggResult, {
              overrideType: aggInfo.instance.getType()
            });
          } else {
            aggResult_formatted = format2(null, null, aggResult, {
              overrideType: aggInfo.instance.getType(),
              decode: false
            });
          }
          if (aggInfo.debug) {
            console.debug(
              "[DataVis // %s // Footer(%s)] Aggregate result: %s",
              self2.toString(),
              field,
              JSON.stringify(aggResult)
            );
          }
          switch (typeof footerConfig.format) {
            case "function":
              footerVal = footerConfig.format(aggResult_formatted);
              break;
            case "string":
              footerVal = import_sprintf_js13.default.sprintf(footerConfig.format, aggResult_formatted);
              break;
            default:
              throw new Error('Footer config for field "' + field + '": `format` must be a function or a string');
          }
        }
        if (footerVal instanceof Element || footerVal instanceof import_jquery16.default) {
          td.append(footerVal);
        } else {
          td.text(footerVal);
        }
      }
      return td;
    }));
    self2.ui.tfoot.append(tr);
  };
  var makeExternalFooterRow = function() {
    if (self2.opts.footer == null || !self2.opts.stealGridFooter) {
      return;
    }
    var tr = (0, import_jquery16.default)("<tr>");
    if (!isVisible(self2.opts.footer)) {
      tr.hide();
    }
    if (self2.features.rowSelect) {
      if (true) {
        (0, import_jquery16.default)("<td>", { "class": "wcdv_group_col_spacer" }).appendTo(tr);
      } else {
        makeSelectAll(tr);
      }
    }
    (0, import_jquery16.default)("<td>", { "colspan": columns.length + 1 }).append(self2.opts.footer).appendTo(tr);
    self2.ui.tfoot.append(tr);
  };
  makeAggregateRow();
  makeExternalFooterRow();
};
GridTableGroupDetail.prototype.addWorkHandler = function() {
  var self2 = this;
  self2.view.on(ComputedView.events.workEnd, function(info, ops) {
    console.debug("DataVis // GRID TABLE - GROUP - DETAIL // HANDLER (ComputedView.workEnd)", "ComputedView has finished doing work");
    if (!ops.group || ops.pivot) {
      self2.fire("unableToRender", null, ops);
      return;
    }
    console.debug("DataVis // GRID TABLE - GROUP - DETAIL // HANDLER (ComputedView.workEnd)", "Redrawing because the view has done work");
    self2.draw(self2.root);
  }, { who: self2 });
};
GridTableGroupDetail.prototype._addRowSelectHandler = function() {
  var self2 = this;
  self2.ui.tbody.on("change", 'input[type="checkbox"].wcdv_select_row', function() {
    var elt2 = (0, import_jquery16.default)(this);
    var rowNum = +elt2.attr("data-row-num");
    var isChecked = elt2.prop("checked");
    if (isChecked) {
      self2.select(rowNum);
    } else {
      self2.unselect(rowNum);
    }
  });
  self2.ui.tbody.on("change", 'input[type="checkbox"].wcdv_select_group', function() {
    var elt2 = (0, import_jquery16.default)(this);
    var isChecked = elt2.prop("checked");
    var groupMetadataId = +elt2.attr("data-group-id");
    var rowNums = [];
    function recur(node) {
      if (node.children == null) {
        rowNums = rowNums.concat(index_default_default.pluck(self2.data.data[node.rowValIndex], "rowNum"));
      } else {
        index_default_default.each(node.children, recur);
      }
    }
    recur(self2.data.groupMetadata.lookup.byId[groupMetadataId]);
    if (isChecked) {
      self2.select(rowNums);
    } else {
      self2.unselect(rowNums);
    }
  });
};
GridTableGroupDetail.prototype._updateSelectionGui = function() {
  var self2 = this;
  self2.root.find("tbody td.wcdv_selected_row").removeClass("wcdv_selected_row");
  self2.root.find('tbody input[type="checkbox"].wcdv_select_row').prop("checked", false);
  self2.root.find('tbody input[type="checkbox"].wcdv_select_group').prop("checked", false);
  var trs = self2.root.find("tbody tr").filter(function(_idx, elt2) {
    return self2.selection.indexOf(+(0, import_jquery16.default)(elt2).attr("data-row-num")) >= 0;
  });
  trs.children("td").addClass("wcdv_selected_row");
  trs.find('input[type="checkbox"].wcdv_select_row').prop("checked", true);
  var numSelected = {};
  index_default_default.each(index_default_default.keys(self2.data.groupMetadata.lookup.byId), function(id2) {
    numSelected[id2] = 0;
  });
  for (var i2 = 0; i2 < self2.selection.length; i2 += 1) {
    var s2 = self2.selection[i2];
    var id = getProp(self2.data, "groupMetadata", "lookup", "byRowNum", s2, "id");
    if (id == null) {
      continue;
    }
    if (numSelected[id] == null) {
      numSelected[id] = 0;
    }
    numSelected[id] += 1;
  }
  (function() {
    function postorder(node) {
      if (node.children != null) {
        numSelected[node.id] = 0;
        index_default_default.each(node.children, function(c2) {
          postorder(c2);
          numSelected[node.id] += numSelected[c2.id];
        });
      }
    }
    postorder(self2.data.groupMetadata);
  })();
  index_default_default.each(numSelected, function(count, id2) {
    var numRows = self2.data.groupMetadata.lookup.byId[id2].numRows;
    var checkbox = self2.root.find('input[type="checkbox"][data-group-id="' + id2 + '"].wcdv_select_group');
    if (checkbox.length === 0) {
      return;
    }
    if (numRows === 0) {
      checkbox.prop({
        disabled: true,
        indeterminate: false,
        checked: false
      });
    } else if (count === 0) {
      checkbox.prop({
        disabled: false,
        indeterminate: false,
        checked: false
      });
    } else if (numRows === count) {
      checkbox.prop({
        disabled: false,
        indeterminate: false,
        checked: true
      });
    } else {
      checkbox.prop({
        disabled: false,
        indeterminate: true,
        checked: false
      });
    }
  });
};
GridTableGroupDetail.prototype.checkAll = function(evt) {
  var self2 = this;
  (0, import_jquery16.default)(evt.target).parents("div.tabletool").find('input[name="checkAll"]').prop("checked", evt.target.checked);
  if (evt.target.checked) {
    self2.select();
  } else {
    self2.unselect();
  }
};
GridTableGroupDetail.prototype.addDataToCsv = function(data) {
  var self2 = this;
  var columns = determineColumns(self2.colConfig, data, self2.typeInfo);
  console.debug("[DataVis // %s // Generate CSV] Started generating CSV file", self2.toString());
  self2.fire("generateCsvProgress", null, 0);
  self2.csv.start();
  self2.csv.addRow();
  index_default_default.each(data.groupFields, function(fieldName) {
    var fcc = self2.colConfig.get(fieldName) || {};
    self2.csv.addCol(fcc.displayText || fieldName);
  });
  index_default_default.each(index_default_default.difference(columns, data.groupFields), function(fieldName) {
    var fcc = self2.colConfig.get(fieldName) || {};
    self2.csv.addCol(fcc.displayText || fieldName);
  });
  function recur(depth, metadataNode) {
    if (metadataNode.children != null) {
      index_default_default.each(index_default_default.keys(metadataNode.children).sort(), function(childName) {
        self2.csv.addRow();
        for (var j = 0; j < depth; j += 1) {
          self2.csv.addCol();
        }
        self2.csv.addCol(childName);
        for (var j = depth + 1; j < columns.length; j += 1) {
          self2.csv.addCol();
        }
        recur(depth + 1, metadataNode.children[childName]);
      });
    } else {
      index_default_default.each(metadataNode.rows, function(row) {
        self2.csv.addRow();
        for (var j = 0; j < depth; j += 1) {
          self2.csv.addCol();
        }
        index_default_default.each(index_default_default.difference(columns, data.groupFields), function(field, colIndex) {
          var fcc = self2.colConfig.get(field) || {};
          var cell = row.rowData[field];
          var value = format2(fcc, self2.typeInfo.get(field), cell);
          if (value instanceof Element) {
            self2.csv.addCol((0, import_jquery16.default)(value).text());
          } else if (value instanceof import_jquery16.default) {
            self2.csv.addCol(value.text());
          } else if (fcc.allowHtml && self2.typeInfo.get(field).type === "string" && value.charAt(0) === "<") {
            self2.csv.addCol((0, import_jquery16.default)(value).text());
          } else {
            self2.csv.addCol(value);
          }
        });
      });
    }
  }
  recur(0, data.groupMetadata);
  self2.csv.finish(function() {
    console.debug("[DataVis // %s // Generate CSV] Finished generating CSV file", self2.toString());
    self2.csvLock.unlock();
    self2.fire("generateCsvProgress", null, 100);
    self2.fire("csvReady");
  });
};
GridRenderer.registry.set("table_group_detail", GridTableGroupDetail);

// node_modules/wcdatavis/src/renderers/grid/table/group_summary.js
var import_sprintf_js14 = __toESM(require_sprintf());
var import_jquery17 = __toESM(require_jquery());
var GridTableGroupSummary = makeSubclass("GridTableGroupSummary", table_default, function(grid, defn, view, features, opts, timing, id) {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.features.limit = false;
  self2.features.rowSelect = false;
  self2.features.footer = false;
  console.debug("DataVis // GRID TABLE - GROUP - SUMMARY", "Constructing grid table; features = %O", features);
  setPropDef(["rowVals", "groupAggregates"], self2.opts, "displayOrder");
});
GridTableGroupSummary.prototype.canRender = function(what) {
  return ["group"].indexOf(what) >= 0;
};
GridTableGroupSummary.prototype.drawHeader = function(columns, data, typeInfo, opts) {
  var self2 = this, tr = (0, import_jquery17.default)("<tr>"), headingSpan, headingTh, headingThControls, headingThContainer;
  self2.csv.addRow();
  index_default_default.each(self2.opts.displayOrder, function(what, displayOrderIndex) {
    if (typeof what === "string") {
      if (what === "rowVals") {
        index_default_default.each(data.groupFields, function(field, fieldIdx) {
          var fcc = self2.colConfig.get(field) || {};
          var headingText = fcc.displayText || field;
          headingSpan = (0, import_jquery17.default)("<span>", {
            "class": "wcdv_heading_title",
            "data-wcdv-field": field,
            "data-wcdv-draggable-origin": "GRID_TABLE_HEADER"
          }).text(headingText)._makeDraggableField();
          headingThControls = (0, import_jquery17.default)("<div>");
          headingThContainer = (0, import_jquery17.default)("<div>").addClass("wcdv_heading_container").append(headingSpan, headingThControls);
          headingTh = (0, import_jquery17.default)("<th>").append(headingThContainer);
          self2.csv.addCol(fcc.displayText || field);
          self2._addSortingToHeader(data, "vertical", { groupFieldIndex: fieldIdx }, headingThControls.get(0), getProp(data, "agg", "info", "group"));
          self2.setCss(headingTh, field);
          self2.ui.thMap[field] = headingTh;
          tr.append(headingTh);
        });
      } else if (what === "groupAggregates") {
        self2.drawHeader_aggregates(data, tr, displayOrderIndex, self2.opts.displayOrder.length);
      } else if (what === "addCols") {
        self2.drawHeader_addCols(tr, typeInfo, opts);
      }
    }
  });
  self2.ui.thead.append(tr);
};
GridTableGroupSummary.prototype.drawBody = function(data, typeInfo, columns, cont, opts) {
  var self2 = this;
  var ai = self2._getAggInfo(data);
  var aggType, aggInfo, rowAgg;
  self2._setupFullValueWin(data);
  index_default_default.each(data.data, function(rowGroup, groupNum) {
    var tr = document.createElement("tr");
    tr.setAttribute("data-wcdv-rvi", groupNum);
    self2.csv.addRow();
    index_default_default.each(self2.opts.displayOrder, function(what, displayOrderIndex) {
      if (typeof what === "string") {
        if (what === "rowVals") {
          self2.drawBody_rowVals(data, tr, groupNum);
        } else if (what === "groupAggregates") {
          self2.drawBody_groupAggregates(data, tr, groupNum, displayOrderIndex, self2.opts.displayOrder.length);
        } else if (what === "addCols") {
          index_default_default.each(self2.opts.addCols, function(addCol) {
            var td = document.createElement("td");
            var addColResult = addCol.value(data.data, groupNum, rowAgg, aggType);
            var addColText;
            if (addColResult instanceof import_jquery17.default) {
              addColResult = addColResult.get(0);
            }
            if (addColResult instanceof Element) {
              td.appendChild(addColResult);
              self2.csv.addCol(addColResult.innerText);
            } else {
              if (aggInfo.instance.inheritFormatting) {
                addColText = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], addColResult, {
                  alwaysFormat: true
                });
              } else {
                addColText = format2(null, null, addColResult, {
                  alwaysFormat: true,
                  decode: false
                });
              }
              td.innerText = addColText;
              self2.csv.addCol(addColText);
            }
            if (getProp(opts, "pivotConfig", "aggField")) {
              self2.setAlignment(td, self2.colConfig.get(opts.pivotConfig.aggField), typeInfo.get(opts.pivotConfig.aggField));
            }
            tr.appendChild(td);
          });
        }
      }
    });
    self2.ui.tbody.append(tr);
  });
  var renderTotalRow = function() {
    var tr;
    tr = (0, import_jquery17.default)("<tr>", { "class": "wcdv_btd" });
    self2.csv.addRow();
    index_default_default.each(self2.opts.displayOrder, function(what) {
      switch (what) {
        case "rowVals":
          for (var i2 = 0; i2 < data.groupFields.length - 1; i2 += 1) {
            self2.csv.addCol("");
          }
          self2.csv.addCol("Total");
          var span = (0, import_jquery17.default)("<span>", { "class": "wcdv_heading_title" }).text("Total");
          var headingThControls = (0, import_jquery17.default)("<div>");
          var headingThContainer = (0, import_jquery17.default)("<div>").addClass("wcdv_heading_container").append(span, headingThControls);
          var th = (0, import_jquery17.default)("<th>").attr({ "colspan": data.groupFields.length }).append(headingThContainer).appendTo(tr);
          break;
        case "groupAggregates":
          index_default_default.each(ai.all, function(aggInfo2, aiAllIndex) {
            var aggResult = data.agg.results.all[aggInfo2.aggNum];
            var td = document.createElement("td");
            td.setAttribute("data-wcdv-agg-scope", "all");
            td.setAttribute("data-wcdv-agg-num", aggInfo2.aggNum);
            var text;
            if (aggResult instanceof import_jquery17.default) {
              aggResult = aggResult.get(0);
            }
            if (aggResult instanceof Element) {
              td.appendChild(aggResult);
              self2.csv.addCol(aggResult.innerText);
            } else {
              if (aggInfo2.instance.inheritFormatting) {
                text = format2(aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggResult, {
                  overrideType: aggInfo2.instance.getType()
                });
                setTableCell(td, text, {
                  field: aggInfo2.fields[0],
                  colConfig: aggInfo2.colConfig[0],
                  typeInfo: aggInfo2.typeInfo[0]
                });
              } else {
                text = format2(null, null, aggResult, {
                  overrideType: aggInfo2.instance.getType(),
                  decode: false
                });
                setTableCell(td, text);
              }
              self2.csv.addCol(td.innerText);
            }
            if (self2.opts.drawInternalBorders || ai.all.length > 1) {
              td.classList.add(aiAllIndex === 0 ? "wcdv_pivot_aggregate_boundary" : "wcdv_pivot_colval_boundary");
            }
            self2.setAlignment(td, aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggInfo2.instance.getType());
            tr.append(td);
          });
          break;
      }
    });
    tr.appendTo(self2.ui.tbody);
  };
  if (ai.all.length > 0) {
    renderTotalRow();
  }
  if (self2.features.floatingHeader) {
    switch (getProp(self2.defn, "table", "floatingHeader", "method")) {
      case "tabletool":
        window.TableTool.update();
        break;
    }
  }
  self2.csv.finish(function() {
    console.debug("[DataVis // %s // Generate CSV] Finished generating CSV file", self2.toString());
    self2.csvLock.unlock();
    self2.fire("generateCsvProgress", null, 100);
    self2.fire("csvReady");
  });
  if (typeof cont === "function") {
    return cont();
  }
};
GridTableGroupSummary.prototype.drawFooter = function(columns, data, typeInfo) {
  var self2 = this;
  var tr, td;
  var colspan;
  tr = (0, import_jquery17.default)("<tr>");
  if (self2.features.rowSelect) {
    self2.ui.checkAll_tfoot = (0, import_jquery17.default)("<input>", { "name": "checkAll", "type": "checkbox" }).on("change", function(evt) {
      self2.checkAll(evt);
    });
    (0, import_jquery17.default)("<td>", { "class": "wcdv_group_col_spacer" }).append(self2.ui.checkAll_tfoot).appendTo(tr);
  }
  if (self2.opts.footer != null && self2.opts.stealGridFooter) {
    tr.append((0, import_jquery17.default)("<td>", { "colspan": data.groupFields.length + self2._getAggInfo(data).group.length }).append(self2.opts.footer));
  }
  if (tr.children().length > 0) {
    self2.ui.tfoot.append(tr);
  }
};
GridTableGroupSummary.prototype.addWorkHandler = function() {
  var self2 = this;
  self2.view.on(ComputedView.events.workEnd, function(info, ops) {
    console.debug("DataVis // GRID TABLE - GROUP - SUMMARY // HANDLER (ComputedView.workEnd)", "ComputedView has finished doing work");
    if (!ops.group || ops.pivot) {
      self2.fire("unableToRender", null, ops);
      return;
    }
    console.debug("DataVis // GRID TABLE - GROUP - SUMMARY // HANDLER (ComputedView.workEnd)", "Redrawing because the view has done work");
    self2.draw(self2.root);
  }, { who: self2 });
};
GridRenderer.registry.set("table_group_summary", GridTableGroupSummary);

// node_modules/wcdatavis/src/renderers/grid/table/pivot.js
var import_sprintf_js15 = __toESM(require_sprintf());
var import_jquery18 = __toESM(require_jquery());
var GridTablePivot = makeSubclass("GridTablePivot", table_default, function(grid, defn, view, features, opts, timing, id) {
  var self2 = this;
  self2.super.ctor.apply(self2, arguments);
  self2.features.limit = false;
  self2.features.footer = false;
  console.debug("DataVis // GRID TABLE - PIVOT", "Constructing grid table; features = %O", features);
  setPropDef(["rowVals", "cells", "groupAggregates", "addCols"], self2.opts, "displayOrder");
});
GridTablePivot.prototype.canRender = function(what) {
  return ["pivot"].indexOf(what) >= 0;
};
GridTablePivot.prototype.drawHeader = function(columns, data, typeInfo, opts) {
  var self2 = this, aggInfo, tr, span, headingThControls, headingThContainer, th;
  var displayRowVals = function(tr2) {
    index_default_default.each(data.groupFields, function(field, fieldIdx) {
      var fcc = self2.colConfig.get(field) || {};
      span = (0, import_jquery18.default)("<span>").addClass("wcdv_heading_title").text(fcc.displayText || field);
      self2.csv.addCol(fcc.displayText || field);
      headingThControls = (0, import_jquery18.default)("<div>");
      headingThContainer = (0, import_jquery18.default)("<div>").addClass("wcdv_heading_container").append(span, headingThControls);
      th = (0, import_jquery18.default)("<th>").dvAttr({
        "gfi": fieldIdx,
        "field": field,
        "draggable-origin": "GRID_TABLE_HEADER"
      }).append(headingThContainer)._makeDraggableField();
      self2._addSortingToHeader(data, "vertical", { groupFieldIndex: fieldIdx }, headingThControls.get(0), getPropDef([], data, "agg", "info", "cell"));
      self2.setCss(th, field);
      self2.ui.thMap[field] = th;
      tr2.append(th);
    });
  };
  var displayRowVals_padding = function(tr2) {
    if (data.groupFields.length > 1) {
      tr2.append((0, import_jquery18.default)("<th>", { colspan: data.groupFields.length - 1 }));
      for (var i2 = 0; i2 < data.groupFields.length - 1; i2 += 1) {
        self2.csv.addCol("");
      }
    }
  };
  var displayCells = function(tr2, pivotFieldIdx2, displayOrderIndex) {
    var colVal, colValIndex;
    var ai = self2._getAggInfo(data);
    var df = self2._getDisplayFormat();
    var isLastPivotField = pivotFieldIdx2 === data.pivotFields.length - 1;
    var pivotField = data.pivotFields[pivotFieldIdx2];
    var fcc = self2.colConfig.get(pivotField) || {};
    var pivotSpec = data.pivotSpec[pivotFieldIdx2];
    var fti = self2.typeInfo.get(pivotField);
    if (pivotSpec.fun != null) {
      fti = {
        type: GROUP_FUNCTION_REGISTRY.get(pivotSpec.fun).resultType
      };
    }
    var span2 = (0, import_jquery18.default)("<span>").addClass("wcdv_heading_title").text(fcc.displayText || pivotField);
    self2.csv.addCol(fcc.displayText || pivotField);
    var headingThControls2 = (0, import_jquery18.default)("<div>");
    var headingThContainer2 = (0, import_jquery18.default)("<div>").addClass("wcdv_heading_container").append(span2, headingThControls2);
    var th2 = (0, import_jquery18.default)("<th>").dvAttr({
      "field": pivotField,
      "draggable-origin": "GRID_TABLE_HEADER"
    }).append(headingThContainer2)._makeDraggableField();
    self2._addSortingToHeader(data, "horizontal", { pivotFieldIndex: pivotFieldIdx2 }, headingThControls2.get(0), getPropDef([], data, "agg", "info", "cell"));
    self2.setCss(th2, pivotField);
    self2.ui.thMap[pivotField] = th2;
    tr2.append(th2);
    var lastColVal = null;
    var lastColValCount = 0;
    for (colValIndex = 0; colValIndex < data.colVals.length; colValIndex += 1) {
      colVal = data.colVals[colValIndex][pivotFieldIdx2];
      colVal = format2(self2.colConfig.get(pivotField), fti, colVal);
      if (colVal !== lastColVal || isLastPivotField) {
        if (lastColVal !== null) {
          var colSpan = lastColValCount;
          if ((df.cell.length || ai.cell.length) >= 2) {
            colSpan *= ai.cell.length;
          }
          th2.attr("colspan", colSpan);
          tr2.append(th2);
          for (var i2 = 0; i2 < colSpan - 1; i2 += 1) {
            self2.csv.addCol("");
          }
        }
        lastColVal = colVal;
        lastColValCount = 1;
        span2 = (0, import_jquery18.default)("<span>").addClass("wcdv_heading_title");
        setElement(span2, colVal, {
          field: pivotField,
          colConfig: fcc,
          typeInfo: fti
        });
        self2.csv.addCol(span2.text());
        headingThControls2 = (0, import_jquery18.default)("<div>");
        headingThContainer2 = (0, import_jquery18.default)("<div>").addClass("wcdv_heading_container").append(span2, headingThControls2);
        th2 = (0, import_jquery18.default)("<th>").dvAttr("cvi", colValIndex).append(headingThContainer2);
        self2.setCss(th2, colVal);
        if (isLastPivotField) {
          self2._addSortingToHeader(data, "vertical", { colVal: data.colVals[colValIndex], aggNum: 0 }, headingThControls2.get(0), getPropDef([], data, "agg", "info", "cell"));
        }
        if ((df.cell.length || ai.cell.length) === 1) {
          aggInfo = data.agg.info.cell[0];
          self2.setAlignment(th2, aggInfo.colConfig[0], aggInfo.typeInfo[0], aggInfo.instance.getType());
        } else if ((df.cell.length || ai.cell.length) > 1) {
          self2.setAlignment(th2, null, null, null, "center");
        }
        if (self2.opts.drawInternalBorders || (df.cell.length || ai.cell.length) > 1) {
          th2.addClass("wcdv_pivot_colval_boundary");
        }
      } else {
        lastColValCount += 1;
      }
    }
    var colSpan = lastColValCount;
    if ((df.cell.length || ai.cell.length) >= 2) {
      colSpan *= df.cell.length || ai.cell.length;
    }
    if (th2 != null) {
      th2.attr("colspan", colSpan);
      tr2.append(th2);
    }
    for (i2 = 0; i2 < colSpan - 1; i2 += 1) {
      self2.csv.addCol("");
    }
  };
  var displayCells_padding = function(tr2) {
    var ai = self2._getAggInfo(data);
    var df = self2._getDisplayFormat();
    var numCols = df.cell.length || ai.cell.length;
    var hr = (0, import_jquery18.default)("<hr>", {
      class: "wcdv_hr_gradient"
    });
    var div = (0, import_jquery18.default)("<div>&nbsp;</div>");
    var th2 = (0, import_jquery18.default)("<th>", {
      class: "wcdv_pivot_colval_boundary wcdv_cell_empty",
      colspan: data.colVals.length * Math.max(numCols, 1)
    });
    div.appendTo(th2);
    th2.appendTo(tr2);
    for (var i2 = 0; i2 < data.colVals.length * Math.max(numCols, 1); i2 += 1) {
      self2.csv.addCol("");
    }
  };
  var displayGroupAggregates_padding = function(tr2, displayOrderIndex, displayOrderMax) {
    var ai = self2._getAggInfo(data);
    var numCols = ai.group.length + getPropDef(0, self2.opts, "addCols", "length");
    if (numCols > 0) {
      var th2 = (0, import_jquery18.default)("<th>", { colspan: numCols });
      if (displayOrderIndex > 0) {
        th2.addClass("wcdv_bld");
      }
      if (displayOrderIndex < displayOrderMax - 1) {
        th2.addClass("wcdv_brd");
      }
      tr2.append(th2);
    }
  };
  var displayGroupAggregates = function(tr2, displayOrderIndex, displayOrderMax) {
    self2.drawHeader_aggregates(data, tr2, displayOrderIndex, displayOrderMax);
    self2.drawHeader_addCols(tr2, typeInfo, opts);
  };
  for (var pivotFieldIdx = 0; pivotFieldIdx < data.pivotFields.length; pivotFieldIdx += 1) {
    self2.csv.addRow();
    tr = (0, import_jquery18.default)("<tr>").dvAttr("pfi", pivotFieldIdx);
    index_default_default.each(self2.opts.displayOrder, function(what, displayOrderIndex) {
      if (typeof what === "string") {
        switch (what) {
          case "rowVals":
            displayRowVals_padding(tr);
            break;
          case "cells":
            displayCells(tr, pivotFieldIdx);
            break;
          case "groupAggregates":
            displayGroupAggregates_padding(tr, displayOrderIndex, self2.opts.displayOrder.length);
            break;
        }
      }
    });
    tr.appendTo(self2.ui.thead);
  }
  self2.csv.addRow();
  tr = (0, import_jquery18.default)("<tr>");
  index_default_default.each(self2.opts.displayOrder, function(what, displayOrderIndex) {
    if (typeof what === "string") {
      switch (what) {
        case "rowVals":
          displayRowVals(tr);
          break;
        case "cells":
          displayCells_padding(tr);
          break;
        case "groupAggregates":
          displayGroupAggregates(tr, displayOrderIndex, self2.opts.displayOrder.length);
          break;
      }
    }
  });
  tr.appendTo(self2.ui.thead);
};
GridTablePivot.prototype.drawBody = function(data, typeInfo, columns, cont, opts) {
  var self2 = this;
  var aggType, aggInfo;
  opts = opts || {};
  opts.pivotConfig = opts.pivotConfig || {};
  var ai = self2._getAggInfo(data);
  var df = self2._getDisplayFormat();
  if (data.groupFields.length === 0) {
    if (typeof cont === "function") {
      return cont();
    } else {
      return;
    }
  }
  self2._setupFullValueWin(data);
  var handlebarsEnv = handlebars_default.makeEnv();
  handlebars_default.addHelpers(handlebarsEnv, self2.data);
  var templates = {};
  index_default_default.each(df, function(tmplStrs, type) {
    templates[type] = index_default_default.map(tmplStrs, function(str) {
      var t2;
      try {
        t2 = handlebarsEnv.compile(str);
      } catch (e2) {
        t2 = function() {
          return e2.message;
        };
      }
      return t2;
    });
  });
  index_default_default.each(data.data, function(rowGroup, groupNum) {
    self2.csv.addRow();
    var tr = document.createElement("tr");
    tr.setAttribute("data-wcdv-rvi", groupNum);
    index_default_default.each(self2.opts.displayOrder, function(what, displayOrderIndex) {
      if (typeof what === "string") {
        switch (what) {
          case "rowVals":
            self2.drawBody_rowVals(data, tr, groupNum);
            break;
          case "cells":
            var rowAgg = [];
            index_default_default.each(rowGroup, function(colGroup, pivotNum) {
              if (df.cell.length > 0) {
                index_default_default.each(df.cell, function(dispFmt, dfCellIndex) {
                  var td = document.createElement("td");
                  td.classList.add("wcdv_pivot_cell");
                  td.setAttribute("data-wcdv-rvi", groupNum);
                  td.setAttribute("data-wcdv-cvi", pivotNum);
                  td.innerHTML = templates.cell[dfCellIndex]({
                    rowValIdx: groupNum,
                    colValIdx: pivotNum
                  });
                  if (index_default_default.every(data.groupSpec, function(gs) {
                    return gs.fun == null;
                  }) && index_default_default.every(data.pivotSpec, function(ps) {
                    return ps.fun == null;
                  })) {
                    self2._addDrillDownClass(td);
                  }
                  if (self2.opts.drawInternalBorders) {
                    td.classList.add("wcdv_pivot_colval_boundary");
                  }
                  tr.appendChild(td);
                });
              } else if (ai.cell.length > 0) {
                index_default_default.each(ai.cell, function(aggInfo2, aiCellIndex) {
                  var aggNum = aggInfo2.aggNum;
                  var aggType2 = aggInfo2.instance.getType();
                  var agg = data.agg.results.cell[aggNum];
                  var aggResult = agg[groupNum][pivotNum];
                  var td = document.createElement("td");
                  td.classList.add("wcdv_pivot_cell");
                  td.setAttribute("data-wcdv-rvi", groupNum);
                  td.setAttribute("data-wcdv-cvi", pivotNum);
                  td.setAttribute("data-wcdv-agg-scope", "cell");
                  td.setAttribute("data-wcdv-agg-num", aggInfo2.aggNum);
                  rowAgg.push(aggResult);
                  var text;
                  if (aggResult instanceof import_jquery18.default) {
                    aggResult = aggResult.get(0);
                  }
                  if (aggResult instanceof Element) {
                    td.appendChild(aggResult);
                    self2.csv.addCol(aggResult.innerText);
                  } else if (self2.opts.hideBottomValueAggResults && aggResult === aggInfo2.instance.bottomValue) {
                    td.innerHTML = "&nbsp;";
                    self2.csv.addCol("");
                  } else {
                    if (aggInfo2.instance.inheritFormatting) {
                      text = format2(aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggResult, {
                        overrideType: aggType2
                      });
                      setTableCell(td, text, {
                        field: aggInfo2.fields[0],
                        colConfig: aggInfo2.colConfig[0],
                        typeInfo: aggInfo2.typeInfo[0]
                      });
                    } else {
                      text = format2(null, null, aggResult, {
                        overrideType: aggType2,
                        decode: false
                      });
                      setTableCell(td, text);
                    }
                    self2.csv.addCol(td.innerText);
                  }
                  if (index_default_default.every(data.groupSpec, function(gs) {
                    return gs.fun == null;
                  }) && index_default_default.every(data.pivotSpec, function(ps) {
                    return ps.fun == null;
                  })) {
                    self2._addDrillDownClass(td);
                  }
                  if ((self2.opts.drawInternalBorders || ai.cell.length > 1) && aiCellIndex === 0) {
                    td.classList.add("wcdv_pivot_colval_boundary");
                  }
                  self2.setAlignment(td, aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggType2);
                  tr.appendChild(td);
                });
              } else {
                tr.appendChild(document.createElement("td"));
              }
            });
            break;
          case "groupAggregates":
            self2.drawBody_groupAggregates(data, tr, groupNum, displayOrderIndex, self2.opts.displayOrder.length);
            break;
          case "addCols":
            index_default_default.each(self2.opts.addCols, function(addCol) {
              var addColResult = addCol.value(data.data, groupNum, rowAgg, aggType);
              var td = document.createElement("td");
              var addColText;
              if (addColResult instanceof import_jquery18.default) {
                addColResult = addColResult.get(0);
              }
              if (addColResult instanceof Element) {
                td.appendChild(addColResult);
                self2.csv.addCol(addColResult.innerText);
              } else {
                if (false) {
                  addColText = format2(aggInfo.colConfig[0], aggInfo.typeInfo[0], addColResult, {
                    alwaysFormat: true
                  });
                } else {
                  addColText = format2(null, null, addColResult, {
                    alwaysFormat: true,
                    decode: false
                  });
                }
                td.innerText = addColText;
                self2.csv.addCol(addColText);
              }
              if (getProp(opts, "pivotConfig", "aggField")) {
                self2.setAlignment(td, self2.colConfig.get(opts.pivotConfig.aggField), typeInfo.get(opts.pivotConfig.aggField));
              }
              tr.appendChild(td);
            });
            break;
        }
      }
    });
    self2.ui.tbody.append(tr);
  });
  index_default_default.each(ai.pivot, function(aggInfo2, aiPivotIndex) {
    var span, text, aggNum = aggInfo2.aggNum, aggResult, headingThControls, headingThContainer, th, tr, i2, td;
    tr = (0, import_jquery18.default)("<tr>");
    self2.csv.addRow();
    if (aiPivotIndex === 0) {
      tr.addClass("wcdv_btd");
    }
    index_default_default.each(self2.opts.displayOrder, function(what) {
      if (typeof what === "string") {
        switch (what) {
          case "rowVals":
            if (data.groupFields.length > 1) {
              for (i3 = 0; i3 < data.groupFields.length - 1; i3 += 1) {
                self2.csv.addCol("");
              }
            }
            self2.csv.addCol(aggInfo2.instance.getFullName());
            span = (0, import_jquery18.default)("<span>").addClass("wcdv_heading_title").text(aggInfo2.instance.getFullName());
            headingThControls = (0, import_jquery18.default)("<div>");
            headingThContainer = (0, import_jquery18.default)("<div>").addClass("wcdv_heading_container").append(span, headingThControls);
            th = (0, import_jquery18.default)("<th>").attr({ "colspan": data.groupFields.length }).append(headingThContainer).appendTo(tr);
            self2._addSortingToHeader(data, "horizontal", { aggType: "pivot", aggNum }, headingThControls.get(0), getPropDef([], data, "agg", "info", "cell"));
            break;
          case "cells":
            index_default_default.each(data.colVals, function(colVal, colValIdx) {
              for (var i4 = 0; i4 < aiPivotIndex; i4 += 1) {
                self2.csv.addCol("");
              }
              var td2 = (0, import_jquery18.default)("<td>").dvAttr({
                "cvi": colValIdx,
                "agg-scope": "pivot",
                "agg-num": aggInfo2.aggNum
              });
              var aggResult2 = data.agg.results.pivot[aggNum][colValIdx];
              if (isElement2(aggResult2)) {
                td2.append(aggResult2);
                self2.csv.addCol(getElement(aggResult2).innerText);
              } else {
                if (aggInfo2.instance.inheritFormatting) {
                  text = format2(aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggResult2, {
                    overrideType: aggInfo2.instance.getType()
                  });
                  setTableCell(td2, text, {
                    field: aggInfo2.fields[0],
                    colConfig: aggInfo2.colConfig[0],
                    typeInfo: aggInfo2.typeInfo[0]
                  });
                } else {
                  text = format2(null, null, aggResult2, {
                    overrideType: aggInfo2.instance.getType(),
                    decode: false
                  });
                  setTableCell(td2, text);
                }
                self2.csv.addCol(td2.text());
              }
              if (index_default_default.every(data.pivotSpec, function(ps) {
                return ps.fun == null;
              })) {
                self2._addDrillDownClass(td2.get(0));
              }
              if ((df.cell.length || ai.cell.length) > 1) {
                td2.attr("colspan", df.cell.length || ai.cell.length);
              }
              if (self2.opts.drawInternalBorders || ai.cell.length > 1) {
                td2.addClass("wcdv_pivot_colval_boundary");
              }
              self2.setAlignment(td2, aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggInfo2.instance.getType());
              td2.appendTo(tr);
              for (i4 = aiPivotIndex + 1; i4 < ai.pivot.length; i4 += 1) {
                self2.csv.addCol("");
              }
            });
            break;
          case "groupAggregates":
            if (getProp(data, "agg", "info", "all", aggNum)) {
              for (i3 = 0; i3 < aiPivotIndex; i3 += 1) {
                td = (0, import_jquery18.default)("<td><div>&nbsp;</div></td>");
                if (self2.opts.drawInternalBorders || ai.cell.length > 1) {
                  td.addClass(i3 === 0 ? "wcdv_pivot_aggregate_boundary" : "wcdv_pivot_colval_boundary");
                }
                td.addClass("wcdv_cell_empty");
                self2.csv.addCol("");
                td.appendTo(tr);
              }
              aggInfo2 = data.agg.info.all[aggNum];
              aggResult = data.agg.results.all[aggNum];
              td = (0, import_jquery18.default)("<td>");
              td.attr("data-wcdv-agg-scope", "all");
              td.attr("data-wcdv-agg-num", aggInfo2.aggNum);
              if (isElement2(aggResult)) {
                td.append(aggResult);
                self2.csv.addCol(getElement(aggResult).innerText);
              } else {
                if (aggInfo2.instance.inheritFormatting) {
                  text = format2(aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggResult, {
                    overrideType: aggInfo2.instance.getType()
                  });
                  setTableCell(td, text, {
                    field: aggInfo2.fields[0],
                    colConfig: aggInfo2.colConfig[0],
                    typeInfo: aggInfo2.typeInfo[0]
                  });
                } else {
                  text = format2(null, null, aggResult, {
                    overrideType: aggInfo2.instance.getType(),
                    decode: false
                  });
                  setTableCell(td, text);
                }
                self2.csv.addCol(td.text());
              }
              if (self2.opts.drawInternalBorders || ai.cell.length > 1) {
                td.addClass(aiPivotIndex === 0 ? "wcdv_pivot_aggregate_boundary" : "wcdv_pivot_colval_boundary");
              }
              self2.setAlignment(td, aggInfo2.colConfig[0], aggInfo2.typeInfo[0], aggInfo2.instance.getType());
              td.appendTo(tr);
              for (var i3 = aiPivotIndex + 1; i3 < ai.cell.length; i3 += 1) {
                td = (0, import_jquery18.default)("<td><div>&nbsp;</div></td>");
                if (self2.opts.drawInternalBorders || ai.cell.length > 1) {
                  td.addClass("wcdv_pivot_colval_boundary");
                }
                td.addClass("wcdv_cell_empty");
                self2.csv.addCol("");
                td.appendTo(tr);
              }
            }
            break;
        }
      }
    });
    tr.appendTo(self2.ui.tbody);
  });
  self2.csv.finish(function() {
    console.debug("[DataVis // %s // Generate CSV] Finished generating CSV file", self2.toString());
    self2.csvLock.unlock();
    self2.fire("generateCsvProgress", null, 100);
    self2.fire("csvReady");
  });
  if (typeof cont === "function") {
    return cont();
  }
};
GridTablePivot.prototype.addWorkHandler = function() {
  var self2 = this;
  self2.view.on(ComputedView.events.workEnd, function(info, ops) {
    console.debug("DataVis // " + self2.toString() + " // HANDLER (ComputedView.workEnd)", "ComputedView has finished doing work");
    if (!ops.pivot) {
      console.debug("DataVis // " + self2.toString() + " // HANDLER (ComputedView.workEnd)", "Unable to render this data: %O", ops);
      self2.fire("unableToRender", null, ops);
      return;
    }
    console.debug("DataVis // " + self2.toString() + " // HANDLER (ComputedView.workEnd)", "Redrawing because the view has done work");
    self2.draw(self2.root);
  }, { who: self2 });
};
GridRenderer.registry.set("table_pivot", GridTablePivot);

// node_modules/wcdatavis/src/grid.js
var Grid = makeSubclass("Grid", Object, function(defn, opts, cb2) {
  var self2 = this;
  opts = deepDefaults(opts, {
    runImmediately: true,
    showOnDataChange: true,
    showToolbar: true,
    showControls: false
  });
  self2.setName(opts.name);
  var rowCount = null;
  var clearFilter = null;
  var doingServerFilter = getProp(defn, "server", "filter") && getProp(defn, "server", "limit") !== -1;
  var viewDropdown = null;
  self2._isIdle = false;
  self2.generateCsv = false;
  self2.csvReady = false;
  self2.exportLock = new lock_default("Export");
  self2.colConfigLock = new lock_default("colConfig");
  self2.rootHasFixedHeight = false;
  self2.timing = new Timing();
  self2.colConfigWin = new ColConfigWin(self2);
  self2.debugWin = new DebugWin();
  self2.defn = self2._normalize(defn);
  self2.opts = opts;
  self2.grid = null;
  self2.ui = {};
  self2.selected = {};
  self2._validateFeatures();
  self2._validateId(self2.defn.id);
  self2.debug(null, "Definition: %O", defn);
  self2.debug(null, "Options: %O", opts);
  if (defn.computedView != null && !(defn.computedView instanceof ComputedView)) {
    throw new Error("Call Error: `defn.computedView` must be null or an instance of ComputedView");
  }
  if (defn.mirageView != null && !(defn.mirageView instanceof MirageView)) {
    throw new Error("Call Error: `defn.mirageView` must be null or an instance of MirageView");
  }
  if (defn.prefs != null && !(defn.prefs instanceof Prefs)) {
    throw new Error("Call Error: `defn.prefs` must be null or an instance of Prefs");
  }
  self2.computedView = defn.computedView;
  self2.mirageView = defn.mirageView;
  self2.prefs = defn.prefs;
  if (self2.computedView == null) {
    self2.debug("COMPUTED VIEW", "No computed view specified, creating our own.");
    self2.computedView = new ComputedView();
  }
  if (self2.mirageView == null) {
    self2.debug("MIRAGE VIEW", "No mirage view specified, creating our own.");
    self2.mirageView = new MirageView();
  }
  if (self2.prefs == null) {
    self2.debug("PREFS", "No prefs specified, creating our own.");
    self2.prefs = new Prefs(self2.id);
  }
  self2.computedView.setPrefs(self2.prefs);
  self2.mirageView.setPrefs(self2.prefs);
  self2.view = self2.defn.computedView || self2.defn.mirageView || self2.computedView;
  if (self2.colConfig != null) {
    self2.view.setColConfig(self2.colConfig);
  }
  self2.view.addClient(self2, "grid");
  self2.defn.grid = self2;
  self2.TemplatesEditor = new TemplatesEditor(self2, function() {
    self2.redraw();
  });
  self2.ui.root = jQuery(document.getElementById(self2.id)).addClass("wcdv_grid").attr("data-title", self2.id + "_title");
  self2.ui.root.children().remove();
  if (self2.ui.root.height() !== 0) {
    self2.rootHasFixedHeight = true;
    self2.rootHeight = self2.ui.root.height();
    if (self2.features.floatingHeader && getProp(self2.defn, "table", "floatingHeader", "method") === "tabletool" && window.TableTool != null) {
      self2.ui.root.css("height", "");
    }
  }
  if (self2.view.source.origin instanceof FileSource) {
    self2.ui.root._onFileDrop(function(files) {
      self2.view.source.origin.setFiles(files);
    });
  }
  self2.ui.titlebar = jQuery('<div class="wcdv_grid_titlebar">').attr("title", trans("GRID.TITLEBAR.SHOW_HIDE")).on("click", function(evt) {
    evt.stopPropagation();
    self2.toggle();
  }).droppable({
    accept: ".wcdv_drag_handle",
    over: function(evt, ui) {
      self2.showControls();
      ui.draggable.draggable("option", "refreshPositions", true);
    }
  }).appendTo(self2.ui.root);
  self2._addTitleWidgets(self2.ui.titlebar, doingServerFilter, self2.id);
  self2.ui.content = jQuery("<div>", {
    "class": "wcdv_grid_content"
  }).appendTo(self2.ui.root);
  self2.ui.toolbar = jQuery("<div>").addClass("wcdv_grid_toolbar").droppable({
    accept: ".wcdv_drag_handle",
    over: function(evt, ui) {
      self2.showControls();
      ui.draggable.draggable("option", "refreshPositions", true);
    }
  }).appendTo(self2.ui.content);
  self2.ui.toolbar_prefs = new PrefsToolbar(self2);
  self2.ui.toolbar_prefs.attach(self2.ui.toolbar);
  self2.prefs.bind("grid", self2, {
    toolbar: self2.ui.toolbar_prefs.ui.root
  });
  self2.ui.toolbar_computedView = new ComputedViewToolbar(self2);
  self2.ui.toolbar_computedView.attach(self2.ui.toolbar);
  self2.ui.toolbar_plain = new PlainToolbar(self2);
  self2.ui.toolbar_plain.attach(self2.ui.toolbar);
  self2.ui.toolbar_plain.hide();
  self2.ui.toolbar_group = new GroupToolbar(self2);
  self2.ui.toolbar_group.attach(self2.ui.toolbar);
  self2.ui.toolbar_group.hide();
  self2.ui.toolbar_pivot = new PivotToolbar(self2);
  self2.ui.toolbar_pivot.attach(self2.ui.toolbar);
  self2.ui.toolbar_pivot.hide();
  self2.ui.toolbar_renderer = new RendererToolbar(self2);
  self2.ui.toolbar_renderer.attach(self2.ui.toolbar);
  self2.ui.controls = jQuery("<div>", { "class": "wcdv_grid_control" });
  self2.ui.filterControl = jQuery("<div>", { "class": "wcdv_control_pane wcdv_filter_control" });
  self2.ui.groupControl = jQuery("<div>", { "class": "wcdv_control_pane wcdv_group_control" });
  self2.ui.pivotControl = jQuery("<div>", { "class": "wcdv_control_pane wcdv_pivot_control" });
  self2.ui.aggregateControl = jQuery("<div>", { "class": "wcdv_control_pane wcdv_aggregate_control" });
  self2.ui.operationsPalette = jQuery("<div>", { "class": "wcdv_grid_control" }).css({
    display: "block"
  });
  self2.ui.grid = jQuery("<div>", { "id": defn.table.id, "class": "wcdv_grid_table" });
  if (self2.rootHasFixedHeight) {
    if (!self2.features.floatingHeader || getProp(self2.defn, "table", "floatingHeader", "method") !== "tabletool") {
      self2.ui.grid.css("height", "0px");
    }
  }
  if (!self2.opts.showToolbar) {
    self2.ui.toolbar.hide();
  }
  if (!self2.opts.showControls) {
    self2.ui.controls.hide();
  }
  self2.filterControl = new FilterControl(self2, self2.colConfig, self2.view, self2.features, self2.timing);
  self2.ui.filterControl.children().remove();
  self2.filterControl.draw(self2.ui.filterControl);
  self2.ui.filterControl.show();
  self2.groupControl = new GroupControl(self2, self2.colConfig, self2.view, self2.features, self2.timing);
  self2.groupControl.draw(self2.ui.groupControl);
  self2.groupControl.on("fieldAdded", function(fieldAdded, fields) {
    self2.ui.pivotControl.show();
    self2.ui.aggregateControl.show();
  });
  self2.groupControl.on("fieldRemoved", function(fieldRemoved, fields) {
    if (fields.length === 0) {
      self2.ui.pivotControl.hide();
      self2.ui.aggregateControl.hide();
    }
  });
  self2.groupControl.on("cleared", function() {
    self2.ui.pivotControl.hide();
    self2.ui.aggregateControl.hide();
  });
  self2.pivotControl = new PivotControl(self2, self2.colConfig, self2.view, self2.features, self2.timing);
  self2.pivotControl.draw(self2.ui.pivotControl);
  self2.groupControl.getListElement().sortable({
    connectWith: "#" + self2.pivotControl.getListElement().attr("id")
  }).on("sortupdate", function() {
    self2.groupControl.sortableSync();
  });
  self2.pivotControl.getListElement().sortable({
    connectWith: "#" + self2.groupControl.getListElement().attr("id")
  }).on("sortupdate", function() {
    self2.pivotControl.sortableSync();
  });
  self2.operationsPalette = new OperationsPalette(self2);
  if (getProp(self2.defn, "operations", "all") != null) {
    self2.operationsPalette.setOperations(self2.defn.operations);
    self2.operationsPalette.draw(self2.ui.operationsPalette);
    self2.ui.operationsPalette.show();
  }
  self2.aggregateControl = new AggregateControl(self2, self2.colConfig, self2.view, self2.features, self2.timing);
  self2.aggregateControl.draw(self2.ui.aggregateControl);
  if (self2.rootHasFixedHeight) {
    self2.ui.grid.css({ "overflow": "auto" });
  }
  if (document.getElementById(self2.id + "_footer")) {
    self2.ui.footer = jQuery(document.getElementById(self2.id + "_footer"));
  }
  self2.ui.root.append(self2.ui.titlebar).append(self2.ui.content.append(self2.ui.toolbar).append(self2.ui.controls.append(self2.ui.filterControl).append(self2.ui.groupControl).append(self2.ui.pivotControl).append(self2.ui.aggregateControl)).append(self2.ui.operationsPalette).append(self2.ui.grid).append(self2.ui.footer));
  var initialRender = true;
  self2.tableDoneCont = function(grid, srcIndex) {
    self2.debug(null, "Finished drawing grid table!");
    if (initialRender) {
      initialRender = false;
    }
    if (typeof cb2 === "function") {
      cb2();
    }
  };
  self2.view.on("fetchDataBegin", function() {
    self2._setSpinner("loading");
    self2._showSpinner();
    if (self2.opts.title) {
      self2.ui.title._addTrailing(",");
      self2.ui.statusSpan.show().text(trans("GRID.TITLEBAR.LOADING"));
      self2.ui.rowCount.hide();
    }
    if (self2.view.source.isCancellable()) {
      self2.ui.cancelFetchBtn.show();
    }
  });
  self2.view.on("fetchDataEnd", function() {
    self2._hideSpinner();
    self2.ui.cancelFetchBtn.hide();
    self2.ui.statusSpan.show().text(trans("GRID.TITLEBAR.LOADED"));
  });
  self2.view.source.on("fetchDataCancel", function() {
    self2.ui.cancelFetchBtn.hide();
    if (initialRender) {
      if (self2.opts.title) {
        self2.ui.title._addTrailing(",");
        self2.ui.statusSpan.show().text(trans("GRID.TITLEBAR.NOT_LOADED"));
        self2.ui.rowCount.hide();
      }
      self2._setSpinner("not-loaded");
      self2.hasRun = false;
      self2.hide();
    } else {
      if (self2.opts.title) {
        self2.ui.title._addTrailing(",");
        self2.ui.statusSpan.hide();
        self2.ui.rowCount.show();
      }
      self2._hideSpinner();
    }
  });
  self2.view.on("workBegin", function() {
    self2._isIdle = false;
    self2._setSpinner("working");
    self2._showSpinner();
    if (self2.opts.title) {
      self2.ui.title._addTrailing(",");
      self2.ui.statusSpan.show().text(trans("GRID.TITLEBAR.WORKING"));
      self2.ui.rowCount.hide();
    }
  });
  self2.view.on("workEnd", function(info, ops) {
    self2._isIdle = true;
    self2._hideSpinner();
    self2.ui.title._stripTrailing(",");
    self2.ui.statusSpan.hide();
    self2.ui.rowCount.show();
    self2._updateRowCount(info, ops);
  });
  self2.view.on("dataUpdated", function() {
    if (self2.opts.showOnDataChange && !self2.isVisible()) {
      self2.show({ redraw: false });
    }
    self2.redraw();
  });
  self2.view.on("getTypeInfo", function(typeInfo) {
    self2.colConfigFromTypeInfo(typeInfo);
  });
  self2.prefs.prime(function() {
    self2.prefs.on("perspectiveChanged", function(id, p) {
      self2.setView();
      self2.redraw();
    }, {
      info: "Changing view type to match new perspective"
    });
    if (self2.opts.runImmediately) {
      self2.setView();
      self2.redraw();
    } else {
      self2.hasRun = false;
      self2.hide();
    }
  });
  setProp(self2, window, "MIE", "WC_DataVis", "grids", self2.id);
});
mixinEventHandling(Grid, [
  "showControls",
  "hideControls",
  "renderBegin",
  "renderEnd",
  "colConfigUpdate",
  "selectionChange"
]);
delegate(Grid, "renderer", ["setSelection", "getSelection", "select", "unselect", "isSelected"]);
mixinDebugging(Grid);
mixinLogging(Grid);
mixinNameSetting(Grid);
Grid.prototype.toString = function() {
  var self2 = this;
  return "Grid(" + self2.id + ")";
};
Grid.prototype._validateFeatures = function() {
  var self2 = this;
  self2.features = {};
  var availableFeatures = [
    "footer",
    "sort",
    "filter",
    "group",
    "pivot",
    "rowSelect",
    "rowReorder",
    "add",
    "edit",
    "delete",
    "limit",
    "floatingHeader",
    "block",
    "progress",
    "incremental",
    "operations"
  ];
  if (getProp(self2.defn, "table", "footer") !== void 0) {
    setPropDef(true, self2.defn, "table", "features", "footer");
  }
  index_default_default.each(availableFeatures, function(feat) {
    self2.features[feat] = getPropDef(false, self2.defn, "table", "features", feat);
  });
  self2.debug(null, "Features =", self2.features);
};
Grid.prototype._validateId = function(id) {
  var self2 = this;
  if (index_default_default.isArray(id) && id[0] instanceof jQuery) {
    id = id[0];
  }
  if (id instanceof jQuery) {
    id = id.attr("id");
  }
  if (typeof id !== "string") {
    throw '<grid> "id" is not a string';
  }
  if (document.getElementById(id) === null) {
    throw "No element exists with given ID: " + id;
  }
  self2.id = id;
  setProp(id + "_gridContainer", self2.defn, "table", "id");
};
Grid.prototype.setView = function() {
  var self2 = this;
  var p = self2.prefs.currentPerspective;
  if (p.isMirage()) {
    self2.debug("SET VIEW", 'Switching to Mirage View for pre-computed data for perspective "%s"', p.name);
    self2.view = self2.prefs.modules["mirage"].target;
    self2.view.setPerspectiveName(p.name);
  } else {
    self2.debug("SET VIEW", 'Switching to Computed View for live data for perspective "%s"', p.name);
    self2.view = self2.prefs.modules["view"].target;
  }
};
Grid.prototype._addTitleWidgets = function(titlebar, doingServerFilter, id) {
  var self2 = this;
  self2.ui.spinner = jQuery("<span>", {
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_spinner"
  }).appendTo(titlebar);
  self2._setSpinner(self2.opts.runImmediately ? "loading" : "not-loaded");
  self2.ui.title = jQuery("<strong>", { "id": id + "_title", "data-parent": id }).addClass("wcdv_title").text(self2.opts.title).appendTo(titlebar);
  var notHeader = jQuery("<span>", { "class": "headingInfo" }).on("click", function(evt) {
    evt.stopPropagation();
  }).appendTo(titlebar);
  notHeader.append(" ");
  self2.ui.statusSpan = jQuery("<span>").appendTo(notHeader);
  self2.ui.rowCount = jQuery("<span>").appendTo(notHeader);
  self2.ui.selectionInfo = jQuery("<span>").appendTo(notHeader);
  self2.ui.clearFilter = jQuery("<span>").hide().append(" (").append(jQuery("<span>", { "class": "link" }).text(trans("GRID.TITLEBAR.CLEAR_FILTER")).on("click", function(evt) {
    evt.stopPropagation();
    self2.ui.clearFilter.hide();
    self2.view.clearFilter({ notify: true });
  })).append(")").appendTo(notHeader);
  self2.ui.cancelFetchBtn = jQuery("<button>", { "type": "button" }).css({ "margin-left": "0.5em" }).text(trans("GRID.TITLEBAR.CANCEL")).on("click", function(evt) {
    evt.stopPropagation();
    self2.view.source.cancel();
  }).hide().appendTo(notHeader);
  if (typeof self2.opts.helpText === "string" && self2.opts.helpText !== "") {
    notHeader.append(" ");
    fontAwesome("F059").tooltip({
      classes: {
        "ui-tooltip": "ui-corner-all ui-widget-shadow wcdv_info_tooltip wcdv_border-primary"
      },
      show: { delay: 1e3 },
      content: self2.opts.helpText
    }).appendTo(notHeader);
  }
  self2.ui.titlebar_controls = jQuery("<div>").addClass("wcdv_titlebar_controls pull-right").appendTo(titlebar);
  if (window.MIE && window.MIE.DEBUGGING) {
    jQuery("<button>", {
      "type": "button",
      "style": "font-size: 18px",
      "class": "wcdv_icon_button wcdv_text-primary"
    }).attr("title", trans("GRID.TITLEBAR.SHOW_DEBUG_INFO")).click(function(evt) {
      evt.stopPropagation();
      self2.debugWin.show(self2, self2.view, self2.view.source);
    }).append(fontAwesome("fa-bug")).appendTo(self2.ui.titlebar_controls);
  }
  self2.ui.exportBtn = jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary"
  }).on("click", function(evt) {
    evt.stopPropagation();
    self2.export();
  }).appendTo(self2.ui.titlebar_controls);
  self2._setExportStatus("notReady");
  self2.ui.refreshBtn = jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary"
  }).attr("title", trans("GRID.TITLEBAR.REFRESH")).on("click", function(evt) {
    evt.stopPropagation();
    self2.refresh();
  }).append(fontAwesome("f021")).appendTo(self2.ui.titlebar_controls);
  var pWinEffect = {
    effect: "fade",
    duration: 100
  };
  var pWin = jQuery("<div>", { title: trans("GRID.PERSPECTIVE_WIN.TITLE") }).dialog({
    autoOpen: false,
    modal: true,
    width: 500,
    position: {
      my: "top",
      at: "bottom",
      of: titlebar
    },
    show: pWinEffect,
    hide: pWinEffect
  });
  var pWinWarning = jQuery("<div>").addClass("wcdv_warning_banner").appendTo(pWin);
  var pWinTextArea = jQuery("<textarea>", { "style": "font-family: monospace; font-size: 10pt; width: 100%", "rows": "20", "readonly": true }).appendTo(pWin);
  jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary"
  }).attr("title", trans("GRID.TITLEBAR.SHOW_HIDE_CONTROLS")).click(function(evt) {
    evt.stopPropagation();
    if (evt.shiftKey) {
      if (self2.prefs.currentPerspective.opts.isTemporary) {
        pWinWarning.text(trans("GRID.PERSPECTIVE_WIN.TEMP_PERSPECTIVE_WARNING"));
        pWinWarning.show();
      } else {
        pWinWarning.hide();
      }
      pWinTextArea.val(JSON.stringify(self2.prefs.currentPerspective.config, null, 2));
      pWin.dialog("open");
    } else {
      self2.toggleControls();
    }
  }).append(jQuery(fontAwesome("fa-cog"))).appendTo(self2.ui.titlebar_controls);
  self2.ui.showHideButton = jQuery("<button>", {
    "type": "button",
    "style": "font-size: 18px",
    "class": "wcdv_icon_button wcdv_text-primary showhide"
  }).attr("title", trans("GRID.TITLEBAR.SHOW_HIDE")).click(function(evt) {
    evt.stopPropagation();
    self2.toggle();
  }).append(jQuery(fontAwesome("f078"))).appendTo(self2.ui.titlebar_controls);
};
Grid.prototype.clear = function() {
  var self2 = this;
  self2.ui.root.children().remove();
};
Grid.prototype.redraw = function(contOk, contFail) {
  var self2 = this;
  if (contOk != null && typeof contOk !== "function") {
    throw new Error("Call Error: `contOk` must be null or a function");
  }
  if (contFail != null && typeof contFail != "function") {
    throw new Error("Call Error: `contFail` must be null or a function");
  }
  contOk = contOk || I;
  contFail = contFail || I;
  var makeGridTable = function() {
    var rendererCtor, rendererCtorOpts;
    self2.colConfigLock.lock("redrawing grid; prevent colConfig changes from notifying existing renderer");
    self2.view.getData(function(ok, data) {
      if (!ok) {
        return contFail();
      }
      if (self2.defn.renderer != null) {
        self2.rendererName = self2.defn.renderer;
        rendererCtor = GridRenderer.registry.get(self2.defn.renderer);
        rendererCtorOpts = deepCopy(self2.defn.rendererOpts);
      } else {
        self2.rendererName = "table";
        if (data.isPlain) {
          rendererCtor = GridRenderer.registry.get(getPropDef("table_plain", self2.defn, "whenPlain", "renderer"));
          rendererCtorOpts = deepCopy(self2.defn.table.whenPlain);
          if (self2.ui.footer) {
            rendererCtorOpts.footer = self2.ui.footer;
          }
          self2.debug(null, "Creating plain grid table");
        } else if (data.isGroup) {
          switch (self2.defn.table.groupMode) {
            case "summary":
              rendererCtor = GridRenderer.registry.get(getPropDef("table_group_summary", self2.defn, "whenGroup", "renderer"));
              break;
            case "detail":
              rendererCtor = GridRenderer.registry.get(getPropDef("table_group_detail", self2.defn, "whenGroup", "renderer"));
              break;
          }
          rendererCtorOpts = deepCopy(self2.defn.table.whenGroup);
          if (self2.ui.footer) {
            rendererCtorOpts.footer = self2.ui.footer;
          }
          self2.debug(null, "Creating group grid table");
        } else if (data.isPivot) {
          rendererCtor = GridRenderer.registry.get(getPropDef("table_pivot", self2.defn, "whenPivot", "renderer"));
          rendererCtorOpts = deepCopy(self2.defn.table.whenPivot);
          self2.debug(null, "Creating pivot grid table");
        }
      }
      if (self2.renderer) {
        self2.renderer.destroy();
      }
      rendererCtorOpts.generateCsv = self2.generateCsv;
      rendererCtorOpts.fixedHeight = self2.rootHasFixedHeight;
      self2.ui.exportBtn.attr("disabled", true);
      self2.renderer = new rendererCtor(self2, self2.defn, self2.view, self2.features, rendererCtorOpts, self2.timing, self2.id, self2.colConfig);
      if (data.isPlain) {
        self2.ui.toolbar_plain.show();
        self2.ui.toolbar_group.hide();
        self2.ui.toolbar_pivot.hide();
      } else if (data.isGroup) {
        self2.ui.toolbar_plain.hide();
        self2.ui.toolbar_group.show();
        self2.ui.toolbar_pivot.hide();
      } else if (data.isPivot) {
        self2.ui.toolbar_plain.hide();
        self2.ui.toolbar_group.hide();
        self2.ui.toolbar_pivot.show();
      }
      self2.renderer.on("renderBegin", function() {
        self2._isIdle = false;
        self2.fire("renderBegin");
      });
      self2.renderer.on("renderEnd", function() {
        self2.fire("renderEnd");
        self2._isIdle = true;
      });
      self2.renderer.on("unableToRender", function() {
        self2._setExportStatus("notReady");
        makeGridTable();
      });
      self2.renderer.on("csvReady", function() {
        if (self2.exportLock.isLocked()) {
          self2.exportLock.unlock();
        }
        self2._setExportStatus("ready");
      });
      self2.renderer.on("generateCsvProgress", function(progress) {
        if (progress === 0) {
          self2.ui.exportBtn.children("span.fa").remove();
          self2.ui.exportBtn.append(fontAwesome("fa-spinner", "fa-pulse"));
        }
      });
      if (self2.features.limit) {
        self2.renderer.on("limited", function() {
          self2.ui.limit_div.show();
        });
        self2.renderer.on("unlimited", function() {
          self2.ui.limit_div.hide();
        });
      }
      if (self2.features.rowSelect) {
        self2.renderer.on("selectionChange", function(selection) {
          if (selection.length === 0) {
            self2.ui.selectionInfo.text("");
          } else {
            var addComma = self2.ui.rowCount.text().length > 0;
            var str = addComma ? ", " : "";
            str += trans(selection.length === 1 ? "GRID.TITLEBAR.SELECTED_COUNT_SINGULAR" : "GRID.TITLEBAR.SELECTED_COUNT_PLURAL", selection.length);
            self2.ui.selectionInfo.text(str);
          }
          self2.fire("selectionChange", null, selection);
        });
      }
      self2.renderer.draw(self2.ui.grid, null, function() {
        if (self2.colConfigLock.isLocked()) {
          self2.colConfigLock.unlock("renderer finished drawing");
        }
        self2.setSelection();
        self2.ui.exportBtn.attr("disabled", false);
        self2.tableDoneCont();
      });
    });
  };
  self2.debug(null, "Redrawing...");
  makeGridTable();
};
Grid.prototype.refresh = function() {
  var self2 = this;
  if (!self2.isVisible()) {
    return;
  }
  self2.debug(null, "Refreshing...");
  self2._isIdle = false;
  self2.view.refresh();
};
Grid.prototype._updateRowCount = function(info, ops) {
  var self2 = this;
  var doingServerFilter = getProp(self2.defn, "server", "filter") && getProp(self2.defn, "server", "limit") !== -1;
  var text = [];
  self2.debug(null, "Updating row count");
  if (!self2.opts.title) {
    return;
  }
  self2._hideSpinner();
  if (info.numRows != null) {
    if (info.totalRows != null) {
      text.push(info.numRows + " / " + trans(info.totalRows === 1 ? "GRID.TITLEBAR.RECORD_COUNT_SINGULAR" : "GRID.TITLEBAR.RECORD_COUNT_PLURAL", info.totalRows));
    } else {
      text.push(trans(info.numRows === 1 ? "GRID.TITLEBAR.RECORD_COUNT_SINGULAR" : "GRID.TITLEBAR.RECORD_COUNT_PLURAL", info.numRows));
    }
  }
  if (info.isGroup || info.isPivot) {
    text.push(trans(info.numGroups === 1 ? "GRID.TITLEBAR.GROUP_COUNT_SINGULAR" : "GRID.TITLEBAR.GROUP_COUNT_PLURAL", info.numGroups));
  }
  self2.ui.rowCount.text(text.join(", "));
  if (self2.view.source.origin.isLimited && !document.getElementById(self2.id + "_isLimitedNotice") && (info.totalRows || info.numRows) == self2.view.source.origin.opts.autoLimit) {
    self2.ui.groupControl.hide();
    jQuery("<span>", {
      "id": self2.id + "_isLimitedNotice",
      "style": "color:red; font-weight:bold; margin-left:50px",
      "text": trans("GRID.TITLEBAR.DATA_LIMITED_WARNING")
    }).on("click", function() {
      self2.view.unlimit();
      self2.refresh();
      self2.ui.groupControl.show();
    }).appendTo(self2.ui.rowCount);
  }
  if (self2.ui.clearFilter) {
    if (info.totalRows) {
      self2.ui.clearFilter.show();
    } else {
      self2.ui.clearFilter.hide();
    }
  }
  self2.ui.title._addTrailing(",");
};
Grid.prototype.hide = function() {
  var self2 = this;
  self2.debug(null, "Hiding...");
  self2.ui.content.hide({
    duration: 0,
    done: function() {
      if (self2.opts.title) {
        self2.ui.showHideButton.removeClass("open fa-rotate-180");
      }
    }
  });
};
Grid.prototype.show = function(opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    redraw: true
  });
  self2.debug(null, "Showing...");
  self2.ui.content.show({
    duration: 0,
    done: function() {
      if (self2.opts.title) {
        self2.ui.showHideButton.addClass("open fa-rotate-180");
      }
      if (!self2.hasRun && opts.redraw) {
        self2.hasRun = true;
        self2.redraw();
      }
    }
  });
};
Grid.prototype.toggle = function() {
  var self2 = this;
  if (self2.ui.content.css("display") === "none") {
    self2.show();
  } else {
    self2.hide();
  }
};
Grid.prototype.isVisible = function() {
  var self2 = this;
  return self2.ui.content.css("display") !== "none";
};
Grid.prototype.hideControls = function() {
  var self2 = this;
  if (self2.ui.controls._isHidden()) {
    return;
  }
  self2.ui.controls.hide({
    duration: 0,
    complete: function() {
      self2.fire(Grid.events.hideControls);
    }
  });
  self2.ui.toolbar.hide({
    duration: 0,
    complete: function() {
    }
  });
};
Grid.prototype.showControls = function() {
  var self2 = this;
  if (!self2.ui.controls._isHidden()) {
    return;
  }
  self2.ui.controls.show({
    duration: 0,
    complete: function() {
      self2.fire(Grid.events.showControls);
    }
  });
  self2.ui.toolbar.show({
    duration: 0,
    complete: function() {
    }
  });
};
Grid.prototype.toggleControls = function() {
  var self2 = this;
  if (self2.ui.controls._isHidden()) {
    self2.showControls();
  } else {
    self2.hideControls();
  }
};
Grid.prototype._setSpinner = function(what) {
  var self2 = this;
  switch (what) {
    case "loading":
      self2.ui.spinner.html(fontAwesome("F021", "fa-spin", trans("GRID.TITLEBAR.LOADING")));
      break;
    case "not-loaded":
      self2.ui.spinner.html(fontAwesome("F05E", null, trans("GRID.TITLEBAR.NOT_LOADED")));
      break;
    case "working":
      self2.ui.spinner.html(fontAwesome("F1CE", "fa-spin", trans("GRID.TITLEBAR.WORKING")));
      break;
  }
};
Grid.prototype._showSpinner = function() {
  var self2 = this;
  if (self2.opts.title) {
    self2.ui.spinner.show();
  }
};
Grid.prototype._hideSpinner = function() {
  var self2 = this;
  if (self2.opts.title) {
    self2.ui.spinner.hide();
  }
};
Grid.prototype._normalize = function(defn) {
  var self2 = this;
  if (defn == null) {
    defn = {};
  }
  if (defn.normalized) {
    return;
  }
  defn.normalized = true;
  deepDefaults(true, defn, {
    prefs: null,
    table: {
      groupMode: "detail",
      features: {
        sort: true,
        filter: true,
        group: true,
        pivot: true,
        rowSelect: false,
        rowReorder: false,
        add: false,
        edit: false,
        delete: false,
        limit: true,
        floatingHeader: true,
        block: false,
        progress: false
      },
      limit: {
        appendBodyLast: false,
        method: "more",
        threshold: 100,
        chunkSize: 50
      },
      floatingHeader: {
        method: "tabletool"
      },
      incremental: {
        method: "setTimeout",
        delay: 10,
        chunkSize: 100
      }
    }
  });
  self2._normalizeColumns(defn);
  return defn;
};
Grid.prototype._normalizeColumns = function(defn) {
  var self2 = this;
  if (getProp(defn, "table", "columns") == null) {
    self2.initColConfig = null;
    self2.colConfig = null;
    return;
  }
  var colConfig = new ordmap_default();
  for (var i2 = 0; i2 < defn.table.columns.length; i2 += 1) {
    var cc = defn.table.columns[i2];
    if (index_default_default.isString(cc)) {
      cc = { field: cc };
    }
    if (typeof cc.field !== "string") {
      log.warn("Column Configuration: `field` must be a string");
      continue;
    }
    cc = deepDefaults(cc, {
      hideMidnight: false,
      format_dateOnly: "LL",
      allowHtml: false,
      canHide: true
    });
    colConfig.set(cc.field, cc);
  }
  self2.initColConfig = colConfig.clone();
  index_default_default.each(getPropDef([], defn, "table", "columnConfig"), function(cc2, colName) {
    if (cc2.widget === "checkbox") {
      if (cc2.filter !== void 0 && cc2.filter !== "checkbox") {
        log.warn('Overriding configuration to use filter type "' + cc2.filter + '" for checkbox widgets.');
      }
      cc2.filter = "checkbox";
    }
  });
  self2.setColConfig(colConfig, {
    from: "defn",
    savePrefs: false
  });
};
Grid.prototype.export = function() {
  var self2 = this;
  if (self2.exportLock.isLocked()) {
    return;
  }
  if (self2.csvReady) {
    var fileName = (self2.opts.title || self2.id) + ".csv";
    var csv = self2.renderer.getCsv();
    var contentType = "text/csv";
    var blob = new Blob([csv], { "type": contentType });
    presentDownload(blob, fileName);
  } else {
    self2.exportLock.lock();
    self2.generateCsv = true;
    self2.redraw();
  }
};
Grid.prototype._setExportStatus = function(status) {
  var self2 = this;
  switch (status) {
    case "notReady":
      self2.csvReady = false;
      self2.ui.exportBtn.attr("title", trans("GRID.TITLEBAR.GENERATE_CSV"));
      self2.ui.exportBtn.children("span.fa").remove();
      self2.ui.exportBtn.append(fontAwesome("fa-file-o"));
      break;
    case "ready":
      self2.csvReady = true;
      self2.ui.exportBtn.attr("title", trans("GRID.TITLEBAR.DOWNLOAD_CSV"));
      self2.ui.exportBtn.children("span.fa").remove();
      self2.ui.exportBtn.append(fontAwesome("fa-download"));
      break;
    default:
      throw new Error('Call Error: invalid status "' + status + '"');
  }
};
Grid.prototype.setColConfig = function(colConfig, opts) {
  var self2 = this;
  var updated = false;
  if (["defn", "prefs", "typeInfo", "ui", "reset"].indexOf(opts.from) < 0) {
    throw new Error("Call Error: `opts.from` must be one of: [defn, prefs, typeInfo, ui, reset]");
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    redraw: true,
    savePrefs: true
  });
  if (self2.colConfigLock.isLocked() && self2.renderer) {
    opts.dontSendEventTo.push(self2.renderer);
  }
  var setCurrent = function() {
    self2.debug("COLCONFIG", "Setting from %s: %O", opts.from || "[unknown]", colConfig);
    self2.colConfig = colConfig;
    self2.colConfigSource = opts.from;
    if (self2.renderer != null) {
      self2.renderer.colConfig = self2.colConfig;
    }
    self2.debug("COLCONFIG", "Setting shadow from %s: %O", opts.from || "[unknown]", colConfig);
    self2.shadowColConfig = colConfig.clone();
    updated = true;
  };
  var setInitial = function() {
    self2.debug("COLCONFIG", "Setting initial from %s: %O", opts.from || "[unknown]", colConfig);
    self2.initColConfig = colConfig.clone();
  };
  var addMissing = function(src, srcMsg, dst, dstMsg) {
    var count = dst.mergeWith(src);
    self2.debug("COLCONFIG", "Merged %d fields from %s into %s", count, srcMsg, dstMsg);
    return count;
  };
  var removeMissing = function(src, srcMsg, dst, dstMsg) {
    var absent = [];
    dst.each(function(fcc, fieldName) {
      if (!src.isSet(fieldName)) {
        absent.push(fieldName);
      }
    });
    if (absent.length > 0) {
      self2.debug(
        "COLCONFIG",
        "Removing %d fields from %s which are absent from %s: %O",
        absent.length,
        dstMsg,
        srcMsg,
        absent
      );
      index_default_default.each(absent, function(fieldName) {
        dst.unset(fieldName);
      });
      return true;
    }
    return false;
  };
  if (typeof getProp(self2.defn, "advice", "setColConfig", "before") === "function") {
    self2.defn.advice.setColConfig.before(colConfig, opts.from, self2);
  }
  switch (opts.from) {
    case "defn":
      setCurrent();
      setInitial();
      self2.colConfigRestricted = true;
      break;
    case "prefs":
      if (self2.colConfigRestricted) {
        self2.colConfig.each(function(v, k) {
          if (colConfig.isSet(k)) {
            index_default_default.defaults(colConfig.get(k), v);
          }
        });
        removeMissing(self2.colConfig, "defn", colConfig, "prefs");
        addMissing(self2.colConfig, "defn", colConfig, "prefs");
      }
      setCurrent();
      break;
    case "reset":
    case "ui":
      setCurrent();
      break;
    case "typeInfo":
      if (self2.colConfig == null) {
        setCurrent();
      } else {
        self2.colConfig = self2.shadowColConfig.clone();
        if (self2.renderer != null) {
          self2.renderer.colConfig = self2.colConfig;
        }
        if (removeMissing(colConfig, "source", self2.colConfig, "existing")) {
          updated = true;
        }
        if (!self2.colConfigRestricted) {
          if (addMissing(colConfig, "source", self2.colConfig, "existing")) {
            updated = true;
          }
        }
      }
      if (self2.initColConfig == null) {
        setInitial();
      }
      break;
  }
  if (!updated) {
    return;
  }
  if (opts.savePrefs) {
    self2.prefs.save();
  }
  if (opts.sendEvent) {
    self2.fire("colConfigUpdate", {
      notTo: opts.dontSendEventTo
    }, self2.colConfig, self2.initColConfig);
  }
  if (opts.redraw) {
  }
};
Grid.prototype.getColConfig = function(colConfig) {
  var self2 = this;
  return self2.colConfig;
};
Grid.prototype.resetColConfig = function(opts) {
  var self2 = this;
  self2.debug("COLCONFIG", "Resetting to: %O", self2.initColConfig);
  opts = deepDefaults(opts, {
    from: "reset",
    savePrefs: false
  });
  self2.setColConfig(self2.initColConfig.clone(), opts);
};
Grid.prototype.isIdle = function() {
  var self2 = this;
  return self2._isIdle;
};
Grid.prototype.colConfigFromTypeInfo = function(typeInfo, opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    from: "typeInfo",
    savePrefs: false
  });
  if (!(typeInfo instanceof ordmap_default)) {
    throw new Error("Call Error: `typeInfo` must be an OrdMap");
  }
  var typeInfoColConfig = new ordmap_default();
  typeInfo.each(function(fti, fieldName) {
    typeInfoColConfig.set(fieldName, {
      field: fieldName
    });
  });
  self2.debug(null, "Creating colConfig from typeInfo: %O -> %O", typeInfo.asMap(), typeInfoColConfig.asMap());
  self2.setColConfig(typeInfoColConfig, opts);
};
Grid.prototype.setOperations = function(ops) {
  var self2 = this;
  if (self2.operationsPalette != null) {
    self2.operationsPalette.setOperations(ops);
    self2.operationsPalette.draw(self2.ui.operationsPalette);
  }
  self2.defn.operations = ops;
  self2.redraw();
};

// node_modules/wcdatavis/src/prefs.js
var Prefs = makeSubclass("Prefs", Object, function(name, moduleBindings, opts) {
  var self2 = this;
  if (typeof name !== "string") {
    throw new Error("Call Error: `name` must be a string");
  }
  if (moduleBindings != null && typeof moduleBindings !== "object") {
    throw new Error("Call Error: `moduleBindings` must be null or an object");
  }
  if (opts != null && typeof opts !== "object") {
    throw new Error("Call Error: `opts` must be null or an object");
  }
  self2.setName(name);
  self2.modules = {};
  self2.bardo = {};
  self2.primeLock = new lock_default("Prefs Prime");
  self2.opts = deepDefaults(opts, {
    autoSave: true,
    saveCurrent: true,
    savePerspectives: true,
    backend: {
      type: Prefs.DEFAULT_BACKEND_TYPE
    }
  });
  self2.init();
  if (!PREFS_BACKEND_REGISTRY.isSet(self2.opts.backend.type)) {
    throw new Error("PREFS BACKEND IS NOT REGISTERED");
  }
  var backendCtor = PREFS_BACKEND_REGISTRY.get(self2.opts.backend.type);
  var backendCtorOpts = self2.opts.backend[self2.opts.backend.type];
  self2.debug(
    null,
    'Creating new preferences backend: name = "%s" ; type = %s ; opts = %O',
    self2.name,
    self2.opts.backend.type,
    backendCtorOpts
  );
  self2.backend = new backendCtor(self2.name, self2, backendCtorOpts);
  if (moduleBindings != null) {
    index_default_default.each(moduleBindings, function(target, moduleName) {
      self2.bind(moduleName, target);
    });
  }
});
Prefs.MAIN_PERSPECTIVE_NAME = "Main Perspective";
Prefs.DEFAULT_BACKEND_TYPE = "localStorage";
mixinEventHandling(Prefs, [
  "perspectiveAdded",
  "perspectiveDeleted",
  "perspectiveRenamed",
  "perspectiveChanged",
  "prefsHistoryStatus",
  "prefsReset",
  "prefsChanged",
  "prefsSaved",
  "moduleBound",
  "primed"
]);
mixinDebugging(Prefs);
mixinLogging(Prefs);
mixinNameSetting(Prefs);
Prefs.prototype.toString = function() {
  var self2 = this;
  return "Prefs(" + self2.name + ", " + self2.opts.backend.type + ")";
};
Prefs.prototype.init = function() {
  var self2 = this;
  if (self2.isInitialized) {
    return;
  }
  self2.debug(null, "Initializing prefs system");
  self2.isInitialized = true;
  self2.perspectives = {};
  self2.availablePerspectives = [];
  self2.currentPerspective = null;
  self2.history = [];
  self2.historyIndex = 0;
};
Prefs.prototype.prime = function(cont) {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  if (self2.isPrimed) {
    return cont(false);
  }
  if (self2.primeLock.isLocked()) {
    return self2.primeLock.onUnlock(function() {
      self2.prime.apply(self2, args);
    });
  }
  self2.primeLock.lock();
  var makeFinishCont = function(status) {
    return function() {
      self2.debug("PRIMING", "End");
      self2.isPrimed = true;
      self2.primeLock.unlock();
      return cont(status);
    };
  };
  self2.init();
  self2.debug("PRIMING", "Begin");
  return self2.backend.getPerspectives(function(ids) {
    self2.availablePerspectives = index_default_default.union(self2.availablePerspectives, ids);
    self2.backend.loadAll(function(perspectives) {
      asyncEach(index_default_default.values(perspectives), function(x, i2, next) {
        self2.addPerspective(x.id, x.name, x.config, null, next, {
          switch: false
        });
      }, function() {
        self2.debug("PRIMING", "Finished adding all perspectives");
        self2.fire("primed");
        if (self2.currentPerspective != null) {
          return makeFinishCont(true)();
        } else if (self2.availablePerspectives.length === 0) {
          self2.debug("PRIMING", "No perspectives exist, creating one");
          return self2.addMainPerspective(makeFinishCont(true));
        } else {
          return self2.backend.getCurrent(function(currentId) {
            if (currentId == null) {
              self2.debug("PRIMING", "No current perspective set, creating one");
              return self2.addMainPerspective(makeFinishCont(true));
            } else {
              self2.setCurrentPerspective(currentId, makeFinishCont(true));
            }
          });
        }
      });
    });
  });
};
Prefs.prototype._firePrefsHistoryStatus = function() {
  var self2 = this;
  self2.fire("prefsHistoryStatus", null, self2.historyIndex < self2.history.length - 1, self2.historyIndex > 0);
};
Prefs.prototype.back = function() {
  var self2 = this;
  if (self2.historyIndex === self2.history.length - 1) {
    return;
  }
  self2.historyIndex += 1;
  self2._firePrefsHistoryStatus();
  self2.setCurrentPerspective(self2.history[self2.historyIndex].id, null, {
    resetHistory: false
  });
};
Prefs.prototype.forward = function() {
  var self2 = this;
  if (self2.historyIndex === 0) {
    return;
  }
  self2.historyIndex -= 1;
  self2._firePrefsHistoryStatus();
  self2.setCurrentPerspective(self2.history[self2.historyIndex].id, null, {
    resetHistory: false
  });
};
Prefs.prototype._resetHistory = function(p) {
  var self2 = this;
  self2.history.splice(0, self2.historyIndex);
  if (p != null) {
    self2.history.unshift(p);
  }
  self2.historyIndex = 0;
  self2._firePrefsHistoryStatus();
};
Prefs.prototype._historyDebug = function() {
  var self2 = this;
  console.log("### HISTORY ### [%d] %O", self2.historyIndex, self2.history.map(function(x) {
    return x.name;
  }));
};
Prefs.prototype.bind = function(moduleName, target, moduleBoundUserData) {
  var self2 = this;
  if (typeof moduleName !== "string") {
    throw new Error("Call Error: `moduleName` must be a string");
  }
  if (target == null) {
    throw new Error("Call Error: `target` is required");
  }
  if (!PREFS_MODULE_REGISTRY.isSet(moduleName)) {
    throw new Error("Module is not registered: " + moduleName);
  }
  var moduleCtor = PREFS_MODULE_REGISTRY.get(moduleName);
  self2.modules[moduleName] = new moduleCtor(self2, target);
  self2.debug("BIND", "Binding module %s to target %s", moduleName, target.toString());
  self2.fire("moduleBound", null, moduleName, self2.modules[moduleName], target, moduleBoundUserData);
  if (self2.currentPerspective != null) {
    self2.currentPerspective.load([moduleName]);
  }
};
Prefs.prototype.getPerspectives = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  return cont(self2.availablePerspectives);
};
Prefs.prototype.getPerspective = function(qry) {
  var self2 = this;
  if (!index_default_default.isObject(qry)) {
    throw new Error("Call Error: `qry` must be an object");
  }
  if (qry.id != null) {
    return self2.perspectives[qry.id];
  } else if (qry.name != null) {
    return index_default_default.findWhere(self2.perspectives, { name: qry.name });
  } else {
    return null;
  }
};
Prefs.prototype.addPerspective = function(id, name, config, perspectiveOpts, cont, opts) {
  var self2 = this;
  if (id != null && typeof id !== "string") {
    throw new Error("Call Error: `id` must be null or a string");
  }
  if (name != null && typeof name !== "string") {
    throw new Error("Call Error: `name` must be null or a string");
  }
  if (config != null && typeof config !== "object") {
    throw new Error("Call Error: `config` must be null or an object");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  if (opts != null && typeof opts !== "object") {
    throw new Error("Call Error: `opts` must be null or an object");
  }
  if (name == null) {
    name = id;
  }
  cont = cont || I;
  opts = deepDefaults(opts, {
    switch: true,
    loadAfterSwitch: true,
    sendEvent: true,
    onDuplicate: "nothing"
  });
  var needToLoad = opts.loadAfterSwitch;
  if (["error", "nothing", "replace"].indexOf(opts.onDuplicate) < 0) {
    throw new Error("Call Error: `opts.onDuplicate` must be one of: error, nothing, replace");
  }
  var maybeSwitch = function() {
    if (opts.switch) {
      return self2.setCurrentPerspective(id, cont, {
        loadPerspective: needToLoad,
        sendEvent: opts.sendEvent
      });
    }
    return cont(true);
  };
  if (self2.perspectives[id] != null) {
    switch (opts.onDuplicate) {
      case "error":
        throw new Error("Perspective already exists: " + id);
      case "nothing":
        return maybeSwitch();
    }
  }
  var addPerspective = function() {
    var p = new Perspective(id, name, config, self2.modules, perspectiveOpts);
    if (id == null) {
      id = p.id;
    }
    self2.debug(null, 'Adding new perspective: id = "%s" ; name = "%s" ; config = %O', id, name, config);
    if (self2.availablePerspectives.indexOf(id) < 0) {
      self2.availablePerspectives.push(id);
    }
    self2.perspectives[id] = p;
    if (opts.sendEvent) {
      self2.fire("perspectiveAdded", {
        notTo: opts.dontSendEventTo
      }, id);
    }
    return maybeSwitch();
  };
  if (self2.currentPerspective) {
    self2.debug("ADD", 'Saving current perspective "%s" before adding new one "%s"', self2.currentPerspective.name, name);
    self2.save();
    if (config == null) {
      config = deepCopy(self2.currentPerspective.config);
    }
    return addPerspective();
  } else if (config == null) {
    config = {};
  }
  return addPerspective();
};
Prefs.prototype.addMainPerspective = function(cont) {
  var self2 = this;
  for (var i2 = 0; i2 < self2.availablePerspectives.length; i2 += 1) {
    var id = self2.availablePerspectives[i2];
    if (self2.perspectives[id].name === Prefs.MAIN_PERSPECTIVE_NAME) {
      return self2.setCurrentPerspective(id, cont);
    }
  }
  self2.addPerspective(null, Prefs.MAIN_PERSPECTIVE_NAME, {}, null, cont);
};
Prefs.prototype.deletePerspective = function(id, cont, opts) {
  var self2 = this;
  if (id != null && typeof id !== "string") {
    throw new Error("Call Error: `id` must be null or a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  opts = deepDefaults(opts, {
    sendEvent: true
  });
  if (id == null) {
    id = self2.currentPerspective.id;
  }
  if (self2.perspectives[id].opts.isEssential) {
    self2.logError(
      "DELETE PERSPECTIVE",
      'Not allowed to delete essential perspective: id = "%s" ; name = "%s"',
      id,
      self2.perspectives[id].name
    );
    return cont(false);
  }
  self2.backend.deletePerspective(id, function(ok) {
    var newCurrent;
    var i2;
    if (!ok) {
      return cont(false);
    }
    delete self2.perspectives[id];
    self2.availablePerspectives = index_default_default.without(self2.availablePerspectives, id);
    if (opts.sendEvent) {
      self2.fire("perspectiveDeleted", {
        notTo: opts.dontSendEventTo
      }, id, newCurrent);
    }
    if (self2.availablePerspectives.length === 0) {
      self2.historyIndex = self2.history.length;
      self2._resetHistory();
      self2.currentPerspective = null;
      return self2.addMainPerspective(cont);
    }
    if (self2.currentPerspective.id === id) {
      while (self2.historyIndex > 0 && self2.history[self2.historyIndex].id === id) {
        self2.historyIndex -= 1;
      }
      self2.history = index_default_default.reject(self2.history, function(p) {
        return p.id === id;
      });
      if (self2.history.length === 0) {
        self2.currentPerspective = null;
        return self2.addMainPerspective(cont);
      } else {
        var newCurId = self2.history[self2.historyIndex].id;
        for (var i2 = self2.historyIndex + 1; i2 < self2.history.length && self2.history[i2].id !== newCurId; i2 += 1) {
          self2.history[i2] = null;
        }
        self2.history = index_default_default.without(self2.history, null);
        self2._firePrefsHistoryStatus();
        if (self2.history.length > 0) {
          self2.setCurrentPerspective(self2.history[0].id, null, {
            resetHistory: false
          });
        } else {
          self2.setCurrentPerspective(self2.availablePerspectives[0]);
        }
      }
    }
  });
};
Prefs.prototype.renamePerspective = function(id, newName, cont, opts) {
  var self2 = this;
  var isCurrent = false;
  opts = deepDefaults(opts, {
    sendEvent: true
  });
  if (id != null && typeof id !== "string") {
    throw new Error("Call Error: `id` must be null or a string");
  }
  if (typeof newName !== "string") {
    throw new Error("Call Error: `newName` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  if (id == null) {
    id = self2.currentPerspective.id;
  }
  cont = cont || I;
  if (id === self2.currentPerspective.id) {
    isCurrent = true;
  }
  if (self2.perspectives[id] == null) {
    throw new Error(import_sprintf_js17.default.sprintf('Perspective does not exist: id = "%s"', id));
  }
  index_default_default.each(self2.perspectives, function(p) {
    if (p.name === newName) {
      log.warn(import_sprintf_js17.default.sprintf(
        'Renaming perspective (id = "%s") now shares the name "%s" with a different perspective (id = "%s")',
        id,
        newName,
        p.id
      ));
    }
  });
  self2.perspectives[id].name = newName;
  self2.perspectives[id].save(function() {
    self2.backend.save(self2.currentPerspective, function() {
      if (opts.sendEvent) {
        self2.fire("perspectiveRenamed", {
          notTo: opts.dontSendEventTo
        }, id, newName);
      }
      return cont(true);
    });
  });
};
Prefs.prototype.setCurrentPerspective = function(id, cont, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments);
  if (typeof id !== "string") {
    throw new Error("Call Error: `id` must be a string");
  }
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  opts = deepDefaults(opts, {
    loadPerspective: true,
    sendEvent: true,
    resetHistory: true
  });
  if (self2.perspectives[id] == null) {
    if (self2.availablePerspectives.indexOf(id) < 0) {
      self2.logWarning("SET CURRENT PERSPECTIVE", 'Perspective does not exist: id = "%s"', id);
      if (self2.availablePerspectives.length === 0) {
        return self2.addMainPerspective(cont);
      } else {
        id = self2.availablePerspectives[0];
      }
    }
    return self2.backend.load(id, function(config) {
      return self2.addPerspective(id, null, config, null, cont);
    });
  }
  self2.debug(null, 'Switching to perspective: id = "%s"', id);
  self2.currentPerspective = self2.perspectives[id];
  if (opts.resetHistory) {
    self2._resetHistory(self2.currentPerspective);
  }
  var afterLoad = function() {
    if (opts.sendEvent) {
      self2.fire("perspectiveChanged", {
        notTo: opts.dontSendEventTo
      }, id, self2.currentPerspective);
    }
    self2.backend.setCurrent(id, function(ok) {
      return cont(ok);
    });
  };
  if (opts.loadPerspective) {
    return self2.currentPerspective.load(null, afterLoad);
  } else {
    return afterLoad();
  }
};
Prefs.prototype.setCurrentPerspectiveByName = function(name, cont, opts) {
  var self2 = this;
  var p = index_default_default.findWhere(self2.perspectives, { name });
  if (p != null) {
    return self2.setCurrentPerspective(p.id, cont, opts);
  }
  throw new Error('No such perspective: "' + name + '"');
};
Prefs.prototype.clonePerspective = function(qry, name, configMutator, ok, fail, opts) {
  var self2 = this;
  var src;
  if (name != null && !index_default_default.isString(name)) {
    throw new Error("Call Error: `name` must be null or a string");
  }
  if (configMutator != null && typeof configMutator !== "function") {
    throw new Error("Call Error: `configMutator` must be null or a function");
  }
  opts = deepCopy(opts, {
    message: "Enter new perspective name",
    switch: true,
    sendEvent: true
  });
  if (qry == null) {
    src = self2.currentPerspective;
  } else {
    src = self2.getPerspective(qry);
    if (src == null) {
      return fail('Perspective "' + JSON.stringify(qry) + '" does not exist');
    }
  }
  var newConfig = (configMutator || I)(deepCopy(src.config));
  var newName = name || prompt(opts.message, src.name);
  if (newName != null) {
    self2.debug("CLONE", 'Creating new perspective "%s" with config = %O', newName, newConfig);
    self2.addPerspective(null, newName, newConfig, null, function(isOk) {
      if (isOk) {
        return self2.save(ok);
      } else {
        return fail("Error cloning perspective");
      }
    }, {
      switch: opts.switch,
      loadAfterSwitch: false,
      sendEvent: opts.sendEvent
    });
  } else {
    return fail("Operation cancelled");
  }
};
Prefs.prototype.save = function(cont) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  if (self2.currentPerspective.opts.isTemporary) {
    return cont(false);
  }
  if (self2.opts.autoSave) {
    self2.reallySave(cont);
  } else {
    self2.currentPerspective.isUnsaved = true;
    self2.fire("prefsChanged");
  }
};
Prefs.prototype.reallySave = function(cont) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  if (self2.currentPerspective.opts.isTemporary) {
    return cont(false);
  }
  self2.currentPerspective.save(function() {
    self2.backend.save(self2.currentPerspective, function(ok) {
      if (ok) {
        self2.currentPerspective.isUnsaved = false;
        self2.fire("prefsSaved");
      }
      return cont(ok);
    });
  });
};
Prefs.prototype.reset = function(cont) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  index_default_default.each(self2.perspectives, function(p) {
    if (p.opts.isTemporary && p.opts.isEssential) {
      self2.debug(null, "Saving temporary essential perspective: %s", p.id);
      self2.bardo[p.id] = {
        id: p.id,
        name: p.name,
        config: p.config,
        opts: p.opts
      };
    }
  });
  var current = self2.currentPerspective.id;
  self2.backend.reset(function() {
    self2.isInitialized = false;
    self2.init();
    self2.fire("prefsReset");
    index_default_default.each(self2.modules, function(module2, moduleName) {
      if (typeof module2.reset === "function") {
        self2.debug(null, "Resetting module: moduleName = %s", moduleName);
        module2.reset();
      }
    });
    self2.debug(null, "Restoring temporary essential perspectives: %s", JSON.stringify(index_default_default.keys(self2.bardo)));
    index_default_default.each(self2.bardo, function(p) {
      self2.addPerspective(p.id, p.name, p.config, p.opts, null, { switch: false });
    });
    if (self2.perspectives[current]) {
      self2.setCurrentPerspective(current);
    }
    self2.isPrimed = false;
    self2.prime(function() {
      return cont(true);
    });
  });
};
Prefs.prototype.inspect = function() {
  var self2 = this;
  var paths = Array.prototype.slice.call(arguments);
  var fmtRe = new RegExp("^(.*)/(\\w+)$");
  console.group("INSPECT RESULTS");
  index_default_default.each(self2.perspectives, function(perspective, uuid2) {
    var s2 = "", x = [];
    index_default_default.each(paths, function(path) {
      var m2 = path.match(fmtRe);
      var f2 = m2 && m2[2].length > 0 ? m2[2] : "string";
      path = m2 ? m2[1].split(".") : path.split(".");
      if (s2.length > 0) {
        s2 += ", ";
      }
      s2 += path[path.length - 1] + " = ";
      var y = getProp(perspective, path);
      if (typeof y === "string" || typeof y === "number") {
        s2 += y;
      } else if (f2 === "json") {
        s2 += JSON.stringify(y);
      } else {
        s2 += "%O";
        x.push(deepCopy(y));
      }
    });
    console.log.apply(null, [s2].concat(x));
  });
  console.groupEnd();
};

// node_modules/wcdatavis/src/computed_view.js
var ComputedView = makeSubclass("ComputedView", View, function(source, opts) {
  var self2 = this;
  if (!(source instanceof Source2) && !(source instanceof ComputedView)) {
    throw new Error("Call Error: `source` must be an instance of MIE.WC_DataVis.Source or MIE.WC_DataVis.ComputedView");
  }
  opts = deepDefaults(opts, {
    prefs: null,
    saveViewConfig: true,
    groupIsPivot: false
  });
  if (opts.prefs != null && !(opts.prefs instanceof Prefs)) {
    throw new Error("Call Error: `opts.prefs` must be null or an instance of MIE.WC_DataVis.Prefs");
  }
  self2.source = source;
  self2.opts = opts;
  self2.source.on("dataUpdated", function() {
    self2.clearCache();
    self2.fire("dataUpdated");
  });
  self2.source.on("fetchDataCancel", function() {
    self2.lock.clear();
  });
  self2.echo(self2.source, ["fetchDataBegin", "fetchDataEnd"]);
  self2.setName(opts.name);
  self2.colConfig = new ordmap_default();
  self2.timing = new Timing();
  self2.lock = new lock_default(self2.toString());
  self2.sortSpec = null;
  self2.filterSpec = null;
  self2.groupSpec = null;
  self2.pivotSpec = null;
  self2.aggregateSpec = objFromArray(["group", "pivot", "cell", "all"], [[{ fun: "count" }]]);
  if (opts.prefs != null) {
    self2.setPrefs(opts.prefs);
  }
  self2.isBoundToPrefs = false;
}, {
  prefsModule: "view"
});
mixinEventHandling(ComputedView, [
  "fetchDataBegin",
  "fetchDataEnd",
  "getTypeInfo",
  "dataUpdated",
  "workBegin",
  "workEnd",
  "sortSet",
  "filterSet",
  "groupSet",
  "pivotSet",
  "aggregateSet",
  "sortBegin",
  "sort",
  "sortEnd",
  "filterBegin",
  "filter",
  "filterEnd",
  "invalidFilterField",
  "invalidGroupField",
  "invalidPivotField",
  "invalidSortField",
  "invalidAggregate"
  // An aggregate function is invalid.
]);
delegate(ComputedView, "source", ["getUniqueVals", "decodeAll", "setToolbar"]);
mixinDebugging(ComputedView);
mixinLogging(ComputedView);
mixinNameSetting(ComputedView);
ComputedView.prototype.unlimit = function() {
  var self2 = this;
  this.source.unlimit();
};
ComputedView.prototype.toString = function() {
  var self2 = this;
  return "ComputedView(" + self2.name + ")";
};
ComputedView.prototype.addClient = function(client, kind) {
  var self2 = this;
  self2.clients = self2.clients || {};
  self2.clients[kind] = self2.clients[kind] || [];
  self2.clients[kind].push(client);
};
ComputedView.prototype.hasClientKind = function(kind) {
  var self2 = this;
  return getPropDef(0, self2.clients, kind, "length") > 0;
};
ComputedView.prototype.getRowCount = function() {
  var self2 = this;
  if (self2.data.isPlain) {
    return self2.data.data.length;
  } else if (self2.data.isGroup) {
    return index_default_default.reduce(self2.data.data, function(prev1, groupedData, rowValNum) {
      return prev1 + groupedData.length;
    }, 0);
  } else if (self2.data.isPivot) {
    return index_default_default.reduce(self2.data.data, function(prev1, groupedData, rowValNum) {
      return prev1 + index_default_default.reduce(groupedData, function(prev2, pivottedData, colValNum) {
        return prev2 + pivottedData.length;
      }, 0);
    }, 0);
  } else {
    throw new Error("Unable to determine row count when data is not plain, but also not grouped.");
  }
};
ComputedView.prototype.getTotalRowCount = function() {
  return this.source.cache.data.length;
};
ComputedView.prototype.setSort = function(spec, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setSort.apply(self2, args);
    }, "Waiting to set sort: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET SORT", "spec = %O", spec);
  isDifferent = !index_default_default.isEqual(self2.sortSpec, spec);
  self2.super.setSort(spec, opts);
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (opts.updateData) {
    self2.getData();
  }
  return true;
};
ComputedView.prototype.getSort = function() {
  var self2 = this;
  return self2.sortSpec;
};
ComputedView.prototype.clearSort = function(opts) {
  return this.setSort(null, opts);
};
ComputedView.prototype.sort = function(cont) {
  var self2 = this, timingEvt = ['Data Source "' + self2.source.name + '" : ' + self2.name, "Sorting"], conv = I, aggInfo = getProp(self2.data, "agg", "info");
  if (self2.sortSpec == null) {
    return cont(false);
  }
  self2.debug("SORT", "Beginning sort: %s", JSON.stringify(self2.sortSpec));
  var determineCmp = function(spec, fti) {
    var cmp2;
    if (fti == null) {
      log.error("Unable to sort: no type information {spec = %O}", spec);
      return null;
    }
    if (typeof fti === "string" || fti instanceof String) {
      fti = {
        type: fti
      };
    }
    if (fti.type == null) {
      log.error("Unable to sort: type unknown {spec = %O, fti = %O}", spec, fti);
      return null;
    }
    cmp2 = getComparisonFn.byType(fti.type);
    if (cmp2 == null) {
      log.error("Unable to sort: no comparison function for type {spec = %O, type = %s}", spec, fti.type);
      return null;
    }
    if (typeof cmp2 !== "function") {
      log.error("Unable to sort: invalid comparison function for type {spec = %O, type = %s}", spec, fti.type);
      return null;
    }
    Source2.decodeAll(self2.data.dataByRowId, fti.field, self2.typeInfo);
    return cmp2;
  };
  var packBundle = function(spec, orientation, sortSourceFn) {
    var bundle, len;
    if (sortSourceFn == null) {
      log.error("Unable to sort: no sort source function given {spec = %O}", spec);
      return null;
    }
    switch (orientation) {
      case "vertical":
        len = self2.data.isPlain ? self2.data.data.length : self2.data.rowVals.length;
        break;
      case "horizontal":
        len = self2.data.isPlain ? self2.data.data.length : self2.data.colVals.length;
        break;
      default:
        return null;
    }
    bundle = new Array(len);
    for (var i2 = 0; i2 < len; i2 += 1) {
      bundle[i2] = {
        oldIndex: i2,
        sortSource: sortSourceFn(i2)
      };
    }
    return bundle;
  };
  var unpackBundle = function(orientation) {
    return function(sorted) {
      self2.debug(
        "SORT // UNPACK",
        "Unpacking bundle of %d sorted chunks in %s orientation",
        sorted.length,
        orientation
      );
      var origData = self2.data.data;
      var origRowVals = getProp(self2.data, "rowVals");
      var origColVals = getProp(self2.data, "colVals");
      var origCellAgg = getProp(self2.data, "agg", "results", "cell");
      var origGroupAgg = getProp(self2.data, "agg", "results", "group");
      var origPivotAgg = getProp(self2.data, "agg", "results", "pivot");
      var ai, rvi;
      switch (orientation) {
        case "vertical":
          self2.data.data = [];
          if (origRowVals != null) {
            self2.data.rowVals = [];
          }
          if (origCellAgg != null) {
            self2.data.agg.results.cell = [];
          }
          if (origGroupAgg != null) {
            self2.data.agg.results.group = [];
          }
          var rowValIdxMap = {};
          index_default_default.each(sorted, function(s2, newIndex) {
            if (self2.data.isPlain) {
              self2.fire("sort", {
                silent: true
              }, origData[s2.oldIndex].rowNum, newIndex);
            }
            self2.data.data[newIndex] = origData[s2.oldIndex];
            if (origRowVals != null) {
              self2.data.rowVals[newIndex] = origRowVals[s2.oldIndex];
            }
            rowValIdxMap[s2.oldIndex] = newIndex;
          });
          if (self2.data.isGroup || self2.data.isPivot) {
            var postorder = function(node, depth) {
              if (node.children == null) {
                node.rowValIndex = rowValIdxMap[node.rowValIndex];
                self2.data.groupMetadata.lookup.byRowValIndex[node.rowValIndex] = node;
              } else {
                index_default_default.each(node.children, function(child) {
                  postorder(child, depth + 1);
                });
                if (depth > 0) {
                  node.rowValIndex = node.children[index_default_default.keys(node.children)[0]].rowValIndex;
                }
              }
            };
            postorder(self2.data.groupMetadata, 0);
          }
          if (origCellAgg != null) {
            for (ai = 0; ai < origCellAgg.length; ai += 1) {
              self2.data.agg.results.cell[ai] = [];
              index_default_default.each(sorted, function(s2, newIndex) {
                self2.data.agg.results.cell[ai][newIndex] = origCellAgg[ai][s2.oldIndex];
              });
            }
          }
          if (origGroupAgg != null) {
            for (ai = 0; ai < origGroupAgg.length; ai += 1) {
              self2.data.agg.results.group[ai] = [];
              index_default_default.each(sorted, function(s2, newIndex) {
                self2.data.agg.results.group[ai][newIndex] = origGroupAgg[ai][s2.oldIndex];
              });
            }
          }
          break;
        case "horizontal":
          self2.data.data = [];
          if (origColVals != null) {
            self2.data.colVals = [];
          }
          if (origCellAgg != null) {
            self2.data.agg.results.cell = [];
          }
          if (origPivotAgg != null) {
            self2.data.agg.results.pivot = [];
          }
          index_default_default.each(sorted, function(s2, newIndex) {
            self2.data.colVals[newIndex] = origColVals[s2.oldIndex];
            if (origColVals != null) {
              for (var rvi2 = 0; rvi2 < self2.data.rowVals.length; rvi2 += 1) {
                if (self2.data.data[rvi2] === void 0) {
                  self2.data.data[rvi2] = [];
                }
                self2.data.data[rvi2][newIndex] = origData[rvi2][s2.oldIndex];
              }
            }
          });
          if (origCellAgg != null) {
            for (ai = 0; ai < origCellAgg.length; ai += 1) {
              self2.data.agg.results.cell[ai] = new Array(self2.data.rowVals.length);
              for (rvi = 0; rvi < self2.data.rowVals.length; rvi += 1) {
                self2.data.agg.results.cell[ai][rvi] = new Array(self2.data.colVals.length);
                index_default_default.each(sorted, function(s2, newIndex) {
                  self2.data.agg.results.cell[ai][rvi][newIndex] = origCellAgg[ai][rvi][s2.oldIndex];
                });
              }
            }
          }
          if (origPivotAgg != null) {
            for (ai = 0; ai < origPivotAgg.length; ai += 1) {
              self2.data.agg.results.pivot[ai] = new Array(self2.data.colVals.length);
              index_default_default.each(sorted, function(s2, newIndex) {
                self2.data.agg.results.pivot[ai][newIndex] = origPivotAgg[ai][s2.oldIndex];
              });
            }
          }
          break;
      }
    };
  };
  var makeFinishCb = function(postProcess, next) {
    return function(sorted) {
      if (typeof postProcess === "function") {
        postProcess(sorted);
      } else {
        self2.data.data = sorted;
      }
      return next(true);
    };
  };
  var performSort = function(orientation, next) {
    var fti, sortSourceFn, spec = getProp(self2, "sortSpec", orientation), sortAlgorithm = "mergeSort";
    var rvi, cvi, gfi;
    if (spec == null) {
      return next(true);
    }
    spec = deepCopy(spec);
    if (self2.data.isPlain) {
      if (orientation === "horizontal") {
        log.error("Unable to sort: cannot perform horizontal sort on plain data");
        return next(false);
      }
      if (spec.field) {
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else {
          fti = self2.typeInfo.get(spec.field);
        }
        sortSourceFn = function(i2) {
          return self2.data.data[i2].rowData[spec.field].value;
        };
      }
    } else if (self2.data.isGroup) {
      if (orientation === "horizontal") {
        log.error("Unable to sort: cannot perform horizontal sort on grouped data");
        return next(false);
      }
      if (spec.field != null) {
        gfi = self2.data.groupFields.indexOf(spec.field);
        if (gfi < 0) {
          log.error('Unable to sort: `field` property does not refer to a grouped field {field = "%s", groupFields = %s}', spec.field, self2.data.groupFields);
        } else {
          spec.groupFieldIndex = gfi;
        }
      }
      if (spec.groupFieldIndex != null) {
        if (spec.groupFieldIndex < 0 || spec.groupFieldIndex >= self2.data.groupFields.length) {
          log.error(
            "Unable to sort: groupFieldIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.groupFields.length
          );
          return next(false);
        }
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else if (self2.data.groupSpec[spec.groupFieldIndex].fun != null) {
          fti = {
            type: GROUP_FUNCTION_REGISTRY.get(self2.data.groupSpec[spec.groupFieldIndex].fun).sortType
          };
        } else {
          fti = self2.typeInfo.get(self2.data.groupFields[spec.groupFieldIndex]);
        }
        sortSourceFn = function(i2) {
          return self2.data.rowVals[i2][spec.groupFieldIndex];
        };
      } else if (spec.aggType === "group" && spec.aggNum != null) {
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.group.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.group.length
          );
          return next(false);
        }
        fti = aggInfo.group[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.group[spec.aggNum][i2];
        };
      }
    } else if (self2.data.isPivot) {
      if (spec.field != null) {
        switch (orientation) {
          case "vertical":
            gfi = self2.data.groupFields.indexOf(spec.field);
            if (gfi < 0) {
              log.error('Unable to sort: `field` property does not refer to a grouped field {field = "%s", groupFields = %s}', spec.field, self2.data.groupFields);
            } else {
              spec.groupFieldIndex = gfi;
            }
            break;
          case "horizontal":
            var pfi = self2.data.pivotFields.indexOf(spec.field);
            if (pfi < 0) {
              log.error('Unable to sort: `field` property does not refer to a pivotted field {field = "%s", pivotFields = %s}', spec.field, self2.data.pivotFields);
            } else {
              spec.pivotFieldIndex = pfi;
            }
            break;
        }
      }
      if (spec.groupFieldIndex != null) {
        if (spec.groupFieldIndex < 0 || spec.groupFieldIndex >= self2.data.groupFields.length) {
          log.error(
            "Unable to sort: groupFieldIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.groupFields.length
          );
          return next(false);
        }
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else if (self2.data.groupSpec[spec.groupFieldIndex].fun != null) {
          fti = {
            type: GROUP_FUNCTION_REGISTRY.get(self2.data.groupSpec[spec.groupFieldIndex].fun).sortType
          };
        } else {
          fti = self2.typeInfo.get(self2.data.groupFields[spec.groupFieldIndex]);
        }
        sortSourceFn = function(i2) {
          return self2.data.rowVals[i2][spec.groupFieldIndex];
        };
      } else if ((spec.rowVal || spec.rowValIndex != null) && spec.aggNum != null) {
        if (spec.rowVal) {
          spec.rowValIndex = -1;
          for (rvi = 0; rvi < self2.data.rowVals.length; rvi += 1) {
            if (index_default_default.isEqual(self2.data.rowVals[rvi], spec.rowVal)) {
              spec.rowValIndex = rvi;
              break;
            }
          }
          if (spec.rowValIndex === -1) {
            log.error("Unable to sort: invalid rowVal {spec = %O}", spec);
            return next(false);
          }
        }
        if (spec.rowValIndex < 0 || spec.rowValIndex >= self2.data.rowVals.length) {
          log.error(
            "Unable to sort: rowValIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.rowVals.length
          );
          return next(false);
        }
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.cell.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.cell.length
          );
          return next(false);
        }
        fti = aggInfo.cell[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.cell[spec.aggNum][spec.rowValIndex][i2];
        };
      } else if (spec.pivotFieldIndex != null) {
        if (spec.pivotFieldIndex < 0 || spec.pivotFieldIndex >= self2.data.pivotFields.length) {
          log.error(
            "Unable to sort: pivotFieldIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.pivotFields.length
          );
          return next(false);
        }
        if (spec.values) {
          sortAlgorithm = "pigeonHole";
        } else if (self2.data.pivotSpec[spec.pivotFieldIndex].fun != null) {
          fti = {
            type: GROUP_FUNCTION_REGISTRY.get(self2.data.pivotSpec[spec.pivotFieldIndex].fun).sortType
          };
        } else {
          fti = self2.typeInfo.get(self2.data.pivotFields[spec.pivotFieldIndex]);
        }
        sortSourceFn = function(i2) {
          return self2.data.colVals[i2][spec.pivotFieldIndex];
        };
      } else if ((spec.colVal || spec.colValIndex != null) && spec.aggNum != null) {
        if (spec.colVal) {
          spec.colValIndex = -1;
          for (cvi = 0; cvi < self2.data.colVals.length; cvi += 1) {
            if (index_default_default.isEqual(self2.data.colVals[cvi], spec.colVal)) {
              spec.colValIndex = cvi;
              break;
            }
          }
          if (spec.colValIndex === -1) {
            log.error("Unable to sort: invalid colVal {spec = %O}", spec);
            return next(false);
          }
        }
        if (spec.colValIndex < 0 || spec.colValIndex >= self2.data.colVals.length) {
          log.error(
            "Unable to sort: colValIndex out of range {spec = %O, range = [0,%d]}",
            spec,
            self2.data.colVals.length
          );
          return next(false);
        }
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.cell.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.cell.length
          );
          return next(false);
        }
        fti = aggInfo.cell[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.cell[spec.aggNum][i2][spec.colValIndex];
        };
      } else if (spec.aggType === "pivot" && spec.aggNum != null) {
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.pivot.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.pivot.length
          );
          return next(false);
        }
        fti = aggInfo.pivot[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.pivot[spec.aggNum][i2];
        };
      } else if (spec.aggType === "group" && spec.aggNum != null) {
        if (spec.aggNum < 0 || spec.aggNum >= aggInfo.group.length) {
          log.error(
            "Unable to sort: aggNum out of range {spec = %O, range = [0,%d]}",
            spec,
            aggInfo.group.length
          );
          return next(false);
        }
        fti = aggInfo.group[spec.aggNum].instance.getType();
        sortSourceFn = function(i2) {
          return self2.data.agg.results.group[spec.aggNum][i2];
        };
      } else {
        log.error("Invalid sort spec for pivotted data: " + JSON.stringify(spec));
        return next(false);
      }
    }
    var cmp2, comparison;
    if (sortAlgorithm === "mergeSort") {
      cmp2 = determineCmp(spec, fti);
      if (cmp2 == null) {
        return next(false);
      }
      comparison = function(a2, b) {
        if (spec.dir.toUpperCase() === "ASC") {
          return cmp2(a2.sortSource, b.sortSource) <= 0;
        } else if (spec.dir.toUpperCase() === "DESC") {
          return cmp2(a2.sortSource, b.sortSource) > 0;
        } else {
          throw new Error('Invalid sort spec: `dir` must be either "ASC" or "DESC"');
        }
      };
    }
    var bundle = packBundle(spec, orientation, sortSourceFn);
    if (bundle == null) {
      return next(false);
    }
    var finish = makeFinishCb(unpackBundle(orientation), next);
    self2.debug("SORT", "Performing sort using %s algorithm", sortAlgorithm);
    switch (sortAlgorithm) {
      case "mergeSort":
        return mergeSort4(bundle, comparison, finish, self2.sortProgress && self2.sortProgress.update);
      case "pigeonHole":
        return pigeonHoleSort(bundle, spec.values, finish);
      default:
        throw new Error("Internal Error: Invalid sort algorithm: " + sortAlgorithm);
    }
  };
  var start = function() {
    self2.fire("sortBegin");
    self2.timing.start(timingEvt);
    if (self2.sortProgress && typeof self2.sortProgress.begin === "function") {
      self2.sortProgress.begin();
    }
  };
  var end = function(ok) {
    if (self2.sortProgress && typeof self2.sortProgress.end === "function") {
      self2.sortProgress.end();
    }
    self2.timing.stop(timingEvt);
    self2.fire("sortEnd");
    return cont(ok);
  };
  start();
  performSort("horizontal", function(didHorizontal) {
    if (!didHorizontal) {
      return end(false);
    }
    performSort("vertical", function(didVertical) {
      return end(didVertical);
    });
  });
};
ComputedView.prototype.setFilter = function(spec, progress, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  opts = deepCopy(opts) || {};
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setFilter.apply(self2, args);
    }, "Waiting to set filter: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET FILTER", "spec = %O ; options = %O", spec, opts);
  isDifferent = !index_default_default.isEqual(self2.filterSpec, spec);
  if (self2.filterSpec != null && spec == null) {
    self2.wasPreviouslyFiltered = true;
  }
  self2.filterSpec = spec;
  self2.filterProgress = progress;
  self2.super.setFilter(spec, opts);
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (opts.updateData) {
    self2.getData();
  }
  return true;
};
ComputedView.prototype.getFilter = function() {
  var self2 = this;
  return self2.filterSpec;
};
ComputedView.prototype.clearFilter = function(opts) {
  this.setFilter(null, null, opts);
};
ComputedView.prototype.isFiltered = function() {
  return this.filterSpec != null;
};
ComputedView.prototype.filter = function(cont) {
  var self2 = this, timingEvt = ['Data Source "' + self2.source.name + '" : ' + self2.name, "Filtering"], now2 = moment_default(getProp(window, "MIE", "WC_DataVis", "CURRENT_DATE"));
  if (self2.filterSpec == null) {
    if (!self2.wasPreviouslyFiltered) {
      return cont(false, self2.data.data);
    } else {
      self2.wasPreviouslyFiltered = false;
    }
  }
  index_default_default.each(self2.filterSpec, function(fieldSpec, field) {
    var fti = self2.typeInfo.get(field);
    if (fti === void 0) {
      log.error('Filter field "' + field + '" does not exist in the source');
      self2.fire("invalidFilterField", null, field);
      delete self2.filterSpec[field];
      return;
    }
    if (fti.type === void 0) {
      log.error('Unable to filter field "' + field + '", type is unknown');
      self2.fire("invalidFilterField", null, field);
      delete self2.filterSpec[field];
      return;
    }
    if (["date", "datetime"].indexOf(fti.type) >= 0 && fti.internalType === "moment") {
      index_default_default.each(fieldSpec, function(val, op) {
        if (typeof val === "string") {
          fieldSpec[op] = moment_default(val);
        }
      });
    }
    Source2.decodeAll(self2.data.dataByRowId, fti.field, self2.typeInfo);
  });
  function passesFilter(fltr, field, row) {
    var fti = self2.typeInfo.get(field);
    var datum = row[field].value;
    if (datum === void 0) {
      debug.warn(
        "VIEW (" + self2.name + ") // FILTER",
        "Attempted to filter by non-existent column: " + field
      );
      return false;
    }
    var isMoment2 = moment_default.isMoment(datum);
    var isNumeral = import_numeral16.default.isNumeral(datum);
    var isString2 = typeof datum === "string";
    var isNumber3 = typeof datum === "number";
    var pred = {};
    var cmp2 = getComparisonFn.byType(fti.type);
    pred["$eq"] = function(operand2) {
      return cmp2(datum, operand2) === 0;
    };
    pred["$ne"] = function(operand2) {
      return !pred["$eq"](operand2);
    };
    pred["$contains"] = function(operand2) {
      return isMoment2 && false || isNumeral && false || isString2 && datum.indexOf(operand2.toString().toLowerCase()) >= 0 || isNumber3 && false;
    };
    pred["$notcontains"] = function(operand2) {
      return !pred["$notcontains"](operand2);
    };
    pred["$gt"] = function(operand2) {
      return cmp2(datum, operand2) > 0;
    };
    pred["$gte"] = function(operand2) {
      return pred["$gt"](operand2) || pred["$eq"](operand2);
    };
    pred["$lt"] = function(operand2) {
      return cmp2(datum, operand2) < 0;
    };
    pred["$lte"] = function(operand2) {
      return pred["$lt"](operand2) || pred["$eq"](operand2);
    };
    pred["$exists"] = function(operand2) {
      return operand2 ? datum != null && (isString2 ? datum !== "" : true) : datum == null || (isString2 ? datum === "" : false);
    };
    pred["$notexists"] = function(operand2) {
      return !pred["$exists"](operand2);
    };
    if (index_default_default.isArray(fltr)) {
      fltr = { "$in": fltr };
    } else if (!index_default_default.isObject(fltr)) {
      fltr = { "$eq": fltr };
    }
    for (var operator in fltr) {
      if (!Object.prototype.hasOwnProperty.call(fltr, operator)) {
        continue;
      }
      var operand = fltr[operator];
      if (pred[operator] !== void 0) {
        if (index_default_default.isArray(operand)) {
          if (index_default_default.every(operand, pred[operator]) === false) {
            return false;
          }
        } else if (pred[operator](operand) === false) {
          return false;
        }
      } else {
        switch (operator) {
          case "$in":
            if (!index_default_default.isArray(operand)) {
              throw new Error('Invalid filter spec, operator "$in" for column "' + field + '" requires array value');
            }
            if (index_default_default.map(operand, function(elt2) {
              return elt2.toString().toLowerCase();
            }).indexOf(datum.toString().toLowerCase()) < 0) {
              return false;
            }
            break;
          case "$nin":
            if (!index_default_default.isArray(operand)) {
              throw new Error('Invalid filter spec, operator "$nin" for column "' + field + '" requires array value');
            }
            if (index_default_default.map(operand, function(elt2) {
              return elt2.toString().toLowerCase();
            }).indexOf(datum.toString().toLowerCase()) >= 0) {
              return false;
            }
            break;
          case "$every":
            var days2 = ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"];
            var months2 = ["JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER"];
            if (fti.type !== "date" && fti.type !== "datetime") {
              console.error('Invalid operator "$every" for field "' + field + '" of type "' + fti.type + '"');
              return false;
            }
            var dayIdx = days2.indexOf(operand);
            var monthIdx = months2.indexOf(operand);
            var d2 = isString2 ? moment_default(datum) : isMoment2 ? datum : null;
            if (d2 == null) {
              console.error('Operator "$every" cannot be applied to data in field "' + field + '" of type "' + fti.type + '" and internal type "' + fti.internalType + '"');
              return false;
            }
            if (dayIdx >= 0) {
              return d2.day() === dayIdx;
            } else if (monthIdx >= 0) {
              return d2.month() === monthIdx;
            } else {
              console.error('Invalid "$every" operand "' + operand + '" for field "' + field + '"');
              return false;
            }
            break;
          case "$this":
            if (fti.type !== "date" && fti.type !== "datetime") {
              console.error('Invalid operator "$this" for field "' + field + '" of type "' + fti.type + '"');
              return false;
            }
            var d2 = isString2 ? moment_default(datum) : isMoment2 ? datum : null;
            if (d2 == null) {
              console.error('Operator "$this" cannot be applied to data in field "' + field + '" of type "' + fti.type + '" and internal type "' + fti.internalType + '"');
              return false;
            }
            switch (operand) {
              case "DATE":
                return d2.format("YYYY-MM-DD") === now2.format("YYYY-MM-DD");
                break;
              case "WEEK":
                return d2.format("YYYY-WW") === now2.format("YYYY-WW");
                break;
              case "MONTH":
                return d2.format("YYYY-MM") === now2.format("YYYY-MM");
                break;
              case "QUARTER":
                return d2.format("YYYY-Q") === now2.format("YYYY-Q");
                break;
              case "YEAR":
                return d2.format("YYYY") === now2.format("YYYY");
                break;
              default:
                console.error('Invalid "$this" operand "' + operand + '" for field "' + field + '"');
                return false;
            }
            break;
          case "$last":
            if (fti.type !== "date" && fti.type !== "datetime") {
              console.error('Invalid operator "$last" for field "' + field + '" of type "' + fti.type + '"');
              return false;
            }
            var d2 = isString2 ? moment_default(datum) : isMoment2 ? datum : null;
            if (d2 == null) {
              console.error('Operator "$last" cannot be applied to data in field "' + field + '" of type "' + fti.type + '" and internal type "' + fti.internalType + '"');
              return false;
            }
            switch (operand) {
              case "DATE":
                return d2.format("YYYY-MM-DD") === now2.clone().subtract(1, "days").format("YYYY-MM-DD");
                break;
              case "WEEK":
                return d2.format("YYYY-WW") === now2.clone().subtract(1, "weeks").format("YYYY-WW");
                break;
              case "MONTH":
                return d2.format("YYYY-MM") === now2.clone().subtract(1, "months").format("YYYY-MM");
                break;
              case "QUARTER":
                return d2.format("YYYY-Q") === now2.clone().subtract(1, "quarters").format("YYYY-Q");
                break;
              case "YEAR":
                return d2.format("YYYY") === now2.clone().subtract(1, "years").format("YYYY");
                break;
              default:
                console.error('Invalid "$last" operand "' + operand + '" for field "' + field + '"');
                return false;
            }
            break;
          default:
            throw new Error('Invalid operator "' + operator + '" for column "' + field + '"');
        }
      }
    }
    return true;
  }
  function passesAllFilters(row) {
    var passes = self2.filterSpec == null ? true : eachUntilObj(self2.filterSpec, passesFilter, false, row.rowData);
    self2.fire("filter", {
      silent: true
    }, row.rowNum, !passes);
    return passes;
  }
  var i0 = {
    val: 0
  }, i_step = self2.filterProgress ? 100 : self2.data.data.length;
  var newData = [];
  var doFilter = function() {
    var i2;
    for (i2 = i0.val; i2 < self2.data.data.length && i2 < i0.val + i_step; i2 += 1) {
      if (passesAllFilters(self2.data.data[i2])) {
        newData.push(self2.data.data[i2]);
      }
    }
    if (i2 < self2.data.data.length) {
      i0.val = i2;
      if (self2.filterProgress && typeof self2.filterProgress.update === "function") {
        self2.filterProgress.update(i2, self2.data.data.length);
      }
      logAsync("ComputedView#filter");
      return window.setTimeout(doFilter);
    } else {
      if (self2.filterProgress && typeof self2.filterProgress.end === "function") {
        self2.filterProgress.end();
      }
      self2.fire("filterEnd");
      self2.timing.stop(timingEvt);
      return cont(true, newData);
    }
  };
  self2.timing.start(timingEvt);
  if (self2.filterProgress && typeof self2.filterProgress.begin === "function") {
    self2.filterProgress.begin();
  }
  self2.fire("filterBegin");
  return doFilter();
};
ComputedView.prototype.setGroup = function(spec, opts, cont) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setGroup.apply(self2, args);
    }, "Waiting to set group: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET GROUP", "spec = %O", spec);
  if (spec == null && self2.pivotSpec != null) {
    log.warn("VIEW (" + self2.name + ") // SET GROUP", "Having a pivot without a group is not allowed");
    self2.clearPivot(opts);
  }
  if (spec != null) {
    if (!index_default_default.isArray(spec.fieldNames)) {
      log.warn("VIEW (" + self2.name + ") // SET GROUP", "`spec.fieldNames` is not an array");
      spec.fieldNames = [];
    }
    for (var i2 = 0; i2 < spec.fieldNames.length; i2 += 1) {
      if (typeof spec.fieldNames[i2] === "string") {
        spec.fieldNames[i2] = { field: spec.fieldNames[i2] };
      }
    }
  }
  isDifferent = !index_default_default.isEqual(self2.groupSpec, spec);
  self2.super.setGroup(spec, opts);
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (!opts.updateData) {
    return true;
  }
  self2.getData();
  return true;
};
ComputedView.prototype.getGroup = function() {
  var self2 = this;
  return self2.groupSpec;
};
ComputedView.prototype.clearGroup = function(opts) {
  return this.setGroup(null, opts);
};
ComputedView.prototype.group = function() {
  var self2 = this, finalGroupSpec = [], newData, rowVals;
  if (self2.groupSpec == null) {
    return false;
  }
  if (self2.typeInfo == null) {
    log.error("Source type information is missing");
    return false;
  }
  index_default_default.each(self2.groupSpec.fieldNames, function(fieldObj) {
    var fti = self2.typeInfo.get(fieldObj.field);
    if (fti == null) {
      log.error("Group field does not exist in the source: " + fieldObj.field);
      self2.fire("invalidGroupField", null, fieldObj.field);
    } else if (fti.type == null) {
      log.error('Unable to group by field "%s": type is undefined');
    } else {
      Source2.decodeAll(self2.data.dataByRowId, fti.field, self2.typeInfo);
      finalGroupSpec.push(fieldObj);
    }
  });
  if (finalGroupSpec.length === 0) {
    return false;
  }
  var origKeys = [];
  var buildRowVals = function(addRowVals) {
    var rowVals2 = [], rowVal, row, rowIndex, groupSpecElt, groupFieldIndex2, cell, value, natRep, groupFun, groupFunResult;
    for (rowIndex = 0; rowIndex < self2.data.data.length; rowIndex += 1) {
      row = self2.data.data[rowIndex];
      rowVal = [];
      for (groupFieldIndex2 = 0; groupFieldIndex2 < finalGroupSpec.length; groupFieldIndex2 += 1) {
        groupSpecElt = finalGroupSpec[groupFieldIndex2];
        cell = row.rowData[groupSpecElt.field];
        value = cell.value;
        if (groupSpecElt.fun == null) {
          natRep = getNatRep(value);
          origKeys[groupFieldIndex2][natRep] = value;
        } else {
          groupFun = GROUP_FUNCTION_REGISTRY.get(groupSpecElt.fun);
          groupFunResult = groupFun.applyValueFun(value, self2.typeInfo.get(groupSpecElt.field));
          natRep = getNatRep(groupFunResult);
          origKeys[groupFieldIndex2][natRep] = groupFunResult;
        }
        rowVal[groupFieldIndex2] = natRep;
        setProp(natRep, cell, "natRep", "group", groupFieldIndex2);
      }
      if (index_default_default.findIndex(rowVals2, function(x) {
        return arrayEqual(rowVal, x);
      }) === -1) {
        rowVals2.push(rowVal);
      }
    }
    if (addRowVals != null) {
      for (var arvIndex = 0; arvIndex < addRowVals.length; arvIndex += 1) {
        rowVal = addRowVals[arvIndex];
        if (rowVal.length != finalGroupSpec.length) {
          log.error(
            "Unable to add rowVal %s when grouping by %s: the lengths must be the same",
            JSON.stringify(rowVal),
            JSON.stringify(finalGroupSpec)
          );
          continue;
        }
        for (groupFieldIndex2 = 0; groupFieldIndex2 < rowVal.length; groupFieldIndex2 += 1) {
          value = rowVal[groupFieldIndex2];
          natRep = getNatRep(value);
          origKeys[groupFieldIndex2][natRep] = value;
          rowVal[groupFieldIndex2] = natRep;
        }
        if (index_default_default.findIndex(rowVals2, function(x) {
          return arrayEqual(rowVal, x);
        }) === -1) {
          rowVals2.push(rowVal);
        }
      }
    }
    rowVals2.sort(function(a2, b) {
      return arrayCompare(a2, b);
    });
    return rowVals2;
  };
  var buildData = function(data, rowVals2) {
    var rowVal, rowValIndex, metadataLeaf, row, rowIndex, groupSpecElt, groupFieldIndex2, value, groupFun;
    var result2 = new Array(rowVals2.length);
    var metadataTree = {
      lookup: {
        byRowNum: new Array(data.length),
        byRowValIndex: new Array(rowVals2.length),
        byId: []
      }
    };
    for (rowValIndex = 0; rowValIndex < rowVals2.length; rowValIndex += 1) {
      rowVal = rowVals2[rowValIndex];
      metadataLeaf = {
        rowValIndex,
        rowValElt: rowVal[rowVal.length - 1],
        parent: null,
        numRows: 0,
        rows: []
      };
      result2[rowValIndex] = metadataLeaf.rows;
      setProp(metadataLeaf, metadataTree, "children", interleaveWith(rowVal, "children"));
      metadataTree.lookup.byRowValIndex[rowValIndex] = metadataLeaf;
    }
    for (rowIndex = 0; rowIndex < data.length; rowIndex += 1) {
      row = data[rowIndex];
      rowVal = new Array(finalGroupSpec.length);
      for (groupFieldIndex2 = 0; groupFieldIndex2 < finalGroupSpec.length; groupFieldIndex2 += 1) {
        groupSpecElt = finalGroupSpec[groupFieldIndex2];
        rowVal[groupFieldIndex2] = row.rowData[groupSpecElt.field].natRep.group[groupFieldIndex2];
      }
      metadataLeaf = getProp(metadataTree, "children", interleaveWith(rowVal, "children"));
      metadataTree.lookup.byRowNum[row.rowNum] = metadataLeaf;
      metadataLeaf.rows.push(row);
    }
    var metadataId = 0;
    var postorder = function(node, depth) {
      node.id = metadataId++;
      node.numRows = 0;
      metadataTree.lookup.byId[node.id] = node;
      if (node.children == null) {
        if (node.rows != null) {
          node.numRows = node.rows.length;
        }
      } else {
        node.numChildren = index_default_default.keys(node.children).length;
        node.rows = [];
        index_default_default.each(node.children, function(child) {
          child.parent = node;
          postorder(child, depth + 1);
          node.numRows += child.numRows;
          node.rows = node.rows.concat(child.rows);
        });
        if (depth > 0) {
          node.rowValIndex = node.children[index_default_default.keys(node.children)[0]].rowValIndex;
          node.rowValElt = rowVals2[node.rowValIndex][depth - 1];
        }
      }
      if (depth > 0) {
        node.groupFieldIndex = depth - 1;
        node.groupField = finalGroupSpec[node.groupFieldIndex].field;
        node.groupSpec = finalGroupSpec[node.groupFieldIndex];
        if (node.rows != null && node.rows.length > 0) {
          node.rowValCell = node.rows[0].rowData[node.groupField];
        }
      }
    };
    postorder(metadataTree, 0);
    return {
      data: result2,
      metadata: metadataTree
    };
  };
  var convertRowVals = function(rowVals2) {
    var result2 = [];
    for (var rowValIndex = 0; rowValIndex < rowVals2.length; rowValIndex += 1) {
      var rowVal = rowVals2[rowValIndex];
      result2[rowValIndex] = [];
      for (var groupFieldIndex2 = 0; groupFieldIndex2 < finalGroupSpec.length; groupFieldIndex2 += 1) {
        result2[rowValIndex][groupFieldIndex2] = origKeys[groupFieldIndex2][rowVal[groupFieldIndex2]];
      }
    }
    return result2;
  };
  for (var groupFieldIndex = 0; groupFieldIndex < finalGroupSpec.length; groupFieldIndex += 1) {
    origKeys[groupFieldIndex] = {};
  }
  rowVals = buildRowVals(self2.groupSpec.addRowVals);
  newData = buildData(self2.data.data, rowVals);
  rowVals = convertRowVals(rowVals);
  self2.debug("GROUP", "Group Spec: %O", finalGroupSpec);
  self2.debug("GROUP", "Row Vals: %O", rowVals);
  self2.debug("GROUP", "New Data: %O", newData.data);
  self2.data.isPlain = false;
  self2.data.isGroup = true;
  self2.data.groupFields = index_default_default.pluck(finalGroupSpec, "field");
  self2.data.groupSpec = finalGroupSpec;
  self2.data.rowVals = rowVals;
  self2.data.data = newData.data;
  self2.data.groupMetadata = newData.metadata;
  self2.debug("GROUP", "Final Data: %O", self2.data);
  return true;
};
ComputedView.prototype.setPivot = function(spec, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setPivot.apply(self2, args);
    }, "Waiting to set pivot: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET PIVOT", "spec = %O", spec);
  if (self2.groupSpec == null && spec != null) {
    log.warn("VIEW (" + self2.name + ") // SET PIVOT", "Having a pivot without a group is not allowed");
    self2.clearPivot(opts);
    return false;
  }
  if (spec != null) {
    if (!index_default_default.isArray(spec.fieldNames)) {
      log.warn("VIEW (" + self2.name + ") // SET PIVOT", "`spec.fieldNames` is not an array");
      spec.fieldNames = [];
    }
    for (var i2 = 0; i2 < spec.fieldNames.length; i2 += 1) {
      if (typeof spec.fieldNames[i2] === "string") {
        spec.fieldNames[i2] = { field: spec.fieldNames[i2] };
      }
    }
  }
  isDifferent = !index_default_default.isEqual(self2.pivotSpec, spec);
  self2.super.setPivot(spec, opts);
  if (isDifferent) {
    if (self2.pivotSpec == null || self2.pivotSpec.fieldNames.length === 0) {
      var sortSpec = self2.getSort();
      if (sortSpec != null && sortSpec.horizontal != null) {
        delete sortSpec.horizontal;
        log.warn("VIEW (" + self2.name + ") // SET PIVOT", "Removing horizontal sort configuration since pivot was cleared");
        self2.setSort(sortSpec, { updateData: false });
      }
    }
    if (self2.prefs != null && opts.savePrefs) {
      self2.prefs.save();
    }
  }
  self2.clearCache();
  if (!opts.updateData) {
    return true;
  }
  self2.getData();
  return true;
};
ComputedView.prototype.getPivot = function() {
  var self2 = this;
  return self2.pivotSpec;
};
ComputedView.prototype.clearPivot = function(opts) {
  return this.setPivot(null, opts);
};
ComputedView.prototype.pivot_orig = function() {
  var self2 = this, pivotFields = [], colValsTree, colVals;
  if (!self2.data.isGroup) {
    return false;
  }
  if (self2.pivotSpec == null) {
    return false;
  }
  if (self2.typeInfo == null) {
    log.error("Source type information is missing");
    return false;
  }
  index_default_default.each(self2.pivotSpec.fieldNames, function(field, fieldIdx) {
    if (!self2.typeInfo.isSet(field)) {
      log.error("Pivot field does not exist in the source: " + field);
      self2.fire("invalidPivotField", null, field);
    } else {
      pivotFields.push(field);
    }
  });
  if (pivotFields.length === 0) {
    return false;
  }
  var buildColValsTree = function(pivotFields2) {
    var colValsTree2 = {};
    index_default_default.each(self2.data.data, function(groupedRows) {
      (function RECUR(fieldNames, data, tree) {
        var field = car(fieldNames), tmp = {};
        index_default_default.each(data, function(row) {
          var value = row.rowData[field].orig || row.rowData[field].value;
          if (tree[value] === void 0) {
            tree[value] = fieldNames.length > 1 ? {} : true;
          }
          if (tmp[value] === void 0) {
            tmp[value] = [];
          }
          tmp[value].push(row);
        });
        if (fieldNames.length > 1) {
          index_default_default.each(tmp, function(pivottedRows, value) {
            RECUR(cdr(fieldNames), pivottedRows, tree[value]);
          });
        }
      })(pivotFields2, groupedRows, colValsTree2);
    });
    return colValsTree2;
  };
  var buildColVals = function(colValsTree2) {
    var colVals2 = [];
    (function RECUR(tree, level, path) {
      if (level === self2.pivotSpec.fieldNames.length) {
        index_default_default.each(index_default_default.keys(tree).sort(), function(value) {
          colVals2.push(path.concat([value]));
        });
      } else {
        index_default_default.each(tree, function(subtree, value) {
          RECUR(subtree, level + 1, path.concat([value]));
        });
      }
    })(colValsTree2, 1, []);
    return colVals2;
  };
  var buildData = function(data) {
    var result2 = [];
    index_default_default.each(data, function(groupedRows, groupNum) {
      var newData = [];
      index_default_default.each(colVals, function(colVal) {
        var tmp = [];
        index_default_default.each(groupedRows, function(row) {
          if (index_default_default.every(colVal, function(colValElt, colValNum) {
            var pivotField = pivotFields[colValNum];
            var value = row.rowData[pivotField].value;
            var natRep = getNatRep(value);
            return colValElt === natRep;
          })) {
            tmp.push(row);
          }
        });
        newData.push(tmp);
      });
      result2.push(newData);
    });
    return result2;
  };
  colValsTree = buildColValsTree(pivotFields);
  colVals = buildColVals(colValsTree);
  self2.data.data = buildData(self2.data.data, colVals);
  self2.debug("PIVOT", "Pivot Fields: %O", pivotFields);
  self2.debug("PIVOT", "Col Vals Tree: %O", colValsTree);
  self2.debug("PIVOT", "Col Vals: %O", colVals);
  self2.debug("PIVOT", "New Data: %O", self2.data);
  self2.data.isPlain = false;
  self2.data.isGroup = false;
  self2.data.isPivot = true;
  self2.data.pivotFields = pivotFields;
  self2.data.colVals = colVals;
  return true;
};
ComputedView.prototype.pivot = function() {
  var self2 = this, finalPivotSpec = [], colValsTree, colVals, newData;
  if (!self2.data.isGroup) {
    return false;
  }
  if (self2.pivotSpec == null) {
    return false;
  }
  if (self2.typeInfo == null) {
    log.error("Source type information is missing");
    return false;
  }
  index_default_default.each(self2.pivotSpec.fieldNames, function(fieldObj) {
    var fti = self2.typeInfo.get(fieldObj.field);
    if (fti == null) {
      log.error("Pivot field does not exist in the source: " + fieldObj.field);
      self2.fire("invalidPivotField", null, fieldObj.field);
    } else if (fti.type == null) {
      log.error('Unable to pivot by field "%s": type is undefined');
    } else {
      Source2.decodeAll(self2.data.dataByRowId, fti.field, self2.typeInfo);
      finalPivotSpec.push(fieldObj);
    }
  });
  if (finalPivotSpec.length === 0) {
    return false;
  }
  var origKeys = [];
  var buildColVals = function(addColVals) {
    var colVal, pivotFieldIndex2, pivotSpecElt, value, natRep, groupFun, groupIndex, group2, row, rowIndex, acvIndex, colVals2 = [];
    for (groupIndex = 0; groupIndex < self2.data.data.length; groupIndex += 1) {
      group2 = self2.data.data[groupIndex];
      for (rowIndex = 0; rowIndex < group2.length; rowIndex += 1) {
        row = group2[rowIndex];
        colVal = [];
        for (pivotFieldIndex2 = 0; pivotFieldIndex2 < finalPivotSpec.length; pivotFieldIndex2 += 1) {
          pivotSpecElt = finalPivotSpec[pivotFieldIndex2];
          value = row.rowData[pivotSpecElt.field].value;
          if (pivotSpecElt.fun == null) {
            natRep = getNatRep(value);
            origKeys[pivotFieldIndex2][natRep] = value;
          } else {
            groupFun = GROUP_FUNCTION_REGISTRY.get(pivotSpecElt.fun);
            natRep = groupFun.applyValueFun(value, self2.typeInfo.get(pivotSpecElt.field));
            origKeys[pivotFieldIndex2][natRep] = natRep;
          }
          setProp(natRep, row.rowData[pivotSpecElt.field], "natRep", "pivot", pivotFieldIndex2);
          colVal[pivotFieldIndex2] = natRep;
        }
        if (index_default_default.findIndex(colVals2, function(x) {
          return arrayEqual(colVal, x);
        }) === -1) {
          colVals2.push(colVal);
        }
      }
    }
    if (addColVals != null) {
      for (acvIndex = 0; acvIndex < addColVals.length; acvIndex += 1) {
        colVal = addColVals[acvIndex];
        if (colVal.length != finalPivotSpec.length) {
          log.error(
            "Unable to add colVal %s when pivotting by %s: the lengths must be the same",
            JSON.stringify(colVal),
            JSON.stringify(finalPivotSpec)
          );
          continue;
        }
        for (pivotFieldIndex2 = 0; pivotFieldIndex2 < colVal.length; pivotFieldIndex2 += 1) {
          value = colVal[pivotFieldIndex2];
          natRep = getNatRep(value);
          origKeys[pivotFieldIndex2][natRep] = value;
          colVal[pivotFieldIndex2] = natRep;
        }
        if (index_default_default.findIndex(colVals2, function(x) {
          return arrayEqual(colVal, x);
        }) === -1) {
          colVals2.push(colVal);
        }
      }
    }
    colVals2.sort(function(a2, b) {
      return arrayCompare(a2, b);
    });
    return colVals2;
  };
  var buildData = function(data) {
    var result2 = [];
    index_default_default.each(data, function(groupedRows, groupNum) {
      var newData2 = [];
      index_default_default.each(colVals, function(colVal) {
        var tmp = [];
        index_default_default.each(groupedRows, function(row) {
          if (index_default_default.every(colVal, function(colValElt, colValIndex) {
            var pivotSpecElt = finalPivotSpec[colValIndex];
            return colValElt === row.rowData[pivotSpecElt.field].natRep.pivot[colValIndex];
          })) {
            tmp.push(row);
          }
        });
        newData2.push(tmp);
      });
      result2.push(newData2);
    });
    return result2;
  };
  var convertColVals = function(colVals2) {
    var result2 = [];
    for (var colValIndex = 0; colValIndex < colVals2.length; colValIndex += 1) {
      var colVal = colVals2[colValIndex];
      result2[colValIndex] = [];
      for (var pivotFieldIndex2 = 0; pivotFieldIndex2 < finalPivotSpec.length; pivotFieldIndex2 += 1) {
        result2[colValIndex][pivotFieldIndex2] = origKeys[pivotFieldIndex2][colVal[pivotFieldIndex2]];
      }
    }
    return result2;
  };
  for (var pivotFieldIndex = 0; pivotFieldIndex < finalPivotSpec.length; pivotFieldIndex += 1) {
    origKeys[pivotFieldIndex] = {};
  }
  colVals = buildColVals(self2.pivotSpec.addColVals);
  newData = buildData(self2.data.data, colVals);
  colVals = convertColVals(colVals);
  self2.debug("PIVOT", "Pivot Spec: %O", finalPivotSpec);
  self2.debug("PIVOT", "Orig Keys: %O", origKeys);
  self2.debug("PIVOT", "Col Vals: %O", colVals);
  self2.debug("PIVOT", "New Data: %O", newData);
  self2.data.isPlain = false;
  self2.data.isGroup = false;
  self2.data.isPivot = true;
  self2.data.pivotFields = index_default_default.pluck(finalPivotSpec, "field");
  self2.data.pivotSpec = finalPivotSpec;
  self2.data.colVals = colVals;
  self2.data.data = newData;
  self2.debug("GROUP", "Final Data: %O", self2.data);
  return true;
};
ComputedView.prototype.setAggregate = function(spec, opts) {
  var self2 = this, args = Array.prototype.slice.call(arguments), isDifferent = false;
  var shouldGraph = {
    group: [],
    pivot: []
  };
  if (self2.lock.isLocked()) {
    return self2.lock.onUnlock(function() {
      self2.setAggregate.apply(self2, args);
    }, "Waiting to set aggregate: " + JSON.stringify(spec));
  }
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  self2.debug("SET AGGREGATE", "spec = %O ; options = %O", spec, opts);
  isDifferent = !index_default_default.isEqual(self2.aggregateSpec, spec);
  if (spec == null) {
    self2.super.setAggregate(null, opts);
  } else {
    index_default_default.each(spec, function(aggSpec, aggType) {
      aggSpec = index_default_default.filter(aggSpec, function(agg) {
        var a2 = AGGREGATE_REGISTRY.get(agg.fun);
        if (a2 == null) {
          log.error('Ignoring aggregate "' + agg.fun + '" because no such aggregate function exists');
          return false;
        }
        if ((aggType === "group" || aggType === "pivot") && agg.shouldGraph) {
          shouldGraph[aggType].push(agg);
        }
        return true;
      });
      spec[aggType] = aggSpec;
    });
    self2.super.setAggregate(deepCopy(spec), opts);
  }
  if (isDifferent && self2.prefs != null && opts.savePrefs) {
    self2.prefs.save();
  }
  self2.clearCache();
  if (!opts.updateData) {
    return true;
  }
  self2.getData();
  return true;
};
ComputedView.prototype.getAggregate = function() {
  var self2 = this;
  return self2.aggregateSpec;
};
ComputedView.prototype.clearAggregate = function(opts) {
  var self2 = this;
  return self2.setAggregate(objFromArray(["group", "pivot", "cell", "all"], [[{ fun: "count" }]]), opts);
};
ComputedView.prototype.aggregate = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  if (!(self2.aggregateSpec && (self2.data.isGroup || self2.data.isPivot))) {
    return cont(false);
  }
  index_default_default.each(["group", "pivot", "cell", "all"], function(what) {
    self2.debug(
      "AGGREGATE",
      "Computing %s aggregate functions: %s",
      what,
      index_default_default.pluck(getProp(self2, "aggregateSpec", what), "fun").join(", ")
    );
  });
  var groupResults = [];
  var pivotResults = [];
  var cellResults = [];
  var allResults = [];
  var info = {
    group: [],
    pivot: [],
    cell: [],
    all: []
  };
  index_default_default.each(["group", "pivot", "cell", "all"], function(what) {
    index_default_default.each(self2.aggregateSpec[what], function(spec, aggNum) {
      try {
        info[what][aggNum] = new AggregateInfo(what, spec, aggNum, self2.colConfig, self2.typeInfo, function(field) {
          Source2.decodeAll(self2.data.dataByRowId, field, self2.typeInfo);
        });
      } catch (e2) {
        log.error("Invalid Aggregate: " + what + "[" + aggNum + "] - " + e2.message);
        info[what][aggNum] = null;
        self2.fire("invalidAggregate", null, aggNum, e2.message);
      }
    });
    info[what] = index_default_default.without(info[what], null);
  });
  index_default_default.each(self2.data.rowVals, function(rowVal, rowValIdx) {
    index_default_default.each(info.group, function(aggInfo, aggNum) {
      if (groupResults[aggNum] === void 0) {
        groupResults[aggNum] = [];
      }
      var aggResult = aggInfo.instance.calculate(index_default_default.flatten(self2.data.data[rowValIdx]));
      groupResults[aggNum][rowValIdx] = aggResult;
      if (aggInfo.debug) {
        self2.debug(
          "AGGREGATE",
          "Group aggregate [%d] (%s) : Group [%s] = %s",
          aggNum,
          info.group[aggNum].instance.name + (info.group[aggNum].name ? " -> " + info.group[aggNum].name : ""),
          rowVal.join(", "),
          isElement2(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult)
        );
      }
    });
    if (self2.data.isPivot) {
      index_default_default.each(info.cell, function(aggInfo, aggNum) {
        if (cellResults[aggNum] === void 0) {
          cellResults[aggNum] = [];
        }
        cellResults[aggNum][rowValIdx] = [];
        index_default_default.each(self2.data.colVals, function(colVal, colValIdx) {
          var aggResult = aggInfo.instance.calculate(self2.data.data[rowValIdx][colValIdx]);
          cellResults[aggNum][rowValIdx][colValIdx] = aggResult;
          if (aggInfo.debug) {
            self2.debug(
              "AGGREGATE",
              "Cell aggregate [%d] (%s) : Cell [%s ; %s] = %s",
              aggNum,
              info.cell[aggNum].instance.name + (info.cell[aggNum].name ? " -> " + info.cell[aggNum].name : ""),
              rowVal.join(", "),
              colVal.join(", "),
              isElement2(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult)
            );
          }
        });
      });
    }
  });
  if (self2.data.isPivot && info.pivot) {
    index_default_default.each(info.pivot, function(aggInfo, aggNum) {
      pivotResults[aggNum] = [];
      index_default_default.each(self2.data.colVals, function(colVal, colValIdx) {
        var aggResult = aggInfo.instance.calculate(index_default_default.flatten(index_default_default.pluck(self2.data.data, colValIdx)));
        pivotResults[aggNum][colValIdx] = aggResult;
        if (aggInfo.debug) {
          self2.debug(
            "AGGREGATE",
            "Pivot aggregate [%d] (%s) : Col Val [%s] = %s",
            aggNum,
            info.pivot[aggNum].instance.name + (info.pivot[aggNum].name ? " -> " + info.pivot[aggNum].name : ""),
            colVal.join(", "),
            isElement2(aggResult) ? getElement(aggResult).innerText : JSON.stringify(aggResult)
          );
        }
      });
    });
  }
  if (info.all && (self2.data.isGroup || self2.data.isPivot)) {
    index_default_default.each(info.all, function(aggInfo, aggNum) {
      var aggResult = aggInfo.instance.calculate(index_default_default.flatten(self2.data.data));
      allResults[aggNum] = aggResult;
      if (aggInfo.debug) {
        self2.debug(
          "AGGREGATE",
          "All aggregate [%d] (%s) = %s",
          aggNum,
          info.all[aggNum].instance.name + (info.all[aggNum].name ? " -> " + info.all[aggNum].name : ""),
          JSON.stringify(aggResult)
        );
      }
    });
  }
  self2.data.agg = {
    info,
    results: {
      group: groupResults,
      pivot: pivotResults,
      cell: cellResults,
      all: allResults
    }
  };
  cont(true);
};
ComputedView.prototype.getData = function(cont, reason) {
  var self2 = this;
  if (cont != null && typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be null or a function");
  }
  cont = cont || I;
  var lockMsg;
  if (self2.lock.isLocked()) {
    lockMsg = "Waiting to get data";
    if (reason != null) {
      lockMsg += ": " + reason;
    }
    return self2.lock.onUnlock(function() {
      self2.getData(cont);
    }, lockMsg);
  } else {
    lockMsg = "Getting data";
    if (reason != null) {
      lockMsg += ": " + reason;
    }
    self2.debug(lockMsg);
  }
  if (self2.data !== void 0) {
    self2.debug(null, "Got cached data: %O", self2.data);
    if (typeof cont === "function") {
      return cont(true, self2.data);
    }
  }
  var fail = function() {
    self2.lock.unlock();
    return cont(false);
  };
  self2.lock.lock();
  return self2.source.getData(function(ok, data) {
    if (!ok) {
      return fail();
    }
    return self2.getTypeInfo(function(ok2, typeInfo) {
      if (!ok2) {
        return fail();
      }
      self2.fire("workBegin");
      var ops = {
        filter: false,
        group: false,
        pivot: false,
        sort: false
      };
      self2.data = {
        isPlain: true,
        isGroup: false,
        isPivot: false,
        data: [],
        dataByRowId: []
      };
      index_default_default.each(data, function(rowData, rowNum) {
        self2.data.data.push({
          rowNum,
          rowData
        });
        self2.data.dataByRowId[rowNum] = rowData;
      });
      return self2.filter(function(didFilter, filteredData) {
        ops.filter = didFilter;
        if (didFilter) {
          self2.data.data = filteredData;
        }
        ops.group = self2.group();
        ops.pivot = self2.pivot();
        return self2.aggregate(function() {
          return self2.sort(function(didSort) {
            ops.sort = didSort;
            var workEndObj = {
              isPlain: self2.data.isPlain,
              isGroup: self2.data.isGroup,
              isPivot: self2.data.isPivot
            };
            workEndObj.numRows = self2.getRowCount();
            if (self2.isFiltered()) {
              workEndObj.totalRows = self2.getTotalRowCount();
            }
            if (self2.data.isGroup) {
              workEndObj.numGroups = self2.data.rowVals.length;
            }
            if (self2.data.isPivot) {
              workEndObj.numGroups = self2.data.rowVals.length;
              workEndObj.numPivots = self2.data.colVals.length;
            }
            self2.lastOps = ops;
            self2.fire("workEnd", null, workEndObj, ops);
            self2.lock.unlock();
            self2.debug(null, "Got new data: %O", self2.data);
            if (typeof cont === "function") {
              return cont(true, self2.data);
            }
          });
        });
      });
    });
  });
};
ComputedView.prototype.getTypeInfo = function(cont) {
  var self2 = this;
  if (typeof cont !== "function") {
    throw new Error("Call Error: `cont` must be a function");
  }
  if (self2.typeInfo != null) {
    return cont(true, self2.typeInfo);
  }
  return self2.source.getTypeInfo(function(ok, typeInfo) {
    if (!ok) {
      return cont(false);
    }
    self2.typeInfo = typeInfo;
    self2.fire("getTypeInfo", null, self2.typeInfo, self2.colConfig);
    return cont(true, self2.typeInfo);
  });
};
ComputedView.prototype.clearCache = function() {
  var self2 = this;
  self2.data = void 0;
  self2.typeInfo = void 0;
  self2.debug(null, "Cleared cache");
};
ComputedView.prototype.clearSourceData = function() {
  var self2 = this;
  if (self2.source instanceof Source2) {
    self2.source.clearCachedData();
  } else if (self2.source instanceof ComputedView) {
    self2.source.clearSourceData();
  }
  self2.debug(null, "Cleared source data");
};
ComputedView.prototype.refresh = function() {
  var self2 = this;
  self2.debug(null, "Refreshing...");
  self2.source.refresh();
};
ComputedView.prototype.reset = function(opts) {
  var self2 = this;
  opts = deepDefaults(opts, {
    sendEvent: true,
    dontSendEventTo: [],
    updateData: true,
    savePrefs: true
  });
  var clearOpts = jQuery.extend({}, opts, {
    updateData: false
  });
  self2.debug(null, "RESET!");
  self2.clearSort(clearOpts);
  self2.clearFilter(clearOpts);
  self2.clearAggregate(clearOpts);
  self2.clearPivot(clearOpts);
  self2.clearGroup(clearOpts);
  if (!opts.updateData) {
    delete self2.lastOps;
    return;
  }
  self2.getData();
};
ComputedView.prototype.getUniqueVals = function(cont) {
  var self2 = this;
  return self2.source.getUniqueVals(cont);
};
ComputedView.prototype.getLastOps = function() {
  var self2 = this;
  return self2.lastOps;
};
ComputedView.prototype.setColConfig = function(colConfig) {
  var self2 = this;
  if (!(colConfig instanceof ordmap_default)) {
    throw new Error("Call Error: `colConfig` must be an instance of OrdMap");
  }
  self2.debug(null, "Setting column configuration");
  self2.colConfig = colConfig;
};

// node_modules/wcdatavis/datavis.js
window.MIE = window.MIE || {};
window.MIE.log = log;
window.MIE.debug = debug;
window.MIE.OrdMap = ordmap_default;
window.MIE.Lock = lock_default;
window.MIE.trans = trans;
window.MIE.makeSubclass = makeSubclass;
window.MIE.WC_DataVis = window.MIE.WC_DataVis || {};
window.MIE.WC_DataVis.Aggregate = Aggregate;
window.MIE.WC_DataVis.ParamInput = ParamInput;
window.MIE.WC_DataVis.Source = Source2;
window.MIE.WC_DataVis.GroupFunction = GroupFunction;
window.MIE.WC_DataVis.ComputedView = ComputedView;
window.MIE.WC_DataVis.MirageView = MirageView;
window.MIE.WC_DataVis.Grid = Grid;
window.MIE.WC_DataVis.grids = {};
window.MIE.WC_DataVis.Graph = Graph;
window.MIE.WC_DataVis.graphs = {};
window.MIE.WC_DataVis.Perspective = Perspective;
window.MIE.WC_DataVis.Prefs = Prefs;
window.MIE.WC_DataVis.PrefsBackend = PrefsBackend;
window.MIE.WC_DataVis.PrefsModule = PrefsModule;
window.MIE.WC_DataVis.PrefsModuleGrid = PrefsModuleGrid;
window.MIE.WC_DataVis.EXPORT_URL = "export.php";
window.MIE.WC_DataVis.AGGREGATE_REGISTRY = AGGREGATE_REGISTRY;
window.MIE.WC_DataVis.GROUP_FUNCTION_REGISTRY = GROUP_FUNCTION_REGISTRY;
window.MIE.WC_DataVis.PREFS_BACKEND_REGISTRY = PREFS_BACKEND_REGISTRY;
window.MIE.WC_DataVis.PREFS_MODULE_REGISTRY = PREFS_MODULE_REGISTRY;
window.MIE.WC_DataVis.Util = misc_exports;
/*! Bundled license information:

block-ui/jquery.blockUI.js:
  (*!
   * jQuery blockUI plugin
   * Version 2.70.0-2014.11.23
   * Requires jQuery v1.7 or later
   *
   * Examples at: http://malsup.com/jquery/block/
   * Copyright (c) 2007-2013 M. Alsup
   * Dual licensed under the MIT and GPL licenses:
   * http://www.opensource.org/licenses/mit-license.php
   * http://www.gnu.org/licenses/gpl.html
   *
   * Thanks to Amir-Hossein Sobhi for some excellent contributions!
   *)

sumoselect/jquery.sumoselect.js:
  (*!
   * jquery.sumoselect
   * http://hemantnegi.github.io/jquery.sumoselect
   * 2016-12-12
   *
   * Copyright 2015 Hemant Negi
   * Email : hemant.frnz@gmail.com
   * Compressor http://refresh-sf.com/
   *)

numeral/numeral.js:
  (*! @preserve
   * numeral.js
   * version : 2.0.6
   * author : Adam Draper
   * license : MIT
   * http://adamwdraper.github.com/Numeral-js/
   *)

papaparse/papaparse.min.js:
  (* @license
  Papa Parse
  v5.4.1
  https://github.com/mholt/PapaParse
  License: MIT
  *)

jquery-ui/dist/jquery-ui.min.js:
  (*! jQuery UI - v1.14.0 - 2024-08-05
  * https://jqueryui.com
  * Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-patch.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
  * Copyright OpenJS Foundation and other contributors; Licensed MIT *)

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=chunk-OELRHE6W.js.map
