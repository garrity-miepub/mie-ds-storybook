import {
  createStoriesExtractorContext,
  useStoryRenderer
} from "./chunk-RYHFBKE5.js";
import {
  gt,
  yn
} from "./chunk-6QKMFTPM.js";
import "./chunk-RNIMMRSM.js";
import "./chunk-LTIG36C7.js";
import "./chunk-3MU2VDGX.js";
import {
  check_target,
  component,
  hmr,
  legacy_api,
  validate_prop_bindings
} from "./chunk-UYNHXJBJ.js";
import {
  append,
  comment,
  mount,
  unmount
} from "./chunk-H6BEBDWE.js";
import {
  FILENAME,
  HMR,
  first_child,
  mark_module_end,
  mark_module_start,
  pop,
  push,
  set,
  user_effect
} from "./chunk-VSM3E7OU.js";
import "./chunk-BOVLM7T7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-BFCEFRYA.js";

// node_modules/.cache/sb-vite-plugin-externals/@storybook/preview-api.js
var require_preview_api = __commonJS({
  "node_modules/.cache/sb-vite-plugin-externals/@storybook/preview-api.js"(exports, module) {
    module.exports = __STORYBOOK_MODULE_PREVIEW_API__;
  }
});

// node_modules/@storybook/addon-svelte-csf/dist/runtime/StoriesExtractor.svelte
mark_module_start();
StoriesExtractor[FILENAME] = "node_modules/@storybook/addon-svelte-csf/dist/runtime/StoriesExtractor.svelte";
function StoriesExtractor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StoriesExtractor);
  validate_prop_bindings($$props, [], [], StoriesExtractor);
  createStoriesExtractorContext($$props.repository());
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => $$props.Stories, ($$anchor2, $$component) => {
    $$component($$anchor2, {});
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StoriesExtractor = hmr(StoriesExtractor, () => StoriesExtractor[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StoriesExtractor[HMR].source;
    set(StoriesExtractor[HMR].source, module.default[HMR].original);
  });
}
var StoriesExtractor_default = StoriesExtractor;
mark_module_end(StoriesExtractor);

// node_modules/@storybook/addon-svelte-csf/dist/runtime/emit-code.js
var import_preview_api = __toESM(require_preview_api(), 1);

// node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === partial.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    return func.apply(this, args);
  };
}
var partialPlaceholder = Symbol("partial.placeholder");
partial.placeholder = partialPlaceholder;

// node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === partialRightPlaceholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const args = [];
    let providedIndex = 0;
    for (let i = 0; i < rangeLength; i++) {
      args.push(providedArgs[providedIndex++]);
    }
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === partialRight.placeholder) {
        args.push(providedArgs[providedIndex++]);
      } else {
        args.push(arg);
      }
    }
    return func.apply(this, args);
  };
}
var partialRightPlaceholder = Symbol("partialRight.placeholder");
partialRight.placeholder = partialRightPlaceholder;

// node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

// node_modules/es-toolkit/dist/string/deburr.mjs
var deburrMap = new Map(Object.entries({
  Æ: "Ae",
  Ð: "D",
  Ø: "O",
  Þ: "Th",
  ß: "ss",
  æ: "ae",
  ð: "d",
  ø: "o",
  þ: "th",
  Đ: "D",
  đ: "d",
  Ħ: "H",
  ħ: "h",
  ı: "i",
  Ĳ: "IJ",
  ĳ: "ij",
  ĸ: "k",
  Ŀ: "L",
  ŀ: "l",
  Ł: "L",
  ł: "l",
  ŉ: "'n",
  Ŋ: "N",
  ŋ: "n",
  Œ: "Oe",
  œ: "oe",
  Ŧ: "T",
  ŧ: "t",
  ſ: "s"
}));

// node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs
function isDeepKey(key) {
  switch (typeof key) {
    case "number":
    case "symbol": {
      return false;
    }
    case "string": {
      return key.includes(".") || key.includes("[") || key.includes("]");
    }
  }
}

// node_modules/es-toolkit/dist/compat/_internal/toKey.mjs
function toKey(value) {
  if (Object.is(value, -0)) {
    return "-0";
  }
  return value.toString();
}

// node_modules/es-toolkit/dist/compat/util/toPath.mjs
function toPath(deepKey) {
  const result = [];
  const length = deepKey.length;
  if (length === 0) {
    return result;
  }
  let index = 0;
  let key = "";
  let quoteChar = "";
  let bracket = false;
  if (deepKey.charCodeAt(0) === 46) {
    result.push("");
    index++;
  }
  while (index < length) {
    const char = deepKey[index];
    if (quoteChar) {
      if (char === "\\" && index + 1 < length) {
        index++;
        key += deepKey[index];
      } else if (char === quoteChar) {
        quoteChar = "";
      } else {
        key += char;
      }
    } else if (bracket) {
      if (char === '"' || char === "'") {
        quoteChar = char;
      } else if (char === "]") {
        bracket = false;
        result.push(key);
        key = "";
      } else {
        key += char;
      }
    } else {
      if (char === "[") {
        bracket = true;
        if (key) {
          result.push(key);
          key = "";
        }
      } else if (char === ".") {
        if (key) {
          result.push(key);
          key = "";
        }
      } else {
        key += char;
      }
    }
    index++;
  }
  if (key) {
    result.push(key);
  }
  return result;
}

// node_modules/es-toolkit/dist/compat/object/get.mjs
function get(object, path, defaultValue) {
  if (object == null) {
    return defaultValue;
  }
  switch (typeof path) {
    case "string": {
      const result = object[path];
      if (result === void 0) {
        if (isDeepKey(path)) {
          return get(object, toPath(path), defaultValue);
        } else {
          return defaultValue;
        }
      }
      return result;
    }
    case "number":
    case "symbol": {
      if (typeof path === "number") {
        path = toKey(path);
      }
      const result = object[path];
      if (result === void 0) {
        return defaultValue;
      }
      return result;
    }
    default: {
      if (Array.isArray(path)) {
        return getWithPath(object, path, defaultValue);
      }
      if (Object.is(path == null ? void 0 : path.valueOf(), -0)) {
        path = "-0";
      } else {
        path = String(path);
      }
      const result = object[path];
      if (result === void 0) {
        return defaultValue;
      }
      return result;
    }
  }
}
function getWithPath(object, path, defaultValue) {
  if (path.length === 0) {
    return defaultValue;
  }
  let current = object;
  for (let index = 0; index < path.length; index++) {
    if (current == null) {
      return defaultValue;
    }
    current = current[path[index]];
  }
  if (current === void 0) {
    return defaultValue;
  }
  return current;
}

// node_modules/es-toolkit/dist/compat/function/bind.mjs
function bind(func, thisObj, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bind.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new func(...args);
    }
    return func.apply(thisObj, args);
  };
  return bound;
}
var bindPlaceholder = Symbol("bind.placeholder");
bind.placeholder = bindPlaceholder;

// node_modules/es-toolkit/dist/compat/function/bindKey.mjs
function bindKey(object, key, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bindKey.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new object[key](...args);
    }
    return object[key].apply(object, args);
  };
  return bound;
}
var bindKeyPlaceholder = Symbol("bindKey.placeholder");
bindKey.placeholder = bindKeyPlaceholder;

// node_modules/es-toolkit/dist/compat/function/curry.mjs
function curry(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curry.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurry(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function makeCurry(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curry.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurry(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function composeArgs(providedArgs, partialArgs) {
  const args = [];
  let startIndex = 0;
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curry.placeholder && startIndex < providedArgs.length) {
      args.push(providedArgs[startIndex++]);
    } else {
      args.push(arg);
    }
  }
  for (let i = startIndex; i < providedArgs.length; i++) {
    args.push(providedArgs[i]);
  }
  return args;
}
var curryPlaceholder = Symbol("curry.placeholder");
curry.placeholder = curryPlaceholder;

// node_modules/es-toolkit/dist/compat/function/curryRight.mjs
function curryRight(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curryRight.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurryRight(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function makeCurryRight(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curryRight.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs2(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurryRight(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function composeArgs2(providedArgs, partialArgs) {
  const placeholderLength = partialArgs.filter((arg) => arg === curryRight.placeholder).length;
  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
  const args = [];
  let providedIndex = 0;
  for (let i = 0; i < rangeLength; i++) {
    args.push(providedArgs[providedIndex++]);
  }
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curryRight.placeholder) {
      if (providedIndex < providedArgs.length) {
        args.push(providedArgs[providedIndex++]);
      } else {
        args.push(arg);
      }
    } else {
      args.push(arg);
    }
  }
  return args;
}
var curryRightPlaceholder = Symbol("curryRight.placeholder");
curryRight.placeholder = curryRightPlaceholder;

// node_modules/es-toolkit/dist/compat/_internal/MAX_SAFE_INTEGER.mjs
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

// node_modules/@storybook/addon-svelte-csf/dist/runtime/emit-code.js
var channel = import_preview_api.addons.getChannel();
var emitCode = (params) => {
  const { storyContext } = params;
  if (skipSourceRender(storyContext)) {
    return;
  }
  const codeToEmit = generateCodeToEmit({
    code: storyContext.parameters.__svelteCsf.rawCode,
    args: params.args
  });
  setTimeout(() => {
    channel.emit(yn, {
      id: storyContext.id,
      args: storyContext.unmappedArgs,
      source: codeToEmit
    });
  });
};
var skipSourceRender = (context) => {
  var _a;
  const sourceParams = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source;
  const isArgsStory = context == null ? void 0 : context.parameters.__isArgsStory;
  const rawCode = context == null ? void 0 : context.parameters.__svelteCsf.rawCode;
  if (!rawCode) {
    return true;
  }
  if ((sourceParams == null ? void 0 : sourceParams.type) === gt.DYNAMIC) {
    return false;
  }
  return !isArgsStory || (sourceParams == null ? void 0 : sourceParams.code) || (sourceParams == null ? void 0 : sourceParams.type) === gt.CODE;
};
var generateCodeToEmit = ({ code, args }) => {
  const allPropsArray = Object.entries(args ?? {}).map(([argKey, argValue]) => argsToProps(argKey, argValue)).filter((p) => p);
  let allPropsString = allPropsArray.join(" ");
  if (allPropsString.length > 50) {
    allPropsString = `
  ${allPropsArray.join("\n  ")}
`;
  }
  let codeToEmit = code.replaceAll("{...args}", allPropsString).replace(/args(?:[\w\d_$\.\?\[\]"'])+/g, (argPath) => {
    const path = argPath.replaceAll("?", "");
    const value = get({ args }, path);
    return valueToString(value);
  });
  return codeToEmit;
};
var getFunctionName = (fn) => {
  var _a;
  const name = ((_a = fn.getMockName) == null ? void 0 : _a.call(fn)) ?? fn.name;
  if (name && name !== "spy") {
    return name;
  }
  return "() => {}";
};
var valueToString = (value) => {
  var _a;
  if (typeof value === "object" && value[Symbol.for("svelte.snippet")]) {
    return "snippet";
  }
  if (typeof value === "function") {
    return getFunctionName(value);
  }
  return (_a = JSON.stringify(value, null, 1)) == null ? void 0 : _a.replace(/\n/g, "").replace(new RegExp("(?<!\\s)([}\\]])$"), " $1");
};
var argsToProps = (key, value) => {
  if (value === void 0 || value === null) {
    return null;
  }
  if (value === true) {
    return key;
  }
  const stringValue = valueToString(value);
  if (typeof value === "string") {
    return `${key}=${stringValue}`;
  }
  return `${key}={${stringValue}}`;
};

// node_modules/@storybook/addon-svelte-csf/dist/runtime/StoryRenderer.svelte
mark_module_start();
StoryRenderer[FILENAME] = "node_modules/@storybook/addon-svelte-csf/dist/runtime/StoryRenderer.svelte";
function StoryRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StoryRenderer);
  validate_prop_bindings($$props, [], [], StoryRenderer);
  const context = useStoryRenderer();
  user_effect(() => {
    context.set({
      currentStoryExportName: $$props.exportName,
      args: $$props.args,
      storyContext: $$props.storyContext
    });
  });
  user_effect(() => {
    emitCode({
      args: $$props.args,
      storyContext: $$props.storyContext
    });
  });
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => $$props.Stories, ($$anchor2, $$component) => {
    $$component($$anchor2, {});
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StoryRenderer = hmr(StoryRenderer, () => StoryRenderer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StoryRenderer[HMR].source;
    set(StoryRenderer[HMR].source, module.default[HMR].original);
  });
}
var StoryRenderer_default = StoryRenderer;
mark_module_end(StoryRenderer);

// node_modules/@storybook/addon-svelte-csf/dist/runtime/create-runtime-stories.js
var createFragment = document.createDocumentFragment ? () => document.createDocumentFragment() : () => document.createElement("div");
var createRuntimeStories = (Stories, meta) => {
  const repository = {
    stories: /* @__PURE__ */ new Map()
  };
  try {
    const context = mount(StoriesExtractor_default, {
      target: createFragment(),
      props: {
        Stories,
        repository: () => repository
      }
    });
    unmount(context);
  } catch (e) {
    console.error(`Error in mounting stories ${e.toString()}`, e);
  }
  const stories = {};
  for (const [exportName, story] of repository.stories) {
    const storyObj = {
      ...story,
      // @ts-expect-error WARN: Here we are attempting to convert every `StoryCmp` into `StoryObj`, and the types are different
      render: (args, storyContext) => ({
        Component: StoryRenderer_default,
        props: {
          exportName,
          Stories,
          storyContext,
          args
        }
      })
    };
    const play = meta.play ?? story.play;
    if (play) {
      storyObj.play = (storyContext) => {
        var _a;
        const delegate = (_a = storyContext.playFunction) == null ? void 0 : _a.__play;
        if (delegate) {
          return delegate(storyContext);
        }
        return play(storyContext);
      };
    }
    stories[exportName] = storyObj;
  }
  return stories;
};
export {
  createRuntimeStories
};
//# sourceMappingURL=@storybook_addon-svelte-csf_internal_create-runtime-stories.js.map
