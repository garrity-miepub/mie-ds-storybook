{
  "version": 3,
  "sources": ["../../../../sb-vite-plugin-externals/@storybook/preview-api.js", "../../../../../@storybook/addon-svelte-csf/dist/runtime/StoriesExtractor.svelte", "../../../../../@storybook/addon-svelte-csf/dist/runtime/emit-code.js", "../../../../../es-toolkit/dist/function/partial.mjs", "../../../../../es-toolkit/dist/function/partialRight.mjs", "../../../../../es-toolkit/dist/string/words.mjs", "../../../../../es-toolkit/dist/string/deburr.mjs", "../../../../../es-toolkit/dist/compat/_internal/isDeepKey.mjs", "../../../../../es-toolkit/dist/compat/_internal/toKey.mjs", "../../../../../es-toolkit/dist/compat/util/toPath.mjs", "../../../../../es-toolkit/dist/compat/object/get.mjs", "../../../../../es-toolkit/dist/compat/function/bind.mjs", "../../../../../es-toolkit/dist/compat/function/bindKey.mjs", "../../../../../es-toolkit/dist/compat/function/curry.mjs", "../../../../../es-toolkit/dist/compat/function/curryRight.mjs", "../../../../../es-toolkit/dist/compat/_internal/MAX_SAFE_INTEGER.mjs", "../../../../../@storybook/addon-svelte-csf/dist/runtime/StoryRenderer.svelte", "../../../../../@storybook/addon-svelte-csf/dist/runtime/create-runtime-stories.js"],
  "sourcesContent": ["module.exports = __STORYBOOK_MODULE_PREVIEW_API__;", null, "import { SourceType, SNIPPET_RENDERED } from '@storybook/docs-tools';\nimport { addons } from '@storybook/preview-api';\nimport { get } from 'es-toolkit/compat';\nconst channel = addons.getChannel();\n/**\n * Given a code string representing the raw source code for the story,\n * and the current, dynamic args\n * this function:\n * 1. Replaces args references in the code with the actual values\n * 2. Emits the final code to Storybook's internal code provider\n * So that it can be shown in source code viewer\n */\nexport const emitCode = (params) => {\n    const { storyContext } = params;\n    if (skipSourceRender(storyContext)) {\n        return;\n    }\n    const codeToEmit = generateCodeToEmit({\n        code: storyContext.parameters.__svelteCsf.rawCode,\n        args: params.args,\n    });\n    // Using setTimeout here to ensure we're emitting after the base @storybook/svelte emits its version of the code\n    // TODO: fix this in @storybook/svelte, don't emit when using stories.svelte files\n    setTimeout(() => {\n        channel.emit(SNIPPET_RENDERED, {\n            id: storyContext.id,\n            args: storyContext.unmappedArgs,\n            source: codeToEmit,\n        });\n    });\n};\n// Copied from @storybook/svelte at https://github.com/storybookjs/storybook/blob/17b7512c60256c739b890b3d85aaac992806dee6/code/renderers/svelte/src/docs/sourceDecorator.ts#L16-L33\nconst skipSourceRender = (context) => {\n    const sourceParams = context?.parameters.docs?.source;\n    const isArgsStory = context?.parameters.__isArgsStory;\n    const rawCode = context?.parameters.__svelteCsf.rawCode;\n    if (!rawCode) {\n        return true;\n    }\n    // always render if the user forces it\n    if (sourceParams?.type === SourceType.DYNAMIC) {\n        return false;\n    }\n    // never render if the user is forcing the block to render code, or\n    // if the user provides code, or if it's not an args story.\n    return !isArgsStory || sourceParams?.code || sourceParams?.type === SourceType.CODE;\n};\nexport const generateCodeToEmit = ({ code, args }) => {\n    const allPropsArray = Object.entries(args ?? {})\n        .map(([argKey, argValue]) => argsToProps(argKey, argValue))\n        .filter((p) => p);\n    let allPropsString = allPropsArray.join(' ');\n    // make the props multiline if the string is longer than 50 chars\n    // TODO: do this at the final stage instead, taking into account the singular args replacements\n    if (allPropsString.length > 50) {\n        // TODO: the indentation only works if it's in the root-level component. In a nested component, the indentation will be too shallow\n        allPropsString = `\\n  ${allPropsArray.join('\\n  ')}\\n`;\n    }\n    let codeToEmit = code\n        .replaceAll('{...args}', allPropsString)\n        // replace single arg references with their actual value,\n        // eg. myProp={args.something} => myProp={\"actual\"}\n        // or <h1>{args.something}</h1> => <h1>\"actual\"</h1>\n        .replace(/args(?:[\\w\\d_$\\.\\?\\[\\]\"'])+/g, (argPath) => {\n        const path = argPath.replaceAll('?', ''); // remove optional chaining character\n        const value = get({ args }, path);\n        return valueToString(value);\n    });\n    return codeToEmit;\n};\nconst getFunctionName = (fn) => {\n    const name = fn.getMockName?.() ?? fn.name;\n    if (name && name !== 'spy') {\n        return name;\n    }\n    return '() => {}';\n};\n/**\n * convert a value to a stringified version\n */\nconst valueToString = (value) => {\n    if (typeof value === 'object' && value[Symbol.for('svelte.snippet')]) {\n        return 'snippet';\n    }\n    if (typeof value === 'function') {\n        return getFunctionName(value);\n    }\n    return (JSON.stringify(value, null, 1)\n        ?.replace(/\\n/g, '')\n        // Find \"}\" or \"]\" at the end of the string, not preceded by a space, and add a space\n        .replace(/(?<!\\s)([}\\]])$/, ' $1'));\n};\n/**\n * convert a {key: value} pair into Svelte attributes, eg. {someKey: \"some string\"} => someKey=\"some string\"\n */\nconst argsToProps = (key, value) => {\n    if (value === undefined || value === null) {\n        return null;\n    }\n    if (value === true) {\n        return key;\n    }\n    const stringValue = valueToString(value);\n    if (typeof value === 'string') {\n        return `${key}=${stringValue}`;\n    }\n    return `${key}={${stringValue}}`;\n};\n", "function partial(func, ...partialArgs) {\n    return function (...providedArgs) {\n        const args = [];\n        let startIndex = 0;\n        for (let i = 0; i < partialArgs.length; i++) {\n            const arg = partialArgs[i];\n            if (arg === partial.placeholder) {\n                args.push(providedArgs[startIndex++]);\n            }\n            else {\n                args.push(arg);\n            }\n        }\n        for (let i = startIndex; i < providedArgs.length; i++) {\n            args.push(providedArgs[i]);\n        }\n        return func.apply(this, args);\n    };\n}\nconst partialPlaceholder = Symbol('partial.placeholder');\npartial.placeholder = partialPlaceholder;\n\nexport { partial };\n", "function partialRight(func, ...partialArgs) {\n    return function (...providedArgs) {\n        const placeholderLength = partialArgs.filter(arg => arg === partialRightPlaceholder).length;\n        const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n        const args = [];\n        let providedIndex = 0;\n        for (let i = 0; i < rangeLength; i++) {\n            args.push(providedArgs[providedIndex++]);\n        }\n        for (let i = 0; i < partialArgs.length; i++) {\n            const arg = partialArgs[i];\n            if (arg === partialRight.placeholder) {\n                args.push(providedArgs[providedIndex++]);\n            }\n            else {\n                args.push(arg);\n            }\n        }\n        return func.apply(this, args);\n    };\n}\nconst partialRightPlaceholder = Symbol('partialRight.placeholder');\npartialRight.placeholder = partialRightPlaceholder;\n\nexport { partialRight };\n", "const CASE_SPLIT_PATTERN = /\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+/gu;\nfunction words(str) {\n    return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);\n}\n\nexport { CASE_SPLIT_PATTERN, words };\n", "const deburrMap = new Map(Object.entries({\n    Æ: 'Ae',\n    Ð: 'D',\n    Ø: 'O',\n    Þ: 'Th',\n    ß: 'ss',\n    æ: 'ae',\n    ð: 'd',\n    ø: 'o',\n    þ: 'th',\n    Đ: 'D',\n    đ: 'd',\n    Ħ: 'H',\n    ħ: 'h',\n    ı: 'i',\n    Ĳ: 'IJ',\n    ĳ: 'ij',\n    ĸ: 'k',\n    Ŀ: 'L',\n    ŀ: 'l',\n    Ł: 'L',\n    ł: 'l',\n    ŉ: \"'n\",\n    Ŋ: 'N',\n    ŋ: 'n',\n    Œ: 'Oe',\n    œ: 'oe',\n    Ŧ: 'T',\n    ŧ: 't',\n    ſ: 's',\n}));\nfunction deburr(str) {\n    str = str.normalize('NFD');\n    let result = '';\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        if ((char >= '\\u0300' && char <= '\\u036f') || (char >= '\\ufe20' && char <= '\\ufe23')) {\n            continue;\n        }\n        result += deburrMap.get(char) ?? char;\n    }\n    return result;\n}\n\nexport { deburr };\n", "function isDeepKey(key) {\n    switch (typeof key) {\n        case 'number':\n        case 'symbol': {\n            return false;\n        }\n        case 'string': {\n            return key.includes('.') || key.includes('[') || key.includes(']');\n        }\n    }\n}\n\nexport { isDeepKey };\n", "function toKey(value) {\n    if (Object.is(value, -0)) {\n        return '-0';\n    }\n    return value.toString();\n}\n\nexport { toKey };\n", "function toPath(deepKey) {\n    const result = [];\n    const length = deepKey.length;\n    if (length === 0) {\n        return result;\n    }\n    let index = 0;\n    let key = '';\n    let quoteChar = '';\n    let bracket = false;\n    if (deepKey.charCodeAt(0) === 46) {\n        result.push('');\n        index++;\n    }\n    while (index < length) {\n        const char = deepKey[index];\n        if (quoteChar) {\n            if (char === '\\\\' && index + 1 < length) {\n                index++;\n                key += deepKey[index];\n            }\n            else if (char === quoteChar) {\n                quoteChar = '';\n            }\n            else {\n                key += char;\n            }\n        }\n        else if (bracket) {\n            if (char === '\"' || char === \"'\") {\n                quoteChar = char;\n            }\n            else if (char === ']') {\n                bracket = false;\n                result.push(key);\n                key = '';\n            }\n            else {\n                key += char;\n            }\n        }\n        else {\n            if (char === '[') {\n                bracket = true;\n                if (key) {\n                    result.push(key);\n                    key = '';\n                }\n            }\n            else if (char === '.') {\n                if (key) {\n                    result.push(key);\n                    key = '';\n                }\n            }\n            else {\n                key += char;\n            }\n        }\n        index++;\n    }\n    if (key) {\n        result.push(key);\n    }\n    return result;\n}\n\nexport { toPath };\n", "import { isDeepKey } from '../_internal/isDeepKey.mjs';\nimport { toKey } from '../_internal/toKey.mjs';\nimport { toPath } from '../util/toPath.mjs';\n\nfunction get(object, path, defaultValue) {\n    if (object == null) {\n        return defaultValue;\n    }\n    switch (typeof path) {\n        case 'string': {\n            const result = object[path];\n            if (result === undefined) {\n                if (isDeepKey(path)) {\n                    return get(object, toPath(path), defaultValue);\n                }\n                else {\n                    return defaultValue;\n                }\n            }\n            return result;\n        }\n        case 'number':\n        case 'symbol': {\n            if (typeof path === 'number') {\n                path = toKey(path);\n            }\n            const result = object[path];\n            if (result === undefined) {\n                return defaultValue;\n            }\n            return result;\n        }\n        default: {\n            if (Array.isArray(path)) {\n                return getWithPath(object, path, defaultValue);\n            }\n            if (Object.is(path?.valueOf(), -0)) {\n                path = '-0';\n            }\n            else {\n                path = String(path);\n            }\n            const result = object[path];\n            if (result === undefined) {\n                return defaultValue;\n            }\n            return result;\n        }\n    }\n}\nfunction getWithPath(object, path, defaultValue) {\n    if (path.length === 0) {\n        return defaultValue;\n    }\n    let current = object;\n    for (let index = 0; index < path.length; index++) {\n        if (current == null) {\n            return defaultValue;\n        }\n        current = current[path[index]];\n    }\n    if (current === undefined) {\n        return defaultValue;\n    }\n    return current;\n}\n\nexport { get };\n", "function bind(func, thisObj, ...partialArgs) {\n    const bound = function (...providedArgs) {\n        const args = [];\n        let startIndex = 0;\n        for (let i = 0; i < partialArgs.length; i++) {\n            const arg = partialArgs[i];\n            if (arg === bind.placeholder) {\n                args.push(providedArgs[startIndex++]);\n            }\n            else {\n                args.push(arg);\n            }\n        }\n        for (let i = startIndex; i < providedArgs.length; i++) {\n            args.push(providedArgs[i]);\n        }\n        if (this instanceof bound) {\n            return new func(...args);\n        }\n        return func.apply(thisObj, args);\n    };\n    return bound;\n}\nconst bindPlaceholder = Symbol('bind.placeholder');\nbind.placeholder = bindPlaceholder;\n\nexport { bind };\n", "function bindKey(object, key, ...partialArgs) {\n    const bound = function (...providedArgs) {\n        const args = [];\n        let startIndex = 0;\n        for (let i = 0; i < partialArgs.length; i++) {\n            const arg = partialArgs[i];\n            if (arg === bindKey.placeholder) {\n                args.push(providedArgs[startIndex++]);\n            }\n            else {\n                args.push(arg);\n            }\n        }\n        for (let i = startIndex; i < providedArgs.length; i++) {\n            args.push(providedArgs[i]);\n        }\n        if (this instanceof bound) {\n            return new object[key](...args);\n        }\n        return object[key].apply(object, args);\n    };\n    return bound;\n}\nconst bindKeyPlaceholder = Symbol('bindKey.placeholder');\nbindKey.placeholder = bindKeyPlaceholder;\n\nexport { bindKey };\n", "function curry(func, arity = func.length, guard) {\n    arity = guard ? func.length : arity;\n    arity = Number.parseInt(arity, 10);\n    if (Number.isNaN(arity) || arity < 1) {\n        arity = 0;\n    }\n    const wrapper = function (...partialArgs) {\n        const holders = partialArgs.filter(item => item === curry.placeholder);\n        const length = partialArgs.length - holders.length;\n        if (length < arity) {\n            return makeCurry(func, arity - length, partialArgs);\n        }\n        if (this instanceof wrapper) {\n            return new func(...partialArgs);\n        }\n        return func.apply(this, partialArgs);\n    };\n    wrapper.placeholder = curryPlaceholder;\n    return wrapper;\n}\nfunction makeCurry(func, arity, partialArgs) {\n    function wrapper(...providedArgs) {\n        const holders = providedArgs.filter(item => item === curry.placeholder);\n        const length = providedArgs.length - holders.length;\n        providedArgs = composeArgs(providedArgs, partialArgs);\n        if (length < arity) {\n            return makeCurry(func, arity - length, providedArgs);\n        }\n        if (this instanceof wrapper) {\n            return new func(...providedArgs);\n        }\n        return func.apply(this, providedArgs);\n    }\n    wrapper.placeholder = curryPlaceholder;\n    return wrapper;\n}\nfunction composeArgs(providedArgs, partialArgs) {\n    const args = [];\n    let startIndex = 0;\n    for (let i = 0; i < partialArgs.length; i++) {\n        const arg = partialArgs[i];\n        if (arg === curry.placeholder && startIndex < providedArgs.length) {\n            args.push(providedArgs[startIndex++]);\n        }\n        else {\n            args.push(arg);\n        }\n    }\n    for (let i = startIndex; i < providedArgs.length; i++) {\n        args.push(providedArgs[i]);\n    }\n    return args;\n}\nconst curryPlaceholder = Symbol('curry.placeholder');\ncurry.placeholder = curryPlaceholder;\n\nexport { curry };\n", "function curryRight(func, arity = func.length, guard) {\n    arity = guard ? func.length : arity;\n    arity = Number.parseInt(arity, 10);\n    if (Number.isNaN(arity) || arity < 1) {\n        arity = 0;\n    }\n    const wrapper = function (...partialArgs) {\n        const holders = partialArgs.filter(item => item === curryRight.placeholder);\n        const length = partialArgs.length - holders.length;\n        if (length < arity) {\n            return makeCurryRight(func, arity - length, partialArgs);\n        }\n        if (this instanceof wrapper) {\n            return new func(...partialArgs);\n        }\n        return func.apply(this, partialArgs);\n    };\n    wrapper.placeholder = curryRightPlaceholder;\n    return wrapper;\n}\nfunction makeCurryRight(func, arity, partialArgs) {\n    function wrapper(...providedArgs) {\n        const holders = providedArgs.filter(item => item === curryRight.placeholder);\n        const length = providedArgs.length - holders.length;\n        providedArgs = composeArgs(providedArgs, partialArgs);\n        if (length < arity) {\n            return makeCurryRight(func, arity - length, providedArgs);\n        }\n        if (this instanceof wrapper) {\n            return new func(...providedArgs);\n        }\n        return func.apply(this, providedArgs);\n    }\n    wrapper.placeholder = curryRightPlaceholder;\n    return wrapper;\n}\nfunction composeArgs(providedArgs, partialArgs) {\n    const placeholderLength = partialArgs.filter(arg => arg === curryRight.placeholder).length;\n    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n    const args = [];\n    let providedIndex = 0;\n    for (let i = 0; i < rangeLength; i++) {\n        args.push(providedArgs[providedIndex++]);\n    }\n    for (let i = 0; i < partialArgs.length; i++) {\n        const arg = partialArgs[i];\n        if (arg === curryRight.placeholder) {\n            if (providedIndex < providedArgs.length) {\n                args.push(providedArgs[providedIndex++]);\n            }\n            else {\n                args.push(arg);\n            }\n        }\n        else {\n            args.push(arg);\n        }\n    }\n    return args;\n}\nconst curryRightPlaceholder = Symbol('curryRight.placeholder');\ncurryRight.placeholder = curryRightPlaceholder;\n\nexport { curryRight };\n", "const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\nexport { MAX_SAFE_INTEGER };\n", null, "import { mount, unmount } from 'svelte';\nimport StoriesExtractor from './StoriesExtractor.svelte';\nimport StoryRenderer from './StoryRenderer.svelte';\nconst createFragment = document.createDocumentFragment\n    ? () => document.createDocumentFragment()\n    : () => document.createElement('div');\n/**\n * @module\n * Called from a bundler.\n *\n * It mounts the Stories components in a context which disables\n * the rendering of every `<Story />`,\n * but instead collects names and properties.\n *\n * For every discovered `<Story />`, it creates a `StoryFn` which\n * instantiate the main Stories component: Every Story but\n * the one selected is disabled.\n */\n// TODO: I'm not sure the 'meta' is necessary here. As long as it's default exported, SB should internally combine it with the stories. Except for the play logic below, that looks funky, need to ask Pablo about that.\nexport const createRuntimeStories = (Stories, meta) => {\n    const repository = {\n        stories: new Map(),\n    };\n    try {\n        const context = mount(StoriesExtractor, {\n            target: createFragment(),\n            props: {\n                Stories,\n                repository: () => repository,\n            },\n        });\n        unmount(context);\n    }\n    catch (e) {\n        console.error(`Error in mounting stories ${e.toString()}`, e);\n    }\n    const stories = {};\n    for (const [exportName, story] of repository.stories) {\n        const storyObj = {\n            ...story,\n            // @ts-expect-error WARN: Here we are attempting to convert every `StoryCmp` into `StoryObj`, and the types are different\n            render: (args, storyContext) => ({\n                Component: StoryRenderer,\n                props: {\n                    exportName,\n                    Stories,\n                    storyContext,\n                    args,\n                },\n            }),\n        };\n        const play = meta.play ?? story.play;\n        if (play) {\n            /*\n             * The 'play' function should be delegated to the real play Story function\n             * in order to be run into the component scope.\n             */\n            storyObj.play = (storyContext) => {\n                const delegate = storyContext.playFunction?.__play;\n                if (delegate) {\n                    return delegate(storyContext);\n                }\n                // @ts-expect-error WARN: It should not affect user perspective- the problem lies in this addon's type `SvelteRenderer` missing type constrains or default generic parameter type\n                return play(storyContext);\n            };\n        }\n        stories[exportName] = storyObj;\n    }\n    return stories;\n};\n"],
  "mappings": "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",
  "names": ["composeArgs"]
}
